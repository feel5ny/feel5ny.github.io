---
title: CodeSpitz78 3/ (stack êµ¬ì¡°) HTML parser âœ¨âœ¨
date: '2018-09-24'
description: "\U0001F315\U0001F311\U0001F311 > \U0001F525 ì½”ë“œìŠ¤í”¼ì¸  ìˆ˜ì—…ì„ ìˆ˜ê°•í•˜ë©´ì„œ ë³µìŠµí•œ ë‚´ìš©ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤. ì°¸ê³  : ë Œë”ë§ ì—”ì§„ - íŒŒì‹± --- 1. ê°œìš” ì–´ë–¤ ìƒí™©ì„ ë³´ê³  êµ¬ì¡°ì ì´ê³  ì¬ê·€ì ì¸ í˜•íƒœë¡œ íŒŒì•…ì„ í•  ìˆ˜ ìˆëŠëƒ,  ë°ì´í„° ë¶„ì„ì„ í•  ìˆ˜ ìˆëŠëƒ.. BNF  ::=  - ë‚´ë¶€ êµ¬ì„±ìš”ì†Œë¡œë¶€í„°..."
author: Joy Kim
tags:
  - javaScript
  - web
  - OOP
categories:
  - 01_Web
  - zz. Workshop
enableComment: true
customList: |-
  [
    {
      "title": {
        "name": "1. ê°œìš”",
        "id": "1"
      }
    },
    {
      "title": {
        "name": "2. í…ìŠ¤íŠ¸ ë…¸ë“œ",
        "id": "2"
      }
    },
    {
      "title": {
        "name": "3. íƒœê·¸ ë…¸ë“œ",
        "id": "3"
      },
      "depth1": [
        {
          "name": "3.1 empty element tag & open tag",
          "id": "3-1"
        },
        {
          "name": "3.2 close tag",
          "id": "3-2"
        }
      ]
    },
    {
      "title": {
        "name": "4. ìµœì¢…",
        "id": "4"
      }
    },
    {
      "title": {
        "name": "cf__1. ì½”ë“œì„¤ê³„ë¥¼ ì˜í•˜ì",
        "id": "cf__1"
      }
    },
    {
      "title": {
        "name": "cf__2. í™”ì´íŠ¸ë¦¬ìŠ¤",
        "id": "cf__2"
      }
    },
    {
      "title": {
        "name": "cf__3. ê°€ë…ì„±ì´ ë†’ì€ ì½”ë“œ?",
        "id": "cf__3"
      }
    },
    {
      "title": {
        "name": "cf__4. html ì••ì¶•ìœ¼ë¡œ ë¸Œë¼ìš°ì € ë¶€í•˜ë¥¼ ì¤„ì´ì",
        "id": "cf__4"
      }
    }
  ]
thumbnail: /images/2018/36/thumb_default.jpg
---

ğŸŒ•ğŸŒ‘ğŸŒ‘

> ğŸ”¥ ì½”ë“œìŠ¤í”¼ì¸  ìˆ˜ì—…ì„ ìˆ˜ê°•í•˜ë©´ì„œ ë³µìŠµí•œ ë‚´ìš©ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤. ì°¸ê³  : ë Œë”ë§ ì—”ì§„ -
> [íŒŒì‹±](https://feel5ny.github.io/2018/06/06/rendering_engine_1/#html_parser)

---


## 1. ê°œìš” ì–´ë–¤ ìƒí™©ì„ ë³´ê³  êµ¬ì¡°ì ì´ê³  ì¬ê·€ì ì¸ í˜•íƒœë¡œ íŒŒì•…ì„ í•  ìˆ˜ ìˆëŠëƒ, ë°ì´í„° ë¶„ì„ì„ í•  ìˆ˜
ìˆëŠëƒ..

### BNF

`<ê¸°í˜¸> ::= <í‘œí˜„ì‹>`

- ë‚´ë¶€ êµ¬ì„±ìš”ì†Œë¡œë¶€í„° ì‘ìš©êµ¬ì„±ìš”ì†Œ í™•ì¥í•˜ëŠ” ê²ƒì„ BNF ì •ì˜ë°©ì‹
- ì–¸ì–´ì˜ êµ¬ì„±ìš”ì†Œë¥¼ ì •ì˜í•˜ëŠ” ì—¬ëŸ¬ ë¬¸ë²•ë“¤ì´ ìˆë‹¤ (lex, yak)

### html ê¸°ë³¸ íŒ¨í„´

```
A = <tag>body</tag>
B = <tag />
C = text
body = (A|B|C)N
```

<img src ="/images/2018/36/01.png" />
> ìœ„ì˜ ê·¸ë¦¼ì„ íŒŒì‹±í•  ìˆ˜ ìˆëŠ” íŒŒì„œë¥¼ ë§Œë“¤ê³  ì‹¶ë‹¤!
> ì¼€ì´ìŠ¤ê°€ ì¬ê·€ë©´ì„œ ë³µí•©ì ì¸ ìƒí™©ì„ ì§¤ ìˆ˜ ìˆë‹¤ë©´ **ì¤‘ê¸‰ê°œë°œì**

### íŒŒì„œì˜ ê¸°ë³¸ êµ¬ì¡°

- í•¨ìˆ˜ì˜ ëª©í‘œ, ì¸ìê°’ê³¼ ë¦¬í„´ê°’ì´ ë¬´ì—‡ì¸ì§€ ì •ì˜í•œë‹¤.
- ë¬´ìŠ¨ ì¸ìë¥¼ ë°›ì•„ì„œ ë¬´ì—‡ì„ ë¦¬í„´í•˜ì§€?

**ë¬¸ìì—´ì„ ì½ì–´ì„œ êµ¬ì¡°ì ìœ¼ë¡œ ê°ì²´í™” ì‹œì¼œ ë¦¬í„´í•˜ê²Œ í•˜ê³  ì‹¶ë‹¤.**

```ts
interface Result {
  name?: string;
  type: string; // text, node
  children: Result[];
}

interface StackItem {
  tag: Result;
}

const parser = (input: string): Result[] => {
  input = input.trim();
  // ì´ˆê¸°í™”
  const result = { name: 'ROOT', type: 'node', children: [] };
  const stack = [{ tag: result }];

  let curr,
    i = 0,
    j = input.length;
  while ((curr = stack.pop())) {
    while (i < j) {
      const cursor = i; // í—·ê°ˆë¦¬ê¸°ë•Œë¬¸ì— ì¡°íšŒìš©ìœ¼ë¡œ ë”°ë¡œ
      if (input[cursor] === '<') {
        // '<'ë¡œ ì‹œì‘í•˜ë©´ íƒœê·¸: A,Bì˜ ê²½ìš°
      } else {
        // í…ìŠ¤íŠ¸ íƒ€ì…: Cì˜ ê²½ìš°
      }
    }
  }
  return result;
};
```

### ì¤‘ì²©ë£¨í”„

- ì²«ë²ˆì§¸ loopëŠ” ë™ì  ë£¨í”„
  - ë£¨í”„ë¥¼ ê²°ì •í•˜ëŠ” ìš”ì¸ì´ ì•ˆì˜ ë£¨í”„ë¥¼ ëŒë‹¤ê°€ ë³€í•  ìˆ˜ë„ ìˆë‹¤.
  - ì´ëŸ° ë£¨í”„ê°€ ê¸°ë³¸ì´ë‹¤. ìµìˆ™í•´ì§€ì ~
  - ì¡°ê±´ì´ `false`ê°€ ë ë•Œê¹Œì§€ loop
- ë‘ë²ˆì§¸ loopëŠ” ì •í•´ì ¸ìˆëŠ” ë£¨í”„
  - **ìŠ¤ìºë„ˆ ë£¨í”„**ë¼ê³  í•œë‹¤.
- ê³„íšë˜ì§€ ì•Šì€ loopëŠ” ìœ„í—˜í•˜ë‹¤ëŠ” ìƒê°ì„ ë²„ë¦¬ì.
- ìŠ¤íƒìˆ˜ì¤€ìœ¼ë¡œ loopë¥¼ ëŒì•„ì•¼í•œë‹¤. **ë•Œë¬¸ì— ìŠ¤íƒêµ¬ì¡° ë£¨í”„ ì•„ë˜ì— ì•Œê³ ë¦¬ì¦˜ì´ ìˆëŠ” ìƒí™©ì´ë‹¤**

---


## 2. í…ìŠ¤íŠ¸ ë…¸ë“œ Cíƒ€ì…: í…ìŠ¤íŠ¸

### 2-1. ìˆœì„œ

**ë‹¤ìŒ íƒœê·¸**ê¹Œì§€ë¥¼ íŒŒì•…

- **name**: í˜„ì¬ ì»¤ì„œ ~ ë‹¤ìŒ íƒœê·¸ê¹Œì§€ì˜ í…ìŠ¤íŠ¸ ì¶”ì¶œ
- **type**: 'text'
- **children**ì€ ì—†ë‹¤.

```ts
interface Result {
  name?: string,
  type: string, // text, node
  children: Result[]
}

interface StackItem {
  tag: Result
}

const parser = (input: string): Result[] => {
  input = input.trim();
  const result = {name: 'ROOT', type: 'node', children: []};
  const stack = [{tag: result}];

  let curr, i = 0, j = input.length;
  while(curr = stack.pop()){
    while(i < j){
      const cursor = i;
      if(input[cursor] === '<'){
        // '<'ë¡œ ì‹œì‘í•˜ë©´ íƒœê·¸: A,Bì˜ ê²½ìš°
      } else {
        // í…ìŠ¤íŠ¸ íƒ€ì…: Cì˜ ê²½ìš°
        ğŸ‘‡ğŸ‘‡ğŸ‘‡
        const idx = input.indexOf('<', cursor);
        // cursorìœ„ì¹˜ì—ì„œë¶€í„° < ìœ„ì¹˜: ë‹¤ìŒ íƒœê·¸ ì „ê¹Œì§€
        curr.tag.children.push({
          type: 'text',
          text: input.substring(cursor, idx);
        }); // childrenì´ ì—†ê¸° ë•Œë¬¸ì— childrenì€ íŒ¨ìŠ¤
        i = idx; // ë‹¤ìŒ ì‹œì‘ì§€ì ì„ ì˜®ê¹€
        ğŸ‘†ğŸ‘†ğŸ‘†
      }
    }
  };
  return result;
}
```

### 2-2. ë¶„ë¦¬

- ë¡œì§ì´ ë…ë¦½ì ì´ë‹¤.
- ë”°ë¡œ ë¶„ë¦¬ ê°€ëŠ¥ !
- **`curr`** ë•Œë¬¸ì— ê²°í•©ë„ê°€ ì˜¬ë¼ê°€ì§€ë§Œ ì–´ì©” ìˆ˜ ì—†ëŠ” ë¶€ë¶„

> **ì—­í• ì„ ì¸ì‹í•˜ìë§ˆì!! ë¶„ë¦¬í•˜ì.** ë‚˜ì¤‘ì— ë¶„ë¦¬í•  ë•ŒëŠ” ì´ë¯¸ ì˜¤ì—¼ë˜ì–´ìˆì–´ì„œ ë¶„ë¦¬ì‹œí‚¤ê¸° ì–´ë µë‹¤.

```ts
const textNode = (input: string, cursor: number, curr: StackItem): number => {
  const idx = input.indexOf('<', cursor);
  curr.tag.children.push({
    type: 'text',
    text: input.substring(cursor, idx);
  });
  return idx;
}
```

```ts
interface Result {
  name?: string,
  type: string, // text, node
  children: Result[]
}

interface StackItem {
  tag: Result
}

const parser = input => {
  input = input.trim();
  const result = {name: 'ROOT', type: 'node', children: []};
  const stack = [{tag: result}];

  let curr, i = 0, j = input.length;
  while(curr = stack.pop()){
    while(i < j){
      const cursor = i; // í—·ê°ˆë¦¬ê¸°ë•Œë¬¸ì— ì¡°íšŒìš©ìœ¼ë¡œ ë”°ë¡œ
      if(input[cursor] === '<'){
        // '<'ë¡œ ì‹œì‘í•˜ë©´ íƒœê·¸: A,Bì˜ ê²½ìš°
      } else {
        ğŸ‘‡ğŸ‘‡ğŸ‘‡
        i = textNode(input, cursor, curr)
        ğŸ‘†ğŸ‘†ğŸ‘†
      }
    }
  };
  return result;
}

// ëª©í‘œ: textNodeë¥¼ ìƒì„± + result ë°°ì—´ì— ì¶”ê°€ => idxê°’(í…ìŠ¤íŠ¸ ë…¸ë“œì˜ ë§ˆì§€ë§‰ ìˆœì„œê°’) ë°˜í™˜
const textNode = (input: string, cursor: number, curr: StackItem): number => {
  const idx = input.indexOf('<', cursor);
  curr.tag.children.push({
    type: 'text',
    text: input.substring(cursor, idx);
  });
  return idx;
}
```

#### **ì½”ë“œë¥¼ ì§¤ ë•ŒëŠ” ë¬´ì¡°ê±´ ì‰¬ìš´ ê²ƒ ë¶€í„° ì²˜ë¦¬í•œë‹¤.**

- why? ì‰¬ìš´ê²ƒì˜ íŠ¹ì§•ì€ :
  1. ì˜ì¡´ì„±ì´ ë‚®ë‹¤.
  2. ë…ë¦½ëœ ê¸°ëŠ¥ì¼ ê²½ìš°ê°€ ë†’ë‹¤.
- **ì˜ì¡´ì„±ì´ ë‚®ì€ ëª¨ë“ˆë¶€í„° ë†’ì€ ëª¨ë“ˆë¡œ ì˜¬ë¼ê°€ì.**

---


## 3. íƒœê·¸ ë…¸ë“œ

#### <span class="mint">`<`</span>ê°€ ë°œë™ íŠ¸ë¦¬ê±°ë¡œ ì“°ì´ê³  ìˆë‹¤.

- ì´ë ‡ê²Œ weekí•˜ê²Œ ?
- íŒŒì„œë¥¼ ë§Œë“¤ ë•ŒëŠ” ì´ë ‡ê²Œ seperator, token í˜•íƒœì˜ íŠ¸ë¦¬ê±°ê°€ ë§Œë“¤ì–´ì§„ë‹¤.

#### **íŠ¸ë¦¬ê±°ê°€ ë°œë™ë˜ëŠ” ì¼€ì´ìŠ¤ê°€ 3ê°€ì§€ ì¢…ë¥˜ê°€ ìˆë‹¤.**

1. ì‹œì‘íƒœê·¸
2. ë‹«ëŠ”íƒœê·¸
3. ì™„ë£Œíƒœê·¸

<img src="/images/2018/36/03.png" style={{width: '100px'}} />

- **ê³µí†µì ** ì‹œì‘íƒœê·¸ë¡œ ì‹œì‘í•´ì„œ ë‹«ëŠ”íƒœê·¸ë¡œ ëë‚œë‹¤.

> ê³µí†µì ì„ ì°¾ì•„ì„œ ì½”ë“œë¥¼ ì¤‘ë³µì‹œí‚¤ëŠ” ê²ƒì„ í”¼í•´ì•¼í•œë‹¤. ëˆˆì„ í›ˆë ¨í•´ì„œ ë¨¼ì € ê³µí†µìš”ì†Œë¥¼ ì¶”ìƒí™” í•  ìˆ˜ ìˆëŠ”
> ëŠ¥ë ¥ì„ í‚¤ì›Œì•¼í•œë‹¤.


### 3.1 empty element `<img />`, open tag `<div>`
empty elementê°€ ë” ê°„ë‹¨í•´ ë³´ì´ë¯€ë¡œ ë¨¼ì €ì§œê¸”

```js
const parser = input => {
  input = input.trim();
  const result = {name: 'ROOT', type: 'node', children: []}; // ë¦¬í„´ê°’ : ì´ë¦„ì´ ë­ê³ , íƒ€ì…ì´ ë­ê³ , childrenì„ ë­˜ ê°–ê³  ì‡ëŠ”ì§€.
  const stack = [{tag: result}]; // DOM ê°ì²´

  let curr, i = 0, j = input.length;
  while(curr = stack.pop()){
    while(i < j){
      const cursor = i; // í—·ê°ˆë¦¬ê¸°ë•Œë¬¸ì— ì¡°íšŒìš©ìœ¼ë¡œ ë”°ë¡œ
      if(input[cursor] === '<'){
        // '<'ë¡œ ì‹œì‘í•˜ë©´ íƒœê·¸: A,Bì˜ ê²½ìš°
        // í˜„ì¬ cursor |<
        const idx = input.indexOf('>', cursor);
        // í˜„ì¬ idx |>
        i = idx + 1;
        if(input[cursor + 1] === '/'){
          // close íƒœê·¸
        } else {
        ğŸ‘‡ğŸ‘‡ğŸ‘‡
          if(input[idx - 1] === '/'){
            // empty íƒœê·¸
          } else {
            // open íƒœê·¸
          }
        }
        ğŸ‘†ğŸ‘†ğŸ‘†
      } else i = textNode(input, cursor, curr)
    }
  };
  return result;
}

const textNode = (input, cursor, curr) => {...};
```


#### cf__1 ì½”ë“œ ì„¤ê³„ë¥¼ ì˜í•˜ì ì¢‹ì€ ì½”ë“œë¥¼ ì§œëŠ” ë¹„ë°€ì€ - í…ŒìŠ¤íŠ¸ ì£¼ë„ ê°œë°œì— ìˆëŠ” ê²ƒì´ ì•„ë‹ˆë¼, -
ë°ì´í„°ë¥¼ ì´í•´í•˜ê³  ì¬ê·€ì ì¸ ë¡œì§ì„ ì°¾ì•„ë‚´ê±°ë‚˜ - ì¶”ìƒí™”ëœ ê³µí†µì ì„ ì°¾ì•„ë‚´ê±°ë‚˜ - ì—­í• ì„ ì´í•´í•˜ê±°ë‚˜ì—
ìˆë‹¤.

ë¨¸ë¦¿ì†ì— ë§¨í†¨ëª¨ë¸ì´ ê·¸ë ¤ì§€ë©´ ì½”ë“œë¡œ ë˜‘ê°™ì´ í‘œí˜„ë˜ì–´ì•¼ì§€ ì •ìƒì´ë‹¤.

- ê·¸ë˜ì•¼ ë‚˜ì¤‘ì— ìœ ì§€ë³´ìˆ˜ê°€ ëœë‹¤.
- ê·¸ëŸ¬ê¸° ë•Œë¬¸ì— ì£¼ì„ì´ í•„ìš”ì—†ë‹¤.

ë°”ë¥¸ ë°ì´í„° ëª¨ë¸ë§ì´ ë¼ì—ˆìœ¼ë©´

- ì½”ë“œëŠ” ê·¸ëƒ¥ ë§¤í•‘ìš©ì´ë‹¤.

```js
let name, isClose; // ğŸ‘ˆ ê³µí†µ ì¤€ë¹„ì‚¬í•­ ì¸µ
if (input[idx - 1] === '/') {
  // ğŸ‘ˆ ê³µí†µ ì²˜ë¦¬ì‚¬í•­ ì¸µ ~
  // empty element íƒœê·¸
  // nameì€ '<'ì™€ '>'ì‚¬ì´
  name = input.substring(cursor + 1, idx - 1);
  isClose = true;
} else {
  // open íƒœê·¸
  name = input.substring(cursor + 1, idx);
  isClose = false;
}
const tag = { name, type: 'node', children: [] }; // ğŸ‘ˆ í¡ìˆ˜í•˜ëŠ”? ì¸µ
curr.tag.children.push(tag);
```

ì¼€ì´ìŠ¤ëŠ” ë‹¤ ê°’ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ ìˆë‹¤.

- ì¼€ì´ìŠ¤ì˜ ì°¨ì´ë¥¼ ê°’ìœ¼ë¡œ í¡ìˆ˜í•´ì„œ í•˜ë‚˜ì˜ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë§Œë“¦.
- ë©”ëª¨ë¦¬(name, isClose)ì™€ ì—°ì‚°(ì¡°ê±´ë¬¸)ì€ êµí™˜ëœë‹¤.
- ì—°ì‚°ì„ ë©”ëª¨ë¦¬ë¡œ ë°”ê¿ˆ => ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚¤ëŠ” í•˜ë‚˜ì˜ ì—°ì‚°ë§Œ ê¸°ìˆ í•˜ë©´ ëœë‹¤.

ìœ„ì˜ ì½”ë“œ í˜•íƒœ

1. ê³µí†µ ì¤€ë¹„ì‚¬í•­ ì¸µ
2. ê³µí†µ ì²˜ë¦¬ì‚¬í•­ ì¸µ
3. ë‹¤ë¥¸ì ì„ ê¸°ìˆ í•˜ëŠ” ë¶€ë¶„ì„ í¡ìˆ˜í•˜ëŠ” ì¸µ


#### cf__2 í™”ì´íŠ¸ë¦¬ìŠ¤ **í™”ì´íŠ¸ë¦¬ìŠ¤ whitelist** 'ì•ˆì „'ì´ ì¦ëª…ëœ ê²ƒë§Œì„ í—ˆìš©í•˜ëŠ” ê²ƒìœ¼ë¡œ 'ì•…ì˜ì„±'ì´
ì…ì¦ëœ ê²ƒì„ ì°¨ë‹¨í•˜ëŠ” ë¸”ë™ë¦¬ìŠ¤íŠ¸ ë³´ì•ˆê³¼ ìƒë°˜ë˜ëŠ” ë³´ì•ˆ ë°©ì‹ ì´ë‹¤. í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸, ë¸”ë™ë¦¬ìŠ¤íŠ¸ë¼ëŠ” ìš©ì–´
ëŒ€ì‹  'positive'ì™€ 'nagative' ë³´ì•ˆ ë°©ë²•ìœ¼ë¡œ ë¶ˆë ¤ì§€ê¸°ë„ í•©ë‹ˆë‹¤.

```js
const idx = input.indexOf('>', cursor);
// í˜„ì¬ idx |>
i = idx + 1;
if(input[cursor + 1] === '/'){
  // close íƒœê·¸
} else {
  let name, isClose;
  if(input[idx - 1] === '/'){
    // empty element íƒœê·¸
    // nameì€ '<'ì™€ '>'ì‚¬ì´
    name = input.substring(cursor + 1, idx - 1);
    isClose = true;
  } else {
    // open íƒœê·¸
    name = input.substring(cursor + 1, idx);
    isClose = false;
  }
  const tag = {name, type: 'node', children: []};
  curr.tag.children.push(tag);

  ğŸ‘‡ğŸ‘‡ğŸ‘‡
  if(!isClose){
    stack.push({tag, back:curr});
    // âœ¨âœ¨ ë¦¬í„´í¬ì¸íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì •ì˜í•˜ëŠ” ìƒí™©.
    break; // whileë¬¸ì˜ break
  }
  ğŸ‘†ğŸ‘†ğŸ‘†
}
```

**ë¶„ë¦¬ ~**

```ts
const idx = input.indexOf('>', cursor);
// í˜„ì¬ idx |>
i = idx + 1;
if(input[cursor + 1] === '/'){
  // close íƒœê·¸
} else {
  if(elementNode(input, cursor, idx, curr, stack)) break;
}
...

const elementNode = (
  input: string,
  cursor: number,
  idx: number,
  curr: StackItem,
  stack: StackItem[]): boolean => {
  let name, isClose;
  if(input[idx - 1] === '/'){
    // empty element íƒœê·¸
    // nameì€ '<'ì™€ '>'ì‚¬ì´
    name = input.substring(cursor + 1, idx - 1);
    isClose = true;
  } else {
    // open íƒœê·¸
    name = input.substring(cursor + 1, idx);
    isClose = false;
  }
  const tag = {name, type: 'node', children: []};
  curr.tag.children.push(tag);

  if(!isClose){
    stack.push({tag, back:curr});
    // ë¦¬í„´í¬ì¸íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì •ì˜í•˜ëŠ” ìƒí™©.
    return true;
  }
  return false;
}

```


#### cf__3 ê°€ë…ì„±ì´ ë†’ì€ ì½”ë“œ? (ë³€ìˆ˜ëª…ì„ ì´ì˜ê²Œ ì“°ë˜, ì»¨ë²¤ì…˜ì„ ì§€í‚¤ë˜) **ì½”ë“œê°€ ë¦¬ë”ë¸”í•˜ë‹¤?**
Readable - **ì ì ˆí•œ ì—­í• ëª¨ë¸**ë¡œ ìœ„ì„ë˜ì„œ ê·¸ë“¤ê°„ì˜ **í†µì‹ ê³¼ í˜‘ì—…ë§Œ ë³¼ ìˆ˜ ìˆëŠ” ì½”ë“œ**ê°€ ê°€ë…ì„±ì´ ë†’ì€
ì½”ë“œì´ë‹¤.


### 3.2 close tag

```js
stack.push({ tag, back: curr });
```

```js
...
const idx = input.indexOf('>', cursor);
// í˜„ì¬ idx |>
i = idx + 1;
if(input[cursor + 1] === '/'){
  ğŸ‘‡ğŸ‘‡ğŸ‘‡
  // close íƒœê·¸
  curr = curr.back;
  ğŸ‘†ğŸ‘†ğŸ‘†
} else {
  if(elementNode(input, cursor, idx, curr, stack)) break;
}
...

const elementNode = (input, cursor, idx, curr, stack) => {
  let name, isClose;
  if(input[idx - 1] === '/'){
    // empty element íƒœê·¸
    // nameì€ '<'ì™€ '>'ì‚¬ì´
    name = input.substring(cursor + 1, idx - 1);
    isClose = true;
  } else {
    // open íƒœê·¸
    name = input.substring(cursor + 1, idx);
    isClose = false;
  }
  const tag = {name, type: 'node', children: []};
  curr.tag.children.push(tag);

  if(!isClose){
    stack.push({tag, back:curr});
    // ë¦¬í„´í¬ì¸íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì •ì˜í•˜ëŠ” ìƒí™©.
    return true;
  }
  return false;
}

```


#### cf__4 cssì••ì¶•ì´ë‚˜ javascriptì••ì¶•ë³´ë‹¤ **htmlì••ì¶•ì´ ë¸Œë¼ìš°ì €ì˜ ë¶€í•˜ë¥¼ ì¤„ì´ëŠ” ë°©ë²•** ì“¸ë°ì—†ëŠ”
ë…¸ë“œìƒì„±ì„ ì¤„ì¸ë‹¤.

```js
const elementNode = (input, cursor, idx, curr, stack) => {
  const isClose = input[idx - 1] === '/';
  const tag = {
    name: input.substring(cursor + 1, idx - (isClose ? 1 : 0)),
    type: 'node',
    children: [],
  };
  curr.tag.children.push(tag);
  if (!isClose) {
    stack.push({ tag, back: curr });
    // âœ¨âœ¨ ë¦¬í„´í¬ì¸íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì •ì˜í•˜ëŠ” ìƒí™©.
    return true;
  }
  return false;
};
```

---


## 4. ìµœì¢…

```js
const parser = input => {
  input = input.trim();
  const result = { name: 'ROOT', type: 'node', children: [] };
  const stack = [{ tag: result }]; // DOM ê°ì²´

  let curr,
    i = 0,
    j = input.length;
  while ((curr = stack.pop())) {
    while (i < j) {
      const cursor = i; // í—·ê°ˆë¦¬ê¸°ë•Œë¬¸ì— ì¡°íšŒìš©ìœ¼ë¡œ ë”°ë¡œ
      if (input[cursor] === '<') {
        const idx = input.indexOf('>', cursor);
        i = idx + 1;
        if (input[cursor + 1] === '/') {
          // ë‹«ëŠ”íƒœê·¸
          curr = curr.back;
        } else {
          if (elementNode(input, cursor, idx, curr, stack)) break; // ë‘ë²ˆì§¸ ë£¨í”„ break
        }
      } else i = textNode(input, cursor, curr);
    }
  }
  return result;
};

const textNode = (input, cursor, curr) => {
  const idx = input.indexOf('<', cursor);
  curr.tag.children.push({
    type: 'text',
    text: input.substring(cursor, idx),
  });
  return idx;
};

const elementNode = (input, cursor, idx, curr, stack) => {
  const isClose = input[idx - 1] === '/';
  const tag = {
    name: input.substring(cursor + 1, idx - (isClose ? 1 : 0)),
    type: 'node',
    children: [],
  };
  curr.tag.children.push(tag);
  if (!isClose) {
    stack.push({ tag, back: curr });
    // âœ¨âœ¨ ë¦¬í„´í¬ì¸íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì •ì˜í•˜ëŠ” ìƒí™©.
    return true;
  }
  return false;
};
```

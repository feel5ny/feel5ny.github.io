---
title: 도커 개념과 컨테이너
date: '2022-02-13'
description: >-
  > 도커 환경으로 구성된 인프라들을 최근들어 자주 접하게 되고, 프론트 리소스도 도커, 쿠버네티스 환경에서 운영됨에 따라, 프론트 개발자도
  이에 대한 지식이 필요하다고 느껴 스터디를 진행합니다. 스터디는 "시작하세요 도커/쿠버네티스" 책으로 진행합니다. 왜 우린 도커를...
author: Joy Kim
tags:
  - Docker
categories:
  - 03_DevOps
  - 06. Deploy
enableComment: true
customList: |-
  [
    {
      "title": {
        "name": "도커 개념",
        "id": "basic"
      }
    },
    {
      "title": {
        "name": "도커 컨테이너 조작",
        "id": "container"
      }
    }
  ]
thumbnail: /images/2022/01/thumb_default.jpg
---

> 도커 환경으로 구성된 인프라들을 최근들어 자주 접하게 되고, 프론트 리소스도 도커, 쿠버네티스
> 환경에서 운영됨에 따라, 프론트 개발자도 이에 대한 지식이 필요하다고 느껴 스터디를 진행합니다.
> 스터디는 "시작하세요 도커/쿠버네티스" 책으로 진행합니다.

[왜 우린 도커를 써야하나요?](https://www.44bits.io/ko/post/why-should-i-use-docker-container)

<a name="basic" />

## 도커? 🐋

**리눅스 컨테이너**에 여러 기능을 추가하여 → **어플리케이션을 컨테이너**로서 좀더 쉽게 사용할 수
있게 만들어진 오픈소스 프로젝트

- 리눅스 : **리눅스**(**Linux**)는 1991년 9월 17일 리누스 토르발스가 처음 출시한 운영 체제 커널인
  **리눅스** 커널에 기반을 둔 오픈 소스 유닉스 계열 운영 체제 계열
- 컨테이너: 컨테이너는 기존의 시스템에 존재하는 **프로세스**를 → 해당 시스템에서 격리하여, →
  독자적인 시스템 환경을 구축하는 기술입니다.
  - 이를 리눅스 환경에서 실제로 구현한 것이 리눅스 컨테이너입니다.
- Go 언어로 작성돼 있음
- 도커 == 도커 엔진 혹은 도커에 관련된 모든 프로젝트
- 도커의 생태계에 있는 여러 프로젝트들은: 도커엔진을 좀 더 효율적으로 사용하기 위한 것에 불과함
- → 핵심은 도커 엔진
  - 도커엔진을 사용하는 방법을 익히는것 == 도커와 관련된 모든 프로젝트를 능숙하게 다루기 위한 첫걸음
  - 도커의 철학: 한 컨테이너에 프로세스 하나만 실행하는 것

## 가상머신과 도커 컨테이너

- 기존의 가상화 기술 : **하이퍼 바이저**를 이용해, 여러개의 운영체제를 하나의 호스트에서 생성해,
  사용하는 방식

### 가상머신 Hypervisor

- 하이퍼바이저:
  [가상 머신(Virtual Machine, VM)](https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine)을
  생성하고 구동하는 소프트웨어
- 서로 다른 복수 개의 OS(== **가상머신**이라는 단위)를 단일 물리 머신 위에서 스케줄링 할 수 있는
  소프트웨어
- 각 가상머신에는 우분투 Ubuntu, CentOS 등의 운영체제가 설치되어 사용된다.

<img src="/images/2022/01/01.png" alt="hypervisor"/>
        
> 참고
[[네이버클라우드 기술&경험] 가상화 개념 이해하기#1, QEMU vs KVM](https://medium.com/naver-cloud-platform/%EB%84%A4%EC%9D%B4%EB%B2%84%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EA%B0%80%EC%83%81%ED%99%94-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-qemu-vs-kvm-962113641799)

- Guest OS: 하이퍼바이저에 의해 생성되고 관리되는 운영체제
  - 다른 게스트 운영체제와는 완전히 독립된 시스템 자원을 할당 받아 사용한다.
- 가상화 방식을 사용할 수 있는 가상화 툴: [VirtualBox](https://www.virtualbox.org/),
  [VMware](https://www.vmware.com/kr.html)

### Hypervisor의 단점 👎

- **일반 호스트에 비해 성능의 손실이 발생**: 각종 시스템 자원을 가상화하고, 독립된 공간을 생성하는
  작업은 ⇒ 하이퍼바이저를 반드시 거침
- **이미지의 크기 또한 커진다**: 가상머신은 게스트 운영체제를 사용하기위한 라이브러리, 커널 등을
  전부 포함하기 때문에, 가상머신을 배포하기위한 이미지로 만들었을 때 이미지의 크기 또한 커진다.

> 커널? 운영 체제(OS)의 주요 구성 요소이며 컴퓨터 하드웨어와 프로세스를 잇는 핵심 인터페이스

- 장점 👍: 완벽한 운영체제를 생성할 수 있다.
- 단점 👎: 일반 호스트에 비해 성능 손실 / 가상머신을 배포하기 위한 이미지로 만들었을때, 이미지 크기
  또한, 커진다.

<img src="/images/2022/01/02.png" alt="VM vs Docker" />

## 도커 컨테이너 특징

1. 성능 손실이 없다.
   - 가상화된 공간을 생성하기 위해 리눅스의 자체 기능인 chroot, 네임스페이스 namespace, cgroup을
     사용,
   - → 프로세스 단위의 격리 환경을 만든다.
   - → 성능손실이 없다. 가상화된 공간을 사용할때의 성능손실도 없음.
2. 용량이슈 없음
   - 컨테이너에 필요한 커널은 → 호스트의 커널을 공유해 사용
   - 컨테이너 안에는 어플리케이션을 구동하는 데 필요한 라이브러리 및 실행파일만 존재
   - 이미지로 만들어서 배포시, 시간이 가상머신보다 빠름.

## 💡 도커를 시작해야하는 이유!

- 컨테이너는 OpenVZ, LXC, cri-o등 몇가지 존재는 함
- 도커는 컨테이너 생태계에서 사실상 표준.
  - 쿠버네티스, 메소스와 같은 오픈소스 프로젝트에서도, 도커를 기준으로 개발됨.

1. 어플리케이션의 개발과 배포가 편해진다.
2. 여러 어플리케이션의 독립성과 확장성이 높아짐.

### 1. 어플리케이션의 개발과 배포가 편해진다.

- **호스트OS**: 서버 부팅시 실행되는 운영체제
- **도커 컨테이너** : 호스트OS 위에서 실행되는 격리된 공간
  - 컨테이너 내부에서 설정수정, 디펜던시 설치 해도 호스트OS에는 영향 없음
- 컨테이너 내부에서 여러 작업을 마친뒤, 운영환경에 배포하려고 한다면?
  - 해당 컨테이너를 도커 이미지라고 하는 일종의 패키지로 만들어 운영서버에 전달하기만 하면된다.
  - 서비스를 개발할 때 사용했던 환경을 다른 서버에서도 컨테이너로써 똑같이 복제할 수 있기 때문에
    개발/운영 환경의 통합이 가능하다.
- **도커 이미지**: 가상머신의 이미지와 달리, 커널을 포함하고 있지 않아 이미지가 크지 않다.
  - 도커 이미지 내용을 레이어 단위로 구성
  - 중복되는 레이어를 재사용할 수 있다. → 어플리케이션 배포 속도가 빨라진다.

### 2. 여러 어플리케이션의 독립성과 확장성이 높아짐.

- 모놀리스 Monolith 어플리케이션 :
  - 소프트웨어의 여러 모듈이 상호작용하는 로직을 하나의 프로그램 내에서 구동시키는 방식
  - 소규모에서는 어울리지만,
    - 서비스의 기능이 복잡해지고, 거디해질수록 → 소프트웨어 자체의 확장성과 유연성이 줄어든다.
- 마이크로 서비스 microservices
  - 여러 모듈을 독립된 형태로 구성
  - 언어에 종속되지 않고, 변화에 빠르게 대응할 수 있다.
  - 모듈 관리가 쉬워진다.
  - → 컨테이너는 수 초 내로 생성, 시작이 가능하며, → 여러 모듈에게 독립된 환경을, 동시에 제공할 수
    있기 때문에 → 마이크로 서비스 구조에서 가장 많이 사용되는 가상화 기술이다.
  - 컨테이너 기반의 마이크로 서비스는 개발자가 그 구조를 직접구현하지 ❌
    - 컨테이너 오케스트레이션 플랫폼을 통해 사용하는 것이 일반적 (도커 스웜모드, 쿠버네티스...)

#### 예) 웹서비스

- 데이터베이스 컨테이너 / 웹서버 컨테이너 분리
- 웹서비스에 부하 발생시 → 웹 서버 컨테이너만 동적으로 늘려서 부하 분산
- 웹서버와 데이터베이스의 이미지 버전을 독립적으로 관리
  - 유지보수 용이해짐

## 도커 이미지와 컨테이너

- 이미지, 컨테이너 : 도커 엔진에서 사용하는 기본단위

### 도커 이미지

- 컨테이너를 생성할 때 필요한 요소 (가상머신을 생성할 때 사용하는 iso 파일과 비슷)
- 이미지: 여러개의 계층으로된 바이너리 파일이 존재 (컨테이너를 생성하고, 실행할 때 읽기 전용으로
  사용됨)
- 도커 명령어로 내려받을 수 있다.
- 리툭스 운영체제, 어플리케이션, 빅데이터 분석도구, .. 갖가지 종류가 있음

```
{{ 저장소 }}/{{ 이미지 이름 }}:{{ 태그 }}
```

- **저장소**: 이미지가 저장된 저장소를 의미
- **이미지 이름**: 이미지가 어떤 역할을 하는지 나타낸다.
- **태그**: 이미지의 버전 관리, 리비전 관리에 사용된다. (생략시 latest)

### 도커 컨테이너

- 이미지로 -> 컨테이너 생성가능
- 해당 이미지의 목적에 맞는 파일이 들어있는, 파일시스템과 격리된 시스템 자원 및 네트워크를 사용할 수
  있는 독립된 공간이 생성된다.
- 도커 컨테이너는, 생성될 때 사용된 도커이미지의 종류에 따라, 알맞은 설정과 파일을 갖고 있다.
  - 도커이미지의 목적에 맞도록 사용되는 것이 일반적
  - 예) 웹서버 도커이미지로부터, 여러개의 컨테이너를 생성하면 → 생성된 컨테이너의 갯수만큼 웹서버가
    생성
- 컨테이너는 이미지를 **읽기 전용**으로 사용함
  - 이미지에서 변경된 사항만 컨테이너 계층에 저장한다...
  - → 컨테이너에서 무엇을 하던, 원래 이미지는 영향을 받지 않는다.

<a name="container" />

## 도커 컨테이너 다루기

> [도커 GUI 클라이언트](https://www.docker.com/products/docker-desktop) 사용하며 익히면 굳

1. 컨테이너 생성: `docker run -i -t ubuntu:14.04` (1. ubuntu:14.04 이미지 기준으로 `pull`, 2.
   컨테이너 생성 `create`, 3. 내부 진입 `attach`)
2. 컨테이너 나가기: `exit` (컨테이너 정지 + 나감), `Ctrl+P,Q` (그냥 나감 (정지 않함))
3. 컨테이너 목록확인: `docker ps` (정지되지 않은 컨테이너만 출력) (`-a` 정지된 것까지 출력)
4. 컨테이너 삭제: `docker rm`(복구 불가능/ 실행중인것은 삭제 불가능), `docker container prune`(모든
   컨테이너 삭제)
5. 컨테이너 외부에 노출: 가상 IP주소를 할당받으며 (`eth0`), 외부 노출 가능
   - `eth0`의 IP포트를 Host의 IP와 포트에 바인딩 해야함
   - `docker run ... -p 81:80 ubuntu:14.04`
   - 1. Host IP의 81번 호트로 컨테이너 접근
   - 2. 컨테이너 80번 포트로 port forwarding (컨테이너의 열려있는 80번 포트로 연결)

### 기타 cli

```
docker run -i -t --name joy ubuntu:14.04
```

- `-i` : 상호 입출력
- `-t` : tty를 활성화 (bash shell 사용하도록 설정)
- `--name`: 컨테이너 네이밍

```
docker run -d --name detach_test ubuntu:14.04
```

- detached 모드 (foreground): detached 모드로 컨테이너를 실행한다.
- detached 모드: 컨테이너를 백그라운드에서 동작하는 어플리케이션으로써 실행하도록 설정
- 입출력이 없는 상태로 컨테이너를 실행
- detached 모드는 반드시 컨테이너에서 **프로그램이 실행되야 하며**, 포그라운드 프로그램이 실행되지
  않으면 컨테이너는 종료됨
- detached 모드여도, 컨테이너 내부 shell 사용가능:

```
 docker exec -it {{ 컨테이너 이름 }} /bin/sh
```

```
docker pull     // 원격에 있는 이미지 풀받기
docker images   // 로컬에 다운받은 이미지 확인
docker create   // 컨테이너 생성시 사용 (반환값: 컨테이너 고유 ID)
dokcer start    // 컨테이너 띄우기
docker attach   // 컨테이너 내부 들어가기
```

---

### 참고

- [왜 우린 도커를 써야하나요?](https://www.44bits.io/ko/post/why-should-i-use-docker-container)
- [[네이버클라우드 기술&경험] 가상화 개념 이해하기#1, QEMU vs KVM](https://medium.com/naver-cloud-platform/%EB%84%A4%EC%9D%B4%EB%B2%84%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EA%B0%80%EC%83%81%ED%99%94-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-qemu-vs-kvm-962113641799)

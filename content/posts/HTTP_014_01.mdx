---
title: HTTPS 이해를 위한 디지털 암호학
date: '2019-12-01'
description: >-
  ---- > 최근 인증서 관련 이슈를 만난적이 있었는데,  > 이번 장을 통해서 조금이나마 이해가 될 수 있게 되었다 :)  ----
  HTTP를 안전하게 만들기  - 사람들은 웹 트랜잭션을 중요한 일에 사용한다.  - 강력한 보안이 없다면, 사람들은 온라인 쇼핑이나 인...
author: Joy Kim
tags:
  - http
  - https
  - study
  - cryptography
  - X.509
categories:
  - 01_Web
  - 02. HTTP
enableComment: true
customList: |-
  [
    {
      "title": {
        "name": "HTTP를 안전하게 만들기",
        "id": "secure"
      }
    },
    {
      "hr": {
        "type": "start",
        "name": "디지털 암호학"
      }
    },
    {
      "title": {
        "name": "비밀코드의 기술과 과학",
        "sub": "비밀 메세지 / 도청, 변조 방지 / 저자 증명",
        "id": "cryptography",
        "style": {
          "type": "number",
          "index": "1"
        }
      }
    },
    {
      "title": {
        "name": "암호 cipher",
        "sub": "암호기계, 키, 디지털암호",
        "id": "cipher",
        "style": {
          "type": "number",
          "index": "2"
        }
      }
    },
    {
      "title": {
        "name": "대칭키 암호법",
        "sub": "키 길이와 열거 공격, 공유키 발급",
        "id": "symmetry",
        "style": {
          "type": "number",
          "index": "3"
        }
      }
    },
    {
      "title": {
        "name": "공개키 암호법",
        "sub": "RSA, 혼성 암호체계와 세션 키",
        "id": "public",
        "style": {
          "type": "number",
          "index": "4"
        }
      }
    },
    {
      "title": {
        "name": "디지털 서명",
        "sub": "저자 확인, 메세지 위조 방지",
        "id": "signing",
        "style": {
          "type": "number",
          "index": "5"
        }
      }
    },
    {
      "title": {
        "name": "디지털 인증서",
        "sub": "X.509, 서버 인증",
        "id": "certs",
        "style": {
          "type": "number",
          "index": "6"
        }
      }
    },
    {
      "hr": {
        "type": "end"
      }
    }
  ]
thumbnail: /images/2019/44/thumb_default.jpg
---

---

> 최근 인증서 관련 이슈를 만난적이 있었는데, 이번 장을 통해서 조금이나마 이해가 될 수 있게 되었다 :)

---



# HTTP를 안전하게 만들기

<img src="/images/2019/44/01.png" />

- 사람들은 웹 트랜잭션을 중요한 일에 사용한다.
- 강력한 보안이 없다면, 사람들은 온라인 쇼핑이나 인터넷뱅킹을 할 때 안심할 수 없을 것이다.
- 기본인증이나 다이제스트 인증은 대량구매, 은행 업무, 보안자료 접근에는 강력하지 않다.

## HTTP와 디지털 암호화 기술을 결합해야한다.

- 2. HTTP 보안 버전은
  1. 효율적이고
  1. 이식성이 좋아야 하고,
  1. 관리가 쉬워야 하며
  1. 현실세계의 변화에 대한 적응력이 좋아야 한다.
  1. 사회와 정부의 요구사항에도 맞아야한다.

다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요하다.

1. **서버인증**: 클라는 자신이 위조된 서버가 아닌 **진짜 서버**와 소통하고 있음을 알 수 있어야 함.
2. **클라 인증**: 서버는 자신이 가짜가 아닌 **진짜 사용자**와 소통하고 있음을 알 수 있어야 한다.
3. **무결성**: 클라와 서버는 그들의 데이터가 **위조되는 것으로부터 안전**해야 한다.
4. **암호화**: 클라와 서버는 **도청에 대한 걱정 없이** 서로 대화할 수 있어야 한다.
5. **효율**: 알고리즘은 빨라야 한다.
6. **편재성** Ubiquity: 프로토콜은 거의 **모든 클라와 서버에서 지원**되어야 한다.
   > 편재성은 자원을 뜻할때 주로 쓰이는 성질이다. 자원의 민족주의. **도처에 존재하는 성질**이라고
   > 이해하면 됨
7. **관리상 확장성**: **누구든, 어디서든**, 즉각적인 보안 통신을 할 수 있어야 한다.
8. **적응성**: 현재 알려진 최선의 보안방법을 지원해야 한다.
9. **사회적 생존성**: 사회의 문화적, 정치적 요구를 만족시켜야 한다.

## HTTP`S`

- 2.  HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다.
- `S`는 **Over Secure Socket Layer**의 약자이다.
- 2.  HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 된다.
- 2.  HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층에 의해 동작한다.
- 이 보안계층은 안전소켓계층, (Secure Sockets Layer, **SSL**) 전송 계층 보안(Transport Layer
  Security, **TLS**)을 이용하여 구현된다.
  - 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로
    변경되면서 **TLS**라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다
    SSL이라는 이름이 훨씬 많이 사용되고 있다.
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에 보안 HTTP를 사용하기
  위해, 웹 클라와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다.

---

---

# 디지털 암호학

- SSL과 HTTPS에서 이용되는 암호 인코딩 기법에 대해 잠깐 알아본다.

1. **암호**: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
2. **키**: 암호의 동작을 변경하는 숫자로 된 매개변수
3. **대칭키 암호 체계**: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
4. **비대칭키 암호 체계**: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
5. **공개키 암호법**: 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
6. **디지털 서명**: 메세지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
7. **디지털 인증서**: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

---



## 1. 비밀코드의 기술과 과학

암호법 cryptography는 메세지 인코딩과 디코딩에 대한 과학이자 기술이다.

### 비밀 메세지 / 도청, 변조 방지 / 저자 증명

- 사람들은 암호법의 방법론을 **비밀 메세지**를 보내는데에 적용해 왔다.
- **도청**이나 메세지의 **변조를 방지**하기 위해 사용할 수 있다.
- 암호법은 누군가가 정말로 어떤 메세지나 트랜잭션의 저자임을 **증명**하는 데도 사용될 수 있다.

---



## 2. 암호 cipher

- 암호법은 암호라 불리는 비밀코드에 기반한다.
- 암호란, **메세지를 인코딩하는 어떤 특정한 방법**과 **그 비밀 메세지를 디코딩하는 방법**이다.
- `텍스트, 평문`: 인코딩 되기 전의 **원본** 메세지
- `암호문`: 암호가 적용되어 **코딩**된 메세지

### 2.1 암호 기계

- 암호는 상대적으로 간단한 알고리즘으로 시작했는데, 사람이 직접 인코딩하고 디코딩해야 했기 때문이다.
- 기술이 진보하면서, 복잡한 암호로 메세지를 빠르고 정확하게 인코딩하고 디코딩하는 기계를 만들기
  시작했다.
- 예\_2차 세계대전의 에니그마 암호기계

### 2.2 키가 있는 암호

- 코드 알고리즘과 기계가 적의 손에 들어갈 수 있기 때문에, 대부분의 기계들에는 **암호의 동작방식을
  변경할 수 있는** 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다.
- 올바른 다이얼 설정(키 값)이 없이는 디코더가 동작하지 않을 것이다.
- 이러한 **암호 매개변수를 키**라고 부른다. key
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다.

### 2.3 디지털 암호

- 디지털 계산의 도래로, 두가지 발전이 있다
  1. 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
  2. 단일 암호 알고리즘으로
  - 키의 값마다 서로 다른 수조 개의 **가상 암호 알고리즘**을 만들어낼 수 있게 되었다.
  - 키가 길수록 인코딩의 많은 조합이 가능해지고, 무작위로 추측한 키에 의한 크래킹이 어려워진다.
- 평문메세지 `P`, 인코딩 함수 `E`, 디지털 인코딩 키 `e`가 주어지면 부호화된 암호문 `C`를 생성할 수
  있다.
- 암호문 `C`를 디코더 함수 `D`와 디코딩 키 `d`를 사용해서 원래의 평문 `P`로 도로 디코딩할 수 있다.

```
C = E(P,e)
P = D(C,d)
```

---



## 3. 대칭키 암호법

- 많은 디지털 암호 알고리즘은 대칭키 암호라고 불림
- 인코딩을 할 때 사용하는 키가 디보딩을 할 때와 같기 때문 (e = d, k라 부르자)
- 대칭키 암호에서, 발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있다.
  - 발송자는 공유된 비밀 키로 메세지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해
    사용한다.
  - 수신자도 암호문을 키를 사용하여 원래의 평문으로 복원한다.
- 잘 알려진 대칭키 암호 알고리즘
  - DES(Data Encryption Standard), Triple-DES, RC2, RC4
  - DES는 취약하다는 결론 => 요즘은 AES를 사용한다.
  - **[AES](https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%EC%95%94%ED%98%B8%ED%99%94_%ED%91%9C%EC%A4%80)**,
    Advanced Encryption Standard: 고급 암호화 표준

### 3.1. 키 길이와 열거 공격 Enumeration Attack

- 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다.
- **무차별로 모든 키 값을 대입해보는 공격**을 열거 공격이라고 한다.
- 128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주된다.
- 미국 국가안보국에서는 긴 키를 사용하는 암호화 소프트웨어의 수출을 통제한다.
  - 깨뜨릴 수 없는 암호문을 적대적인 조직이 만들어 낼 가능성을 차단하기 위해

### 3.2. 공유키 발급하기

- 대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는
  것이다.
- 만약 누군가 쇼핑몰에서 private 대화를 다누려면 개인 비밀 키가 발급되어야 한다.
  - 관리해야하는 사람 입장에서는 모든 키를 관리해야하므로 복잡성이 올라간다.

### 3.3. 대칭키 만들어보기

```
echo 'this is the plain text' > plaintext.txt;
openssl enc -e -des3 -salt -in plaintext.txt -out ciphertext.bin
```

1. 'this is the plain text' 문자열이 들어간 plaintext.txt가 만들어진다
2. plaintext.txt 안의(`-in`) 내용들을 des3방식으로 암호화를 하고, ciphertext.bin이라는 파일로
   산출할(`-out`) 것이다 라는 뜻.
3. 비밀번호를 요구하는 input이 나온다. => 요게 **`대칭키`!**

<img src="/images/2019/44/04.png" />

> 이런식으로 암호화된다.

```
openssl enc -d -des3 -in ciphertext.bin -out plaintext2.txt;
```

4. ciphertext.bin 안의 내용을 des3 방식으로 복호화(디코딩)(`-d`) 하여서 plaintext2.txt 파일에 산출할
   것이다 라는 뜻.

---



## 4. 공개키 암호법

- 공개키 암호 방식은 2개의 비대칭 키를 사용한다.
- 하나는 호스트의 메세지를 인코딩하기 위한 것 다른 하나는 그 호스트의 메세지를 디코딩하기 위한
  것이다.
- 인코딩 키는 모두를 위해 공개되어 있다. 하지만 호스트만이 개인 디코딩 키를 알고 있다.
- 키의 분리는, 메세지의 인코딩은 누구나 할 수 있도록 해주는 동시에 메세지를 디코딩하는 능력은
  소유자에게만 부여한다.
- 표준화된 공개키 기술 묶음을 만드는 것의 중요성 때문에 거대한 공개 키 인프라 표준화 작업이 계속되고
  있다. Public-Key Infrastructure, PKI
  - PKI란, 공개 키 암호 방식을 바탕으로 한 디지털 인증서를 활용하는 소프트웨어, 하드웨어, 사용자,
    정책 및 제도 등을 총칭하여 일컫는다.

### 4.1 RSA (Ribest Shamir Adelman)

- 공개키 비대칭 암호의 과제는, 악당이 아래 내용을 알고 있다고 하더라도 비밀인 개인 키를 계산할 수
  없다는 것을 확신시켜 주는 것이다.
  1. 공개키
  2. 가로채서 얻은 암호문의 일부 - 네트워크를 스누핑해서
  3. 메세지와 그것을 암호화한 암호문 - 인코더에 임의의 텍스트를 넣고 실행
- 이 모둔 요구를 만족하는 공개키 암호 체계중 유명한 하나는 RSA 알고리즘이다.
  - = Ribest Shamir Adelman / 발명한 세 명의 이름 첫글자를 따온 이름

### 4.2 혼성 암호 체계와 세션 키

- 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다.
- 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.
- 예
  - 공개키 암호를 사용하고
  - 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여
  - 이후의 나머지 데이터를 암호화 할때는 빠른 대칭키를 사용하는 방식

---



## 5. 디지털 서명

- 암호 체계는 누가 메세지를 썻는지 알려주고 그 메세지가 위조되지 않았음을 증명하기 위해 **메세지에
  서명**을 하도록 하는 데에 이용될 수 있다.
- 디지털 서명 digital signing 이라 불리는 이 기법은 인터넷 보안 인증서에게 중요하다.

### 5.1 서명은 암호 체크섬이다.

- 디지털 서명은 **메세지에 붙어있는 특별한 암호 체크섬**이다.
- 두가지 이점이 있다.
  1. 서명은 메세지를 작성한 **저자가 누군지** 알려준다.
  - 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다.
  - 체크섬은 저자의 개인 서명처럼 동작한다.
  2. 서명은 **메세지 위조를 방지한다.**
  - 송신 중에 누군가 메세지를 수정했다면, 체크섬은 더 이상 그 메세지와 맞지 않게 될 것이다.
  - 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에 침입자는 그 위조된 메세지에 대한 올바른
    체크섬을 날조해낼 수 없을 것이다.
- 디지털 서명은 보통 **비대칭 공개키**에 의해 생성된다.
- 개인 키는 오직 소유자만이 알고 있기 때문에 저자의 개인 키는 일종의 **지문**처럼 사용된다.

#### 예시

노드A가 노드B에게 메세지를 보내고, 그것을 서명하는 전체 플로우.

1. 노드 A는 가변 길이 메세지를 정제하여 고정된 길이의 digest로 만든다.
2. 노드 A는 그 digest에 **서명** 함수를 적용한다. (서명함수: **사용자의 개인 키를 매개변수**로 하는
   함수)

- 오직 그 사용자만이 개인 키를 알고 있기 때문에, **올바른 서명 함수는 서명자가 소유자임을
  보여준다.**
- 서명함수가 이미 개인 키를 입력으로 취했기 때문에 **디코더 함수**를 사용한다.

3. 한번 서명이 계산되면, 노드 A는 그것을 메세지의 끝에 덧붙이고, 메세지와 그에 대한 설명을 둘다 노드
   B에 전송한다.
4. 메세지를 받은 노드 B가, 만약 그 메세지를 쓴 것이 정말로 노드 A이며, 위조되지도 않았다는 것을
   확인하길 원한다면, 노드 B는 서명을 검사할 수 있다.

- 노드 B는 개인 키로 알아보기 어렵게 변형된 서명에 **공개키를 이용한 역함수를 적용한다.**
- 만약 풀어낸 요약이 노드 B가 갖고 있는 버전의 요약과 일치하지 않는다면, 메세지가 송신 중에
  위조되었거나, 아니면 발송자가 노드 A의 개인 키를 갖고 있지 않은 것이다.

---



## 6. 디지털 인증서

- 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.
  (디지털 인증서는 흔히 certs라고 불린다.)
- 여권처럼 신뢰할 수 있는 형태의 신원증명은
  1. 서명이 되어있고,
  2. 특별한 종이 위에
  3. 정부가 새긴 도장이 찍혀있다.
- 이것들은 위조하기 어렵고, 본질적으로 더 높은 수준의 신뢰를 받게 된다.

### 6.1 인증서의 내부

- 디지털 인증서에는 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨있다.

1. 대상자 이름 (사람, 서버, 조직 등)
2. 유효 기간
3. 인증서 발급자 (누가 이 인증서를 보증하는가)
4. 인증서 발급자의 디지털 서명

- 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보, 대상의 공개키도 담고 있다.
- 누구나 디지털 인증서를 만들 수 있지만, (모두가 인증서의 정보를 보증하고 인증서의 개인 키로 서명할
  수 있는,) **널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다.**

<img src="/images/2019/44/02.png" />

### 6.2 `X.509` v3 인증서

- 디지털 인증서에 대한 전 세계적인 단일 표준은 없다.
- 여러가지 미묘하게 다른 스타일의 디지털 인증서들이 존재한다.
- 오늘날 사용되는 대부분의 인증서가 **`X.509`라 불리는 표준화된 서식**에 그들의 정보를 저장하고
  있다는 것이다.
- **공인인증서 대부분은 `X.509` 인증서 표준을 기반으로 한다.**
- `X.509`기반 인증서에는 웹서버 인증서 / 클라 이메일 인증서 / 스프트웨어 코드사인 인증서 / 인증기관
  인증서를 비롯한 몇가지 변종이 있다.
- `X.509` v3 인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공한다.

---

[X.509 위키피디아 설명](https://ko.wikipedia.org/wiki/X.509)

- **버전**: 이 인증서가 따르는 `X.509` 인증서 버전의 번호 (보통은 v3)
- **일련번호**: 인증기관에 의해 생성된 고유한 정수
- **서명 알고리즘 ID**: 서명을 위해 사용된 암호 알고리즘 (예\_RSA 암호화를 이용한 MD2 digest)
- **인증서 발급자**: 인증서를 발급하고 서명한 기관의 이름 (CA: certificate authority)
- **유효기간**: 인증서가 유효한 기간. 시작일과 종료일로 정의
- **대상의 이름**: 인증서에 기술된, 사람이나 조직과 같은 엔터티.
- **대상의 공개 키 정보**: 인증 대상의 공개키, 공개키에 사용된 알고리즘, 추가 매개변수
- **발급자의 고유 ID**: 발급자의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한
  식별자
- **대상의 고유 ID**: 대상의 이름이 겹치는 경우를 대비한, 인증 대상에 대한 선택적인 고유한 식별자
- **확장**: 각 확장 필드는 중요한 것인지 그렇지 않은지가 표시되어 있음
  - 기본제약 / 인증서 정책 / 키 사용
- **인증기관 서명**: 인증기관의 디지털 서명, 명시된 서명 알고리즘을 사용한다.

### 6.3 서버 인증을 위해 인증서 사용하기

- 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서
  디지털 인증서를 가져온다
- 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.
- 서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

1. 웹사이트의 이름과 호스트 명
2. 웹 사이트의 공개키
3. 서명 기관의 이름
4. 서명 기관의 서명

<img src="https://i.imgur.com/KYgfDFo.png" />

> 출처 [Network-3:HTTPS란?](https://minwan1.github.io/2019/01/09/2019-01-14-https/)

- 브라우저가 인증서를 받으면, 서명 기관을 검사한다.
- 만약 그 기관이 신뢰할만한 서명 기관이라면, 브라우저는 그것의 공개키를 이미 알고 있을 것이며
  **(브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출하된다)**, 브라우저는 그 서명을
  검증할 수 있다.
- 만약 서명 기관이 모르는 곳이라면, 브라우저는 그 서명 기관을 신뢰해야 할지 확신할 수 없으므로, 대개
  사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다.

<img src="/images/2019/44/03.jpg" />

---

- [HTTP 완벽가이드](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966261208&orderClick=LAG&Kc=)
  책을 보고 이해한 내용을 정리 한 글입니다.

---

**참고자료**

- [AES](https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%EC%95%94%ED%98%B8%ED%99%94_%ED%91%9C%EC%A4%80)
- [PKI](https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EA%B8%B0%EB%B0%98_%EA%B5%AC%EC%A1%B0)
- [RSA](https://blogger.pe.kr/583)
- [Network-3:HTTPS란?](https://minwan1.github.io/2019/01/09/2019-01-14-https/)
- [생활코딩 - 02. HTTPS와 SSL 인증서](https://opentutorials.org/course/228/4894)
- [암호학](https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99#%EB%8C%80%EC%B9%AD%ED%82%A4_%EC%95%94%ED%98%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C)

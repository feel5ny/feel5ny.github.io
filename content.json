{"meta":{"title":"필오의 개발일지","subtitle":"Frontend developer & love UX, Interaction","description":"프론트엔드 공부를 하며 기록하는 공간입니다.","author":"clara Kim","url":"http://feel5ny.github.io"},"pages":[],"posts":[{"title":"3/ Typescript_기본 데이터 타입","slug":"Typescript_04","date":"2017-11-17T03:33:40.000Z","updated":"2017-11-22T07:08:56.000Z","comments":true,"path":"2017/11/17/Typescript_04/","link":"","permalink":"http://feel5ny.github.io/2017/11/17/Typescript_04/","excerpt":"","text":"기본 데이터 타입 &#127793;타입스크립트에서 기본 자료형을 잘! 숙지해야 한다. 타입스크립트는 타입을 새로 만들면서 짜는 방식인데, 특정한 골격을 갖출 때 결국 남는건 기본 자료형들이 남는다. 이때 기본 자료형이 정확히 어떤 것들이 있는지 인지하고 있어야, 그 기본 자료형들을 잘 조합해서 내가 사용할 인터페이스를 만들어 낼 수 있고, 타입을 만들 수 있다. 자바스크립트의 기본자료형을 모두 포함한다. 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. literal 기본 자료형 Primitive Type (javascript) &#127793; boolean number string Template String Undefined &amp; null undefined &amp; null are subtypes of all other types null in JavaScript undefined in JavaScript 참조타입 (javascript) &#127919; Array Symbol 타입스크립트에서 추가로 제공하는 타입 &#128037; Void Any Never Tuple Enum 0. literal 값 자체가 변하지 않는 값을 의미합니다. 상수와 다른 것은 상수는 가리키는 포인터가 고정이라는 것이고, 리터럴은 그 자체가 값이자 그릇입니다. “리터럴 상수는 5, 1.23과 같은 숫자나, ‘This is a string’ 혹은 “It’s a string!”과 같은 문자열 등을 말합니다. 이것들이 리터럴 상수라고 불리우는 이유는 이것들이 프로그램 내에 직접 문자 형태로(literally) 지정되는 값들 이기 때문입니다. 이러한 값들은 한번 지정되면 변하지 않습니다. 예를 들면 숫자 2는 언제나 자기 자신이 2라는 숫자임을 나타내며 어떤 다른 의미도 갖지 않습니다. 이들은 한번 지정되면 그 값을 변경할 수 없기 때문에 상수입니다. 그 중에서도 특별히 이러한 값들을 리터럴 상수라고 부릅니다.” @kangpual 1. 기본 자료형 Primitive Type object와 reference 형태가 아닌 실제 값을 저장하는 자료형입니다. 프리미티브 형의 내장 함수를 사용 가능한것은 자바스크립트 처리 방식 덕분 동작 자체는 마치 객체인 것처럼 처리된다. 메모리를 아끼기 위해서 123let name = 'Nayoung';name.toString(); 1-1. boolean 가장 기본적인 데이터 타입 단순한 true 혹은 false 값 입니다. JavaScript / TypeScript 에서 ‘boolean’ 이라고 부른다. 소문자 boolean과 대문자 Boolean 소문자 boolean은 프리미티브 타입의 불린, 대문자 Boolean은 레퍼 오브젝트의 생성자 class인데, 자바스크립트에서는 두 가지의 차이가 크게 없지만, 타입스크립트에서는 차이가 있다. 타입스크립트에서는 소문자를 권장한다. Type &#39;boolean&#39; is assignable to type &#39;Boolean&#39;. Type ‘Boolean’ is not assignable to type ‘boolean’. ‘boolean’ is a primitive, but ‘Boolean’ is a wrapper object. Prefer using ‘boolean’ when possible. 1234567891011let isDone: boolean = false;typeof isDone === 'boolean' // true// Type 'boolean' is assignable to type 'Boolean'.let isOk: Boolean = true;// Type 'Boolean' is not assignable to type 'boolean'.// 'boolean' is a primitive, but 'Boolean' is a wrapper object.// Prefer using 'boolean' when possible.let isNotOk: boolean = new Boolean(true); 1-2. number JavaScript 와 같이, TypeScript 의 모든 숫자는 부동 소수점 값 입니다. TypeScript는 16진수 및 10진수 리터럴 외에도, ECMAScript 2015에 도입된 2진수 및 8진수를 지원합니다. 1234let decimal: number = 6; // 10진수 리터럴let hex: number = 0xf00d; // 16진수 리터럴let binary: number = 0b1010; // 2진수 리터럴let octal: number = 0o744; // 8진수 리터럴 1-3. string Template String을 자주 쓴다. 다른 언어에서와 마찬가지로 텍스트 형식을 참조하기 위해 string형식을 사용한다. 자바스크립트와 마찬가지로, 타입스크립트는 문자열 데이터를 둘러싸기 위해 큰 따옴표나 작은따옴표를 사용한다.12let name: string = \"mark\";name = 'anna'; 1-4. Template String 주로 사용한다. 행에 걸쳐 있거나, 표현식을 넣을 수 있는 문자열 이 문자열은 backtick (= backquote 기호에 둘러쌓여 있습니다.12345678910111213- 포함된 표현식은 `$&#123; expr &#125;` 와 같은 형태로 사용합니다.```jslet fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; fullName &#125;.I&apos;ll be $&#123; age + 1 &#125; years old next month.`;// template string 을 사용하지 않을 경우let sentence: string = &quot;Hello, my name is &quot; + fullName + &quot;.\\n\\n&quot; + &quot;I&apos;ll be &quot; + (age + 1) + &quot; years old next month.&quot;; 1-5. Undefined &amp; null TypeScript 에서 ‘undefined’ 와 ‘null’ 은 실제로 각각 ‘undefined’ 와 ‘null’ 이라는 고유한 타입을 가집니다. ‘void’ 와 마찬가지로, undefined 와 null 은 그 자체로는 쓸모가 없습니다. 둘다 소문자만 존재합니다. 1234// 이 변수들에 할당할 수 있는 것들은 거의 없다.let u: undefined = undefined;let n: null = null; 위 처럼 사용하기 보다는 return에서 주로 사용 1-5-1. undefined &amp; null are subtypes of all other types 기본 설정이 그렇습니다. 대입이 가능하다는 것이다. number에 null 또는 undefined 를 할당할 수 있다는 의미입니다. 하지만, 컴파일 옵션에서 --strictNullChecks사용하면, null과 undefined는 void나 자기 자신들에게만 할당할 수 있습니다. 이 경우, null과 undefined를 할당할 수 있게 하려면, union type 을 이용해야 합니다. (union type: 두개의 타입을 합치는 것.) 123456789101112131415161718// 대입 가능let name: string = null;let age: number = undefined;// strictNullChecks =&gt; true// 보통 위의 옵션을 true로 하진 않는다..// 위의 옵션이 추가되면 자기 자신이나 void에게만 할당 가능, 다른 타입에는 할당하지 못함.// let name: null = null; // (O)// Type 'null' is not assignable to type 'string'.let name: string = null; // (X)// null =&gt; null || void, undefined =&gt; undefined || void// Type 'null' is not assignable to type 'undefined'.let u: undefined = null; // (X)let v: void = undefined; // (O)let union: string | null | undefined = 'str'; 1-5-2. null in JavaScript null 이라는 값으로 할당된 것을 null 이라고 합니다. 무언가가 있는데, 사용할 준비가 덜 된 상태. (undefined는 무언가가 아예 준비가 안된 상태) null 이라는 타입은 null 이라는 값만 가질 수 있습니다. 런타임에서 typeof 연산자를 이용해서 알아내면, object 입니다. 1234let n: null = null;console.log(n); // nullconsole.log(typeof n); // object 1-5-3. undefined in JavaScript 값을 할당하지 않은 변수는 undefined 라는 값을 가집니다. 무언가가 아예 준비가 안된 상태 object 의 property 가 없을 때도 undefined 입니다. 런타임에서 typeof 연산자를 이용해서 알아내면, undefined 입니다.1234let u: undefined = undefined;console.log(u); // undefinedconsole.log(typeof u); // undefined 2. 참조타입 (javascript)2-1. Array 원래 자바스크립트에서 array 는 객체입니다. 사용방법 2가지 &#9996; Array&lt;타입&gt; 타입[] 123let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; 2-2. Symbol &#128580; ECMAScript 2015 의 Symbol입니다. 프리미티브 타입의 값을 담아서 사용합니다. 고유하고 수정불가능한 값으로 만들어줍니다. 그래서 주로 접근을 제어하는데 쓰는 경우가 많았습니다. 1234567let sym = Symbol();let obj = &#123; [sym]: \"value\"&#125;;console.log(obj[sym]); // \"value\" 3. 타입스크립트에서 추가로 제공하는 타입3-1. Void 타입이 없는 상태입니다. any 와 반대의 의미를 가집니다. Void는 대문자가 없습니다. 소문자입니다. 주로 함수의 리턴이 없을 때 사용합니다. 그 외에는 사용할 일이 거의 없습니다. 12345function returnVoid(message): void &#123; console.log(message);&#125;returnVoid('리턴이 없다'); 3-2. Any 어떤 타입이어도 상관없는 타입입니다. 이걸 최대한 쓰지 않는게 핵심입니다. 왜냐면 컴파일 타임에 타입 체크가 정상적으로 이뤄지지 않기 때문입니다. 그래서 컴파일 옵션 중에는 any 를 쓰면 오류를 뱉도록 하는 옵션도 있습니다. noImplicitAny 12345function returnAny(message): any &#123; console.log(message);&#125;returnVoid('리턴은 아무거나'); 3-3. Never 리턴에 주로 사용된다. 아래의 3가지 정도가 대부분123456789101112131415// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 3-4. Tuple 배열인데 타입이 한가지가 아닌 경우 마찬가지로 객체입니다. 꺼내 사용할때 주의가 필요합니다. 배열을 Destructuting 하면 타입이 제대로 얻어집니다. 12345678910111213141516// Declare a tuple typelet x: [string, number];// Initialize itx = [\"hello\", 10]; // OK// Initialize it incorrectlyx = [10, \"hello\"]; // Errorx[3] = \"world\"; // OK, 'string' can be assigned to 'string | number'console.log(x[5].toString()); // OK, 'string' and 'number' both have 'toString'x[6] = true; // Error, 'boolean' isn't 'string | number'const person: [string, number] = ['mark', 35];const [name, age] = person; 3-5. Enum C 에서 보던것과 같습니다. 아래 예제만 이해하면 사용 준비 끝 Enum의 결과값은 string형이다. Da,Da 할때 아침/점심/저녁/간식을 Enum타입으로 받았는데, 이때 문자열이였기 때문에 *1을 해줬었다. 1234567891011enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green;enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green;enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2]; // 결과값은 string으로 해야한다. 참고링크 http://jaroinside.tistory.com/10 http://poiemaweb.com/typescript-vscode http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html","categories":[{"name":"TIL","slug":"TIL","permalink":"http://feel5ny.github.io/categories/TIL/"},{"name":"Typescript","slug":"TIL/Typescript","permalink":"http://feel5ny.github.io/categories/TIL/Typescript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://feel5ny.github.io/tags/til/"},{"name":"typescript","slug":"typescript","permalink":"http://feel5ny.github.io/tags/typescript/"}]},{"title":"2016년 A월 B일","slug":"algorithm_02","date":"2017-11-16T04:42:33.000Z","updated":"2017-11-22T08:09:12.000Z","comments":true,"path":"2017/11/16/algorithm_02/","link":"","permalink":"http://feel5ny.github.io/2017/11/16/algorithm_02/","excerpt":"","text":"2016년 A월 B일2016년 1월 1일은 금요일입니다. 2016년 A월 B일은 무슨 요일일까요? 두 수 A,B를 입력받아 A월 B일이 무슨 요일인지 출력하는 getDayName 함수를 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각SUN,MON,TUE,WED,THU,FRI,SAT를 출력해주면 됩니다. 예를 들어 A=5, B=24가 입력된다면 5월 24일은 화요일이므로 TUE를 반환하면 됩니다. 1. 처음 생각한 로직 월마다 일 수가 다르다.a월이 1,3,5,7,10,12 &gt; 31일a월이 4,6,8,9,11 &gt; 30일a월이 2 &gt; 28일 일별로 요일이 다르다.const day = [&quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;]7일 day[0]6일 day[6] 전체 일수가 x라면x일을 7로 나눈후 나머지값 arr[x%7]x의 값은 ? 전체 일수를 배열과 연결하자.31일 + 1 = 32 // 배열에서 금요일부터 32번 후의 값1월 02월 31일 + b3월 31일 + 29일 + b4월 31일 + 29일 + 31일 + b5월 31일 + 29일 + 31일 + 30일 + b6월 31일 + 29일 + 31일 + 30일 + 31일 = 31일 * 3 + 30일 * 2 - 17월 31일 * 3 + 30일 * 3 -18월 31일 * 4 + 30일 * 3 -19월 31일 * 5 + 30일 * 3 -110월 31일 * 5 + 30일 * 4 -111월 31일 * 6 + 30일 * 4 -112월 31일 * 6 + 30일 * 5 -1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function getDayName(a, b) &#123; let answer = \"\"; let month = a; let date = 0; let inputDate = b; let week = 0; const day = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"] switch (month) &#123; case 1: date = 0 break; case 2: date = 31 break; case 3: date = 31 + 28 break; case 4: date = 31 * 2 + 29 break; case 5: date = 31 * 2 + 30 * 2 - 1 break; case 6: date = 31 * 3 + 30 * 2 - 1 break; case 7: date = 31 * 3 + 30 * 3 - 1 break; case 8: date = 31 * 4 + 30 * 3 - 1 break; case 9: date = 31 * 5 + 30 * 3 - 1 break; case 10: date = 31 * 5 + 30 * 4 - 1 break; case 11: date = 31 * 6 + 30 * 4 - 1 break; case 12: date = 31 * 6 + 30 * 5 - 1 break; &#125; date = date + inputDate return day[date % 7];&#125;//아래 코드는 테스트를 위한 코드입니다.console.log(getDayName(5, 24)); 2. case 문이 너무 비효율적이다. &gt; 반복문으로 바꾸자123456789101112function getDayName(a, b) &#123; let answer = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\",]; let month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; let sum = 0; for (let i = 0; i &lt; a - 1; i++) &#123; sum += month[i]; &#125; sum += b; return answer[(sum % 7)];&#125; 3. Date 메소드를 사용해보자.메소드 사용 123456function getDayName(a, b) &#123; let arr = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']; let date = new Date(`2016,$&#123;a&#125;,$&#123;b&#125;`); let day = date.getDay() return arr[day];&#125; 템플릿 리터럴을 사용하지 않으면 값이 이상하게 나온다. 이유 1234new Date();new Date(value);new Date(dateString);new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); *dateString날짜를 표현하는 문자열값. 문자열은 parse 메소드에 의해 인식가능한 형식이어야 한다. *year, month, date날짜의 각 부분을 표현하는 정수값. 월(month)부분은 0부터 11까지의 값을 가지며, 0이 1월을, 11이 12월을 가리킨다. 때문에 템플릿 리터럴로 넣게 되면 문자열이 되어서 그대로 파싱하지만, 숫자일 경우 배열의 인덱스값으로 인지하여서 월의 시작숫자가 0이게 된다.즉, let date = new Date(2016,a-1,b) 이렇게 넣어야 한다. 참고링크 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://feel5ny.github.io/categories/algorithm/"},{"name":"Level2","slug":"algorithm/Level2","permalink":"http://feel5ny.github.io/categories/algorithm/Level2/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://feel5ny.github.io/tags/algorithm/"}]},{"title":"2/ Typescript_tsconfig.json 프로퍼티의 종류","slug":"Typescript_03","date":"2017-11-15T10:30:01.000Z","updated":"2017-11-21T17:26:48.000Z","comments":true,"path":"2017/11/15/Typescript_03/","link":"","permalink":"http://feel5ny.github.io/2017/11/15/Typescript_03/","excerpt":"","text":"컴파일러 옵션실제 프로젝트에서는 컴파일러 옵션을 그렇게 많이 셋팅하진 않는다. 옵션을 셋팅할 수 있는 전체 스펙은 이 링크로 가면 확인 가능하다. 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 최상위 프로퍼티 compileOnSave extends files, include, exclude types compileOptions 6-1. target과 lib 6-2. outDir, outFile 6-3. module 1. 최상위 프로퍼티 tsconfig.json 파일에서 제일 상위에 정의되어있는 컴파일 옵션들 compileOnSave extends compileOptions (초기에는 compileOptions 요소가 많이 존재한다.) files include exclude 2. compileOnSave파일 변경 후 저장하면 바로 컴파일을 해준다. 에디터마다 안될 수도 있다. true / false (default false) true이면 저장하면 바로 컴파일됨 최상단에 설정해야 한다. 누가 ?? Visual Studio 2015 with TypeScript 1.8.4 이상 atom-typescript 플러그인 3. extends보통 많이 사용하지 않는다. 사용 예를 들면, 클라이언트 타입스크립트와 서버사이드 타입스크립트가 있을 때, 설정이 비슷하다면 어떤 파일을 만든 후, 상속을 받아서 작은 부분만 바꿔서 쓰는 경우 사용 가능하다. 파일 (상대) 경로명: string TypeScript 2.1 New Spec 12345678910111213141516 // in config/base.json&#123; \"compilerOptions\": &#123; \"noImplicitAny\": true, \"strictNullChecks\": true &#125;&#125;// in tsconfig.json&#123; \"extends\": \"./configs/base\", \"files\": [ \"main.ts\", \"supplemental.ts\" ]&#125; 4. files, include, exclude 셋다 설정이 없으면, 전부다 컴파일 files 상대 혹은 절대 경로의 리스트 배열. 파일별 부분 컴파일이 된다. exclude 보다 쎕니다.(exclude가 해놓아도 files에 있으면 컴파일 실행된다는 뜻) 특정 폴더를 exclude가 있어도 컴파일 된다. include, exclude glob 패턴 (마치 .gitignore) include exclude 보다 약하다. 같은걸 사용하면, .ts / .tsx / .d.ts 만 include (allowJS) exclude 설정 안하면 4가지(node_modules, bower_components, - jspm_packages, )를 default 로 제외한다. 은 항상 제외합니다. (include 에 있어도) 5.@types (중요!)TypeScript 2.0 부터 사용 가능해진 내장 type definition 시스템 이전 버전에서는 사용하지 못한다. 아무 설정을 안하면 ? node_modules/@types 라는 모든 경로를 찾아서 사용 typeRoots 를 사용하면 ? 배열 안에 들어있는 경로들 아래서만 가져옵니다. types 를 사용하면 ? 패키지 이름입니다. 배열 안의 모듈 혹은 ./node_modules/@types/ 안의 모듈 이름에서 찾아옵니다. [] 빈 배열을 넣는다는건 이 시스템을 이용하지 않겠다는 것입니다. 블루베리 플젝에서는 types를 사용한다. typeRoots 와 types 를 같이 사용하지 않습니다. 123456789101112131415161718192021// compiileOptions : type&#123; \"type\": \"object\", \"description\": \"Instructs the TypeScript compiler how to compile .ts files.\", \"properties\": &#123; \"typeRoots\": &#123; \"description\": \"Specify list of directories for type definition files to be included. Requires TypeScript version 2.0 or later.\", \"type\": \"array\", \"items\": &#123; \"type\": \"string\" &#125; &#125;, \"types\": &#123; \"description\": \"Type declaration files to be included in compilation. Requires TypeScript version 2.0 or later.\", \"type\": \"array\", \"items\": &#123; \"type\": \"string\" &#125; &#125; &#125;&#125; 6. compileOptions6-1. target과 lib1234567891011121314151617181920212223242526272829303132333435363738&#123; \"type\": \"object\", \"description\": \"Instructs the TypeScript compiler how to compile .ts files.\", \"properties\": &#123; \"target\": &#123; \"description\": \"Specify ECMAScript target version. Permitted values are 'es3', 'es5', 'es2015', 'es2016', 'es2017' or 'esnext'.\", \"type\": \"string\", \"default\": \"es3\", \"anyOf\": [ &#123; \"enum\": [ \"es3\", \"es5\", \"es2015\", \"es2016\", \"es2017\", \"esnext\" // 확정은 아니지만 곧 확정될 것 같은 문법들을 모아둔 ] &#125;, &#123; \"pattern\": \"^([eE][sS]([356]|(201[567])|[nN][eE][xX][tT]))$\" &#125; ] &#125;, \"lib\": &#123; \"description\": \"Specify library file to be included in the compilation. Requires TypeScript version 2.0 or later.\", \"type\": \"array\", \"items\": &#123; \"type\": \"string\", \"enum\": [ \"es5\", \"es6\", \"es2015\", \"es7\", \"es2016\", \"es2017\", \"esnext\", \"dom\", \"dom.iterable\", \"webworker\", \"scripthost\", \"es2015.core\", \"es2015.collection\", \"es2015.generator\", \"es2015.iterable\", \"es2015.promise\", \"es2015.proxy\", \"es2015.reflect\", \"es2015.symbol\", \"es2015.symbol.wellknown\", \"es2016.array.include\", \"es2017.object\", \"es2017.sharedmemory\", \"esnext.asynciterable\" ] &#125; &#125;, \"noLib\": &#123; \"description\": \"Do not include the default library file (lib.d.ts).\", \"type\": \"boolean\" &#125; &#125;&#125; target 빌드의 결과물을 어떤 버전으로 할 것이냐 지정을 안하면 es3 입니다. lib 기본 type definition 라이브러리를 어떤 것을 사용할 것이냐 잘 정의하지 않으면 빨간줄이 계속 생긴다. lib 를 지정하지 않을 때, target 이 ‘es3’ 이고, 디폴트로 lib.d.ts 를 사용합니다. target 이 ‘es5’ 이면, 디폴트로 dom, es5, scripthost 를 사용합니다. target 이 ‘es6’ 이면, 디폴트로 dom, es6, dom.iterable, scripthost 를 사용합니다. es5 이후에는 문법별 쪼개서도 설정 가능하다. ​lib 를 지정하면 그 lib 배열로만 라이브러리를 사용하니다. ​빈 [] =&gt; ‘no definition found 어쩌구’ 혹은 &quot;noLib&quot; : true로 바꾸면 된다. (거의 안쓸듯) 6-2. compileOptions: outDir, outFile 파일을 다 모아서 하나의 컴파일된 하나의 파일로 모으고 싶을 때 outFile을 사용 소스디렉토리에 그대로 똑같이 구조를 컴파일된 상태로 옮길 때 outDir를 사용 많이 사용한다.123456789101112131415161718&#123; \"type\": \"object\", \"description\": \"Instructs the TypeScript compiler how to compile .ts files.\", \"properties\": &#123; \"outFile\": &#123; \"description\": \"Concatenate and emit output to single file.\", \"type\": \"string\" &#125;, \"outDir\": &#123; \"description\": \"Redirect output structure to the directory.\", \"type\": \"string\" &#125;, \"rootDir\": &#123; \"description\": \"Specifies the root directory of input files. Use to control the output directory structure with --outDir.\", \"type\": \"string\" &#125; &#125;&#125; 6-3. compileOptions: modulemodule 결과물을 어떻게 무엇을 쓸것인가에 대한 것이다. 컴파일 된 모듈의 결과물을 어떤 모듈 시스템으로 할지를 결정 target 이 ‘es6’ 이면 es6 가 디폴트이고, target 이 ‘es6’ 가 아니면 commonjs 가 디폴트 입니다. AMD 나 System 와 사용하려면, outFile 이 지정되어야 합니다. ES6 나 ES2015 를 사용하려면, target 이 es5 이하여야 합니다. moduleResolution ts 소스에서 모듈을 사용하는 방식을 지정해야 합니다. classic 아니면 node 입니다. commonJS 일때만 node 라고 생각하시면 됩니다. paths 와 baseUrl 상대경로 방식이 아닌 baseUrl 로 꼭지점과 paths 안의 키/밸류로 모듈을 가져가는 방식입니다. rootDirs 배열 안에서 상대 경로를 찾는 방식입니다. 12345678910111213141516171819202122232425262728293031&#123; \"type\": \"object\", \"description\": \"Instructs the TypeScript compiler how to compile .ts files.\", \"properties\": &#123; \"module\": &#123; \"description\": \"Specify module code generation: 'none', 'CommonJS', 'Amd', 'System', 'UMD', or 'es2015'.\", \"enum\": [ \"commonjs\", \"amd\", \"umd\", \"system\", \"es6\", \"es2015\", \"none\" ] &#125;, \"moduleResolution\": &#123; \"description\": \"Specifies module resolution strategy: 'node' (Node) or 'classic' (TypeScript pre 1.6) .\", \"type\": \"string\", \"pattern\": \"^(([Nn]ode)|([Cc]lassic))$\", \"default\": \"classic\" &#125;, \"baseUrl\": &#123; \"description\": \"Base directory to resolve non-relative module names.\", \"type\": \"string\" &#125;, \"paths\": &#123; \"description\": \"Specify path mapping to be computed relative to baseUrl option.\", \"type\": \"object\" &#125;, \"rootDirs\": &#123; \"description\": \"Specify list of root directories to be used when resolving modules.\", \"type\": \"array\", \"items\": &#123; \"type\": \"string\" &#125; &#125; &#125;&#125; 현재 플젝 tsconfig.json처음보는 옵션들이 있어서 정리해보았다.참고 : 타입스크립트 공식 페이지 allowSyntheticDefaultImports: true Allow default imports from modules with no default export. This does not affect code emit, just typechecking. 리엑트에서 컴포넌트를 import할 때 주로 쓰는 import Something from &#39;./Something&#39;을 사용할 수 있다. noImplicitAny: false Raise error on expressions and declarations with an implied any type. 암시적으로 선언되었는데 any 로 추론되면 에러를 알려줍니다. false이면 무시됨. preserveConstEnums: true Do not erase const enum declarations in generated code. See const enums documentation for more details. enum 변수선언을 유지한다는 것 같은데 정확히 잘 모르겠다. allowJs : false include에 있는 파일 경로들에 존재하는 모든 .ts, .tsx파일들이 컴파일되는데, allowJs를 true로 하면 .js와 .jsx파일도 컴파일 대상이 된다. sourceMap : true Generates corresponding .map file. 트랜스파일을 거치는 많은 모듈들이 디버깅을 위해서 기본적으로 source map 출력을 지원한다. noImplicitReturns : true Report error when not all code paths in function return a value. 제대로 리턴 다 안되면 에러 -&gt; 오류에 대해 강력하게 체크한다는 뜻입니다. noUnusedParameters : true Report errors on unused parameters. 사용하지 않는 파라미터가 있으면 에러를 알려줍니다. noUnusedLocals : true Report errors on unused locals. 사용 안하는 로컬 변수가 있으면 에러를 알려줍니다. 참고링크 http://jaroinside.tistory.com/10 http://poiemaweb.com/typescript-vscode http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html","categories":[{"name":"TIL","slug":"TIL","permalink":"http://feel5ny.github.io/categories/TIL/"},{"name":"Typescript","slug":"TIL/Typescript","permalink":"http://feel5ny.github.io/categories/TIL/Typescript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://feel5ny.github.io/tags/til/"},{"name":"typescript","slug":"typescript","permalink":"http://feel5ny.github.io/tags/typescript/"}]},{"title":"overview","slug":"dada_06week","date":"2017-11-14T01:10:04.000Z","updated":"2017-11-13T11:01:08.000Z","comments":true,"path":"2017/11/14/dada_06week/","link":"","permalink":"http://feel5ny.github.io/2017/11/14/dada_06week/","excerpt":"","text":"식단 다이어리 서비스, DA,DA프론트엔드 스쿨을 마지막 달에는 그동안 배운 기술을 토대로 프로젝트를 필수적으로 진행해야 했다. node.js 스쿨과 함께 5명으로 이루어진 우리 조는 33일간의 대장정을 끝으로, 알바퍼전의 웹서비스가 배포할 수 있게 되었다. 블로그에서는 프론트엔드 중심으로 이번 프로젝트에 대한 개인적인 후기와 더불어 전반적인 진행과정, 이슈에 대해서 5가지 챕터로 포스팅하려고 한다. chapter 1 : 기획 및 프로토타입 및 디자인chapter 2 : 퍼블리싱chapter 3 : 핵심기능 개발chapter 4 : 리팩토링 및 테스트chapter 5 : 추가개발 및 배포 이번 프로젝트를 통해서 크게 3가지를 얻을 수 있었다. 비동기통신 redux 자유로운 사용 react 라이프사이클과 한계 github : https://github.com/huusz/Da-Da DA,DA : https://dada.downmix.net (카카오 아이디로 로그인)","categories":[{"name":"Project","slug":"Project","permalink":"http://feel5ny.github.io/categories/Project/"},{"name":"DA, DA","slug":"Project/DA-DA","permalink":"http://feel5ny.github.io/categories/Project/DA-DA/"}],"tags":[{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"DADA","slug":"DADA","permalink":"http://feel5ny.github.io/tags/DADA/"}]},{"title":"야근지수 (미제)","slug":"algorithm_01","date":"2017-11-13T08:10:04.000Z","updated":"2017-11-22T07:19:03.000Z","comments":true,"path":"2017/11/13/algorithm_01/","link":"","permalink":"http://feel5ny.github.io/2017/11/13/algorithm_01/","excerpt":"","text":"야근 지수회사원인 수민이는 많은 일이 쌓여 있습니다. 수민이는 야근을 최소화하기 위해 남은 일의 작업량을 숫자로 메기고, 일에 대한 야근 지수를 줄이기로 결정했습니다. 야근 지수는 남은 일의 작업량을 제곱하여 더한 값을 의미합니다. 수민이는 1시간 동안 남은 일 중 하나를 골라 작업량 1만큼 처리할 수 있습니다. 수민이의 퇴근까지 남은 N 시간과 각 일에 대한 작업량이 있을 때, noOvertime 함수를 제작하여 수민이의 야근 지수를 최소화 한 결과를 출력해 주세요. 예를 들어, N=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 일을 한 결과는 [2, 2, 2]가 되고 야근 지수는 22 + 22 + 22 = 12가 되어 12를 반환해 줍니다. 처음 생각한 로직 해당 배열의 전체 합 - N값 1번의 값을 배열의 길이로 나눈다. 나머지가 0인 경우와, 0이 아닌 경우가 생긴다. 나머지가 0인 경우, 해당 몫의 제곱근에 length값을 곱한다. (끝) 나머지가 0이 아닌경우, 몫이 소수점이 나온는데, 이는 내림하여 소수점 자리수들을 버리고 (floor) 해당 값과 배열의 인자를 비교하여, 해당 값보다 작은 인자의 경우 바로 제곱근화 하고, 나머지 값은 해당 몫으로 제곱하여 더한다. (이 부분이 잘못되었음) 3번의 첫번째 나머지가 0인 경우는 테스트가 통과하는데 2번째 경우는 로직이 잘못됨 통과하고 싶다","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://feel5ny.github.io/categories/algorithm/"},{"name":"Level3","slug":"algorithm/Level3","permalink":"http://feel5ny.github.io/categories/algorithm/Level3/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://feel5ny.github.io/tags/algorithm/"}]},{"title":"Firebase의 storage 연동하기","slug":"firebaseStorage","date":"2017-11-12T01:10:04.000Z","updated":"2017-11-22T06:48:06.000Z","comments":true,"path":"2017/11/12/firebaseStorage/","link":"","permalink":"http://feel5ny.github.io/2017/11/12/firebaseStorage/","excerpt":"","text":"학교 로고 모음 사이트 현재 상황 팀 프로젝트인 식단 다이어리 서비스 dada 프로젝트에서는 db 설계에 대한 이슈가 없었다. 당연히 난 프론트엔드다보니.. db 설계를 담당하지 않아서인 건데, 현재 개인 프로젝트에서는 db 구조까지 짜는 작업을 하고 있다. DB 구조짜기300개의 데이터와 개당 storage에 연동되어있는 파일들이 있는데, 제일 좋은 건 db에 url 칼럼을 넣는 방식. 파이어베이스에서는 스토리지와 데이터베이스 연결하는 것까지는 제공하지 않는 듯하다. 수동으로 작업해야 하는데 아직 좋은 방법이 떠오르지 않는다. 데이터 불러오기storage에 있는 데이터를 가져오는데, 현재 이슈. 한 디렉토리에 300개를 넣어두고 한 번에 갖고 오는 방식이라 아주 느리다. db 디렉토리를 20개씩 분리한 후, 더 보기 형태의 방식으로 해결해야겠다. map을 돌려서 해당 db 인덱스값과 같은 값의 파일을 갖고 오게 하기위해서 파일 이름에 학교 이름이 아닌 PNG_1.png 이런 방식의 파일 이름으로 지정해두었다. 매칭이 잘못된 학교 이름을 찾아 내기도 힘들고, ux도 너무 안 좋을 것 같아서, 파일 이름을 학교 이름으로 바꾸기로 결정했다. 생각해 보니 지역별 칼럼을 정리하지 않았다. 비록 일일이 검토 후에 로고를 올리는 것이지만, 한 번 더 체킹을 위해 학교 url을 넣는게 좋겠다고 판단. 칼럼을 추가해야겠다. 공공api가 있었으면 좋겠다. 생각보다 db 짜는건 굉장한 노가다다! dada 프로젝트 할 때 백엔드 분께서 ‘생각보다 노가다도 많이 하게 되는데, 또 생각보다 어렵진 않더라구요!’ 라고 했던 말이 와닿는 하루다.","categories":[{"name":"Project","slug":"Project","permalink":"http://feel5ny.github.io/categories/Project/"},{"name":"Univ Project","slug":"Project/Univ-Project","permalink":"http://feel5ny.github.io/categories/Project/Univ-Project/"}],"tags":[{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"firebase","slug":"firebase","permalink":"http://feel5ny.github.io/tags/firebase/"},{"name":"db","slug":"db","permalink":"http://feel5ny.github.io/tags/db/"}]},{"title":"1/ Typescript_환경 셋팅","slug":"Typescript_02","date":"2017-11-10T01:52:01.000Z","updated":"2017-11-21T16:59:08.000Z","comments":true,"path":"2017/11/10/Typescript_02/","link":"","permalink":"http://feel5ny.github.io/2017/11/10/Typescript_02/","excerpt":"","text":"개발환경 구축 및 컴파일러 셋팅앞선 글에서 컴파일러와 트랜스파일러 인터프리터의 차이점을 알아보았다. 트랜스파일러와 컴파일러의 차이가 있다고는 했지만, 앞으로의 글에서는 컴파일러라고 통일해서 쓰려고 한다. 타입스크립트는 컴파일드 언어라고 했지만, 실제적으로 어떻게 환경을 셋팅하고 작업해야하는지 알아보자. 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 실행환경 컴파일러 셋팅, 에디터 간단하게 실습 컴파일러 옵션 목표타입스크립트를 사용하기 위해서 첫번째 실행환경을 셋팅하고, 컴파일러 셋팅(npm으로 설치), 에디터에서 환경셋팅(tslint, 등등)을 하고, 간단하게 실습으로 컴파일 테스팅해본다. 기본 테스트가 완료되면 컴파일러 옵션을 어떻게 추가해야하는지 알아본다. 1. 실행환경런타임 환경 1-1. node.js 자바스크립트 런타임 환경으로 node.js를 사용한다. 컴파일러를 설치하기 위해서 필요하다. 타입스크립트에서 컴파일러 프로그램을 제공하는 것이 npm 모듈로 있기 때문에.. node.js없이 VScode에서도 셋팅이 가능하긴하다. (2번에서 확인!) 버전을 바꾸고 싶을 때는 nvm (node.js version manager) 사용 ~ 1-2. browser 결과를 보는 곳.. 그냥 있는거 쓰자. 2. (타입스크립트) 컴파일러 셋팅, 에디터타입스크립트를 셋팅해 보자. 셋팅 방법에는 npm과 VScode plugin으로 설치하는 방법이 있는데, npm으로 설치해보았다. 2-1. npm으로 설치하기1npm i typescript -g 설치 후 node_modules 폴더의 bin파일에 tsc파일이 생성되는 것을 볼 수 있다. .bin 내부에 있는 파일들은 스크립트에서 경로 없이 파일 이름으로만 바로 실행시킬 수 있다.12345node_modules/.bin/tsc 파일이름// 원래는 이렇게tsc source.ts// 경로 생략 가능, 뒷부분은 컴파일 할 파일 이름 2-2. Visual Studio Code 내장 플러그인 사용하기타입스크립트로 만들어졌기 때문에 타입스크립트에 대한 지원이 강력! ts파일을 선택 후 하단 bar를 보면 Typescript라는 단어와 버전이 보인다. 버전을 누르면 옵션창이 보이게 되는데, 이는 VS Code에 내장되어있는 컴파일러 리스트 중 선택하라는 옵션창이다. 내장된 컴파일러 버전은 VS Code 가 업데이트 되면서 자동으로 올라가며, 컴파일러 버전과 VS Code 의 버전은 상관 관계가 있다. 내장된 컴파일러를 선택할수 있고, 직접 설치한 컴파일러를 선택할 수도 있다. 2-3. tslint 설치eslint와 같이 코딩 컨벤션을 맞추기 위한 프로그램이다.12npm i typescript tslint (로컬)tslint --init tslint.json파일이 생성되고, 프로젝트에 맞게 코딩 컨벤션을 셋팅할 수 있다.https://palantir.github.io/tslint/ 에디터에서 tslint 플러그인 설치 cmd + p &gt; 옵션창 ext install tslint그냥 확장프로그램에 가서 tslint 검색 후 다운로드 받아도 된다. VScode : https://marketplace.visualstudio.com/items?itemName=eg2.tslint 3. 간단하게 실습3-1. 특정 프로젝트 폴더에서 타입스크립트 컴파일러 설정에 맞춰 컴파일tsconfig.json파일에서 옵션을 추가하여 컴파일시 여러 조건을 걸 수 있다. tsconfig파일 초기셋팅 1tsc --init tsconfig.json파일이 생성이 된다. 처음 생성시 디폴트로 되어있는 tsconfig.json파일12345678910&#123; \"compilerOptions\": &#123; /* Basic Options */ \"target\": \"es5\" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. */, \"module\": \"commonjs\" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */, \"strict\": true /* Enable all strict type-checking options. */ &#125;&#125; target : 컴파일된 결과물을 es5 버전으로 맞추겠다는 것 module : 컴파일된 결과물이 어떤 모듈로 사용할 것인지? 옵션에 대한 자세한 설명은 4번에서 설명! 3-2. watch 모드1tsc -w 변경되면 감지해서 새로 컴파일 해주는 것. 보통은 gulp를 사용한다. 3-3. 프로젝트 파일 내에서만 설치할 경우 (로컬)셋팅 방법12345npm init -ynpm i typescript // 프로젝트 이름(폴더이름)이 동일하면 안된다.package.json &gt; \"scripts\"에 \"transpile\" : \"tsc\" 추가.// tsc파일이 .bin폴더 내부에 있는데, npm에서는 .bin내부의 파일들은 전체 상대 경로를 적지 않아도 접근 가능하다.npm run transpile typescirpt를 글로벌로 설치할 경우 tsc 파일이름.ts 명령어만으로 컴파일이 가능하다. 로컬로만 설치할 경우, 위의 방법처럼 따로 스크립트에 추가 후에 명령어를 사용하면된다. cli 명령어로 명렁어를 다 걸어둘 수 있지만 json파일을 만들어서 설정을 정리하며서 쓴다. 참고링크 https://marketplace.visualstudio.com/items?itemName=eg2.tslint https://palantir.github.io/tslint/","categories":[{"name":"TIL","slug":"TIL","permalink":"http://feel5ny.github.io/categories/TIL/"},{"name":"Typescript","slug":"TIL/Typescript","permalink":"http://feel5ny.github.io/categories/TIL/Typescript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://feel5ny.github.io/tags/til/"},{"name":"typescript","slug":"typescript","permalink":"http://feel5ny.github.io/tags/typescript/"}]},{"title":"0/ Typescript?","slug":"Typescript_01","date":"2017-11-08T09:23:55.000Z","updated":"2017-11-21T16:59:10.000Z","comments":true,"path":"2017/11/08/Typescript_01/","link":"","permalink":"http://feel5ny.github.io/2017/11/08/Typescript_01/","excerpt":"","text":"자바스크립트 말고 타입스크립트?최근 프로젝트를 진행하면서 나도 모르는 사이에 타입이 자주 바뀌는 자바스크립트의 불편함을 느끼곤 했었다. 애초에 값을 할당할 때 타입 체킹은 그 순간에 내 머릿속에서만 생각만 하지, 그 이후는 케어하지 못하게 되었다. 나중에 에러가 발생하면, 삽질 후에 원인이 타입 때문이라는 것을 알게 되고.. 이는 생각보다 빈번하게 일어났다. 콘솔에서 타입 에러를 잡지 않고 렌더링이 될 때가 있기 때문에 타입으로 발생한 버그를 잡을 때는 시간이 더 걸린다.( 왜 에러가 나는 거여? 물론 리액트는 타입도 종종 잡아준다. 무튼 시간 아까워! ) 버그 잡는 게 중요하긴 한데, 타입이 원인이라는 것은 뭔가 어처구니없는 실수라는 생각도 들었다..그러다 문득! 예전에 타입 버그가 날 때마다 타입스크립트를 배우면 이런 버그는 애초에 만나지 않을 겁니다! 라고 자주 얘기하셨던 선생님이 종종 생각났고.. 게다가 지금 여러 프로젝트에서 타입스크립트을 도입하고도 있고, 얼마 후에 앵귤러도 시작하고자 해서.. 겸사겸사 동기부여가 여러 군데에서 생겼기 때문에!! 시작!! 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 타입스크립트는 무엇인가 컴파일러? 트랜스파일러? 인터프리터? 정적타입 언어 vs 동적타입 언어 1. 타입스크립트는 무엇인가.타입스크립트는 프로그래밍 언어 중 하나이다. 자바스크립트가 인터프리터 기반의 언어로써, 실행과 동시에 렌더링이 되는데, 타입스크립트는 인터프리터 방식이 아닌 컴파일 후에 실행되는 Compiled Language이다. 별도의 빌드 과정이 필요! 전통적인 컴파일 언어와는 다른데, (C언어, 자바 …) 때문에 Compile말고, Transpile이라는 용어를 사용하기도 한다. 혹은 meta programming이라고 한다. 2. 컴파일러? 트랜스파일러? 인터프리터?간단하게 3가지를 비교해보면 아래 그림과 같다. transpiler하나의 언어를 다른 형태의 언어로 변환해 주는 기능을 부각시키는 표현으로 compiler라는 표현보다 transpiler라는 표현을 쓴다. (번역이라는 말과 합쳐진 듯 하다.)ex. Typescript, Babel compiler한 번 컴파일 하게 되면, 별도 생성된 목적 파일을 통해 빠르게 실행할 수 있다. 대용량 소스에 적합 컴파일이 필요 O 컴파일러가 필요 O 컴파일하는 시점 O =&gt; 컴파일 타임 컴파일된 결과물을 실행 컴파일된 결과물을 실행하는 시점ex. C, Go, C#, JAVA, … interpreter목적 파일 산출 과정이 없이 실행과 동시에 줄 단위로 번역이 된다. 저용량 소스에 적합 컴파일이 필요 X 컴파일러가 필요 X 컴파일하는 시점 X 코드 자체를 실행 코드를 실행하는 시점 o = 런타임ex. javascript *Tranditional Compiled Language 컴파일 언어라고 한다. C, C++, Go, C#, Java, … 프로그래머가 작성한 Source Code 를 기계어로 변환하는 과정을 Compile이라고 한다. 기계어로 변환된 결과물을 Object Code (목적 코드)라 한다. Compile 하는 프로그램을 Compiler 라고 한다. Compile 하는 동안을 Compile Time 이라고 한다. 컴파일된 코드는 프로세서에 따라 다르다. 소스 코드에서는 OS 에 따라 라이브러리가 다르다. 컴파일된 코드는 작은 크기에 최적화된다. 일반적으로 실행시 기계어로 바꾸는 방식(인터프리터 언어)보다 빠르다. 실행시 기계어로 바꿔주는 연산이 필요없기 때문이다. 3. 정적타입 언어 vs 동적타입 언어 정적 타입 언어 : 미리 타입을 지정해놓고 시작 자바스크립트에서 정적타입언어만 갖고오자라고 한 것이 TypeScript 동적 타입 언어가 갖고 있는 단점을 커버하자.하는 목적이다. test coverage를 올리면 상관없긴하다. ex. Typescript 동적 타입 언어 : 타입을 정하지 않는다. 타입 자체가 변화하는 것을 막지않는다. ex. Javascript *The End of Dynamic Languages vs Have Static Languages Won? 최근 나타나는 신생언어들은 대부분 정적 타입을 지원한다. (Typed Racket, Typed Clojure, TypeScript, Typed Lua, Python with type hints) 정적 언어로 작성된 코드의 버그는 해당 코드를 실행하기 전까지는 찾을 수 없다. 동적 언어의 경우 대부분 대충 디자인되어있다. JavaScript의 경우에는 2주만에 개발된 언어이다보니 컴파일러와 힌들리-밀너 타입추론 시스템과 같은 CS지식으로 무장한 사람들이 디자인한 언어와 비교하는건 무리다. Closure 같은 경우에도 이제는 대부분의 언어에서 지원하게 되면서 functional 과 imperative 프로그래밍이 융합되듯이, 동적 언어와 정적 언어도 그렇게 되지 않을까? Crystal Programming Language 의 경우 루비를 기반으로 하는 정적/동적 언어가 합쳐진 언어이다. 참고링크 http://www.notforme.kr/archives/1541 http://www.geekhours.com/2017/03/08/difference-compiling-transpiling/ https://ruslanspivak.com/lsbasi-part1/ http://blog.sejongin.kr/44 http://hieroglyph.tistory.com/4 https://okky.kr/article/304342","categories":[{"name":"TIL","slug":"TIL","permalink":"http://feel5ny.github.io/categories/TIL/"},{"name":"Typescript","slug":"TIL/Typescript","permalink":"http://feel5ny.github.io/categories/TIL/Typescript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://feel5ny.github.io/tags/til/"},{"name":"typescript","slug":"typescript","permalink":"http://feel5ny.github.io/tags/typescript/"}]},{"title":"Hexo 설치","slug":"aboutHEXO","date":"2017-09-10T11:46:25.000Z","updated":"2017-11-13T10:16:59.000Z","comments":true,"path":"2017/09/10/aboutHEXO/","link":"","permalink":"http://feel5ny.github.io/2017/09/10/aboutHEXO/","excerpt":"","text":"intro 무언가를 배울때 하루하루의 기록을 남기는 것은 자기계발의 첫 스타트라고 생각합니다. 머리속에 있는 것을 그대로 옮기는 작업은, 정리하며 내것으로 만들기에도 좋고, 그때그때의 생각을 기록하는 용으로도 좋기 때문입니다. 그래서 우리는 일기를 쓰고, 일지를 쓰고, 이렇게 블로그도 만들며 기록합니다. 특히나 개발은 많은 개념을 숙지하면서 공부해야하기 때문에 블로깅 자체가 공부가 됩니다. 이왕 node.js까지 배우고 있으니, jekyll이 아닌, hexo를 사용해서 블로그를 만들었습니다. 목차 Github 간단 소개 원격 저장소 원격저장소 Github이 제공하는 정적웹사이트, Github Pages 호스팅을 편리하게 만들어주는 generator, Jekyll &amp; HEXO Github Pages로 정적 페이지 Hosting하기 로컬에 저장소 생성하기 원격 저장소 생성하기 (Github Repository) 원격 저장소와 로컬 저장소 연결하기 Hexo 설치하기 Hexo 설치 전 준비 Hexo npm 설치하기 설정파일 업데이트 Github에 배포하기 hexo 설정을 통해 정적 리소스를 생성하기 배포하기 anatol 테마적용하기 0. Github 간단 소개깃에 대해서 잘 알고 있다면 1번으로 넘어가도 됩니다. 0-1. 원격저장소Git이란 소스코드를 효과적으로 관리하기 위해 개발된 ‘분산형 버전 관리 시스템’입니다.git은 저장소에서 관리를 하는데, 내 컴퓨터에 있는 저장소를 로컬저장소라고 하고, 웹 상에 있는 저장소를 원격저장소라고 합니다. 우리가 흔히 알고 있는 원격저장소를 제공하는 서비스에는 깃헙, 비트버킷, 깃랩등이 있습니다다. 헥소를 이용한 블로그 개설을 위해서는 깃헙을 사용해야합니다. 0-2. 원격저장소 Github이 제공하는 정적웹사이트, Github PagesGithub에서 제공하는 Static Website, Github Pages가 있다. 깃헙 저장소에 리소스를 push만 해도(push란 저장소에 리소스를 넣을때 사용하는 명령어) 간단하게 웹사이트를 만들 수 있다. 즉, 다른 호스팅 서비스의 도움없이, 원격저장소에 올리기만해도 호스팅이 가능하다. 0-3. 호스팅을 편리하게 만들어주는 generator, Jekyll &amp; HEXO 사실, hexo나 jekyll이 없이도, html,css,javascript를 통해서도 호스팅이 가능하나, 블로그 구성상 글을 등록하고, 리스트를 보여주며, 댓글을 달 수 있는, 블로그가 갖고 있는 기능을 편라히게 사용하기 위해서 hexo나 jekyll과 같은 generator를 사용해야 한다. Static Website generator는 마크다운을(.md 파일)로 편집 후 html로 변환할 수 있도록 돕는다. generator에는 jekyll과 HEXO가 있는데, jekyll은 ruby기반, HEXO는 node.js기반이다. 그럼 generator을 셋팅하기 전, 내 컴퓨터에 디렉토리(폴더)를 생성하고, 원격저장소(github)에 연결을 시켜보자. 1. Github Pages로 정적 페이지 호스팅하기Github Pages를 사용하기 위해 Github의 원격저장소에 리소스를 올려야한다는 사실을 잊지말자. 아래 그림의 저장소들이 필요하다. 1-1. 로컬에 저장소 생성하기내 컴퓨터 원하는 장소에 폴더를 생성한다.terminal없이도 생성해도 된다.아래는 terminal을 이용한 생성방법 1234&lt;!-- 바탕화면에 생성한다는 가정 (글쓴이는 운영체제가 mac입니다.) --&gt;$ cd Desktop$ mkdir github-blog 바탕화면에 github-blog라는 이름의 폴더가 생성이 되었다. 1-2. 원격 저장소 생성하기 (Github Repository)github pages를 통해 손쉽게 USERNAME.github.io를 통해 정적 페이지를 호스팅 할 수 있다. 번외 &gt; gh-pages 브랜치를 생성하면, 각 repository마다 USERNAME.github.io/레포이름으로 호스팅이 가능하다. 지금부터 말하는 USERNAME은, 당신의 아이디이다. 깃헙주소 뒷부분 /이후 붙는 유저네임을 붙이면된다. 아래 순서로 깃 저장소를 생성한다. New Repository &gt; 이름은 꼭 USERNAME.github.io로 적용한다. Public선택. 원격저장소 생성 완료 1-3. 원격 저장소와 로컬 저장소 연결하기내 컴퓨터에 저장소를 만들고, 원격에도 만들었으니, 연결을 해야한다. 연결하는 방법은 간단하다. 지금은 터미널을 열고 명령어를 입력해야하는 타이밍이다. 1번에서 만들었던 디렉토리로 이동한다. 해당 디렉토리에서 원격저장소의 git을 clone한다. clone 뒤에 생성한 원격저장소의 주소를 입력하는데, 이는 remote가 동시에 일어나므로, 따로 remote 명령어를 입력안해도 된다. 연결 테스트겸, READMD.md 파일을 생성한다. 생성된 README.md파일을 푸시한다. (commit &gt; push) 위의 순서를 코드로 옮기면. 12345678910111213141516&lt;!-- 1. 해당 디렉토리로 이동 --&gt;cd Desktopcd github-blog&lt;!-- 2. git clone --&gt;git clone https://github.com/feel5ny/TEST.github.io.gitcd test.github.io&lt;!-- 3. README.md파일 생성 --&gt;echo README.md&lt;!-- 4. 원격저장소에 올리기 --&gt;git add --allgit commit -m \"first commit\"git push -u origin master step 1이 끝났다! 그리고 벌써 호스팅이 완료되었다.USERNAME.github.io에 가보자. 아직 블로그의 형태를 띄지 않았다. 위에서 말했던 generator를 이용하여 블로그의 구조를 짤 예정인데, 우리는 HEXO를 이용할 것이다. 2. Hexo 설치하기Hexo는 node.js기반이기 때문에 npm을 통해 쉽게 설치가 가능하다. 다양한 plugin과 테마를 지원하고 있다. 2-1. Hexo 설치 전 준비Hexo는 말했다 싶이 node.js 기반이기 때문에 node.js가 로컬에 기본적으로 설치되어있어야 한다. node.js는 공식 사이트에서 설치가 가능하다. stable버전을 추천한다. 2-2. Hexo npm 설치하기Node.js를 설치 한 후에 아래 CLI를 순서대로 입력하여 npm을 설치한다.1234npm install hexo-cli -ghexo init blogcd blognpm install node.js를 설치하면 npm을 사용할 수 있는데, 패키지 중에 hexo-cli를 설치한다. blog파일을 생성하여 hexo를 초기화한다. blog 디렉토리로 이동후, npm install을 사용하여, blog에 필요한 파일들을 자동으로 설치한다. 2-3. 설정파일 업데이트위의 순서가 끝나면, root 디렉토리에 _config.yml이라는 설정파일이 생성된다. (yml파일은 사람이 쉽게 읽을 수 있는 데이터 직력화 양식으로,…more) 해당 파일에 블로그 정보를 수정한다. 나머지 정보는 hexo 공식 문서에서. Site 정보블로그 정보를 수정할 수 있다. 1234title: 제목(html head에 들어가는 title태그에 들어가는 제목과 같다.)subtitle: description:author: Nayoung Kim URL 정보블로그 URL 정보를 설정할 수 있다. 1234url: https://USERNAME.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: Github 정보배포를 위해서 저장소 주소를 추가한다. 1234# Deploymentdeploy: type: git repo: https://github.com/feel5ny/TEST.github.io.git 테마별로 구성을 수정하는 스타일이 다르다. 테마 적용하기 파트에서 anatol 레이아웃 수정방법을 설명하겠다. 2-4. 로컬에서 테스트하기1hexo server blog 디렉토리에 위치되어있는 상태에서 서버를 구동한다. blog에 위치되어있지 않으면 서버구동이 안된다. 서버 구동이 완료되면 4000번 포트로 접속이 가능하다. http://localhost:4000 테스트시 구동이 잘 안될 경우, 서버를 껐다가 다시 실행해 보면된다. 서버를 끄는 방법은 터미널에서 ctrl+c를 두번 입력하면 된다. 3. Github에 배포하기로컬에서 테스트를 완료하면 USERNAME.github.io 주소로 배포해보자. 3-1. hexo 설정을 통해 정적 리소스를 생성하기1hexo generate 위 명령어를 입력하면, github에 올라갈 리소스만 정리되어 따로 폴더가 생성된다. 3-2. 배포하기1hexo deploy 위 명령어를 입력하면 배고가 완료된다. generate와 deploy를 한번에 진행하고 싶은 경우 아래 명령어를 입력한다. 1hexo deploy --generate 약자로 hexo d g를 사용해도 됩니다. 3-3. 배포가 잘 안될 경우12hexo cleanhexo deploy --generate","categories":[{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/categories/blog/"},{"name":"hexo","slug":"blog/hexo","permalink":"http://feel5ny.github.io/categories/blog/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://feel5ny.github.io/tags/hexo/"},{"name":"node.js","slug":"node-js","permalink":"http://feel5ny.github.io/tags/node-js/"}]}]}
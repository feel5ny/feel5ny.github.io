{"meta":{"title":"필오의 개발일지","subtitle":"Frontend developer & love UX, Interaction","description":"프론트엔드 공부를 하며 기록하는 공간입니다. JavaScript에 관심이 많으며 TypeScript, React를 주로 선호합니다.","author":"Joy Kim","url":"http://feel5ny.github.io","root":"/"},"pages":[],"posts":[{"title":"소셜미디어 도파민에서 빠져나오기","slug":"집중력_찾기","date":"2024-11-24T13:00:00.000Z","updated":"2024-11-24T13:16:18.344Z","comments":true,"path":"2024/11/24/집중력_찾기/","permalink":"http://feel5ny.github.io/2024/11/24/%EC%A7%91%EC%A4%91%EB%A0%A5_%EC%B0%BE%EA%B8%B0/","excerpt":"","text":"“개발자 오늘도 마음 튼튼하게 성장하기“ 책을 읽고 작성하였습니다. 요즘 육아를 하다보니 아이의 하루 일과를 잘 기록하는 것이 중요해졌다. 수유, 기저귀갈기, 잠자는 시간 등등 아이의 모든 행동을 기록해야 되는데 주로 사용하는 기록 어플은 babyTime이다. 기록을 위해서 핸드폰을 드는 그 시점에 갑자기 집중력이 흐트러진다. 아무래도 육아는 에너지를 많이 쓰는 노동이다보니 핸드폰을 쥐게되면 본능적으로 “내 개인시간이구나!” 라고 무의식적으로 생각하게 된다. 그러면 본 목적을 잊어버리고 babyTime을 보러 찾아가는 것이 아닌, 쌓여있는 알림센터를 보거나, 종모양 뱃지를 먼저 보게 된다. 어느샌가 컨텍스트스위칭이 이루어지고 나도 모르게 스위칭된 다른 작업을 하고 핸드폰을 끄게된다.그제서야 ‘아 맞다 babyTime에 기록해야하는데’이러거나 ‘원래 뭐하려고 했지?’라는 늪에 빠져버린다. 소셜미디어로 경험했던 장단점들요즘 핸드폰에서 상시로 시선을 뺏앗기는 앱은 인스타그램, 카톡, 링크드인, 당근마켓, 슬랙이고, 비정기적으로 들어가는 앱은 네이버블로그, 브런치, 쓰레드 등이다. 나열해보니.. 생각보다 많이 사용하는 듯해서 몇몇 플랫폼은 한 곳으로 모아야겠다라는 생각이 들었다. 업로드 난이도 형태 플랫폼 목적 5 긴글 카카오 브런치 생각 공유 5 긴글 깃헙 블로그 커리어 4 긴글 네이버 블로그 일기, 일상 공유 3 짧은글 링크드인 커리어 3 짧은글 slack 업무 2 짧은글 당근마켓 육아 1 짧은글 쓰레드 생각 공유 1 사진 인스타그램 일상 공유 자주 인입하는 이유콘텐츠 형태별로 앱에 진입하는 이유가 다르다. 반응 확인 default는 반응을 확인하기 위해서 방문하게 된다. 소셜미디어는 행동수정전략을 위해서 좋아요와 같은 기능을 설계하였는데, “좋아요”와같은 타인의 리액션은 당사자에게 사회적 승인이라는 보상의 개념으로 다가온다고 한다. 오가닉 확인 긴 글의 경우는 다른 사람이 읽기 편한지, 퇴고를 위해서 자주 들어가서 본다. 문장이 어색하지 않은지, 이미지가 적절한 위치에 있는지 등등 이건 제작자 입장으로 지속적으로 보면서 다듬기위해서 확인한다. 배포하기 전에 체크하는 것이 좋긴한데, 실제 배포를 해야 모바일에서 확인하기가 편하다. 더불어 긴 글의 경우는 반응 보다는 검색엔진에 적절히 노출되고 있는지를 더 보는 듯 하다. 개인적으로 플랫폼 팔로우들의 반응보다는 오가닉의 반응이 더 중요하다고 생각하기 때문이다. 대중적으로 니즈가 있던 콘텐츠라는 반증이며, 나아가서 비슷한 주제로 더 딥하게 디벨롭을 할수 있기 때문이기도 하다. 그래서 블로그 글은 정기적으로 모니터링 리포트를 받아서 어떤 키워드에 노출되고 있는지 확인한다. 정리하자면 긴글은 오가닉의 전환률이 높아야 ‘사회적 승인’으로 여기는 듯 하다. 행동수정전략 (feat. 도파민) 짧은 글이나 사진 업로드같이 업로드 난이도가 낮은 플랫폼은 콘텐츠 자체가 간단하고 ux적으로 lock in 장치들이 많아 (무한스크롤, 좋아요, 알림, …) 사람들의 반응을 긴 글보다는 좀더 빠르게 확인할 수 있다. 특히나 인스타그램은 주 업로드 콘텐츠들이 글보다 사진이 메인이기때문에 업로드도 쉽고, 글을 읽는 것보다 에너지를 덜쓰기에 더 쉽게 락인되어 콘텐츠를 소비하게 된다. 업무를 할 때는 커뮤니케이션 매신저가 slack이다보니 어쩔수 없이 자주 들어가게 된다. 주변 동료들 컴퓨터를 언뜻 보게되면 읽지 않음을 열심히 없애는 부류가 있고 수많은 읽지않음을 방치해둔 부류도 보인다. 나는 전자이긴한데 그러다보니 slack에 한번 들어갔다가 읽지 않음을 없애기 위해 여러 글을 확인하게 되고 잦은 컨텍스트 스위칭이 발생한다. 중요한 작업을 하는 와중에도 상대적으로 중요하지 않은 질문에 답을 해주고 있을 때도 있다. 읽지않음을 읽는 행위도 책에서 이야기하는 도파민에 하나라고 생각한다. 가변적 보상때문에 나에게 보상을 줄 수 있는(혹은 도움을 줄 수 있는) 내용이 공유가 되었는지 확인하기위해 읽지않음을 바로바로 확인한다고 생각한다. (종알림과 동일한 효과) 가변적 보상: 특정 행동이 보상으로 이어질 수도, 그렇지 않을 수도 있다는 뜻이다.→ 당신의 잠재의식은 그 행동을 하도록 강요한다. (보상이 있을 수 있다는 가능성) 도파민: 기대와 관련된 신경전달물질. 보상이 가까워졌을 때 분비된다.사람들은 ‘오늘 동기부여가 더 잘 됐으면 뭔가 시도해볼 수 있었을 텐데.’라고 한다. 하지만 우리의 사고는 그와 반대로 작동한다. 뇌는 소위 기분이 좋아지는 화학물질이라 불리는 도파민을 우리가 실제로 무언가하는 순간에 분비한다. 그래서 동기는 행동하기 전이 아니라 행동한 후에 온다. 장점들개발자 오늘도 마음 튼튼하게 성장하기에서는 소셜미디어에 이용당하지 말고 오히려 이용하라고 이야기하고 있다. 개인적으로 커리어 면에서는 Sns의 효과를 많이 본 사람으로써 공감되는 문장이였다. 아무래도 글을 읽게되면 내가 어떤 생각을 갖고 있는지를 사전에 알 수 있게된다. 더 나아가서는 글에서 느껴지는 생각과 가치관이 같을 경우 감사하게도 함께 무언가를 도모하기위해 찾아와주시기도 한다. 이렇듯 Sns를 통해 소비만 하는 것이 아닌 생산자의 역할로 있게 되면 더 많은 기회가 찾아오기도 한다. 단점들실제로 해야할 일들을 하지 못하고 sns에 많은 시간을 쓰게 된다.slack은 업무를 할 때 자주 사용할 수 밖에 없지만 어느 순간 슬랙에 잠식당한다는 생각이 지배적일 때가 있었다. 다른 사람의 문제와 글에 관심을 갖다보니 업무를 거의 못할 때도 있었고, 컨텍스트 스위칭이 심하다보니 정신이 멍할 때도 있었다. 인스타는 릴스의 무한스크롤에 빠져서 시간을 금방 허비하는 것은 기본이고 제일 큰 영향은 광고에 현혹되어서 불필요한 물건을 구매한 적이 많다는 것이다. 인지를 함에도 불구하고 한달에 한번은 구매하는 듯하다. 보통은 릴스의 반복적인 광고노출과 인플런서들의 공구들이다. 공구는 스스로 제한을 두긴했었는데, 광고노출은 무한스크롤 여정에 무조건 노출이기때문에 앱을 사용하지 않는이상은 지속적으로 노출되게 되어있다. 핸드폰을 사용하는 본래의 목적과 다른 작업을 하게되고 잊어버리게 된다.핸드폰을 사용하려는 본래 목적을 달성하기위해서는 많은 관문을 지나쳐야한다. 잠금화면의 알림센터부터, 내가 찾으려는 앱까지 가는 과정에서 노출되어있는 앱 아이콘의 뱃지들. 무의식적으로 방문하고 싶어하는 앱들이 참 지나치기 힘든 관문들이다. 앱의 갯수도 많다보니 사용하려는 목적의 앱을 찾아가기위해서는 무조건 3단계정도는 지나쳐야 찾기 form에 다다를 수 있다. 점진적으로 줄여나가는 방법 생각해보기 + Action Item원인 앱을 진입하기 전: 알림센터의 누적된 알람들, 뱃지(읽지않음)본래 핸드폰을 사용하려는 목적을 달성하는 과정에서 이탈을 하게 만드는 요인들이다.퍼널단계를 줄이고 (자주 사용하는 어플을 근처에 두기), 푸시알림을 적절히 받도록 재설정이 필요하다.[ ] 자주 사용하는 어플 홈 화면에 셋팅[ ] 푸시알림 재설정 앱을 진입한 후: 무한스크롤, 반응(좋아요, 댓글)앱을 사용할 때 완전 락인이되어서 빠져나오기 힘들게 만드는 요인들이다.앱을 장시간 사용한다는 인지를 해야하기에 노티를 받아야하는데, 도움을 주는 어플을 사용하거나 갤럭시의 사용제한 기능을 사용해보는 것도 좋을 듯 싶다.[ ] 갤럭시 디지털 웰빙기능에 사용시간 설정하기 무한스크롤이 발생되면 감지하여 경고메세지를 주는 어플 개발도 괜찮을 듯 싶은데.. 이미 비슷한 어플이 있긴하구나. Digital Detox: Focus &amp; Productivity 의식적으로 목표를 가져보기 휴직 이후에 하루에 갖을 수 있는 개인시간은 3 ~ 4시간이다.일기쓰는 시간을 제외하면 2 ~ 3시간이니, 기본적으로는 개인시간이 확보되지 않을 정도로 sns를 하지 않아야한다.[ ] 개인 시간이 확보되고 있는지 확인하기 너무 지칠 때 sns는 치명적이다. 차라리 명상을 하거나 걷다오거나 잠을 자는 것이 더 생산적이다.뇌가 피곤할 때 소셜미디어가 유혹적이다. 뇌가 보상이라고 인식하는 무언가에 쉽게 접근할 수 있고, 저항할 힘이 더 이상 없다면 결국 자동으로 소셜미디어에 장무하게 될 것이다.소셜미디어를 방문할 때마다 이 행동을 위한 신경경로를 형성하는데 조금씩 기여하는 것이다. 시간이 지나면 더더욱 강화된다. 습관이 강해질수록 더 많은 의지력이 있어야 저항할 수 있다.[ ] 지칠 때는 낮잠자기. 잠이 안오더라도 눈만 감고 누워있기","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"book review","slug":"book-review","permalink":"http://feel5ny.github.io/tags/book-review/"},{"name":"deep work","slug":"deep-work","permalink":"http://feel5ny.github.io/tags/deep-work/"}]},{"title":"레거시를 잘 만들기, 해석하기 (feat. 프로그래머의 뇌 🧠)","slug":"Communication_005","date":"2022-05-15T14:23:55.000Z","updated":"2024-11-23T13:46:05.174Z","comments":true,"path":"2022/05/15/Communication_005/","permalink":"http://feel5ny.github.io/2022/05/15/Communication_005/","excerpt":"","text":"최근 외부에서 책모임을 진행했다. 요즘 많이들 읽고 있는 “프로그래머의 뇌”라는 책을 읽는 모임인데, 많은 이들이 추천해주시기도 하고 기술 교양?서적에 관심이 있어 참여하였다. 결론적으로는 사내에서도 책모임을 진행할 정도로, 개발자 필독서라고 느꼈다. 오늘은 책이 어떤 면에서 괜찮다고 느꼈는지 나열해보고, 나열하면서 관련있는 챕터를 첨부해두려고한다. 한정된 리소스, 전략적으로 사용하기제품을 만들다보면, 내가 작성한 코드, → 제품도 결국에는 시간이라는 요소로 인해 레거시가 된다. 레거시가 된 나의 코드. 내가 생산한 그것이 해석하기 좋은 레거시가 되길 바라고 있다. 하지만 당연히 어려운 부분이고, 아직도 당당하냐고 묻는다면 아니다. 부끄로운 코드를 많이 작성하고있다. ;; ㅎㅎ좋은 레거시란 무엇인가? 누군가 와도 쉽게 유지보수 할 수 있는 제품. 코드라고 상각한다. 혹여나, 짱구처럼 이게 모야모야?라고 말할정도로 바로 받아들일 수 없어도, 컨텍스트와 상황을 설명하면 이해는 할 수 있는 코드는 되어야 좋은 레거시 범위에 포함할 수 있다고 생각한다. (따지고보면 비단 개발 분야에만 해당하는 말은 아니긴하다.) 이해한 코드를 쉽게 유지보수 할수 있는 코드여야한다. 쉽게 유지보수란, 어렵지 않게 해석하고, 유지볼 수 할 수 있는 것이라고 생각한다. 수많은 책에서 읽기 좋은 코드, 바로 해석하기 쉬운 변수명, 주석문 등등 항상 마음속에 새겨야할 십계명처럼 설명해주곤하는데, 이책에서는 근본적으로 사람의 뇌 구조가 이러하기때문에 그럴수밖에 없다라는 방향으로 설명한다. 요즘과 같은 업무환경에서 나의 몸 하나, 나의 한정된 리소스에서 어떻게 빠르게 효율적으로 치고 나갈 수 있는지. 고민하는 요즘, 이 책은 현실적으로 나의 뇌가 어떤면에서 한정적인지에 대해서 말해주고, 이러한 한정적은 환경에서 어떻게 전략적으로 활용할 수 있는지 이야기해준다. 코딩 중 겪는 혼란에 대한 이해 제품을 지속적으로 좋은 퀄리티로 유지하기.책에서 이야기하기를 코드를 생산하는 것보다 해석하는 것이 업무의 반 이상이라고 한다.즉, 누군가가 내가 만든 길을 접근할 때, 그 길을 잘 따라 올 수 있도록 네비게이션을 해두어야한다는 것이다. 코드에서의 UX를 잘 구축해 두는 것이 중요하다는 것.개발을 한다는 것은 결국 문제해결을 위한 것인데, 해결해야하는 문제 자체가 복잡할 수가 있다.(책에서는 이를 내제적 인지부하라고함) 이는 컨트롤할 수 없으니, 컨트롤할 수 있는 인지부하는 최대한 낮춰야한다. 이 책에서는 컨트롤 할 수 있는 외제적 인지부하에 대해서 주로 나온다. (내제적 인지부하를 어떻게 잘 해석할 수 있는지도 나오긴함) 의도한 목적을 잘 전달하는 것을 목표로 해야하는데, 그러기위해서는 여러 장애물들을 낮춰야하고, 인지부하를 낮추는 행위로 귀결된다. 레거시를 (잘) 만들기, 레거시를 해석하기.결국에는 제품을 만드는 입장에서는 해석하기 쉽도록, 유지보수하기 쉽도록 만들어야한다.단순 명료하게, 만드는 사람 입장에서는: 해석하는 사람이 인지부하가 안오도록 해야하고, 해석하는 사람 입장에서는: 정확하게 생산자의 의도를 파악해야한다. 레거시를 해석하기첫 챕터에서 “코딩 중의 혼란” 이라는 챕터가 나온다. 3가지 개념이 나온다. 지식의 부족: 애초에 개념자체를 모르면 해석자체를 할 수 없다. 물론 일하면서 배운다의 개념이 있긴하지만, 블로커가 되지 않기 위해서는 “지식”으로써는 갖고 있어야한다고 생각한다. 정보의 부족: 빠른 해석을 위해서는 지식 기준으로 청킹이 빠르게 되어야한다. 쉽게 말하면 이미 개념적으로 모듈화가 되어있어야한다는 것이다. (우리는 정수기를 보면 버튼을 누르면 물이 나온다는 사실을 이미 정수기라는 단어 하나로 바로 해석할 수 있다. 하나하나 뭐였는지 생각하지 않는다.) 처리 능력의 부족: 한정된 뇌의 리소스에서 처리 능력을 올리는 방법이다. 해석하면서도 인지부하가 최대한 안오도록 꿀팁들을 전달해주고 있다. 복잡한 코드 읽는 방법 코딩 문제 해결을 더 잘하려면 생각의 버그 (오개념을 갖고 있을때) 그리고 혹시나, 읽기 힘든 레거시에서도 잘 해석하기 위해서 복잡한 문제해결을 더 잘하려면 코드를 작성하는 행위 레거시를 (잘)만들기읽는 사람이 인지부하가 안오도록 해야한다. 변수의 역할 바로 이해하기 명명잘하기 변수가 갖고 있는 목적 (역할) 목적에 맞게 지어지는 이름 목적에 맞게 지어지는 이름 형태 언어 안티패턴 설계를 잘 해야한다..","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"}],"tags":[{"name":"programmer","slug":"programmer","permalink":"http://feel5ny.github.io/tags/programmer/"},{"name":"cognitive","slug":"cognitive","permalink":"http://feel5ny.github.io/tags/cognitive/"}]},{"title":"도커 볼륨, 네트워킹, 로깅","slug":"docker_02","date":"2022-02-20T13:00:00.000Z","updated":"2024-11-23T12:25:51.932Z","comments":true,"path":"2022/02/20/docker_02/","permalink":"http://feel5ny.github.io/2022/02/20/docker_02/","excerpt":"","text":"왜 우린 도커를 써야하나요? 지속가능한 데이터를 활용하기 위해 볼륨을 사용할 수 있으며, 호스트볼륨을 공유하거나, 볼륨컨테이터를 만들어 활용하거나, 도커 볼륨을 활용할 수 있다. 도커는 컨테이너 내부IP를 순차적으로 할당하며,(컨테이너 별로 내부망이 생성) veth 인터페이스로 접근가능하다. 도커가 자체적으로 제공하는 5가지 네트워크 드라이버가 존재한다. 도커는 컨테이너의 표준출력과 에러출력을 별도로 메타데이터 파일로 저장하며, 이를 확인가능하도록 한다. 로깅을 도와주는 써드파티 드라이버들도 존재한다. 도커 볼륨? 도커 이미지로 컨테이너 생성시 이미지는 read only 컨테이너 변경사항만 별도로 저장하여 보존한다. 컨테이너 계층에는 DB를 운용하면서 쌓이는 데이터가 저장됨 이미지에 mysql을 실행하는데 필요한 어플리케이션 파일이 존재 컨테이너는 생성,삭제가 쉬우므로 위험 발생 가능성 높음. 이를 방지하기위해 데이터를 Persistent데이터로 활용할 수 있는 방법이 몇가지 있다. 볼륨을 활용한다. 호스트 볼륨을 공유하는 방법 볼륨 컨테이너를 활용하는 방법 도커가 관리하는 볼륨을 생성할 수 있다. 1. 호스트 볼륨을 공유하는 방법복사개념으로 컨테이너 directory를 host directory에 마운트한다. 예시컨테이너 2가지 생성 mysql DB container 워드프레스 웹 서버 container 1. mysql DB container123456❯ docker run -d \\--name wordpressdb_hostvolume \\-e MYSQL_ROOT_PASSWORD=password \\-e MYSQL_DATABASE=wordpress \\-v /home/wordpress_db:/var/lib/mysql \\mysql:5.7 이름: wordpressdb_hostvolume 컨테이너 directory(/home/wordpress_db)를 Host directory(/var/lib/mysql)에 마운트 -v: [호스트 공유 디렉토리]:[컨테이너의 공유 디렉터리] -v /home/wordpress_db:/var/lib/mysql 2. 워드프레스 웹 서버 container123456❯ docker run -d \\-e WORDPRESS_DB_PASSWORD=password \\--name wordpress_hostvolume \\--link wordpressdb_hostvolume:mysql \\-p 80 \\wordpress 이름: wordpress_hostvolume wordpressdb_hostvolume:mysql fyi; -v [호스트 공유 디렉토리]:[컨테이너의 공유 디렉터리] 호스트의 디렉토리와 컨테이너의 디렉토리를 공유한다는 뜻. 디렉토리말고 파일단위로 공유 가능 -v 옵션은 한번에 여러번 쓸 수 있다. 동기화 아니고, 복사개념 오버라이딩: 호스트 공유할 디렉토리가 신규생성이 아닌경우(해당 경로에 무언가 파일이 있던경우) 오버라이딩 됨. 2. 볼륨 컨테이너를 활용하는 방법 (-volumes-from) -v옵션으로 볼륨을 사용하는 컨테이너를, 다른 컨테이너와 공유하는 것 A 컨테이너 생성시 —volumes-from 옵션 설정하면-v 옵션 적용한 컨테이너(B)의 볼륨 디렉터리를 공유할 수 있다.1234docker run -i -t \\&gt; --name volumes_from_container \\ &gt; --volumes-from volume_overide \\ #volume_overide가 공유하는 것&gt; ubuntu:14.04 여러개의 컨테이너가 동일한 컨테이너에 —volumes-from 사용하여 볼륨을 공유해 사용할수도 있다. 볼륨 컨테이너 host에서 볼륨만 공유. 별도의 역할을 담당하지 않는 볼륨컨테이너로써 활용하는 것도 가능. 직접 호스트에서 공유가 아닌, 볼륨컨테이너를 통해서 간접적으로 공유 받는식 3. 도커가 관리하는 볼륨을 생성할 수 있다.도커 자체에서 제공하는 볼륨기능을 활용해, 데이터를 보존할 수도 있다. 도커 볼륨은 디렉토리 하나에 상응하는 단위. 도커엔진에서 관리한다. 도커 볼륨은 호스트에 저장하여 데이터 보존 (어디에 보관되어있는지는 알필요없음 우선순위낮) 1. 볼륨 생성1docker volume create --name myvolume 볼륨 생성시, 플러그인 드라이버를 설정하여, 여러종류의 storage 백엔드 사용가능 활하며 동시 생성 가능 똑같이 -v사용. 컨테이너 디렉토리만 넣어두면, 도커볼륨 자동 생성 1234docker run -i -t \\&gt; --name myvolume_auto \\&gt; -v /root/ \\&gt; ubuntu:14.04 1[볼륨의 이름]:[컨테이너의 공유 디렉토리] 2. 볼륨 삭제 docker volumn prune 도커볼륨을 사용하고 있는 컨테이너를 삭제해도, 볼륨이 자동으로 삭제되지 않는다. fy; Stateless 설계 컨테이너가 아닌, 외부에서 데이터를 저장하고컨테이너는 외부에서의 데이터로 동작하도록 설계하는 것 &#x3D;&#x3D; 컨테이너 자체는 상태가 없고,상태를 결정하는 데이터는 외부로부터 제공받는다. &#x3D;&#x3D; 컨테이너가 삭제돼도, 데이터는 보존되므로,stateless한 컨테이너 설계는 도커사용시 바람직한 설계 stateful한 컨테이너는 지양해야함. 도커 네트워크 구조 도커는 컨테이너 내부IP를 순차적으로 할당 내부IP는 내부망(도커가 설치된 host)에서 쓸 수 있는 IP. 컨테이너를 시작할때마다, 호스트에 veth..라는 네트워크 인터페이스를 생성함으로써 이루어진다. fyi; veth: virtual eth 도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해,컨테이너마다 가상 네트워크 인터페이스를 호스트에 자동 생성→ veth로 이름이 시작 12345678910111213141516root@75308a74b2c2:/# ifconfigeth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:18 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:1532 (1.5 KB) TX bytes:0 (0.0 B)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 도커 네트워크 기능컨테이너 생성시 기본적으로: docker0 브릿지를 통해, 외부와 통신할 수 있는 환경을 사용할 수 있다. custom 가능: 사용자의 선택에 따라 여러 네트워크 드라이버 사용가능 도커가 자체적 제공하는 네트워크 드라이버 브릿지 bridge 호스트 host 논 none 컨테이너 container 오버레이 overlay 써드파티 플러그인 솔루션 weave flannel openvswitch 12345❯ docker network lsNETWORK ID NAME DRIVER SCOPE2013d2e38a9f bridge bridge local9ce30268dbf6 host host localc325e2a4437b none null local 브릿지 bridge 사용자 정의 브릿지를 새로 생성해, 각 컨테이너에 연결하는 네트워크 구조. 컨테이너는 연결된 브릿지를 통해 외부와 통신 가능 브릿지 생성하기1docker network create --driver bridge mybridge --net 옵션으로 컨테이너가 네트워크 사용가능123docker run -i -t --name mynetwork_container \\--net mybridge \\ubuntu:14.04 네트워크 연결: docker network connect 네트워크 분리: docker network disconnect --net-alias 특정 호스트 이름으로, 컨테이너 여러개에 접근 가능 --net-alias 순차적으로 할당된다. (172.18.0.3 ~ 5)12345678910111213141516❯ docker run -i -t -d --name network_alias_container1 \\&gt; --net mybridge \\&gt; --net-alias alicek106 ubuntu:14.04616982dd067988f1e76a04709ad74287dceb73410f886f1630b8364634fe4565~❯ docker run -i -t -d --name network_alias_container2 \\--net mybridge \\--net-alias alicek106 ubuntu:14.044d56a82ace82cc8118e9ef8d5502db76497fce0f7499960f5dcb624c8a006eaf^[[A~❯ docker run -i -t -d --name network_alias_container3 \\--net mybridge \\--net-alias alicek106 ubuntu:14.04d90963f31e42595264165839fbff2d78f8075640f5a4cea6e6782481636edbf9 Docker DNS, Round-Robin 방식 Round-Robin 매번 달라지는 IP를 결정하는 것은 별도의 알고리즘이 아닌, round-robin 방식 하나의 중앙처리장치를 여러 프로세스들이 우선순위 없이 돌아가며 할당받아 실행되는 방식 도커에 내장된 DNS가 alicek106 호스트 이름을 alicek106 을 설정한 컨테이너로 변환 resolve 하기 때문이다. dig라는 명령어로 확인가능. Docker DNS 호스트이름으로 유동적인 컨테이너를 찾을 때 주로 사용됨. —-link : 컨테이너의 IP가 변경돼도, 별명으로 컨테이너를 찾을 수 있게 DNS에 의해 자동관리 --not-alias: 도커는 사용자가 정의한 브릿지 네트워크에 사용되는 내장 DNS 서버를 갖는다. DNS의 IP는 127.0.0.11 위 예시에서는 컨티에너의 IP는 DNS 서버에 alicek106 이라는 호스트 이름으로 등록됨 호스트 네트워크 컨테이너의 네트워크를 → 호스트 모드로 설정하면, 컨테이너 내부의 어플리케이션을 별도의 port forwarding없이 바로 서비스할 수 있다. 실제 호스트에서 어플리케이션을 외부에 노출하는 것과 같다.123docker run -i -t --name mynetwork_host \\--net host \\ubuntu:14.04 none 네트워크말그대로 아무런 네트워크를 쓰지 않는 것. 외부와 연결이 단절됨 lo 외에는 존재하지 않는다. 123docker run -i -t --name mynetwork_none \\--net none \\ubuntu:14.04 container 네트워크 다른 컨테이너의 네트워크 네임스페이스 환경을 공유할 수 있다. 공유되는 속성 : 내부 IP, 네트워크 인터페이스의 mac주소 등..123docker run -i -t --name mynetwork_none \\--net container:network_container_1 \\ubuntu:14.04 Container Loggingjson-file 로그 사용하기 도커는 컨테이너의 표준 출력 StdOut과 에러 StdErr 로그를 별도의 메타데이터 파일로 저장하며, 이를 확인하는 명령어를 제공한다. docker logs --since 옵션에 유닉스 시간을 입력함. 특정시간 이후의 로그를 확인할 수 있다. 1234docker logs --tail 2 mysql2022-02-20T11:18:41.976679Z 0 [Note] mysqld: ready for connections.Version: &#x27;5.7.36&#x27; socket: &#x27;/var/run/mysqld/mysqld.sock&#x27; port: 3306 MySQL Community Server (GPL) 1docker logs -f -t mysql # 전체 출력 위와같은 컨테이너 로그는 JSON형태로 도커 내부저장 1cat /var/lib/docker/container/$&#123;CONTAINER_ID&#125;/$&#123;CONTAINER_ID&#125;-json.log json 파일 크기가 계속 커질 수 있어서, 호스트의 남은 공간도 전부 사용할수도 있음. 이를 방지하기 위해서 json 로그파일의 최대크기 지정할 수 있음. 로그 파일 최대 갯수도 지정가능 도커의 기본적인 로그뿐만아니라, 드라이버로도 로그 가능 syslog jornald fluentd awslogs 1. syslog 로그 컨테이너 로그는 JSON뿐만아니라, syslog로 보내 저장하도록 설정가능 syslog: 유닉스 계역 운영체제에서 로그를 수집하는 오래된 표준 중 하나. 커널, 보안 등 시스템과 관련된 로그, 어플리케이션의 로그 등 다양한 종류의 로그를 수집해 저장. 2. fluentd 로그 오픈소스 도구 컨테이너 로그를 fluentd를 통해 저장할 수 있도록 플러그인 공식제공 수집된 데이터를 aws s3, hdfs(hadoop distributed file system), mongoDB등 다양한 저장소에 저장할 수 있다. 3. 아마존 클라우드워치 로그 도커를 aws ec3에서 사용하고 있다면, 다른 도구 별도 설치없이 컨테이너에서 드라이버 옵션을 설정하여, 클라우드워치 로깅 드라이버 사용가능 도커 환경으로 구성된 인프라들을 최근들어 자주 접하게 되고, 프론트 리소스도 도커, 쿠버네티스 환경에서 운영됨에 따라, 프론트 개발자도 이에 대한 지식이 필요하다고 느껴 스터디를 진행합니다. 스터디는 “시작하세요 도커&#x2F;쿠버네티스” 책으로 진행합니다. 참고","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"06. Deploy","slug":"03-DevOps/06-Deploy","permalink":"http://feel5ny.github.io/categories/03-DevOps/06-Deploy/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://feel5ny.github.io/tags/docker/"},{"name":"docker_volume","slug":"docker-volume","permalink":"http://feel5ny.github.io/tags/docker-volume/"},{"name":"docker_network","slug":"docker-network","permalink":"http://feel5ny.github.io/tags/docker-network/"},{"name":"docker_log","slug":"docker-log","permalink":"http://feel5ny.github.io/tags/docker-log/"}]},{"title":"도커 개념과 컨테이너","slug":"docker_01","date":"2022-02-13T11:00:00.000Z","updated":"2024-11-23T12:25:51.932Z","comments":true,"path":"2022/02/13/docker_01/","permalink":"http://feel5ny.github.io/2022/02/13/docker_01/","excerpt":"","text":"도커 환경으로 구성된 인프라들을 최근들어 자주 접하게 되고, 프론트 리소스도 도커, 쿠버네티스 환경에서 운영됨에 따라, 프론트 개발자도 이에 대한 지식이 필요하다고 느껴 스터디를 진행합니다. 스터디는 “시작하세요 도커&#x2F;쿠버네티스” 책으로 진행합니다. 왜 우린 도커를 써야하나요? 도커? 🐋리눅스 컨테이너에 여러 기능을 추가하여→ 어플리케이션을 컨테이너로서 좀더 쉽게 사용할 수 있게 만들어진 오픈소스 프로젝트 리눅스 : 리눅스(Linux)는 1991년 9월 17일 리누스 토르발스가 처음 출시한 운영 체제 커널인 리눅스 커널에 기반을 둔 오픈 소스 유닉스 계열 운영 체제 계열 컨테이너:컨테이너는 기존의 시스템에 존재하는 프로세스를→ 해당 시스템에서 격리하여,→ 독자적인 시스템 환경을 구축하는 기술입니다. 이를 리눅스 환경에서 실제로 구현한 것이 리눅스 컨테이너입니다. Go 언어로 작성돼 있음 도커 &#x3D;&#x3D; 도커 엔진 혹은 도커에 관련된 모든 프로젝트 도커의 생태계에 있는 여러 프로젝트들은: 도커엔진을 좀 더 효율적으로 사용하기 위한 것에 불과함 → 핵심은 도커 엔진 도커엔진을 사용하는 방법을 익히는것 &#x3D;&#x3D; 도커와 관련된 모든 프로젝트를 능숙하게 다루기 위한 첫걸음 도커의 철학: 한 컨테이너에 프로세스 하나만 실행하는 것 가상머신과 도커 컨테이너 기존의 가상화 기술 : 하이퍼 바이저를 이용해, 여러개의 운영체제를 하나의 호스트에서 생성해, 사용하는 방식 가상머신 Hypervisor 하이퍼바이저: 가상 머신(Virtual Machine, VM)을 생성하고 구동하는 소프트웨어 서로 다른 복수 개의 OS(&#x3D;&#x3D; 가상머신이라는 단위)를 단일 물리 머신 위에서 스케줄링 할 수 있는 소프트웨어 각 가상머신에는 우분투 Ubuntu, CentOS 등의 운영체제가 설치되어 사용된다. 참고[네이버클라우드 기술&amp;경험] 가상화 개념 이해하기#1, QEMU vs KVM Guest OS: 하이퍼바이저에 의해 생성되고 관리되는 운영체제 다른 게스트 운영체제와는 완전히 독립된 시스템 자원을 할당 받아 사용한다. 가상화 방식을 사용할 수 있는 가상화 툴: VirtualBox, VMware Hypervisor의 단점 👎 일반 호스트에 비해 성능의 손실이 발생: 각종 시스템 자원을 가상화하고, 독립된 공간을 생성하는 작업은 ⇒ 하이퍼바이저를 반드시 거침 이미지의 크기 또한 커진다: 가상머신은 게스트 운영체제를 사용하기위한 라이브러리, 커널 등을 전부 포함하기 때문에, 가상머신을 배포하기위한 이미지로 만들었을 때 이미지의 크기 또한 커진다. 커널? 운영 체제(OS)의 주요 구성 요소이며 컴퓨터 하드웨어와 프로세스를 잇는 핵심 인터페이스 장점 👍: 완벽한 운영체제를 생성할 수 있다. 단점 👎: 일반 호스트에 비해 성능 손실 &#x2F; 가상머신을 배포하기 위한 이미지로 만들었을때, 이미지 크기 또한, 커진다. 도커 컨테이너 특징 성능 손실이 없다. 가상화된 공간을 생성하기 위해 리눅스의 자체 기능인 chroot, 네임스페이스 namespace, cgroup을 사용, → 프로세스 단위의 격리 환경을 만든다. → 성능손실이 없다. 가상화된 공간을 사용할때의 성능손실도 없음. 용량이슈 없음 컨테이너에 필요한 커널은 → 호스트의 커널을 공유해 사용 컨테이너 안에는 어플리케이션을 구동하는 데 필요한 라이브러리 및 실행파일만 존재 이미지로 만들어서 배포시, 시간이 가상머신보다 빠름. 💡 도커를 시작해야하는 이유! 컨테이너는 OpenVZ, LXC, cri-o등 몇가지 존재는 함 도커는 컨테이너 생태계에서 사실상 표준. 쿠버네티스, 메소스와 같은 오픈소스 프로젝트에서도, 도커를 기준으로 개발됨. 어플리케이션의 개발과 배포가 편해진다. 여러 어플리케이션의 독립성과 확장성이 높아짐. 1. 어플리케이션의 개발과 배포가 편해진다. 호스트OS: 서버 부팅시 실행되는 운영체제 도커 컨테이너 : 호스트OS 위에서 실행되는 격리된 공간 컨테이너 내부에서 설정수정, 디펜던시 설치 해도 호스트OS에는 영향 없음 컨테이너 내부에서 여러 작업을 마친뒤, 운영환경에 배포하려고 한다면? 해당 컨테이너를 도커 이미지라고 하는 일종의 패키지로 만들어 운영서버에 전달하기만 하면된다. 서비스를 개발할 때 사용했던 환경을다른 서버에서도 컨테이너로써 똑같이 복제할 수 있기 때문에개발&#x2F;운영 환경의 통합이 가능하다. 도커 이미지: 가상머신의 이미지와 달리, 커널을 포함하고 있지 않아 이미지가 크지 않다. 도커 이미지 내용을 레이어 단위로 구성 중복되는 레이어를 재사용할 수 있다. → 어플리케이션 배포 속도가 빨라진다. 2. 여러 어플리케이션의 독립성과 확장성이 높아짐. 모놀리스 Monolith 어플리케이션 : 소프트웨어의 여러 모듈이 상호작용하는 로직을 하나의 프로그램 내에서 구동시키는 방식 소규모에서는 어울리지만, 서비스의 기능이 복잡해지고, 거디해질수록 → 소프트웨어 자체의 확장성과 유연성이 줄어든다. 마이크로 서비스 microservices 여러 모듈을 독립된 형태로 구성 언어에 종속되지 않고, 변화에 빠르게 대응할 수 있다. 모듈 관리가 쉬워진다. → 컨테이너는 수 초 내로 생성, 시작이 가능하며,→ 여러 모듈에게 독립된 환경을, 동시에 제공할 수 있기 때문에→ 마이크로 서비스 구조에서 가장 많이 사용되는 가상화 기술이다. 컨테이너 기반의 마이크로 서비스는 개발자가 그 구조를 직접구현하지 ❌ 컨테이너 오케스트레이션 플랫폼을 통해 사용하는 것이 일반적 (도커 스웜모드, 쿠버네티스…) 예) 웹서비스 데이터베이스 컨테이너 &#x2F; 웹서버 컨테이너 분리 웹서비스에 부하 발생시 → 웹 서버 컨테이너만 동적으로 늘려서 부하 분산 웹서버와 데이터베이스의 이미지 버전을 독립적으로 관리 유지보수 용이해짐 도커 이미지와 컨테이너 이미지, 컨테이너 : 도커 엔진에서 사용하는 기본단위 도커 이미지 컨테이너를 생성할 때 필요한 요소 (가상머신을 생성할 때 사용하는 iso 파일과 비슷) 이미지: 여러개의 계층으로된 바이너리 파일이 존재 (컨테이너를 생성하고, 실행할 때 읽기 전용으로 사용됨) 도커 명령어로 내려받을 수 있다. 리툭스 운영체제, 어플리케이션, 빅데이터 분석도구, .. 갖가지 종류가 있음 1&#123;&#123; 저장소 &#125;&#125;/&#123;&#123; 이미지 이름 &#125;&#125;:&#123;&#123; 태그 &#125;&#125; 저장소: 이미지가 저장된 저장소를 의미 이미지 이름: 이미지가 어떤 역할을 하는지 나타낸다. 태그: 이미지의 버전 관리, 리비전 관리에 사용된다. (생략시 latest) 도커 컨테이너 이미지로 -&gt; 컨테이너 생성가능 해당 이미지의 목적에 맞는 파일이 들어있는,파일시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는독립된 공간이 생성된다. 도커 컨테이너는, 생성될 때 사용된 도커이미지의 종류에 따라, 알맞은 설정과 파일을 갖고 있다. 도커이미지의 목적에 맞도록 사용되는 것이 일반적 예) 웹서버 도커이미지로부터, 여러개의 컨테이너를 생성하면 → 생성된 컨테이너의 갯수만큼 웹서버가 생성 컨테이너는 이미지를 읽기 전용으로 사용함 이미지에서 변경된 사항만 컨테이너 계층에 저장한다… → 컨테이너에서 무엇을 하던, 원래 이미지는 영향을 받지 않는다. 도커 컨테이너 다루기 도커 GUI 클라이언트 사용하며 익히면 굳 컨테이너 생성: docker run -i -t ubuntu:14.04 (1. ubuntu:14.04 이미지 기준으로 pull, 2. 컨테이너 생성 create, 3. 내부 진입 attach) 컨테이너 나가기: exit (컨테이너 정지 + 나감), Ctrl+P,Q (그냥 나감 (정지 않함)) 컨테이너 목록확인: docker ps (정지되지 않은 컨테이너만 출력) (-a 정지된 것까지 출력) 컨테이너 삭제: docker rm(복구 불가능&#x2F; 실행중인것은 삭제 불가능), docker container prune(모든 컨테이너 삭제) 컨테이너 외부에 노출: 가상 IP주소를 할당받으며 (eth0), 외부 노출 가능 eth0의 IP포트를 Host의 IP와 포트에 바인딩 해야함 docker run ... -p 81:80 ubuntu:14.04 Host IP의 81번 호트로 컨테이너 접근 컨테이너 80번 포트로 port forwarding (컨테이너의 열려있는 80번 포트로 연결) 기타 cli1docker run -i -t --name joy ubuntu:14.04 -i : 상호 입출력 -t : tty를 활성화 (bash shell 사용하도록 설정) --name: 컨테이너 네이밍 1docker run -d --name detach_test ubuntu:14.04 detached 모드 (foreground): detached 모드로 컨테이너를 실행한다. detached 모드: 컨테이너를 백그라운드에서 동작하는 어플리케이션으로써 실행하도록 설정 입출력이 없는 상태로 컨테이너를 실행 detached 모드는 반드시 컨테이너에서 프로그램이 실행되야 하며, 포그라운드 프로그램이 실행되지 않으면 컨테이너는 종료됨 detached 모드여도, 컨테이너 내부 shell 사용가능:1docker exec -it &#123;&#123; 컨테이너 이름 &#125;&#125; /bin/sh 12345docker pull // 원격에 있는 이미지 풀받기docker images // 로컬에 다운받은 이미지 확인docker create // 컨테이너 생성시 사용 (반환값: 컨테이너 고유 ID)dokcer start // 컨테이너 띄우기docker attach // 컨테이너 내부 들어가기 참고 왜 우린 도커를 써야하나요? [네이버클라우드 기술&amp;경험] 가상화 개념 이해하기#1, QEMU vs KVM","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"06. Deploy","slug":"03-DevOps/06-Deploy","permalink":"http://feel5ny.github.io/categories/03-DevOps/06-Deploy/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://feel5ny.github.io/tags/Docker/"}]},{"title":"2021 회고","slug":"2021-reflection","date":"2021-12-31T11:00:00.000Z","updated":"2024-11-23T11:38:55.161Z","comments":true,"path":"2021/12/31/2021-reflection/","permalink":"http://feel5ny.github.io/2021/12/31/2021-reflection/","excerpt":"","text":"2021년이 끝났다. 매해가 의미 있는 해지만, 2021년도 역시 배운 점도 많고 의미 있는 해였다. 특히나 올해는 환경의 변화가 있었는데, 이는 나의 태도를 많이 바꾸어주었다. 이런 변화들과 새로운 환경 적응을 위해 기존에 갖고 있던 개인적인 것들을 내려놓아야 했다. 선택과 집중을 해야 했다. 2021년에는 무엇을 선택해야 할지 감을 잡았고2022년에는 그 선택에 집중하기로 마음먹었다. 자립과 책임감 한정된 리소스 자립과 책임감이전 회사를 3년 정도 다니고 올해 초 3월에 회사를 이직했다. 새로 다니게 된 회사는 정말 만족스럽다. 제일 만족스러운 부분은 회사 문화인데, 특히나 개발 문화가 너무 좋고, 서비스를 만드는 maker들 간의 관계도 만족스럽다. 문화가 좋아서 그런지 동료들도 건강하고 멋있는 사람들이 많다. 다들 회사의 성장 &#x3D;&#x3D; 개인의 성장하려는 욕심들이 있고 이를 위해 건강한 논쟁도 하고, 빠르게 오버컴케하며 서로 존중하며 앞으로 나아간다. 이들 사이에서 함께 업무를 하는 과정에서도 많이 배우고 있다. 건강한 논쟁, 효율적 협의, 그리고 경험을 통한 레슨런을 다음 액션에서 녹일 수 있도록 서로 독려해주는 태도 등등. 적다 보니 좀 이상적이긴 하니 한마디 적어보면 이 부분들이 100% 완벽하게 성숙한 상태라고는 말할 수는 없지만, 방향은 이미 잘 조준되어있다고 본다. 입사 이후에 6개월? 7개월은 계속 회사 일에 집중했다. 회사 적응도 해야 하고, 들어가게 되었던 스쿼드도 달리는 마차이다 보니, 들어오자마자 바삐 움직였다. 회사 적응과 업무를 동시에 하다 보니 집에 오면 개발 일을 전혀 하지 않고, 휴식에 집중했다. 짧게 설명했지만, 물리적인 시간 관리 이외에도 여러 가지 관리해야 할 포인트들이 많아졌다. 그 안에서 지금의 리듬을 찾는 데에서 많은 시행착오가 있었다. 사실 지금도 시행착오이긴 하지만 😇 내가 소비하고 생산하는 모든 것들을 조화롭게 관리하기 위해서는 적절한 선택을 하고 이 선택의 책임은 온전히 내가 갖는 것, 그리고 이런 과정을 누군가와 함께 할 때 계속 나아갈 수 있다는 것을 몸소.. 체험하며 깨달은 한 해라고 생각한다. 그리고 이 레슨런은 자연스럽게.. 좀 더 자립심을 갖게 해준 것 같다. 한정된 리소스업무를 보다 보면, 선택과 집중을 해야 하는 부분 때문에 다른 것들을 놓치는 상황이 온다. 리소스는 한정되어있고, 목표가 아닌 것보다 목표해야 하는 것을 달성해야 하기 때문이니 당연한 순리다. 이렇게만 태도를 취하고 달려도 언제나 일정은 빠듯하다. 2개월 전 즈음에 CTO님이 합류하셨다. 정기적인 미팅으로 업무얼라인을 진행하곤 하는데, 종종 적절한 상황에 맞게 조언이나 격려의 말을 해주신다. 아직 배워야 할게 많아서 그런지 모든 말들이 주옥같았다. 그 와중에, 이런 말씀을 하셨다. “누구나 리소스는 한정되어있습니다. 누구나 한정되어있고, 그 한정된 시간 안에서 문제를 해결하는 것이 엔지니어의 역량입니다…” 교양서적에 나올 법 한 문장이고 자주 만났었던 문장이다. 리소스 관리, 문제해결 능력에 대한 고민을 하게 해 준다. 한정된 리소스를 어떻게 효율적으로 할지, 불필요하게 소비하지 않고 생산성 있게 소비할 수 있을까를 좀 더 객관적으로 바라보려고 한다. 다 펼쳐놓고, 어디서 물이 새고 있는지 메꿀 수 있는 방법은 무엇인지 고민하고 해결하는 2022년이 될 듯하다.","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"Joy","slug":"Joy","permalink":"http://feel5ny.github.io/tags/Joy/"},{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/tags/blog/"}]},{"title":"Svg로 Rounded rect형태의 progress bar 만들기 (feat. animation, path)","slug":"svg-line","date":"2021-06-28T14:00:00.000Z","updated":"2024-11-23T12:17:04.477Z","comments":true,"path":"2021/06/28/svg-line/","permalink":"http://feel5ny.github.io/2021/06/28/svg-line/","excerpt":"","text":"Progress bar를 구현해야한다.웹에서 찾을 수 있는 여러 예제들을 참고하여 사용해도 되지만, 커스텀하기 어려운 경우 직접 구현을 해야한다.바로 생각나는 엣지 케이스는 무엇일까 ? Rounded progress bar의 코너 부분채워지는 bar의 Corner 부분! base bar의 코너가 rouneded가 아니거나 + 채워지는 bar도 rounded일경우 디테일한 부분까지 챙기지 않아도 되지만, base bar의 코너가 rounded이면서 + 채워지는 bar가 rouned가 아닐경우, 마지막 채워지는 부분에 rounded를 대응해야한다. 생각나는 방법은 3가지가 있다. css가 가장자리에 닿을 경우의 퍼센트를 계산하여 radius값을 올리기 css의 masking 사용 svg의 gradient를 활용하여 fill animation으로 구현 1번과 2번의 경우 base bar와 채워지는 bar 2가지 모양을 만들어서, 채워지는 bar의 corner를 대응해야한다.1번의 경우 부자연스러움이 걱정되었고, 2번의 경우 구현하는 방법이 상상이 되지 않았다.3번의 경우 2가지 bar를 만드는 것이 아닌, 하나의 bar에서 채워지는 속성을 컨트롤하여 구현하기 때문에 1번 2번보다 자연스럽게 구현할 수 있다고 생각하였다.또한 svg로 선택할 경우 그래프 이외에 커스텀한 디자인이 추가될 경우 대응이 가능하기때문에 3번 방법으로 선택하여 구현해보았다. 해당 포스팅은 3번 구현에 대한 내용을 작성하려고한다. 고려할 부분3번으로 진행할 경우 2가지 케이스를 확인해야한다. 색상이 채워지는 형태로 구현가능한지 반응형 대응은 어떻게 해야할지 기타) 애니메이션도 챙겨보자. 1. 채워지듯이 - Svg와 그라데이션 ⚠️ 이 방법을 사용하기 전에 전제조건은,디자인이 모두 flat한 형태의 디자인일 경우에만 가능하다. 만약 채워지는 bar의 fill이 단색이 아니라 디자인이 추가되어있을 경우 사용할 수 없다. svg는 형태를 만들고, 그 안을 fill로 채울 수 있다. prgress bar에서의 100%를 향해 채워지는 형태로 생각해보았다. 현재 svg에는 색상을 나눌 수 있는 속성은 따로 없다. 대신 그라데이션 효과를 사용하면(linear gradient) fill에 2가지 이상의 색상을 줄 수 있다. 그라데이션은 2가지 이상의 색상을 정의하고, 색상의 position을 정의하면, 각각의 위치에서 서로의 위치 사이의 색상이 점진적으로 정의된다. 여기서 각각의 poisition을 동일하게 둘 경우, 둘 사이의 정의할 색상이 존재하지 않기 때문에 색상이 2가지 단색으로 존재할 수 있다. 위 그림의 중앙 point를 오른쪽으로 움직이면 왼쪽에서 오른쪽으로 채워지는 형태가 될거라고 기대할 수 있다. 2. 반응형 대응그래프가 고정형이 아닌 모바일 대응을 해야할 경우, 폭을 대응해야한다.높이는 유지하고 폭을 대응해야하기 때문에 scale로 늘릴 수는 없다. (정비율로 커지기 때문에)방법은 shape의 point를 옮기는 방법이 있다. 아래와 그림과 같이 가장 오른쪽의 point들을 늘리면 된다. 구현0. 기본bar는 rect 태그를 활용하여 구현한다. rx에는 radius의 값을 추가한다. 1&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;50&quot; rx=&quot;8&quot; fill=&quot;none&quot;/&gt; 1. 채워지듯이 svg의 linerGradient의 stop 태그로 각 position을 정의하면된다. defs에 linerGradient를 추가하고, 하위의 stop 태그 &gt; offset에 정의하면된다. 애니메이션까지 추가하고 싶다면 svg의 animate 태그를 사용하면된다. 원하는 지점은 animation의 to 속성에 비율을 정의하면 된다. (0 ~ 1사이) 애니메이션을 사용하지 않는다면 stop의 offset속성에 비율을 정의하면 된다. linerGradient에 정의한 id를 참조할 모양의 형태에 url로 id를 참고하면 된다. 12345678910111213&lt;svg ...&gt; &lt;defs&gt; &lt;linearGradient id=&quot;left-to-right&quot;&gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;#007AFF&quot;&gt; &lt;animate dur=&quot;2s&quot; attributeName=&quot;offset&quot; fill=&quot;freeze&quot; from=&quot;0&quot; to=&quot;1&quot; /&gt; &lt;/stop&gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;#D8D8D8&quot;&gt; &lt;animate dur=&quot;2s&quot; attributeName=&quot;offset&quot; fill=&quot;freeze&quot; from=&quot;0&quot; to=&quot;1&quot; /&gt; &lt;/stop&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;rect id=&quot;Rectangle&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;50&quot; rx=&quot;8&quot; fill=&quot;url(#left-to-right)&quot;/&gt;&lt;/svg&gt; 2. 반응형 대응 bar를 구현하는 rect태그의 width 값을 다이나믹으로 대응하면 가능하다. 이때에 fill은 비율로 계산되므로 width가 계산되면 자동 계산될 것이다. 최종","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Html","slug":"01-Web/03-Html","permalink":"http://feel5ny.github.io/categories/01-Web/03-Html/"}],"tags":[{"name":"svg","slug":"svg","permalink":"http://feel5ny.github.io/tags/svg/"},{"name":"rounded rect","slug":"rounded-rect","permalink":"http://feel5ny.github.io/tags/rounded-rect/"},{"name":"progress bar","slug":"progress-bar","permalink":"http://feel5ny.github.io/tags/progress-bar/"},{"name":"animation","slug":"animation","permalink":"http://feel5ny.github.io/tags/animation/"}]},{"title":"웹 버저닝과 배포내역관리 (feat. standard-version)","slug":"standard-version","date":"2021-02-23T10:00:00.000Z","updated":"2024-11-23T12:26:13.317Z","comments":true,"path":"2021/02/23/standard-version/","permalink":"http://feel5ny.github.io/2021/02/23/standard-version/","excerpt":"","text":"셋팅은 여기 레포에서 확인 가능하다. 최근 버그와 관련된 CS가 인입이 되어, 픽스 후 배포했음에도 불구하고 유사한 CS가 인입이 되었을때 또 다시 버그 개선 티켓이 생성되곤 했다. 버그 픽스가 제대로 되지 못했을 수도있지만, 상황을 확인해보면 이슈를 CS단계에서 확인하지 못하고 바로 넘어오는 상황이 많았다. (커뮤니케이션으로 해결가능한 것들도) 이런 상황이 반복되고 누적되다보니 개발 집중력이 떨어지고, 불필요한 커뮤니케이션에 시간을 쏟고 있다는 생각이 들어, 개선해야겠다는 생각이 들었다. 문제 사항CS단계에서 진행되지 못하고 넘어올수밖에 없었던 이유 CS 대응 메뉴얼에 새로고침과 관련된 항목이 없었음. CSR의 경우 새로운 배포가 이루어졌을때, 새로고침을 하지 않을 경우 새로 배포한 JS파일을 바라보지 못하고, 이전 JS파일을 바라보고 있게 된다. 새로고침 이전에 사용자가 바라보는 버전이 신규 배포 버전의 JS파일인지 확인을 해야하지만 서비스에 버전을 명시하지 않아, CS 담당자가 확인할 수 없었다는 점. 버전명을 확인해도 해당 버전에 어떤 배포가 이루어졌었는지. 이전에 등록됐던 버그 픽스건이 배포가 되었었는지 확인할 수 있는 내역을 슬랙에서 검색해서 찾는 등 히스토리를 찾아야하는 상황. 배포 notice를 확인할 수 있는 채널이 있지만, CS담당자가 이를 확인하지 못했거나, 잊을수도 있다. 사실 1번과 2번의 경우 SSR형태의 프로젝트나, 브라우저를 오래 유지하지 않고 사용하는 프로젝트라면 화면을 이동할때나 새로 들어갈때 최근에 배포한 파일을 load하기때문에 문제가 거의 발생하지 않는다. 하지만 어드민과 같은 프로젝트의 경우 브라우저를 끄지 않거나 컴퓨터를 아예 끄지 않는 경우 등, 오랫동안 새로고침하지 않고 유지되는 상황이 존재하기에 위 상황이 발생할 가능성이 있다. 해결 방향생각나는 해결 방법은 아래와 같았다. CS담당자가 사용자가 바라보고 있는 버전을 확인할 수 있게 한다. CS담당자가 배포된 내역을 확인할 수 있게 한다. 사용자는 새로 배포된 버전이 있을 경우 새로고침을 유도하는 팝업을 받는다. … 문제사항의 해결방향으로 다시 바라보면 문제사항 1번의 경우 메뉴얼에 해당항목 추가 문제사항 2번의 경우 해결방향 3번으로 해결 가능 문제사항 3번의 경우 해결방향 1번, 2번으로 해결 가능하다. 해결방법 3번이 가장 효과적인 방법이긴하나, 이번 포스팅에서는..해결방법 1,2번의 경우에 해당되는 버전관리, 배포내역관리에대해 작성하고자 했다.ㅎㅎ 구현 방향버전관리와 배포내역 관리는 배포시점에 진행해야하는데, 생각나는 순서는 아래와 같았다. 프러덕션 배포 전 버전을 업데이트 버전의 경우 배포하는 기능의 범위와 유형에 따라 major, minor, patch를 올릴지 결정 package.json의 버전을 결정한 버전으로 변경 빌드 및 배포 배포가 성공하면 배포사항을 내역에 추가 버전을 업데이트하고, 배포사항을 내역에 추가하는 일련의 과정을 배포때마다 한다는 것은 여간 번거로운 일이 아니다. 직접 구현전에 자동화로 만들어 놓은 오픈소스를 찾아보고, 배포시점때마다 진행되어야해서 CI툴에 JOB으로 단계별로 생성하여 진행하기로 했다. 관련 라이브러리 찾아보기 배포 파이프라인에 추가하기 1. 라이브러리 서칭찾기전에 버전과 배포내역이라는 개념을 정리해볼 필요가 있었다.두 가지는 오픈소스 프로젝트에서 자주 볼 수 있었다.이를 참고하여 리서칭해보니 2가지 개념이 나온다. 시맨틱 버저닝 CHANGLOG 개념) 시멘틱 버저닝이란?시맨틱 버저닝의 경우 이 링크에서 자세히 확인 가능하다. 소프트웨어의 버전 변경 규칙에 대한 제안이다. 간단히 말하자면 의존성 지옥을 해결하고자 배포시 버전번호를 명시하여 정의를 내림으로써 의존성관리를 용이하게 한다. SemVer의 형태는 아래와 같다. 1MAJOR.MINOR.PATCH npm에서는 버전을 관리할 수 있는 cli를 제공한다.이 명령어를 통해서 package.json의 버전명을 올릴 수 있다. 123456789101112npm version [ &lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid=&lt;prerelease-id&gt;] | from-git ] 개념) CHANGELOG란? 체인지로그(CHANGLOG, 변경 기록)는 웹 사이트나 프로그램을 제작하는 것 같은 어떤 프로젝트를 진행할 때에 변경 사항에 대한 기록이다. 많은 오픈소스 프로젝트에서는 체인지로그 파일을 가장 상위에 포함해서 배포한다.(위키) 릴리즈 노트와 CHANGLOGCHANGLOG CHANGLOG의 경우 조금 더 개발레벨의 변경사항을 작성한거에 가깝다고 생각한다. 만약 지금과같은 문제사항이서 CS담당자에게는 CHANGLOG파일보다는 기능요약, 버그수정을 비개발자가 알 수 있는 언어로 정리된 릴리즈노트를 제공하는게 맞다고 생각한다. 만약 릴리즈 노트를 작성하지 않는 팀이라면, 비개발용어로 commit 타입을 생성하여 개발자가 일반용어로 작성하여 CHANGLOG에 포함하는 것도 나쁘지 않다고 본다.12345678// .versionrc&#123; &quot;types&quot;: [ ... &#123;&quot;type&quot;:&quot;release&quot;&#125;, // release용으로 생성 ... ]&#125; release note 릴리스 정보 는 제품 또는 서비스의 새 버전 릴리스에 대한 자세한 설명을 제공하기 위해 고객에게 제공되는 문서이다. 이 문서는 일반적으로 PM 또는 PO가 생성하고 기능 요약, 버그 수정, 사용 사례 및 기타 자료를 포함한다. 릴리스 정보는 사용자 문서 외부에서 변경된 사항에 대한 빠른 가이드로 사용된다. library) standard-version이 2가지를 관리할 수 있는 standard-version이라는 라이브러리가 존재한다.standard-version 스크립트 하나로 여러가지 일을 실행해주는데 아래와 같다. 깃의 commit로그를 확인하여 새로운 버전을 생성하고 package.json의 버전 업데이트 (npm version 명령어 대체가능) 커밋을 기준으로 CHANGLOG파일 생성 및 갱신 해당 과정이 마무리되면 CHANGLOG파일과 package.json의 변경내역 커밋을 진행한다. 자동 커밋메세지 : chore(release): 버전명 버전명을 Tag로 만들어서 추가한다. 생각 및 고민 장점) 버전 업데이트, 릴리즈 tag명시, CHANGLOG 갱신을 한번에 해결해준다. 고민) 기여자 모두가 커밋을 conventional commit 스펙에 맞추어 엄격하게 작성해야한다. 장점) 커밋 규칙을 지키며 개발하는 덕분에 커밋정리 및 규칙도 정리된다. 확장) 배포때마다 tag관리가 되어 롤백등의 상황에서도 태그기준으로 롤백이 편리하게 가능하다. 커밋에 의존적인 상황하나 걱정되는 것은 기여자 모두가 conventional commit 스펙을 정확히 맞춰서 작성해야하는 부분이였는데아래 라이브러리들로 해결이 가능했다. 휴먼에러나 규칙을 자동으로 체킹하기 위해 lint와 같은 기능이 필요 commitlint라는 라이브러리 내가 개발한 코드가 어떤 목적인지 카테고라이징을 하는 기준이 각자 정의하기 애매하다면? commitizen&#x2F;cz-cli라는 라이브러리 규격) conventional commit컨벤셔널 커밋은 페이지에서 이렇게 설명한다. Conventional Commits 스펙은 커밋 메시지에 곁들여진 가벼운 컨벤션으로 명확한 커밋 히스토리를 생성하기 위한 간단한 규칙을 제공합니다. 이렇게 만들어진 커밋 히스토리를 이용하여 더 쉽게 자동화된 도구를 만들 수 있습니다. (commitlint, standard-version) 이 컨벤션은 커밋 메세지에 신규 기능 추가, 문제 수정, 커다란 변화가 있음을 기술함으로써 유의적 버전(Sementic Versioning)과 일맥상통한 면이 있습니다. 프로젝트에 셋팅하지 않아도 커밋 습관을 들이기 좋은 컨벤션이라고 생각이 들었다. 형태는 아래와 같다. 12345&lt;타입&gt;[적용 범위(선택 사항)]: &lt;설명&gt;[본문(선택 사항)][꼬리말(선택 사항)] 즉, 위의 규격을 지키며 커밋을 진행해야한다. (예시) 12345678fix: correct minor typos in codesee the issue for detailson typos fixed.Reviewed-by: ZRefs #133 library) commitlintcommitlint를 사용해 commit시에 컨벤션을 잘 지켰는지 체크한다. 컨벤션은 어느정도 규격화되어있다. 컨벤션 셋팅 commit hook에 셋팅 컨벤션 셋팅 standard-version에서 따르는 conventional-commit을 따르려면 @commitlint/config-conventional를 상속받아서 사용하면된다. 123456789101112131415161718192021222324module.exports = &#123; extends: [&quot;@commitlint/config-conventional&quot;], rules: &#123; &quot;type-enum&quot;: [ 2, &quot;always&quot;, [ &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;docs&quot;, &quot;feat&quot;, &quot;fix&quot;, &quot;perf&quot;, &quot;refactor&quot;, &quot;revert&quot;, &quot;style&quot;, &quot;test&quot;, &quot;release&quot;, ], ], &#125;,&#125;; commit hook에 셋팅husky를 사용하여 셋팅하였다. 123456// package.json&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;, &#125;&#125; 정리 버전관리, 배포내역관리를 자동화하기 위해 standard-version를 사용한다. conventional-commit 규격에 엄격하므로,해당 컨벤션을 적용하기 힘든 상황이라면 npm version 명령어를 통해 버전을 관리하고, 배포때마다 직접 CHANGLOG를 작성한다. standard-version 이외에 필요한 라이브러리는 (필수) @commitlint&#x2F;cli : 커밋 작성시 컨벤션용 린트 (옵션) commitizen&#x2F;cz-cli : conventional commit의 규격을 하나씩 문항에 답하면서 커밋을 완성한다. 2. 배포 파이프라인에 추가하기 문제사항 2번을 해결하기 위해 footer같은 곳에 버전명을 명시할 수 있다. 이처럼 버전명이 서비스에 명시되기 때문에 프러덕션 배포시 빌드전 새로운 버전명 업데이트되어야하며 이에 맞춰 버전업과 CHANGLOG셋팅은 빌드 전에 진행한다. jenkins를 쓴다면 파이프라인 프로젝트로 만들어서 사용하고, github action을 사용한다면 worflow에 셋팅하면된다. 이번 포스팅에서는 github action으로 설명 123456789101112131415161718192021222324252627282930313233343536373839build: ... steps: - uses: actions/checkout@v2 # 레포 바라보게 하기용 - uses: fregante/setup-git-user@v1 # 유저 셋팅용 - name: 패키지 설치 run: yarn # 커밋타입에 release 타입을 추가하여 # 릴리즈 노트를 마지막 커밋에 대신 작성하게 하였다. # 해당 스크립트는 lastCommit.sh 파일을 실행한다. - name: 릴리즈 내역 커밋 확인 run: yarn check:lastCommit # standard-version 진행 - name: version 업데이트 및 changelog 생성 run: yarn release # 빌드 및 배포 start - name: 빌드 시작 run: yarn build - name: 배포 run: echo &quot;배포2&quot; # 빌드 및 배포 end - name: 변경내역 푸시 uses: ad-m/github-push-action@master with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; branch: $&#123;&#123; github.ref &#125;&#125; tags: true # 태그까지 생성되기때문에 같이 추가한다. - name: 배포완료 사항 노티 ... - name: Job 상태 노티 ... 마치며운영이슈에서 오는 피로감을 개선하고자 여러가지 방향을 고민해보았는데, 문제해결로 가다가 살짝 옆으로 샌감이 없지않아 있다.ㅎㅎ 무튼 덕분에 버전관리와 배포내역관리에 대한 라이브러리들 을 알 수 있었고 github액션도 사용해보아서 개인적으로 재밌었던 포스팅이었다. 참고자료 SemVr wiki-CHANGELOG standard-version commitlint commitizen&#x2F;cz-cli 규격화","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"05. Release","slug":"03-DevOps/05-Release","permalink":"http://feel5ny.github.io/categories/03-DevOps/05-Release/"}],"tags":[{"name":"version","slug":"version","permalink":"http://feel5ny.github.io/tags/version/"},{"name":"standard-version","slug":"standard-version","permalink":"http://feel5ny.github.io/tags/standard-version/"},{"name":"CHANGLOG","slug":"CHANGLOG","permalink":"http://feel5ny.github.io/tags/CHANGLOG/"},{"name":"SemVr","slug":"SemVr","permalink":"http://feel5ny.github.io/tags/SemVr/"},{"name":"commitlint","slug":"commitlint","permalink":"http://feel5ny.github.io/tags/commitlint/"},{"name":"conventional-commit","slug":"conventional-commit","permalink":"http://feel5ny.github.io/tags/conventional-commit/"}]},{"title":"피츠의 법칙과 Touch Target","slug":"ux-fitts-law","date":"2021-01-24T11:00:00.000Z","updated":"2024-11-23T12:16:04.926Z","comments":true,"path":"2021/01/24/ux-fitts-law/","permalink":"http://feel5ny.github.io/2021/01/24/ux-fitts-law/","excerpt":"","text":"[UX&#x2F;UI의 10가지 심리학 법칙] 책을 읽으며 법칙별로내용 요약 + 개인적으로 찾았던 레퍼런스 + 그밖에 자료들을 모아서 작성한 글입니다. 사용하기 위해 움직이는(소비하는) 시간을 줄인다. → 접근성 인터렉션은 최소한의 노력만으로 불편없이 간단하게 이뤄져야 한다. 사용자가 인터랙티브 요소를 사용하려고 움직이는 데 드는 시간은, 인터렉션의 중요한 지표다. 디자이너는 인터랙티브 요소의 크기와 위치를 적절하게 지정함으로써, 사용자가 해당 요소를 손쉽게 선택하게 하고, 선택 가능 영역에 관한 사용자의 기대에 부응시켜야 한다. 마우스나 손처럼 정밀도가 제각기 다른 다양한 입력 방식이 존재하는 오늘날의 사용환경을 고려하면, 꽤 어려운 과제다. 피츠의 법칙 대상이 커지면, → 대상 선택에 드는 시간이 줄어든다. (W) 대상 선택을 위해 움직이는 거리가 줄면, → 대상을 선택하는 데 드는 시간도 줄어든다. (D) 기원 1954년 미국의 심리학자 : 폴 피츠 터치 대상까지 움직이는 데 드는 시간을 대상까지 거리와 대상 너비 간의 비율에 관한 함수를 통해 예측하면서 탄생 피츠의 법칙은 오늘날 인체 움직임에 관한 가장 영향력 있는 수학적 모델로 여겨지며, 인체 공학, 인간-컴퓨터 상호작용 분야에서 실제로든 가상으로든, 대상을 가리키는 행동에 관한 모델을 만드는 데 널리 쓰이다. 피츠는 대상 선택 작업의 난이도 ID를 정량화하는 측정 기준도 제시했다. D : 대상 중심까지의 거리 → 신호 signal W : 대상의 허용 오차 혹은 너비 → 잡음 noise 피츠의 법칙과 Accessibility 피츠의 법칙에서는 2가지 개념이 나온다.대상 선택을 위해 움직인 거리와 대상 선택이 용이하게끔 키우는 것. 인터렉션의 향상을 위해 → 잡읍을 없애고 거리를 줄이는 것이 핵심이다. 3가지 개념이 나오는데, 대상과 타겟, 거리이다. 대상은 모바일 : 내 손가락 웹 : 마우스 포인터, 및 기타 기기 타겟은 UI 엘리먼트 대상과 타겟과의 거리에 영향을 주는 것은 여러가지가 있겠지만여기서는 2가지를 얘기한다. 대상이 어떤 목적을 위해 움직일때의 맥락(상황) 기기 결국에는 상황에 맞춘 레이아웃을 잡는 것인데, 이는 디자이너의 영역으로 생각하자. 여기서 프론트 개발자가 제어할 수 있는 부분은 UI 엘리먼트이다. 웹 콘텐츠 접근성 가이드(WCAG 2.0)에서도 타겟 사이즈에 대한 내용이 나온다. 이처럼 피츠의 법칙은 접근성과 관련이 있으며, 이중에서도 터치 타겟과 관련이 있다. 영향력있는 단체에서 잡은 터치 사이즈 권장 규격을 확인하고,(머테리얼 디자인 기준) 터치 대상의 크기 요소 사이의 간격 적용한 사례를 살펴보자. Touch Target터치 타겟의 개념에 3가지가 나오는데, 크기, 다른 요소간의 간격, 유사한 흐름에 배치 터치 대상의 크기는 사용자가 정확하게 선택할 수 있을 정도로 충분히 커야 한다. 터치 대상 사이에 충분한 거리를 확보해야 한다. 터치 대상은 인터페이스상에서 쉽게 도달할 수 있는 영역에 배치해야 한다. 터치 대상의 최소 권장 규격 Human interface guideLine : 44 * 44 pt Material design guideLine : 48 * 48 dp Web contents Access GuideLine(WCAG) : 44 * 44 CSS px 닐슨 노먼 그룹 : 1 * 1cm 디자인 시스템에 적용하긔 프론트에서는 프로젝트에 디자인 가이드라인이나 basic philosophy부분에 디자이너와 협의하여 최소 권장규격을 지정하고, (혹은 위에서 제안하는 권장규격을 따르거나) 개발자는 input 성격을 갖고 있는 컴포넌트 소스에 기본 값으로 해당 값을 지정하는 코드를 넣어두면 될 듯 하다. 아래에 머테리얼 디자인에서 구현한 방식을 따르는 것도 좋은 방법인듯하다. 최근에는 구글 머테리얼 디자인의 desgin foundation을 따르는 곳이 많아진 듯 하다. (글쓴이 피셜) 대상이 다를 경우 웹의 경우 데스크탑웹과 모바일 웹이 존재하는데, 각각 사용대상이 다르다. 데스크탑의 경우 마우스 포인터를 사용, 모바일 웹에서는 손가락 터치를 사용한다. 만약 이를 구분하여 적용해야할 여백등이 고려되어야할 경우 미디어 쿼리의 pointer를 활용하면 된다. 123456789.container a &#123; padding: .2em;&#125;@media (pointer: coarse) &#123; .container a &#123; padding: .8em; &#125;&#125; Material design - Touch Target 구글 머테리얼 디자인에서는 최소 규격을 48dp로 지정하였다. 웹에서도 터치 최소 규격이 48px로 계산된다. 구글 머테리얼 디자인에서 @material/touch-target라는 패키지를 제공하는데, 추가적인 sass파일을 적용시켜준다. 기본 버튼 1234&lt;button class=&quot;mdc-button&quot;&gt; &lt;div class=&quot;mdc-button__ripple&quot;&gt;&lt;/div&gt; &lt;span class=&quot;mdc-button__label&quot;&gt;My Inaccessible Button&lt;/span&gt;&lt;/button&gt; touch-target로 감싸기 mdc-touch-target-wrapper로 감싸고 mdc-button__touch를 추가해두었다. → 여기에 absolute로 height값이 지정된다. 1234567&lt;div class=&quot;mdc-touch-target-wrapper&quot;&gt; &lt;button class=&quot;mdc-button mdc-button--touch&quot;&gt; &lt;div class=&quot;mdc-button__ripple&quot;&gt;&lt;/div&gt; &lt;span class=&quot;mdc-button__label&quot;&gt;My Accessible Button&lt;/span&gt; &lt;div class=&quot;mdc-button__touch&quot;&gt;&lt;/div&gt; &lt;/button&gt;&lt;/div&gt; touch-target의 scss 파일을 보면, height값과 width값에 default값으로 48px을 적용한 부분이 보인다. 마지막 margin부분은, 강제로 적용한 touch target 영역을 채우기 위해 margin을 추가적으로 적용하는 부분이 보인다. 아름답다.. 지금까지 scss를 잘 활용하지 못했다고 생각했다.. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// node_modules/@material/touch-target/_touch-target.scss@use &#x27;@material/base/mixins&#x27; as base-mixins;@use &#x27;@material/feature-targeting/feature-targeting&#x27;;$height: 48px !default; 👈👈👈$width: $height !default;/// Styles applied to the component&#x27;s touch target wrapper element.@mixin wrapper($query: feature-targeting.all()) &#123; $feat-structure: feature-targeting.create-target($query, structure); .mdc-touch-target-wrapper &#123; @include feature-targeting.targets($feat-structure) &#123; @include base-mixins.emit-once(&#x27;mdc-touch-target/wrapper&#x27;) &#123; display: inline; &#125; &#125; &#125;&#125;@mixin touch-target($set-width: false, $query: feature-targeting.all()) &#123; $feat-structure: feature-targeting.create-target($query, structure); @include feature-targeting.targets($feat-structure) &#123; position: absolute; top: 50%; right: 0; height: $height; &#125; @if $set-width &#123; @include feature-targeting.targets($feat-structure) &#123; /* @noflip */ left: 50%; width: $width; transform: translate(-50%, -50%); &#125; &#125; @else &#123; @include feature-targeting.targets($feat-structure) &#123; left: 0; transform: translateY(-50%); &#125; &#125;&#125;@mixin margin( $component-height, $component-width: null, $touch-target-height: $height, $touch-target-width: $width, $query: feature-targeting.all()) &#123; $feat-structure: feature-targeting.create-target($query, structure); $vertical-margin-value: ($touch-target-height - $component-height) / 2; @include feature-targeting.targets($feat-structure) &#123; margin-top: $vertical-margin-value; margin-bottom: $vertical-margin-value; &#125; @if $component-width &#123; $horizontal-margin-value: ($touch-target-width - $component-width) / 2; @include feature-targeting.targets($feat-structure) &#123; margin-right: $horizontal-margin-value; margin-left: $horizontal-margin-value; &#125; &#125;&#125; Material design - Space methods 구글 머테리얼 디자인에서는 UI 요소사이의 공간을 8dp 혹은 4dp 단위로 측정한다. 웹에서도 8px, 4px 단위로 여백을 조정한다. 보통은 8px로 진행하는 듯 하다. 이 글과 연관이 있지 않을까 싶다. Layout 사용자의 맥락을 고려한 레이아웃은 디자이너의 영역에 가깝지만,사용자의 기기와 관련된 나용은 한번은 읽어볼만한 내용이였다. 스마트폰 form factor가 다양하다.- 어떤 작업을 할지, 양손을 다 쓸수 있는지에 따라 → 스마트폰을 손에 쥐는 방식도 달라진다.- 한손밖에 쓰지 못할 때 : 기기를 쥔 손의 엄지손가락으로 터치하는 경우, 잘 닿지 않는 영역이 생긴다. - 한 손을 쓸 때의 정확도는 오른쪽 하단에서 왼쪽 상단까지 선형으로 증가하지 않는다. - 스티븐 후버가 진행한 연구 - 사람들이 시선을 두거나, 터치하기 선호하는 영역은 → 스마트폰 화면의 중앙부. 정확도도 중앙부가 높다. - 집중하고 싶어하는 영역 : 중앙부 - PC와는 다르다. PC는 왼쪽 상단에서 오른쪽 하단으로 훑어봄- 양손을 쓸 수 있어서 한손으로 기기를 쥐고 다른 손으로 터치하는 경우 동일한 영역도 쉽게 선택할 수 있다.위 내용은 uxmatters의 글을 읽어보는 것이 더 재밌다. 해당 포스팅에서는 자세히 다루진 않겠다.Design for Fingers, Touch, and People, Part 1Design for Fingers, Touch, and People, Part 2Design for Fingers, Touch, and People, Part 3 적용한 컴포넌트 사례 요즘은 개발자도구에도 접근성이 아주 잘나온다..! 토스는 전체적으로 시원시원한 UI를 갖고있다는 느낌이 들곤했는데, 아무래도 이런 Touch Target의 최소규격을 사용성이 좋게 적당히 잡아둔 듯 하다. Touch Target (Material design) Radio (Material design) Slider (Material design) Switch (Facebook) Button (Facebook) Button - icon (Airbnb) Input (토스) Button - fullfilled Space (Material design) Dialog (Material design) Chips 참고자료 Accessible tap targets 미디어 쿼리 초보자 안내서 Material - Layout and typography Material - web - touch target Material - Spaceing methods Material Web Components Catalog Google - 접근성을 고려한 개발 Google Web Fundamentals - Accessibility toss Design for Fingers, Touch, and People, Part 1 Design for Fingers, Touch, and People, Part 2 Design for Fingers, Touch, and People, Part 3 [피츠의 법칙] Fitts’ Law &amp; Paul M. Fitts","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"00. UX 💅","slug":"01-Web/00-UX-💅","permalink":"http://feel5ny.github.io/categories/01-Web/00-UX-%F0%9F%92%85/"}],"tags":[{"name":"UX","slug":"UX","permalink":"http://feel5ny.github.io/tags/UX/"},{"name":"Frontend","slug":"Frontend","permalink":"http://feel5ny.github.io/tags/Frontend/"},{"name":"UX Law","slug":"UX-Law","permalink":"http://feel5ny.github.io/tags/UX-Law/"},{"name":"Fitts Law","slug":"Fitts-Law","permalink":"http://feel5ny.github.io/tags/Fitts-Law/"},{"name":"Touch Target","slug":"Touch-Target","permalink":"http://feel5ny.github.io/tags/Touch-Target/"},{"name":"Accessibility","slug":"Accessibility","permalink":"http://feel5ny.github.io/tags/Accessibility/"}]},{"title":"프론트엔드 개발자에게 UX는? 연기에 몰입해서 나오는 배우들의 애드립","slug":"ux_01","date":"2021-01-10T11:00:00.000Z","updated":"2024-11-23T12:16:15.284Z","comments":true,"path":"2021/01/10/ux_01/","permalink":"http://feel5ny.github.io/2021/01/10/ux_01/","excerpt":"","text":"피플웨어 책 초반에 이런내용이 나온다. .. 우리가 아는 프로젝트 대다수에서 그 어떤 기술적인 난관보다 사회적인 복잡도가 훨씬 더 컸다는 사실이 분명해 졌다. 그러면서, 불가피하게, 우리는 아주 속상한 결론에 도달했다. 다분히 사회학이 기술보다 더 중요하다는 사실을 오랫동안 느낌으로 알아왔으면서도 정작 우리 중 누구도 그렇게 관리하려 시도하지 않는다는 사실이었다. 물론, 때때로 팀의 협력을 돕거나, 팀 내 긴장을 풀어주기 위해 사회학적인 방법을 사용하기도 했지만, 한번도 우리 업무의 본질이라 여기지 않았다. … - ‘피플웨어’ 중 UX에 대해서 중요하다고 생각은 했는데, 항상 생각만하고 막상 공부나 여러가지 시도를 하지 못하고 있었다. 직감적으로는 알겠는데, 조금 더 스스로 정리하기 위해 해당 글을 작성하였다. 개인적인 견해이니 자유롭게 읽으면 좋을 듯 하다. 1. UX이전에 좀 먼 얘기부터 해보자.. 성장TL;DR 오래 일하려면 재밌게 일하고 공부해야함 어떤 상황에서 재밌었지? 목적지향일때 -&gt; 공부도 그런방향으로 해야함 공부의 이유와 목적을 찾아서 우선순위를 지정해야함. 공부해야할 영역을 찾기위해, 원래 역할을 다시 돌아보면 웹을 잘 만들어야 한다. (완성도, 서비스 효용성) 결국 누가 쓰냐? 사용자를 이해야함 내가 만드는 제품을 사용하는 사용자를 알게되면 어떤걸 원하는지, 그걸 위해 어떻게 만들고, 어떻게 해야 잘 만들지 알 수 있을 것 사용자를 생각하는 것은 디자이너와 롤이 겹칠 수 있지만, 구현관점에서 프론트도 알아야함 (영역이 겹쳐서) 알게된 후 아이디어를 낼 때 배우들의 애드립처럼 나오지 않을까 생각 결론 : 사용자의 기저를 알면 프론트개발자도 충분히 아이디어를! 사용자의 기저를 알기위해 UX 심리학 법칙을 읽어보며 그 기준으로 공부 방향을 잡아본다. 웹개발자를 직업으로 갖으면서 이런 생각이 든다. 직) 즐겁고 재밌게 일하고, 시야를 넓혀서 융합적으로 접근하고 싶다. 업) 개인적으로는 뭔가를 만들고, 피드백 받고 개선하며, 고도화하며 프러덕트를 더 잘 만드는 것을 기본적으로 좋아한다. SO, -&gt; 공부를 꾸준히 해야한다. 재밌게! 그리고 오랫동안 일하고 싶다. 제품을 잘 만들어서, 내 업의 성취감을 얻으려면 -&gt; 재밌고 오랫동안 일하고 공부해야한다.그동안 재밌게 일했던 순간들은 언제였을까? 어떤 조건이 있었을까? 1-1. 재밌게 일하려면, 어떤 상황이여야 하는지프론트개발자로 일을 하면, 여러 유관부서와 협업하며 업무를 진행하게 된다. 디자이너뿐만아니라, 마케터, 기획자, 타 부서 엔지니어등. 그들은 내가 어떤 개발을 해야할지 알려주고, 개발을 요청해 오거나, 혹은 나 스스로가 일을 만들때도 있었다. 몇 년을 이렇게 프로젝트들을 진행하면서, 주변 피드백을 통해 나의 특이점을 찾게 되었는데, 흥미가 있는 프로젝트이거나, 이유가 명확한 프로젝트일수록 업무의 생산성과 속도가 올라가곤 했다. 그리고 그 마음가짐이 오래간다. (근데 모.. 이는 모두가 같을 것이다.) (흥미의 포인트는 개인의 관점일수도, 서비스의 관점일 수도있다.) 여기에 같이 일하는 사람과의 합이 잘 맞을 경우 몇 배나 더 즐겁게 일했던 기억이 난다. 목표지향적인 공부가 되기 위해서는?이렇듯, 사람은 자신이 하는 일에 이유가 있다면, 업무 자체가 목표지향적이게 되어서 빠르게 치고 나갈 수 있는데, 최근 들어서 내가 공부하려는 프론트 skill들은 어떤 이유에서 비롯해서 공부해야하는지? 알긴알고 있지만, 그 이유, 동기들을 정리할 필요가 있다고 생각이 들었다. 굳이 모든 일에 이유를 찾을 필요는 없지만, 조금 더 재밌게 하기위해서는? 시간을 효율적으로 나눠서 공부하기 위해서는? 조금더 근본적인 이유를 찾을 필요는 있는 듯 하다. 그리고 공부가 재밌는 순간은 공부한 내용을 **바로 활용할때..!**이니, 이또한 고려가 되어야한다. 1-2. 이유를 찾기 위한, 공부할 주제와 성격인터넷에 돌아다니는 XXX 로드맵들을 보고 있으면, 참 공부해야할게 많다. 브라우저 엔진에 대하여, 사용하는 언어의 최신문법, 특정상황에 필요한 기술들, 성능향상을 위한 알고리즘, 네트워크, DB, 아키텍처, 패러다임, 디자인 패턴 …위 내용 모두 중요하다. 하지만 오랫동안 재밌게 공부하기 위해서는, 공부할 내용의 성격&#x2F;분량&#x2F;목적 등을 정리해서 꾸준히 공부할 수 있도록 해야한다고 생각했다. 나의 역할을 다시 되돌아보자. (프론트엔드 개발자)웹 개발자는 웹 어플리케이션을 만들고, 사용자는 우리의 웹 서비스를 필요한 상황에 고용하여 사용한다. 사용자는 서비스를 사용하면서, pain point를 개선하게 되고, 이런 혜택을 제일 잘 얻을 수 있는 어플리케이션을 maker들은 ‘잘’ 만들어야한다. 나의 position은 maker에 속하며, 유저가 잘 인지하게 하고, 잘 input하고, 잘 피드백받을 수 있는 인터페이스를 ‘구현’하는 역할이다. 웹을 잘 만들어야한다. (완성도, 서비스 효용성)인터페이스를 만드는 maker에는 여러 유관부서가 기여하게 된다. PO, 디자이너, 클라이언트 개발자 등. 여기서 기여의 비중이 높은 순으로는 디자이너, 클라이언트 개발자라고 생각하는데 이 두 부서간의 교집합은 크다. 클라이언트 개발자가 백엔드 개발자와 커뮤니케이션을 많이 하는 만큼, 디자이너와의 커뮤니케이션 비중도 높다. 백엔드 개발자와는 프러덕트 구현의 퀄리티를 높이기 위해서 커뮤니케이션을, 디자이너와는 프러덕트 사용성의 퀄리티를 높이기 위해서 커뮤니케이션을 한다. 즉, 구현을 위해서는 시스템의 이해도, 기술력의 이해도를 높여하고, 사용성의 퀄리티를 올리기 위해서는 사용자 맥락의 이해도를 올려야한다. 결국 누가쓰나? 사용자를 이해해야한다.‘잘’ 만들려고는 하고 있다. 구현관점에서 이해도를 높이기 위해 기본적인 공부는 꾸준히 진행하며, 어느 정도 실무를 통해서도 자연스럽게 진행하고 있다. 그리고 이쪽은 나름? 우선순위 정리가 되었다. (도움을 준 책은 의외로 : 객체지향의 사실과 오해) 하지만 사용자 맥락의 이해를 올리는 부분은, 중요하다는 인지는 하지만, 막상 업무의 본질로써는 수면위로 올리지 못했다. 아마 구현을 위한 공부에 여유가 없어서일 가능성이 있다. 혹은 디자이너라는 포지션이 있기때문에 나의 영역은 아니라고도 생각하기도 했다. 디자인 영역과 교집합에서의 UX 여러가지 프로젝트를 하면서, 프론트개발자는 시각적인 부분을 구현하는 역할이지만, 제일 큰 킬링 포인트라고 생각되는 점은구현 관점에서도 사용성을 올릴 수 있는 디테일한 포인트를 캐치할 수 있는 역할이 프론트개발자라고도 생각이 들었다. 프론트 개발자만이 할 수 있는 UX개선 (구현 기술력이 요구되는) 프론트 개발자와 디자인의 교집합에 있는 UX 개선 (구현과 시각화 사이) 디자이너가 더 잘 고민할 수 있는 UX개선이 있다고 본다. (시각화) 의외로 구현하면서 “생각해보니 이렇게 하는게 좋지 않을까요?”라는 말을 많이 했던 기억이 난다. 프론트 개발자의 UX개선은 ‘몰입해야 나오는 배우들의 애드립’과 비슷?즉, 1번은 필수적으로 고민하고 진행해야하는 부분, 2번은 협업관점에서 잘 커뮤니케이션하고 전달하기 위해서는, 감각에 의지하지말고, 개념적인 부분을 공부를 하며 끌어올려야하는 영역이라고 생각한다. 그리고 2번의 개념이 올라가고 익숙해지면, 마치 배우들이 연기를 하다가 연기 몰입해서 애드립을 내듯이 프론트개발자도 디자이너와의 합이 잘 맞으면서 적합한 애드립이 튀어나오지 않을까 싶다. 이는 반대로 디자이너가 개발을 배워도 같은 효과. (&#x3D; 융합의 꽃) 3번은 디자이너분들의 역할. 3번 영역은 디자이너분의 의견을 존중한다!! 이 외에도 단순하게 생각하면, 서비스의 수명이 오래가기위해서는 결국에는 두가지 포인트는(퀄리티 관점, UX관점) 병렬로 꾸준히 유지되어야 한다고 생각한다.프론트 개발자도 이 2가지를 같은 레벨로 계속 습득하고, 유지해야한다. 사용자의 본질을 공부해서 서비스의 효용성, 전달력을 높이는데 주력하자.요즘에는 가이드 툴, 프로토타이핑 툴, 인터렉션을 가이드할 수 있는 여러가지 도구가 나오면서, 디자이너가 사용성을 고민하고 시각화를 하거나 가이드안을 산출하는 상황이 많지만, 도움을 줄 수 있는 도구가 나왔다고 해서, 본질적인 부분, 즉 이 교집합인 부분의 지식을 습득하는 것은 여전히 중요하다고 생각한다. 프러덕트 개발은 항상 리소스는 한정되어있는 상황에 마주한다. 이런 상황에서도 좋은 퀄리티의 제품을 만들기 위해서는, 정확한 방향을 잡고, 병렬적으로 여러 사람이 제한된 시간에 많은 아이디어를 내고, 디테일한 부분까지 챙기면서 구현하는 것이 이상적이지만 중요한 부분이라고 생각한다. 그래도 우선순위는 완성도프론트 개발자의 성장관점에서는 구현의 퀄리티와 사용성의 퀄리티의 우선순위로 보면, 당연히 구현완성도를 높이는 기술력 습득이 1순위이다. 2. 어떻게 접근해볼까? 어떻게 정리해볼까? 사용자 경험 패턴을 지식으로 습득하지 않고, 기저에 있는 심리학 법칙을 이해하고 사용한다면, 훨씬 더 설득력 있는 인터페이스로 이어질 것이다. - UX&#x2F;UI의 10가지 심리학 법칙 내가 왜 이 기능을 구현해야하는지. 이 부분은 왜 기본적으로 지켜야하는지를 알기 위해 사용자의 근본적인 심리학과 관련된 책을 읽어보고자 한다. 책은 [UX&#x2F;UI의 10가지 심리학 법칙]이며, 아마.. 이 책을 다 읽으면 다른 책을 선택해보지 않을까 싶다.해당 책은 10가지 심리학 법칙이 나오는데, 법칙들을 읽으면서, 이런 기본적으로 갖고 있는 심리를 유지하기 위해서는 어떤 기술력이 필요로할지 정리하고, 앞으로의 공부방향과 공부분야의 중요성을 이 법칙을 기준으로 정리해보고자한다. 또한 이런 심리를 고려해서 어떤식으로 구현했는지를 정리해보고자한다. 두 분야 다 알야아하는 부분 제이콥의 법칙 : 관습은 유지한다. 멘탈모델은 유지하면서 개선 힉의 법칙 : 인지 부하를 줄여햐한다. 테슬러의 법칙 : 복잡성을 낮춘다. (추상화의 개념과 굉장히 유사) 구현관점 피츠의 법칙 : 입력 사용성 올리기 포스텔의 법칙 : 어떤 상황에서도 일관되게 -&gt; 디자인시스템, 접근성, 반응형 피크엔드 법칙 : 최고의 순간을 극대화 -&gt; 시각적 요소 이용, 모션 이용 도허티 임계 : 체감 성능을 높인다. -&gt; 성능 최적화, 속도개선, … 시각디자인 관점 심미적 사용성 효과 : 레이아웃, 위치 포지션 폰 레스토프 효과 : 특정 맥락에서의 강조 효과","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"00. UX 💅","slug":"01-Web/00-UX-💅","permalink":"http://feel5ny.github.io/categories/01-Web/00-UX-%F0%9F%92%85/"}],"tags":[{"name":"UX","slug":"UX","permalink":"http://feel5ny.github.io/tags/UX/"},{"name":"Frontend","slug":"Frontend","permalink":"http://feel5ny.github.io/tags/Frontend/"}]},{"title":"2020 상반기 회고, 남은 2020년은?","slug":"2020-reflection","date":"2020-11-15T11:00:00.000Z","updated":"2024-11-23T11:38:44.170Z","comments":true,"path":"2020/11/15/2020-reflection/","permalink":"http://feel5ny.github.io/2020/11/15/2020-reflection/","excerpt":"","text":"벌써 11월 중순이다. 60일도 안 남았다.올해는 6월,7월에 상반기 회고를 하지 못했다. 정신이 없었던 것도 있고, 여러가지 이벤트가 많았다는 핑계를 대고싶긴 하지만.. 회고는 하면 할수록 스스로를 돌아볼 수 있는 계기가 되어서, 잊지말고 나를 위해서라도 해야겠다는 생각이 든다. 사실 개인적인 솔직한 회고는 한달에 한번씩 진행하고 있고, 이또한 꾸준히 하려고 노력하고 있다. 앞으로 꾸준히 IT에서 즐겁게 일하기 위해서..! 작년 계획, 잘 지켰을까?2019 회고 + 2020 다짐 (feat. 글또) ➔ 작년 글을 보면, 웹 프론트엔드 개발자로써, 실력향상을 위해서 잡아두었던 계획들이 있었다. 구체적인 일정이나 어떤 방법으로 공부할지는 작성하진 않았었고, 우선순위, 중요도 정도로 작성해두었는데, 결론은 ㅎㅎ 하나도 못했다.. 대신 다른 관심있는 분야 위주로 공부를 하긴했는데, 잡아두었던 방향과는.. 유사한부분도 있고, 아닌 부분도 있다. 1.1. 개인공부 🧐요약 회고요즘 나의 공부스타일로 봐서는, 아예 날짜를 정해서 계획하고 실행했으면 공부를 했을텐데, 블로그에만 작성하고 다른 관심사가 생기면 해당건들을 공부하거나, 현실에 더 필요한 분야를 공부하다보니 놓쳤던 듯 하다. 토이프로젝트 : 데이터 기반 특정 주제에 대한 리포팅 웹페이지 제작 달성률 : 30% 음.. 어떻게보면 오히려 해당 프로젝트는 회사에서 유사하게 진행하였다. 다만, 토이프로젝트에서 녹이고 싶었던 부분은, 조금 더 인터렉션 기술이 많이 녹아져 있는 페이지였으면 좋겠다는 생각이였는데, 회사 프로젝트로는 정말 딱 통계 프로젝트 형식으로 진행되고 있어서, “데이터 기반” 이라는 컨셉은 같았지만, 원하는 리포팅 페이지 스타일은 아니였다.그래도 데이터 기반으로 어떻게 집계해서 보여주는게 좋을지 등등 통계화면에 대한 기획은 배울 수 있었다. Big(덩어리 큰) 공부 🙅‍♀️ 자료구조 공부 &#x2F; 디자인 패턴 공부 둘다 달성하지 못했다.😞 디자인 패턴의 경우 최근에 공부할 의지가 생겨서, 사내에서든 외부에서든 책모임 스터디를 오픈하려고 준비하는 중이다. 다만, 저번에 진행했던 HTTP 완벽가이드 책모임과 같이 이론만 개인적으로 공부하고 정리하는 스타일로는 어려울 듯 하여, 실습위주로 같이 스터디하되, 어떤 멤버로, 어떤 방법으로 진행하는 것이 제일 적합한지를 고민중이다. 현재 사내에서도 실습이 조금 가미된 개발스터디를 진행하고 있는데, 이참에 실습이 포함된 스터디는 어떻게 진행하면 좋을지 고민해 보려고 한다. Small(덩어리가 작은) 공부 🙅‍♀️ 구글 web fundamentals &#x2F; 자바스크립트 공부 둘다 달성하지 못했다.😞 구글 web fundamentals은 회사에서만 작업하는 프론트엔드 방향 이외에 흥미를 올릴 수 있는? 주제들이 모여있어서, 회사일이 지겨울때나, 흥미있는 개발주제를 알고 싶을 때, 보기 좋은 글들이 존재한다. 이 페이지의 정보들은 타이트하게 잡기보다는.. 텀을 두고 읽어볼 거리로 남겨두면 좋을 듯한데, 이번 글또 때 다 보는 걸 목표로 삼아도 좋겠다는 생각이 든다. 1.2. 2020 다짐 🦠 내공 다지기 : 코로나 때문에도 그랬지만, 오프라인 활동은 못했다. 다만, 발표도 책모임등의 외부할동은 진행했던 듯 하다. 내실을 다지는 작업도 놓지지 않았던 듯하다. 🦠 건강, 휴식 : 내면의 건강과 휴식을 위해서 해외 여행을 생각했지만 코로나 때문에 진행되지 못했다. 다른 분야 책 3권 읽기 : 마케팅과 데이터쪽 책을 꽤 읽게 되었던 해였다. 중간부터 점점 개발책을 안 읽게 되었다는 생각에 현타가와서 개발 외의 읽을 책의 비율을 낮추긴 했다. 특히 “경제”라고 했던 ㅎㅎ 부분은 이루지 못했다. 🦠 헬스 : 필라테스를 시작하려 했으나 이 또한 코로나.. 올해 있었던 Event와 Insight올해는 정말 다이나믹한 해였다. 다양한 일을 해보면서, 개인적으로는 내가 잘 하는 부분, 노력하면 잘 될것 같은 부분, 잘 못하는 부분 등. 여러가지 성찰도 해보고, 개발자로써는 어떻게 크로스되는 방향으로 나아가야할지, 그리고 어떻게 하면 함께 잘 일을 해야할지. 고민을 많이 했던 해라고 생각된다. 그리고 그 고민의 해결에는 주변에 도와주는 많인 이들과 책이 있었다. 함께 잘 일하는 법올해는 기존에 같이 일하는 분들 이외에 비개발자 직군들과 새로 입사하신 개발자분들 등, 나와 다른 관점을 가진 사람들과 일하는 상황이 많이 있었는데, 그때마다 어떻게 일을 해야 효율적인지(생산성), 어떻게 커뮤니케이션을 해야 효율적이고 피로도가 덜 쌓일지(프로세스), 어떤 태도를 가져야 곱하기로 나아갈 수 있을지 고민을 많이 하게 되었다.때문에 시간할당이 개발에만 몰리진 않았었는데, 처음 있는 일이다보니, 혼란이 왔지만(내가 이런 고민을?), 결론적으로는 팀을 위한 고민이다 생각을 하니, 같은 업무 레벨로 봐야겠다는 생각이 들었다. 이 고민의 해결에는 책이 정말 많이 도움이 되었다. 그 중에 꼽자면, 피플웨어라는 책과 함께 자라기라는 책이 있는데, 함께 자라기는 입사하고 완전 주니어시절에 읽었지만, 올해 다시 읽어보면서 2년이 지난 이 시점에 또 다른 면을 볼 수 있게 되었다.피플웨어라는 책은 개발자가 읽기보다는 개발자와 함께 일하는 비개발직군들도 꼭!! 읽어야하는 필수책이라고 생각한다. 지식노동자인 개발자와 건강하게 함께 일할 수 있는 노하우가 담겨져 있는 책이라고 생각한다. 함께 잘 일할 수 있는 문화기존에 존재하고 있던 분위기에서 어떤 문화를 녹이는 것을 많은 시도가 필요하다. 계속 나아갈 것은 유지하고, 개선해야할 부분은 하나씩 개선해나가면서, 우리에 맞는 색을 찾는 것이 중요하다고 생각한다. 그렇게 만들게 된 회사의 분위기와 문화로 인해 어느새 회사에서 일하는 업무가 내가 일하고 싶은 업무로 변하게 되고, 이는 나의 성장과 회사의 성장이 일치되는 순간이라고 생각한다. 이런 분위기에서 낼 수 있는 시너지란 곱하기 이상, 제곱이 될 수 있지 않다. 개발자가 재밌게 일하고 잘 일하게 만드는 문화란 무엇일까 고민하며, 우리의 상황에 맞게 만들어가려고 팀 내에서는 많은 고민을 하고 있다. 여러 번의 회고 등을 통해서 하나씩 잡아가고 있으며, 이런 과정이 잘 이루어지고 다른 포지션에도 전파되길 기대하고 있다. 책 공부 습관올해는 여러가지 분야에 대해 알야아하는 환경이 되다보니, 모르는 분야를 접하는 순간도 많았고 때문에 이를 해소하기 위해서 스터디, 인강, 책 등 여러가지 공부 방법을 찾아보려고 했다. 시도 끝에 책을 보는 것을 메인으로 잡고, 나머지는 스터디나 인강을 통해서 보충하거나 다른 시야를 접하는 방식이 나한테 맞는 공부법이라는 것을 깨달았다.또한, 작년에 진행했던 http 완벽가이드 스터디를 (마지막에는 살짝 흐지부지 됐지만) 마친 후, 책을 보는 것에 대한 두려움이 예전보다 많이 감소했다. 특히나 이 책이 400쪽 가까이 되는 두꺼운 책이어서 더더욱 그랬던 듯 하다. 그리고 올해는 6월부터 PO 책모임인 프만사(프러덕트 만드는 사람들)라는 책모임에 참여하면서 습관 붙이기에 더 불이 붙었던 듯 하다. 물론 이 모임도 중간에 정신없는 상황때문에 참여가 더디긴했지만, 책을 읽고 모임때는 모임장이 발제한 질문에 서로 얘기하는 분위기가 책에 대한 거부감을 줄여주었던 것도 있었다. 특히나 모임장인 민지님의 독서 열정을 보고 있으면, 더더욱 큰 효과가.. 외부 책모임에서 얻은 좋은 경험을 사내에도 전파하고 싶어서, 여러가지 책모임들을 스멀스멀 진행해보았었다. 제일 재밌었던 책은 “빅데이터를 통한 예측마케팅”이라는 책과 “손에 잡히는 10분 정규표현식”이였는데, 책을 읽고 책모임 인원들이 회사의 업무에 바로 적용하던 모습이 인상깊어서 그랬던 거 같기도 하다. 한달 반 남은 2020년과 글또 5기 다짐내년 상반기까지 글또에 글을 작성할 예정이다. 13번의 글을 작성한다고 하는데, 어떤 글을 써볼까 주제고민 개발 공부 프론트엔드 기반 공부 패러다임 공부 패턴 공부 다른 언어 공부 삽질기 어떤 경험을 통해 알게된 내용을 정리해서 글을 올리자. 믹스해서 작성해보기 개발자인데 마케팅을 안다면?- 매체 + 유저 베이스 + 데이터를 혼합한.. 뭔가의 글을 쓰지 않을까- 퍼포먼스 마케팅과 유사한 주제를 개발자입장에서 작성하지 않을까 싶다. 지양해야할 주제와 지향해야할 주제 지양해야할 글 - 정리 글 : 책 정리글은 노션에 1차적으로 정리하고, 책을 읽고 난 생각이나 인사이트들을 개인이 특정 주제를 발제를 하던지해서, 인사이트 형태로만 블로그에 올려야겠다는 생각이 든다. 지향해야할 글 - 인사이트 올해는 코로나의 여파일지는 모르겠지만, 참 순식간에 지나갔다.빠르게 지나가는만큼, 기록과 회고는 중요하니 꾸준히 성찰, 개인 성장, 함께 성장, 되돌아보기를 지치지 않게 해나가보자!","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"Joy","slug":"Joy","permalink":"http://feel5ny.github.io/tags/Joy/"},{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/tags/blog/"},{"name":"Reflection","slug":"Reflection","permalink":"http://feel5ny.github.io/tags/Reflection/"}]},{"title":"고객 Profiling (3장)","slug":"Communication_004","date":"2020-07-03T14:23:55.000Z","updated":"2024-11-23T12:36:10.139Z","comments":true,"path":"2020/07/03/Communication_004/","permalink":"http://feel5ny.github.io/2020/07/03/Communication_004/","excerpt":"","text":"TL;DR고객 프로파일링 고객 데이터를 활용하여 새로운 성장 기회를 찾거나, 고객을 초정밀 타겟팅하기 전에 먼저 고객 데이터 자체를 통합하고 클렌징하고 분석해야 한다. 결코 쉬운일이 아니다!! 얼마나 많은 데이터를 수집할 것인가 각 개인 고객은 매일 수백개의 데이터 포인트를 생성하며, 여기에 수천 또는 수백만명의 고객을 곱하면 진정한 고객 빅데이터를 얻을 수 있다. 데이터의 양, 다양성, 속도가 큰 경우 빅데이터라고 한다. 가장 중요한 설계 원칙은 목표를 염두에 두고 시작하는 것이다. 데이터 수집을 위한 설계 원칙 수집된 데이터 : 빈도, 파생데이터, 세분가능성 이걸갖고 뭘? : 유추하고자하는 인사이트, 실행가능성, 데이터 관리 : 정합성, 신상정보 충실도, 저장, 접근성 수집된 데이터 빈도 : 얼마나 자주, 어떤 촉발이벤트에 의해 데이터를 수집할 것인가? 파생 데이터 : 파생 데이터는 원 데이터에서 의미를 추추출하여 만든 데이터 요소이다. 웹사이트를 방문하고 제품을 5회 탐색한 후 7일 이내에 상점에서 구입하는 고객은 ⇒ 온라인으로 정보를 수집하지만, 오프라인에서 구매하는 고객이라고 분류할 수 있다. 세분 가능성 granularity : 웹 데이터는 클릭 하나하나 각기 수집될 수 있고 웹 세션에 대한 요약만으로 충분한 경우들도 있다. 이걸갖고 무엇을? 유추하고자 하는 인사이트 고객의 구매력 상승 여력을 예측하는 것이 목표인 경우 고객이 구매하는 제품의 유형 고객이 거주하는 지역의 우편번호가 중요하다. 유추하고자 하는 인사이트가 데이터 수집 대상을 결정한다. 실행가능성 액션!! 수집된 데이터는 직접 또는 간접적으로 실행으로 이어질 수 있어야 한다. 스포츠에 대한 고객의 관심 여부를 모았을 때, 그러한 정보는 스포츠 용품 판매업자에게는 실행으로 이어질 수 있지만, 세무 컨설팅을 하는 회사의 경우는 그렇지 않다. 데이터 관리 정확성 : 연령을 물어보면 일부 고객들은 아무렇게나 답변을 입력한다. 특히 마케터가 이를 컨텐츠 열람을 위한 사전 조건 또는 가입을 위해 사용하는 경우 더욱 그런 경우가 많다. 마케터는 대체값 삽입을 통해 이러한 부정확성에 대처해야 한다. 결측값 대체는 누락된 값을 대체값으로 대신하는 프로세스이다. 신상정보 충실도 : 마케터는 고객의 신상정보 충실도를 높이기 위해 누적 프로파일링을 사용하여 고객 데이터를 수집하고자 하는 경우가 많다. 저장 : 데이터를 얼마나 많이 또는 얼마나 오래 보관할지는 데이터의 시의성에 따라 다르다. 웹 브라우징 데이터는 몇 주가 지나면 관련성이 없어지지만, 구매 데이터는 수년간 관련성이 유지된다. 접근성 : 수집된 데이터는 분석 및 실행을 위해 마케터가 엑세스할 수 있어야 한다. 고객 데이터가 사일로 안에 갇혀서 현업 마케터가 액세스 할 수 없는 경우가 너무 자주 발생한다. 어떤 유형의 데이터를 수집할 것인가 전통적 마케터 : 구매데이터, 고객의 인구사회학적 데이터 사용 요즘 : 일시적 정보를 제공해주는 행위데이터 포인트에도 더 많이 액세스 일시적 정보는 맥락을 추출하고 마케팅을 적시에 고객과 더욱 관련성 있게 만드는 데 사용될 수 있다. 예_ 마비 90%거래에서 각 고객을 확인할 수 있었다. 목표와 측정을 제대로 설정했고, 항상적으로 개선에 집중 수집한 데이터를 이용하여 고객을 즐겁게 함 매장 직원은 그로인한 이점을 목격했고, 왜 자신들이 그 러한 일을 하는지에 대해 항상 교육을 받았다. 분석을 위한 데이터 정비 불량한 또는 불완전한 고객 데이터 프로파일을 바탕으로 고객 세분화나 예측 모델을 구축하면, 고객에게 잘못된 추천을 하게 된다.&#x3D; 데이터와의 씨름은 업무에서 거대한 부분을 차지한다. 한 고객에 대한 싱글뷰 sigle view가 없이는, 개별고객에 대한 진정한 이해나 고객 트랜드에 대한 결론을 이끌어 내는 것이 불가능하다. 어떤 사람이 자주 웹사이트를 탐색하지만, 최종적으로는 항상 매장에서 구매한다면, 웹사이트에서는 이 사람을 ‘낮은가치’의 고객으로 인식하는 실수를 범하게 된다. 한 고객이 많은 돈을 지출하고 자주 구매하지만, 물건들을 자주 반품해버리거나, 회사의 콜센터로 뻔질나게 전화를 건다. 이 고객은 높은가치의 고객처럼 보이지만, 사실은 수익성이 낮은 고객이다. 수집한 모든 정보를 통합하고, 연결하고, 중복을 제거할 수 있어야 한다. 고객1명의 프로파일에 포함된 정보의 예시 ⭐️ 일반 인구통계 Master 이름 이메일 성별 링크드인 검색 주소 위치 주소의 google지도 보기 예측 분석 (군집) attribute 구매가능성 : 높음 행위 기반 군집 : 할인중독자 제품 기반 군집 : 노트북 컴퓨터 구매자 브랜드 기반 군집 : dell 생애주기 군집 : 신규고객 제품 추천 접촉 전략 (매체,채널) attribute 선호 채널 선호 매장 가장 까가운 매장 선호 브랜드 전화로 판매 가능한가? Y/N 우편으로 판매 가능한가? Y/N 이메일로 판매 가능한가? Y/N 생애주기 군집 값( enum같은 ) 예상 고객 신규 고객 반복 고객 기간 경과된 일회성 고객 기간 경과된 반복 고객 비활성화된 일회성 고객 비활성화된 반복 고객 구매 데이터 분석 attribute 평생 매출 (예: 2007달러) 평생 마진 (예: 576달러) 평생 주문 수 최근 12개월 매출 최근 12개월 마진 최근 12개월 주문수 평균 주문 금액 최근 12개월 매출 세그먼트 (예: 상위 n% 고객) 12개월 이전 매출 세그먼트 매출 추세 (증가,유지,감소) 행위 behavior 마지막 주문 날짜 마지막 주문 채널 마지막 주문 매출 웹사이트 마지막 방문 날짜 웹사이트 방문 횟수 마지막 이메일 발송 날짜 마지막 이메일 열람 날짜 마지막 이메일 링크 클릭 날짜 지난 달 이메일 열람 횟수 이전 2개월 이메일 열람 횟수 지난 달 이메일 링크 클릭 수 이전 2개월 이메일 클릭 횟수 최초 주문 날짜 최초 주문 채널 최초 주문 매출 선호 distinct 채널 선호 제품 선호 카테고리 최근 5개 주문 (채널/날짜/제품/브랜드) 최근 5회 웹사이트 검색 (검색어, 날짜) 고객기업 지원팀, 콜센터 팀, 매장 직원에게 프로파일에 액세스 권한을 준다. 이 정보를 활용, 고객에게 더 나은 서비스를 제공 고객 데이터를 모두 통합한 뒤 고객에 대해 중요한 발견을 하게 되는 경우가 흔히 있다. 데이터에 대해 물어봐야할 100가지 질문 ⭐️일단 모든 데이터를 한곳에 모으게 되면, 이 데이터를 사용하여 비즈니스와 고객을 더 잘 이해할 수 있다.질문은 예측마케팅을 시작하는데 도움을 줄것이다. 판매 매달 얼마나 많은 신규고객을 획득? 신규고객을 획득하는 데 드는 비용은 얼마? 고객당 매출액은 얼마? 추세는 어떠함? 나의 매출과 마진은 계절에 따라 어떻게 변하는가? 매출의 대부분이 신규 구매자로부터 발생하는가, 아니면 반복 구매자로부터 발생하는가? 마진의 대부분이 신규 구매자로부터 발생하는가, 아니면 반복 구매자로부터 발생하는가? 출하한 제품의 연간 총 주문 수는 얼마나 되는가? 월별 주문 금액은 얼마인가? 어떤 달들은 거래가 더 많이 발생하는가? 연간평균 주문 금액은 얼마이며, 시간경과에 따른 추세는 어떠한가? 매출은 액세스 기기(모바일, 태블릿, 기타)별로 어떻게 나뉘는가? 매출은 지역별로 어떻게 나뉘는가? 매출은 매장별로 또는 영업 담당자별로 어떻게 나뉘는가? 매출액 중 마케팅 불가능한 고객으로부터 발생하는 매출은 얼마인가? 고객 제품기반 군집 각 제품 기반 군집에는 몇 명의 고객이 있는가? 제품 기반 군집의 각 구성원은 어느정도의 가치가 있는가? 가장 많은 매출을 올리는 제품 기반 군집은 어느것인가? 가장 큰 마진을 낳는 제품 기반 군집은 어느 것인가? 각 제품 기반 군집별로 선호하는 채널은 어떤 것인가? 브랜드 기반 군집 각 브랜드 기반 군집에는 몇명의 고객이 있는가? 각 브랜드 기반 군집의 각 구성원은 어느정도의 가치가 있는가? 가장 많은 매출을 올리는 브랜드 기반 군집은 어느것인가? 가장 큰 마진을 낳는 브랜드 기반 군집은 어느것인가? 각 브랜드 기반 군집별로 선호하는 채널은 어떤 것인가? 행위기반 군집 각 행위 기반 군집에는 몇 명의 고객이 있는가? 행위 기반 군집의 각 구성원은 어느 정도의 가치가 있는가? 가장 많은 매출을 올리는 행위기반 군집은 무엇인가? 가장 큰 마진을 낳는 행위 기반 군집은 어느것인가? 각 행위 기반 군집별로 선호하는 채널은 어떤 것인가? 각 행위 기반 군집별로 선호하는 채널은 어떤 것인가? 고객 중 몇 %가 할인 구매자인가? 고객 중 몇 %가 (마진이 높은) 정가 구매자인가? 고객 중 몇 %가 일회성 구매자인가? 반품이 많은 불평 고객은 누구인가? 계절성 고객은 누구인가? 단일 채널 고객은 누구인가? 평생가치 가장 높은 가치의 고객은 누구인가? 최상위 10% 고객의 (예상) 평생가치는 얼마인가? 매출 중 최상위 10% (또는 최하위 10%) 고객으로부터 발생하는 매출이 전체 매출에서 차지하는 비율은 몇%인가? 최상위 10% (또는 최하위 10%) 고객의 주문 빈도는 얼마나 되는가? 최고액 소비자들은 어떤 브랜드를 선호하는가? 최고액 소비자들은 어떤 제품 카테고리를 선호하는가? 최고액 소비자들은 어떤 채널을 선호하는가? VIP를 어떻게 정의하는가? 높은 가치의 고객들 중 이탈할 위험이 있는 고객들은 얼마나 되는가? 고객별 (고객 세그먼트 별) 지갑 점유율은 얼마나 되는가? 개별 고객의 매출액 상승 여력은 얼망인가? 잠재적 평생가치는 높지만 자사의 점유율이 낮은 계정들은 어떤 것들인가? 성별에 따른 예상 평생가치는 무엇인가? 할인 사냥꾼들 bargain bunters의 예상 평생가치는 더 낮은가? 모바일 쇼핑객의 평생가치는 더 낮은가? 가장 높은 가치의 고객들은 어떤 브랜드를 선호하는가? 멤버십 적립 프로그램 가입자의 평생가치는 평균보다 높은가? 구매가능성 무료 배송 서비스의 제공은 매출(및 마진)에 어떤 영향을 미치는가? 할인이 판매 증가를 촉진했는가? 프로모션 비용을 고려할 때 할인이 마진 증가를 촉진했는가? 각 고객에 대한 최고의 인센트브는 무엇인가? 방문하는 사람들 중에 고매 가능성이 높은 잠재 고객들이 있는가? 회원가입비를 받을 것인가? 기존고객들 중 재무개할 가능성이 가장 높은것은 누구인가? 생애주기 단계 활성고객 (지난 12개월 동안 구매한적이 있는 고객)은 몇명인가? 기간이 경과한 고객은 몇 명인가? 매출 및 마진의 대부분을 신규고객이 차지하는가 아니면 반복 고객이 차지하는가? 구매자는 일반적으로 얼마나 빨리 재구매를 할것인가? 리필 캠페인을 통해서 몇 명의 고객을 다시 불러들일 수 있는가? 신규 고객 환영 캠페인을 통해서 몇명의 고객을 다시 불러들일 수 있는가? 회사가 이메일 주소를 갖고 있는 구매자들 중 최근에 회사 웹사이트를 방문했으나, 구매하지 않은 사람은 몇명인가? 오랫동안 구매하지 않다가 최근에 이메일을 열어본 고객은 몇명인가? 고객 유지에 초점을 맞춰야하는가? 신규고객들이 다시 돌아오고 있는가 (그리고 이것이 더 나아지고 있는가 아니면 더 나빠지고 있는가)? 여러번 구매한 사람들은 몇명이며, 그들이 마지막으로 구매한 것은 언제인가? 이탈할 위험이 있는 고객들은 누구인가? 인구사회학적 특징 우리로부터 구매한 가구수는 얼마나 되는가? 성별에 따른 평균 주문 금액은 얼마인가? 고객별(세그먼트별)로 가장 가까운 매장까지의 거리는 얼마인가? 제품추천 고객별로 다음에는 어떤 제품을 추천해야 하는가? 각 고객별로 핵심적인 채널은 어느 것인가? 마케팅/채널 매월 몇 개의 장바구니가 매출로 이어지지 않고, 중도에서 포기되고 있는가? 매월 몇 개의 웹 검색이 매출로 이어지지 않고 중도에서 포기되고 있는가? 이메일 1개당 매출은 얼마이며, 시간 경과에 따라 어떻게 변화하는가? 가입자 중 우리가 보낸 이메일을 실제로 읽은 사람들은 몇명인가? 가입자 수가 늘어나고 있는가, 아니면 줄어들고 있는가? 다이렉트 마케팅 캠페인의 성과는 무엇인가? 어떤 마케팅 프로그램이 최고의 수익을 내고 있는가? 어떤 프로모션 행사가 가장 많은 판매액을 올리는가? 우리 회사의 카탈로그 발송이 이익 증가로 이어지는가? 지난 1년동안 우리 이메일을 한통도 받지 못한 고객은 누구인가? 전체 매출에서 각 채널이 차지하는 퍼센트는 얼마인가? 전체 마진에서 각 채널이 차지하는 퍼센트는 얼마인가? 채널별 연간 매출 추세는 어떠한가? 채널별 월간 매출 추세는 어떠한가? 채널별 마진 추세는 어떠한가? 어떤 채널에서 가장 수익성 높은 고객을 얻는가? 어떤 채널에서 가장 충성도 높은 고객을 얻는가? 제품 제품 카테고리별 매출 및 마진은 어떠한가? 제품 소개 캠페인으로 타겟팅할 수 있는 사람들은 얼마나 되는가? 가장 실적이 좋은 제품 카테고리는 무엇인가? 특정한 제품 카테고리의 구매빈도는 얼마인가? 특정한 우편번호 지역의 사람들이 특정한 제품을 구매하고 있는가? 새로운 제폼/콘텐츠/행사 등에 어떤 고객이 관심을 가질 것인가? 각 고객은 얼마나 많은 유형의 제품들을 우리에게서 구매하는가? 빅데이터를 활용한 예측마케팅 전략 책을 보고 이해한 내용을 정리 한 글입니다.","categories":[{"name":"04_AARRR","slug":"04-AARRR","permalink":"http://feel5ny.github.io/categories/04-AARRR/"},{"name":"00. Analyze","slug":"04-AARRR/00-Analyze","permalink":"http://feel5ny.github.io/categories/04-AARRR/00-Analyze/"}],"tags":[{"name":"maketing","slug":"maketing","permalink":"http://feel5ny.github.io/tags/maketing/"},{"name":"LTV","slug":"LTV","permalink":"http://feel5ny.github.io/tags/LTV/"}]},{"title":"예측 분석이란? (2장)","slug":"Communication_003","date":"2020-07-02T14:23:55.000Z","updated":"2024-11-23T12:36:10.139Z","comments":true,"path":"2020/07/02/Communication_003/","permalink":"http://feel5ny.github.io/2020/07/02/Communication_003/","excerpt":"","text":"예측 분석이란?마케터가 알아야할 예측분석 자율학습 (군집화모델) 데이터속의 숨겨져있는 패턴을 찾아낸다. 감독학습 (경향성 모델 또는 예측) 입력 샘플과 목적변수를 학습하여,어떤 입력값이 주어졌을 때,출력값을 추정하는 데 사용 고객평생가치 engage 가능성 &#x2F; 다음에 구매할 가능성이 있는 특정한 제품을 추정 강화학습 (추천기능) 데이터속의 숨겨진 패턴과 유사성을 지렛대 삼아사용자 또는 특정 이벤트에서 최적의 다음단계, 결과, 제품, 콤텐츠를 정확하게 에측할 수 있게해준다. 1. 자율학습: 군집화 모델 cluster 당신이 찾고 있는 것이무엇인지 미리 알지 못하거나, 명시적 변수명을 사용하지 않고도데이터의 패턴을 인식해내는 것 이러한 접근법 중 하나를 군집화 cluster 행위가 유사한 고객을 그룹화함으로써이 그룹의 패턴이 어떤 것인지 드러날 수도 있다. 군집화와 세분화의 차이점 clustering, segmentation 세분화 segmentation 유사성을 기반으로 고객들을 여러 그룹에 각기 수동으로 배치하는 프로세스 타깃으로 삼을 사람을 사전에 알고 있다. 군집화 clustering 고객을 그룹으로 묶을 수 있도록그들 내의 유사성들을 찾아내는 자동화된, 통계적으로 엄격한 프로세스이다. 누구를 타깃으로 삼을 것인지 발견하는 것⇒ 고객에 대해 이미 알고있는 속성들을 사용하여 회사의 고객 기반 속에 존재하는 세그먼트들을 자동으로 발견해내는 방법 군집화 알고리즘 K-means Apriori 군집화를 알고리즘은 더 많은 차원을 검토한다. 마케터들은 이제브랜드 선호도,할인 선호도,웹사이트에 머문시간,웹페이지 열람행위,통화길이 등수백가지 고객특성 feature을 확보하고 있다. 하나의 고객군집은 일반적으로 약 8~15개의 속성을 통해서 설명된다. 자동으로 발견된, 마케팅 대상으로 삼을 수 있는 페르소나로 간주할 수 있다. 2. 감독학습: 경향성 모델 (&#x3D; 반응모델 response models &#x3D; 우도모델 likelihood) 경향성 모델은과거의 사례들을 통해 학습함으로써,고객의 미래 행위를 예측해낸다는 점 예_ 고객이 제품을 구매할 가능성 또는예상 고객이 웹사이트에서 뭔가 행동할 가능성 반응모델 **response models**라고도 종종 불린다. 다이렉트 메일을 수신한 결과로제품을 구매하게 될지 아닐지와 같은고객반응을 예측하기 때문 우도 모델 (likelihood,가능성) 알고리즘 신경망 neural networks 로지스틱 회귀 logistic regression 랜덤 포레스트 random forest 회귀 트리 regresstion trees 가이드 학습 guided-learning 모델이다.&#x3D; 데이터를 학습하는데 시간이 걸린다는 것&#x3D; 시간이 지남에 따라 모델이 더 나아진다는 것을 의미 대부분의 경향성 모델은 예측을 위해 사용하기 전에 짧은 훈련기간과 검증 기간을 필요로 한다. 경향성 십분위를 사용하는 법 deciles십분위 개별 고객 점수 대신에 대부부의 실무자는 고객을 10분위로 나눈다. 예_고객이 평생동안 얼마나 돈을 쓸 것인지 예측하려면?평생가치 예측 모델이라고 불리느 것을 사용한다. 2가지 측명에서 유용 평생가치 또는 지출과 같이 기업이 기대하는 행위에 대한 평균값을 제공한다. 고객들을 동일한 크기의 묶음 bucket 10개로 나누어, 그 중에서 가장 가치가 높은 것부터 가장 낮은것까지, 또는 구매할 가능성이 가장 높은 것부터 가장 낮은 것까지 순위를 매길 수 있도록 해준다. 예 값비싼 카탈로그를 누구에게 보낼지 결정할때 a&#x2F;b 행상도 테스트를 설계하 ㄹ때 이탈한 웹사이트 방문자를 대상으로 한 캠페인 비구매자들을 추적할 수 있는 많은 리타겟팅 솔루션들을 이용할 수 있다. 구매 가능성에 따라 고객에게 제공하는 혜택을 차별화할 수 있다면? 구매 가능성이 높은 사람 ⇒ 리마인드 메세지만으로 지갑을 열게 함 구매 가능성이 낮은 사람 ⇒ 할인 또는 무료배송 제안 이 유형의 모델은 예상 고객과 기존 고객의 미래 행위를 예측하는데 사용할 수 있다. 예_ 구찌 핸드백을 구입한 순간부터 이 사치품 업체는 내가 앞으로 핸드백을 몇개나 더 구매할지에 대해서 높은 정확도로 예측할 수 있다. 구찌의 알고리즘은 나의 구매, 웹사이트 방문, 이메일 클릭이나 나의 연령, 성별, 지역 등을 이전에 구매한 수천명의 다른 고객의 행동 미 인구사회학적 특징과 비교한다. 미래 구매행위를 나보다 더 잘 예측할 수 있다. 경향성 모델과 RFM 모델링의 비교RFM 모델링 예측분석이 널리 보급되기 전에는 RFM이라고 불리는 모델이 구매 가능성이 높은 사람을 파악하는 업계 표준 방식이었다. 그 효용이 제한적, 현실 생활에 적용하기가 생각보다 너무 어렵다. 통계적, 예측적 기반이 없는, 단순한 경험적 접근방식일 뿐이다. (주먹구구식으로 나름 지적인 추측을 하는) 이 모델의 핵심 아이디어는 한 고객이 다른 제품을최근에 구입했거나,자주 구입했거나,당신의 제품에 많은 돈을 지출하였다면그 고객은 당신의 제품을 다시 구매할 가능성이 높다는 것이다. 시기 : 이 고객이 우리 제품을 마지막으로 구입한 이래로 며칠이 지났는가? 빈도 : 그 고객은 우리 제품을 얼마나 자주 구매했는가? 금액 : 그 고객은 우리에게 얼마나 많은 매출을 가져다 주었는가? 데이터에서 파생될 수 있는 많은 다른 변수들 중에는 추가적으로 우수한 예측 변수로 사용할 수 있는 것들이 있지만, 이 모델리에서는 변수 사용을 많이 안하는 방법이다. 과거의 결과가 미래의 성과를 보장하지 못한다가 적용되는 방법이다. 한 고객의 현재 행동을 과거 다른사람들의 이후 행동과 비교하기 보다는,오로지 해당 고객의 과거에 대해서만 되돌아본다. 높은 가치의 고객이 실제로 구매를 하기 전에는 이들을 인지할 수 없다. 예 대부분의 고객이 3번 구매한 다음 사라진다면 이미 3번 구매한 어떤 고객이 다시 구매할 가능성은 사실 매우 낮지만 RFM모델은 이 고객을 구매 가능성 매우 높음 이라는 세그먼트에 배치할 것이다. 반응을 할 가능성이 높은 좋은 고객이⇒ 가치가 그다지 높지 않은 세그먼트에 포함될 수도⇒ 프로모션 발송대상에서 제외될 수도 구매가 빈번한 환경에서만 향후 구매할 가능성에 대한 예측을 할 수 있다. 감독학습 모델은 이러한 모든 고객 행위를 예측하는 데 사용할 수 있다. 경향성 모델은 RFM모델보다 평균 40% 더 정확 3. 강화학습 및 협업 필터링(reinforcement learning, collavorative filtering) 강화학습은 일반적으로 협업필터링 모델과 함께 사용된다. 협업필터링 모델의 일반적인 마케팅 응용 프로그램은 ⇒ 추천 추천모델 협업 필터링 베이지안 네트워크 bayesian networks 빈발 항목집합 frequent item sets 시간가중치 time-decay 최근 행동이 이전 행동보다 예측에 대한 가중치가 더 크다는 사실을 감안하기 위해서 강화학습은 고객의 선호에 조응하도록(꼭 맞게 대응함)모델을 교육하기 위해 적용된다. 고객이 처한 맥락에 맞는 추천을 하는 것이 중요하다. 잘못된 추천 또는 맥락을 벗어난 추천은 불쾌한 간섭하는 부적합한 것으로 간주된다. 추천하는 시점도 적절해야한다. 예 장바구니 결제시 ‘이것을 구입한 고객은 또한 XX도 추가했다’ 2일 후에 후속구매를 제안하는 감사 이메일 추천이유를 제공하기 시작 간섭적 특성을 제거하기 위해 아마존 당신이 이 제품을 보았으므로, 이런 제품들에도 관심이 있으실 것입니다. 어떤 제품이 추천되는지에 대해서 소비자에게 통제 권한을 부여하기 시작 설정메뉴에서 추천알고리즘이 특정한 항목을 고려대상에서 배제하도록 설정가능 추천 알고리즘의 중요한 3가지 고객과의 관련성을 유지하기 위해 이상적으로는 추천이 실시간으로 갱신되어야 함 추천모델이재고가 없는 제품,반품 비율이 높은 제품,사용후기가 나쁜 제품을 추천하는 것은 바람직하지 않다. 다양한 유형의 추천모델 상향 판매 upsell 추천 고객에게 더 나은 가격 조건을 제안하거나, 상품의 품질을 강조하는 등 고객이 희망했던 상품보다 단가가 높은 상품 판매 구입을 유도하는 판매방법입니다. 판매 증대는 물론 고객 만족을 위해서도 중요한 마케팅 활동입니다. ex) 500원 추가하면 라지사이즈 가능한데 변경하시겠습니까? 후속 판매 next sell 추천 후속 판매는 구매하고 며칠 후에 구매자의 기존 구매를 바탕으로 구매자에게 다른 제안을 독점적으로 진행하는, 후속 조치를 취하는 판매 행위입니다. ex) 구매자가 콤보 식사를 구매 한 경우 패스트 푸드 체인은 그들에게 독점적 인 월별 버거 클럽 제공을 실제 버거 애호가에게만 제공 할 수 있습니다. ex_ 컴퓨터를 구매하는 경우, 상점은 그들에게 ‘99 달러 할인 가격으로 ‘컴퓨터 사용 방법’워크숍에 참석할 수있는 독점적 인 제안을 보낼 수 있습니다. 참고: Upselling, Cross-selling and Next selling 교차 판매 cross sell 추천 한 제품을 구입한 고객이 다른 제품을 추가로 구입할 수 있도록 유도하는 것을 목적으로 합니다. 금융회사들이 자체 개발한 상품에만 의존하지 않고 다른 금융회사가 개발한 상품까지 파는 적극적인 판매방식입니다. ex) 햄버거만 시킬때, 점원이 ‘음료수는 안하시겠습니까? 일반적으로 함께 구입하는 제품들 고객별로 특화된 것이 아니다. 제품 대 제품 추천 이 제품을 구입한 고객은 일반적으로 어떤 다른 제품들을 구입했습니까? 라는 질문에 대한 답 동일한 제품을 검색하는 두 사람에게 동일한 추천을 적용한다. 이러한 유형의 일반적인 추천은당신의 웹사이트를 처음 방문한 사람들처럼,당신이 특정한 고객에 대해 별로 알지 못하고 있는 경우에 특히 적합하다 사용자에게 특화된 추천 제품 대 사용자 추천 비키니 세트를 탐색하는 동안 비키니 탑을 추천하는 것이 적절할 수 있다. 이 고객이 물건을 구입한 뒤, 2일 후에그에게 감사 이메일을 보내면서 다음 구매 항목에 대한 추천을 이메일로 보내는 경우라면? 이 고객이 가장 최근에 검색한 내용들뿐만 아니라 그와 과거 기록 전체를 고려하여 이 사용자만을 위해 특화된 추천을 하는 것이 좋다 ex_사쟘 사용자가 자신이 좋아하는 음악을 태그하면 그의 음악적 취향을 기록 취향에 근거해서 샤잠은 관심 있어 할 만한 콘서트들을 추천하는데그 콘서트가 실제로 당신이 살고 있는 지역 근방에서 열리는 경우에만 추천한다. 샤잠이 고객의 취향뿐만 아니라, 고객의 지리적 위치를 알아야 한다. 예측분석 프로세스 데이터의 수집, 클랜징, 정비 preparation 수집된 모든 데이터를 즉시 사용할 수 있는 것은 아니다. 누락된 데이터 또는 아웃라이어로 인해서 결과가 왜곡될 수 있고 (지나치게 높거나 낮은 데이터) 보유한 데이터 생성 시스템과 맞지 않는 데이터 유형이 있을 수도 있다. 이상치 검출 아웃라이어 일반 지속적 구매 소비자가 아닌 소수의 단기적 고액 소비자가 생길 경우 지표를 왜곡시킬 수 있음 상황을 인지하지 못한다면 vip 고객이라고 생각할 것이다. vip 고객 정의가 왜곡되어 진정한 vip 고객을 놓치게 됨 마케팅 전략의 방향을 읽게됨 아웃라이어를 제거해야함 결측값 대체 방법 평균값으로 대체 데이터가 가지고 있는 분포유형에서 무작위로 숫자를 선택 사용가능한 다른 변수를 기반으로 데이터 모델링 feature의 생성 및 추출 데이터가 그대로 사용하기에 너무 큰 경우 현재 방식으로 표현된 데이터가 모델에 적합하지 않은 경우 특징 추출은 불필요한 정보를 삭제하거나 노이즈 제거를 위해 변환한다. 최적의 추출은 데이터에 포함된 노이즈를 감소시킴으로써, 예측분석의 정확성을 높인다. 분류 변수 classifier 및 시스템 설계 올바른 알고리즘을 선택 올바른 문제에 올바른 알고리즘 선택하기 위해서는 문제를 잘 이해하는 것이 중요 편향 분산 딜래마 bias-variance 특정한 문제에 편향된 biased 시스템은 다른 문제들을 해결하기 위한 성능이 점점 더 떨어지게 된다는 것이다.참고 : 쉽게 이해해보는 bias-variance tradeoff 설계하고 미세조정하는 것 back-test를 통해 실제로 작동하는지 테스트 자체 개발시 필요 80%훈련 + 10% 테스트 + 10% 유효성 검사 빅데이터를 활용한 예측마케팅 전략 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 쉽게 이해해보는 bias-variance tradeoff Upselling, Cross-selling and Next selling","categories":[{"name":"04_AARRR","slug":"04-AARRR","permalink":"http://feel5ny.github.io/categories/04-AARRR/"},{"name":"00. Analyze","slug":"04-AARRR/00-Analyze","permalink":"http://feel5ny.github.io/categories/04-AARRR/00-Analyze/"}],"tags":[{"name":"maketing","slug":"maketing","permalink":"http://feel5ny.github.io/tags/maketing/"},{"name":"LTV","slug":"LTV","permalink":"http://feel5ny.github.io/tags/LTV/"}]},{"title":"예측 마케팅이란? (1장)","slug":"Communication_002","date":"2020-07-01T14:23:55.000Z","updated":"2024-11-23T12:36:10.954Z","comments":true,"path":"2020/07/01/Communication_002/","permalink":"http://feel5ny.github.io/2020/07/01/Communication_002/","excerpt":"","text":"TL;DR 예측마케팅은 예측분석을 사용하여서 고객접점마다 고객과 더 관련성 있고, 의미 있는 고객경험을 제공하고, 이를 통해 고객 충성도와 수익을 향상시킬 수 있다. 고객들도 개인화 접근방식을 원하며, 잘되는서비스들 또한 이를 증명해내고 있으며, 마케터들도 쉽게 다가갈 수 있는 좋은 솔루션들이 나오고 있다. 고객의 평생가치와 지갑점유율의 최적화에 초점을 맞추고, 고객관련성이 핵심지표가 된다. 고객 자산의 힘과 예측 마케팅 1. 예측 마케팅에 대하여 예측마케팅은예측분석을 사용하여,고객생애주기 전반에 걸쳐 모든 고객접점에서고객과 더 관련성 있고, 의미 있는 고객경험을 제공하고이를 통해 고객 충성도와 수익을 향상시킬 것이다. 1-1. 예측 마케팅의 증가요인 고객이 많은 채널들을 통해 마케팅 및 세일즈에 접하게 되면서, 고객들은 점점 더 개인적, 통합적 접근방식을 원하고 있다. 얼리어답터들은(잘되는 서비스들) 예측마케팅이 엄청난 가치를 가져다준다는 것을 보여주었다. 넷플릭스의 콘텐츠 추천 아미존의 장바구니 내의 추천 상품 새로운 기술 등장 2. 고객자산의 힘 customer equity 수익성을 높이기 위해 고객평상가치와 지갑점유율 share of wallet을 최적화하는데 중점을 둔다. 지갑점유율 (share of wallet)한 소비자의 전체 지출 중에서 특정 제품에 대한 지출이 차지하는 비중을 말한다. 더 타게팅된 고객 의사소통이 이루어지며,도달 범위가 아니라 고객관련성 relevance이 핵심 지표가 된다. 고객에게 제공하는 경험을 더 많이 개인화할수록고객은 브랜드 충성도를 유지하게 된다. 2-1. 예측 마케팅을 하면, 고객 타게팅 및 고객 획득 활동의 정밀도를 향상시킨다 가장 수익성 높은 고객을 창출하는 채널 파악하기 마케팅 지출 최적화 구매자 페르소나에 대한 더 나은 행동과학 정보로 무장한 마케터는특정한 마이크로 세그먼트를 초정밀 타깃으로 설정하고이들의 고객 전환율을 4배 이상 증가시키는더 효과적인 고객 획득 캠페인을 설계할 수 있다. 개인화된 경험을 활용하여 고객 평생가치를 높인다. 마케터는 고객상호작용의 개인화, 관련성, 타이밍을 개선할 수 있다. 고객으로 하여금 재방문하게 만들고고객평생가치를 극대화한다 고객 유지 및 충성도에 대해서 이해한다. 언제, 왜, 어떤 고객이 되돌아올지 아니면 이탈할지 예측하는 것은 많은 기업에게 커다란 미션 예측마케팅은 고객을 계속 붙잡아두기 위해선제적으로 조치를 취할 수 있도록 이탈 위험이 있는 고객을 찾아내어 리스트에 표시할 수 있다. 고객 인게이지먼트를 최적화한다. 이메일 프로모션에 누가 응답할 것인지 구경꾼 browser을 구매자로 전환하기 위해서 필요한 것이 무엇인지 거래를 완료하도록 고객을 유인하는 데 필요한 할인은 어느 정도인지를 예측하는 것 2-2. 예측 마케팅으로 답할 수 있는 질문들 (현재) 최우수고객 최우수 고객은 누구인가? (현재) 유사고객 기존의 최우수 고객과 유사한 신규고객은 누구인가? 데이터에서 페르소나를 찾아내어그것과 유사한 고객을 더 많이 획득한다. (현재) 채널 어떤 마케팅 채널이 가장 수익성이 높은가? (현재) 지갑점유율 특정고객에게 우리 회사의 지갑점유율은 얼마나 되는가? (예측) 구매 가능성 어떤 예상고객(비구매자)이 구매할 가능성이 가장 높은가? 어떤 기존(또는 과거) 고객이 구매할 가능성이 가장 높은가? 기존고객 중 구매할 가능성이 가장 낮은 것은 누구인가? (예측) 제품 관심도 어떤 고객이 특정한 신제품에 대해서 관심이 있을까? 이 고객이 관심을 가질만한 다른 제품이나 콘텐츠는 무엇일까? 3. 예측마케팅 도입이 가속화되는 이유💁‍♀️ 고객은 브랜드 업체와 더 의미 깊은 관계를 요구하고 있다 ⭐️ 🙋‍♀️ 소비자는 브랜드 업체들에게 일정한 형태의 개인맞춤형 설정을 기대한다. 아무래도 그동안의 피로도 때문에 예_전자상거래 사이트가, 자신들의 과거구매내역을 기억하고 있기를 기대한다. 가장 인기 있는 개인맞춤형 경험 ⭐️ 자신이 이전에 들여다 보았던 제품에 대한 할인 자신이 원하는 제품의 출시에 대한 알림 vip 고객 사은 행사를 제공하는 이메일 신규고객으로서 환영인사를 받기를 원한다. 밀레니엄세대(18세 ~ 34세) 개인맞춤화를 좋게 평가할 가능성이 더 높다. 예_생일을 기억하기를 기대한다. 📩 이메일의 개인맞춤화가웹페이지의 DA(display ads)의 개인맞춤화보다 훨씬 인기가 있다. 이메일 리타겟팅을 환영 웹기반 리타겟팅은 20%미만이 이를 환영 오늘날 고객들은 자신과 관련성이 더 많은 이메일을 적절한 시기에 받는다. 🤦‍♀️ 고객이 자신이 주목받기를 기대했지만,그것을 얻지 못하고 있다는 신호 수신거부가 많이 발생? 불만 CS가 비정상적으로 많이 발생? 반복 구매자가 적음? 생각 방향 틀어보기 많은 마케터들은 고객과 관련이 있는 경험을 제공한다고 스스로 생각하지만,소비자들의 인식은 종종 매우 다르다. 마케터들은 사고방식을 극적으로 바꿔야한다. 이메일 캠페인에서 클릭률이 4%가 되면 마케터는 기뻐할것이다. 반대로 96%가 그 이메일이 자신과 관련성이 없다고 판단했다는 것을 의미한다. 빅데이터를 활용한 예측마케팅 전략 책을 보고 이해한 내용을 정리 한 글입니다.","categories":[{"name":"04_AARRR","slug":"04-AARRR","permalink":"http://feel5ny.github.io/categories/04-AARRR/"},{"name":"00. Analyze","slug":"04-AARRR/00-Analyze","permalink":"http://feel5ny.github.io/categories/04-AARRR/00-Analyze/"}],"tags":[{"name":"maketing","slug":"maketing","permalink":"http://feel5ny.github.io/tags/maketing/"},{"name":"customer","slug":"customer","permalink":"http://feel5ny.github.io/tags/customer/"}]},{"title":"리팩토링2판) 1. 예시로 알아보기","slug":"Refactoring_002","date":"2020-04-04T11:12:34.000Z","updated":"2024-11-23T13:46:05.166Z","comments":true,"path":"2020/04/04/Refactoring_002/","permalink":"http://feel5ny.github.io/2020/04/04/Refactoring_002/","excerpt":"","text":"TL;DR⭐️⭐️⭐️ 리팩토링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다. 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다. 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다. 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다. 캠핑자들에게는 도착했을 때보다 깔끔하게 정돈하고 떠난다는 규칙이 있다. 프로그래밍도 마찬가지다. 항시 코드베이스를 작업 시작 전보다 건강하게(healthy) 만들어놓고 떠나야 한다. 좋은코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가다. (다형성을 활용해 계산 코드 재구성하기) 코드를 건강하게 관리하려면 프로그래밍 팀의 현재와 이상의 차이에 항상 신경 쓰면서, 이상에 가까워지도록 리팩토링해야한다. 예시로 접근해보기 다양한 연극을 외주로 받아서 공연하는 극단에서공연 요청이 들어오면,연극의 장르와 관객 규모를 기초로 비용을 책정하는데,이때 발생했던 공연료와 포인트를 확인하는 프로그램이다. 최초 코드 발견부분 청구내역을 HTML로 출력하는 기능이 필요. 예측 가능한 기획 변경 대응 비슷한 함수를 복사할 경우 중복되는 부분의 수정이 일관되게 반영되도록 보장해야한다. 리팩터링이 필요한 이유는 변경때문이다. 리팩토링하기 전에 제대로 된 테스트부터 마련한다.테스트는 반드시 자가진단하도록 만든다. 테스트코드들부터 마련해야한다. 리팩터링에서 테스트의 역할은 굉장히 중요하다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나,실제 작업은 사람이 수행하기 때문에 언제든지 실수할 수 있다. 리팩터링 시 테스트에 상당히 의지할 필요가 있다. 테스트를 작성하는 데 시간이 좀 걸리지만,신경 써서 만들어두면 디버깅시간이 줄어서 전체 작업시간은 오히려 단축된다. 리펙터링 후에는 반드시 테스트하는 습관을 가져야한다. 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면,먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서원하는 기능을 추가한다. 프로그램이 잘 작동하는 상황에서 그저 코드가 ‘지저분하다‘는 이유료 불평하는 것은프로그램의 구조를 너무 미적인 기준으로만 판단하는 건 아닐까 코드를 수정하려면 사람이 개입되고,사람은 미적 상태에 민감하다. 설계가 나쁜 시스템은 수정하기 어렵다. 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다. 수백줄짜리 코드를 수정할 때면,먼저 프로그램의 작동방식을 더 쉽게 파악할 수 있도록코드를 여러 함수와 프로그램 요소로 재구성한다. 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다. 함수 추출하기 변수명 변경 변수 인라인으로 변경 반복문 쪼개기 함수 추출 이후에는 명확하게 표현할 수 있는 간단한 방법을 찾아보자. 변수명 접두어로 타입을 표현한다. 매개변수의 타입이 뚜렷하지 않으면 부정관사를 붙인다. (a&#x2F;an) 캔트백 [Smalltalk Best Practice Patterns]를 참고했다고함 좋은 코드라면 하는 일이 명확히 드러나야하며, 변수 이름은 커다란 역할을 한다. 추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다. 다음번에 코드를 볼때 다시 분석하지 않아도코드 스스로가 자신이 하는 일이 무엇인지 이야기해줄 것이다. 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다.사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다. 임시변수를 질의함수로 바꾸기(7장): 긴 함수를 쪼갤때마다 변수를 최대한 제거한다. 지역변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경써야 할 대상이 줄어들기 때문이다. 변수 인라인하기(6장): 변수를 제거하고 바로 함수를 적용한다.&gt; 개인적으로 이건 잘 모르겠다.&gt; 함수 안에서 해당변수가 여러번 필요한 경우가 있는데 그때마다 호출하는거가 더 나은건지,&gt; 변수로 해서 레퍼런스만 호출하는게 좋은건지. 라고 했지만, 책 마지막에는“특별한 경우가 아니라면 성능이슈는 일단 무시하라는 것,리팩토링때문에 성능이 떨어진다면,리팩터링을 마무리하고 나서 성능을 개선하자” 함수명 바꾸기(6장) 이름짓기는 중요하면서도 쉽지 않은 작업이다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨일을 하는지 알 수 있다. 반복문 쪼개기(8장): 반복문안에서 여러 역할을 하는 것들을 반복분을 따로 만들어서 각각 수행하도록.. 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는데 주안점을 두고 리팩터링.&#x3D;&#x3D; 복잡하기 얽힌 덩어리를 잘게 쪼개는 작업 문장 슬라이드하기(8장): 문장 위치를 바꾸는것..? 캠핑자들에게는 도착했을 때보다 깔끔하게 정돈하고 떠난다는 규칙이 있다.프로그래밍도 마찬가지다.항시 코드베이스를 작업 시작 전보다 건강하게(healthy) 만들어놓고 떠나야 한다. 단계 쪼개기(6장): 1. 필요한 데이터를 처리하고 &#x3D;&gt; 2. 그 다음 단계 &#x3D;&gt; … 함수 옮기기(8장) 반복문을 파이프라인으로 바꾸기(8장) 간결함이 지혜의 정수일지 몰라도, 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다. 좋은코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가다.다형성을 활용해 계산 코드 재구성하기1234567891011121314151617181920function amountFor(aPerformance) &#123; let result = 0; switch (aPerformance.play.type) &#123; case &quot;tragedy&quot;: //비극 result = 40000; if (aPerformance.audience &gt; 30) result += 1000 * (aPerformance.audience - 30); break; case &quot;comedy&quot;: //희극 result = 30000; if (aPerformance.audience &gt; 20) result += 1000 + 500 * (aPerformance.audience - 20); result += 300 * aPerformance.audience; break; default: throw new Error(`알 수 없는 장르: $&#123;aPerformance.play.type&#125;`); &#125; return result; &#125; 위 코드는 타입이 추가될수록 복잡도가 올라간다. 다형성을 활용하는 것이 자연스럽다. 조건부 로직을 다형성으로 바꾸기(10장) class로 함수옮기기를 하는 것은 다른 컨텍스트로 옮기는 큰 작업 타입코드를 서브클래스로 바꾸기(12장) 생성자 팩터리 함수로 바꾸기(11장) 원본함수를 중첩 함수 여러개로 나눴다. 계산코드와 출력코드를 분리했다. (단계 쪼개기) 계산로직을 다형성으로 표현했다. 코드는 명확해야한다. 코드를 수정해야 할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고,오류 없이 빠르게 수정할 수 있어야 한다. 건강한 코드베이스는 생산성을 극대화하고,고객에게 필요한 기능을더 빠르고 저렴한 비용으로 제공하도록 해준다. 코드를 건강하게 관리하려면프로그래밍 팀의 현재와 이상의 차이에 항상 신경 쓰면서,이상에 가까워지도록 리팩토링해야한다.리팩토링을 효과적으로 하는 핵심은 단계를 잘게 나눠야 더 빠르게 처리할 수 있고 코드는 절대 깨지지 않으며 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"}],"tags":[{"name":"refactoring","slug":"refactoring","permalink":"http://feel5ny.github.io/tags/refactoring/"}]},{"title":"WebDAV와 공동작업","slug":"HTTP_019","date":"2020-02-02T15:10:10.000Z","updated":"2024-11-23T12:12:24.851Z","comments":true,"path":"2020/02/03/HTTP_019/","permalink":"http://feel5ny.github.io/2020/02/03/HTTP_019/","excerpt":"","text":"웹 분산 저작과 버저닝 Web Distributed Authoring and Versioning, WebDAV WebDAV는 웹 배포 공동 작업에 대한 또 다른 영역을 개척했다. 현재 공동작업으로 svn, git이 널리 쓰이고 있다 WebDAV은 공동 저작에 적합한 플랫폼을 제공하려고 HTTP를 확장하는 데 집중하였다. 1. WebDAV와 XML WebDAV의 메서드는 요청과 응답 관련 정보를 모두 잘 다루어야 한다. HTTP는 보통 이 정보를 메세지 헤더에 담아 전달한다. 헤더에만 정보를 담아 전송하는 것은 한계가 있다. WebDAV는 이를 해결하기 위해 XML을 지원한다. XML은 구조화된 데이터를 표현할 때 사용하는 포맷. 메타 마크업 언어다. 다음과 같은 용도로 사용한다. 데이터를 어떻게 처리할 것인지 설명하는 명령 포맷 서버의 복잡한 응답을 표현하는 데 사용하는 포맷 콜렉션과 리소스를 처리하는 데 사용하는 커스텀 정보 포맷 데이터 자체를 표현할 수 있는 유연한 포맷 대부분의 국제화 관련 문제에 대한 훌륭한 해결책 WebDAV는 DAV.라는 별도의 XML namespace를 정의한다. 요소나 속성 이름의 집합 이미 정의된 스키마는,구문 분석 소프트웨어가 DTD 파일을 읽고 그것들을 정확히 해석할 필요 없이,XML 스키마에서 데이터를 추정할 수 있게 한다. 2. WebDAV 헤더 DAV WebDAV를 제공하는 서버와 통신할 때 사용. WebDAV에서 지원하는 모든 리소스는 OPTIONS 요청에 대한 응답에 이 헤더를 포함해야 한다. Depth Destination : COPY나 MOVE 메서드가 목적지 URI를 식별하는데 쓰인다. If: 조건집합을 정의한다. 조건들에 모두 많지 않으면 요청은 실패. Lock-Token: UNLOCK 메서드에서 사용한다. Overwrite: 대상을 덮어쓸 것인지 아닌지 기술한다. Timeout 3. WebDAV 메서드3.1 WebDAV 잠금과 덮어쓰기 방지 공동 작업과 관련한 문제들 WebDAV는 이 문제를 개선하기 위해 잠금이라는 개념을 지원한다. 잠금이 완벽한 해결책은 아니다. 완벽한 해결을 위해서는버저닝와 메세징을 지원해야 한다. WebDAV는 2가지 형식의 잠금을 지원한다. 리소스나 콜렉션에 대한 배타적 쓰기 잠금 리소스나 콜렉션에 대한 공유된 쓰기 잠금 1. 리소스나 콜렉션에 대한 배타적 쓰기 잠금 잠금 소유자만 쓸 수 있게 보장한다. 이 잠금 형식은 잠재적인 충돌을 완벽히 제거한다. 공유된 쓰기 잠금은여러 사람으로 이루어져 있는 그룹이하나의 문서에 작업할 수 있게 한다. 이 잠금 형식은 모든 저자가 각각 서로의 활동을 인식하고 있는 상황에서는 잘 동작한다. WebDAV는 잠금과 관련한 메서드로 LOCK, UNLOCK을 제공한다. 잠금을 수행하려면, 저자를 식별하는 메커니즘이 필요한다. &#x3D;&gt; WebDAV는 다이제스트 인증을 요구한다. 잠금이 승인되면, 서버는 도메인 전체에서 유일한 토큰을 클라에 반환한다. : opaquelocktoken 잠금 토큰 URI 스킴 그 이후에 클라가 서버에 쓰기를 보내고자 할때, 서버에 연결하고 다이제스트 인증을 수행한다. 인증이 완료되면 WebDAV 클라는 PUT 요청을 통해 잠금 토큰을 보낸다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료RFC 4918","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"release","slug":"release","permalink":"http://feel5ny.github.io/tags/release/"}]},{"title":"웹 호스팅","slug":"HTTP_018","date":"2020-02-01T15:10:10.000Z","updated":"2024-11-23T12:12:24.918Z","comments":true,"path":"2020/02/02/HTTP_018/","permalink":"http://feel5ny.github.io/2020/02/02/HTTP_018/","excerpt":"","text":"콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라 한다. 필요한 하드웨어나 소프트웨어를 직접 관리하기 어렵다면,호스팅 서비스나 호스팅 업체가 필요할 것이다. 호스팅 업체는 서버와 웹 사이트 관리 프로그램을 대여해주고다양한 등급의 보안, 리포트, 사용 편의를 제공한다. 1. 호스팅 서비스 웹이 빠르게 대세가 되면서,모든 사람이 웹 사이트를 원했지만,냉난방 장치가 있는 서버실을 짓고, 도메인 이름을 등록하고, 네트워크 대역폭을 구매할 기술과 시간을 가진 사람은 드물었다. 그 시간을 절약하기 위해, 전문적으로 관리하는 웹 호스팅 서비스를 제공하는 여러 신사업이 만들어졌다. 물리적인 장비관리 ~ 고객이 직접 콘텐츠를 제공할 수 있는 총괄적인 웹 호스팅까지다양한 종류의 서비스들이 있다. 1.1 예: 전용 호스팅 참고 wiki GoDaddy의 전용호스팅 2. 가상 호스팅 많은 웹 호스팅 업자는 컴퓨터 한 대를여러 고객이 공유하게 해서저렴한 웹 호스팅 서비스를 제공한다. 이를 공유호스팅 혹은 가상호스팅 이라고 부른다. 각 웹사이트는 다른 서버에서 호스팅하는 것처럼 보이겠지만,사실은 물리적으로 같은 서버에서 호스팅되는 것이다. 최종 사용자의 관점에서 가상 호스팅에 있는 웹사이트는,물리적으로 분리된 전용 서버에서 호스팅 하는 사이트와 구분할 수 없어야 한다. 가상 호스팅은 비용, 공간, 관리에 이점이 있으므로,가상 호스팅을 제공하는 업체는 한 서버에 여러 개의 웹 사이트를 호스팅하려고 한다. 하지만 그것이 PC한대에 웹 사이트 여러 개를 구축한다는 뜻은 아니다. 호스팅 업자는 복제 서버 더미(서버 팜)를 만들고서버팜에 부하를 분산할 수 있다. 팜에 있는 각 서버는 다른 서버를 복제한 것이며,수많은 가상 웹사이트를 호스팅하고 있기 때문에 관리자는 훨씬 편해진다. 2.1 호스트 정보가 없는 가상 서버 요청 HTTP&#x2F;1.0 명세는 공용 웹 서버가 호스팅하고 있는 가상 웹사이트에누가 접근하고 있는지 식별하는 기능을 제공하지 않는다. HTTPs://feel5ny.github.io/index.html을 요청한다면, HTTP&#x2F;1.0 요청은 호스트명에 대한 별다른 언급 없이 “GET &#x2F;index.html”이라는 요청을 한다. 서버가 여러개의 사이트를 가상 호스팅하고 있으면, 사용자가 어떤 가상 웹 사이트로 접근하려고 하는것인지 아는 데 필요한 정보가 충분하지 않다. HTTP 대리 서버와 인터셉트 프락시 또한어떤 사이트를 요청하는지에 관한 정보가 필요하다. 2.2 가상 호스팅 동작하게 하기 VirtualHost HTTP 설계자들이 공유 서버인 가상 호스팅을 고려하지 않았다. 이를 해결하기 위해서, HTTP 요청 메세지에완전한 URL도 포함해서 보내게 해서 간단히 해결하였다. URL경로를 통한 가상 호스팅 서버가 어떤 사이트를 요청하는 것인지 알 수 있게URL에 특별한 경로 컴포넌트를 추가한다. “GET &#x2F;joy&#x2F;index.html” 조이 사이트에 대한 요청이다.“GET &#x2F;grey&#x2F;index.html” 그레이 사이트에 대한 요청이다. 거의 사용하지 않는다. 포트번호를 통한 가상 호스팅 각 사이트에 다른 포트번호를 할당,분리된 웹 서버의 인스턴스가 요청을 처리한다. IP 주소를 통한 가상 호스팅 각 가상 사이트에 별도의 IP 주소를 할당하고, 모든 IP 주소를 장비 하나에 연결한다. 웹 서버는 IP 주소로 사이트 이름을 식별한다. 각 가상 웹 사이트에 유일한 IP 주소를 한 개 이상 부여한다. 모든 가상 서버의 IP주소는 같은 공용 서버에 연결되어 있다. 예 HTTP://feel5ny.github.io은 210.89.164.90http://feel5ny.me는 210.89.164.91 이라고 가정해보자 클라A는 http://feel5ny.github.io/index.html을 요청한다. 클라A는 IP 주소를 요청해 210.89.164.90를 얻는다. 클라A는 210.89.164.90에 공용 웹서버에 TCP 커넥션을 맺는다. 클라A는 “GET &#x2F;index.html HTTP&#x2F;1.0” 요청을 보낸다. 실제 목적지 IP 주소를(210.89.164.90) 기록하고, 이것이 조이의 웹사이트에 대한 가상IP 주소라는 것을 판단하고 요청을 처리한다. 클라B도 유사하게 처리된다. 규모가 큰 호스팅 업자에게는 약간 어려운 문제점이 있다. 컴퓨터 시스템이 연결할 수 있는 장비의 IP 갯수는 제한되어있다. IP주소는 희소 상품이다. IP주소가 부족한 문제는 호스팅 업자가 용량을 늘리려고 서버를 복제하면서 더 심각해진다. 위의 문제점이 있지만 많이 사용되는 방식이다. 참고 IP 기반 가상호스팅 관련: 아파치 Host 헤더를 통한 가상 호스팅 HTTP&#x2F;1.1에 Host 요청 헤더를 정의했다. 웹 서버는 Host 헤더로 가상 사이트를 식별할 수 있다. 브라우저와 서버 개발자들은 서버가 원 호스트 명을 받아 볼 수 있게 HTTP를 확장했다. 모든 요청에 호스트 명(그리고 포트)를 Host 확장 헤더에 기술해서 전달한다. 2.3 HTTP&#x2F;1.1 Host 헤더 RFC 7230 문법과 사용방법 Host 헤더에 포트가 기술되어 있지 않으면, 해당 스킴의 기본 포트를 사용한다. URL에 IP주소가 있으면, Host 헤더는 같은 주소를 포함해야 한다. URL에 호스트 명이 기술되어 있으면, Host 헤더는 같은 호스트 명을 포함해야 한다. Host 헤더는 URL의 호스트명이 가리키는 IP 주소를 포함해서는 안된다. 여러개의 가상 사이트를 한개의 IP주소에 연결한 가상 호스트 서버에서 문제가 될 수 있기 때문 클라가 특정 프락시 서버를 사용한다면 Host헤더에는 origin 서버의 호스트명과 포트를 기술해야 한다. 웹 클라는 모든 요청 메세지에 Host헤더를 기술해야 한다. 웹 프락시는 요청을 전달하기 전에 요청 메세지에 Host 헤더를 추가해야 한다 HTTP&#x2F;1.1 웹 서버는Host 헤더 필드가 없는 HTTP&#x2F;1.1 요청 메세지를 받으면400 상태 코드로 응답해야 한다. Host 헤더 해석하기 호스트를 기준으로 리소스를 구분하는 모든 웹 서버는 HTTP&#x2F;1.1을 통해 오는 리소스를 결정하려면 다음과 같은 규칙을 사용해야 한다. HTTP 요청 메세지에 전체 URL이 기술되어 있으면Host 헤더에 있는 값은 무시하고URL을 사용한다. 전체 URL이 기술되어 있지 않고요청에 Host 헤더가 있으면, 호스트 명과 포트를 Host 헤더에서 가져온다. 전체 URL이나 Host 둘다 없을 경우클라에게 400 Bad Request 응답을 반환한다. Host헤더는 누가 자동 셋팅을? Host나 Connection같이, 셋팅하는 코드를 넣지 않았는데네트워크 탭에서 보면 종종 request 헤더에 포함되어있는 것을 보았다. 이는 브라우저 엔진 내부에서 자동으로 셋팅해준다. 예) chromium 자동 셋팅해주는 헤더는 어디서 확인 가능할까? 크롬 확장 api중 webRequest API에는 라이프사이클이 존재하는데 onBeforeSendHeaders라는 콜백으로 확인 가능하다. 참고 3. 안정적인 웹사이트 만들기웹 사이트에 장애가 생기는 몇가지 상황 서버다운 트래픽 폭증 네트워크 장애나 손실 3.1 미러링 된 서버 팜 서버팜은 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합이다. 서버팜의 서버에 있는 콘텐츠들은 한 곳에 문제가 생기면,다른 한 곳에서 대신 전달할 수 있게 미러링 할 수 있다. 미러링된 서버는 계층적인 관계에 있다. 한 서버는 (원본 콘텐츠를 가지고 있는) ‘콘텐츠의 원본 제작자’ 같이 행동한다. &#x3D;&gt; 마스터 원 서버라 부른다. Master Origin Server 마스터 원 서버로부터 콘텐츠를 받은 미러링된 서버는 &#x3D;&gt; 복제 원 서버라 부른다. Replica Origin Server 서버 팜에 배포하는 간단한 방법 하나는**네트워크 스위치**를 사용해서 서버에 분산 요청을 보내는 것이다. 서버에 호스팅 되고 있는각 웹사이트의 IP주소는스위치의 IP주소가 된다. 마스터 원 서버는 복제 원 서버에 콘텐츠를 보낼 책임이 있다. 외부에서 볼 때, 이 콘텐츠를 가리키는 IP주소는 스위치의 IP주소다.스위치는 서버에게 요청을 전송해야 하는 책임이 있다. 미러링된 웹 서버에는 다른 위치에 있는 콘텐츠와 정확히 같은 복제본이 있다. 위 그림의 시나리오에서는, 클라의 요청이 특정 서버로 가는 2가지 방법이 있다. HTTP 리다이렉션 : 콘텐츠에 대한 URL은 마스터 서버의 IP를 가리키고, 마스터 서버는 요청을 받는 즉시 복제 서버로 리다이렉트 시킨다. DNS 리다이렉션 : 콘텐츠의 URL은 4개의 IP주소를 가리킬 수 있고, DNS 서버는 클라에게 전송할 IP주소를 선택할 수 있다. 3.2 콘텐츠 분산 네트워크 CDN Contents Delivery Network 콘텐츠 분산 네트워크 CDN 은 특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크이다. 네트워크의 노드는 서버 대리 서버 프락시 서버 가 될 수 있다. 기본적으로 사용자가 원격지에 있는 서버(Origin Server)로 부터 Content(예. Web Object, Video, Music, Image, Document 등)를 다운로드 받을 때 가까이 있는 서버에서 받는 것보다 시간이 오래 걸리므로, 사용자와 가까운 곳에 위치한 Cache Server에 해당 Content를 저장(캐싱)하고 Content 요청시에 Cache Server가 응답을 주는 기술입니다.참고 3.3 CDN의 대리 캐시 ( &#x3D;&#x3D; 리버스 프락시 ) Gateway 캐시: 실제 요청을 담당하는 서버에서 관리되는 캐시 &#x3D;&#x3D; Reverse 프락시 : forward 프락시의 반대 방향 대리 서버는 복제 원 서버를 대신해 사용될 수 있다. 대리 서버는 미러링 된 웹 서버처럼, 콘텐츠에 대한 요청을 받는다. 그들은 특정 원 서버 집합을 대신해 요청을 받는다. 이는 콘텐츠에 대한 IP주소가 알려졌기 때문에 가능하다.보통 원 서버와 대리 서버가 연결되며, 대리 서버는 특정 원 서버를 가리키는 요청을 받는다. ?? 대리 서버와 미러링 된 서버의 차이점 대리 서버는 수요에 따라서 동작한다. 대리 서버는 원서버의 전체 콘텐츠를 복사하지 않는다. 클라이언트가 요청하는 콘텐츠만 저장할 뿐이다. 대리 서버의 캐시에 콘텐츠가 분산되는 방식은그들이 받는 요청에 따라 달라진다. 원 서버는 그들의 콘텐츠를 업데이트 해 줄 의무는 없다. 많은 요청이 있는 콘텐츠를 빠르게 제공하려고,사용자가 요청하기도 전에 콘텐츠를 가져오는 “미리 가져오기 기능“을 가진 대리 서버도 있다. 3.4 CDN의 프락시 캐시 네트워크 레이어 캐시: ISP, 방화벽에 설치됨. shared cache 전통적인 프락시 캐시는 어떤 웹 서버 요청이든지 다 받을 수 있다. 대리 서버를 사용하면,프락시 캐시의 콘텐츠는 요청이 있을 때만 저장될 것이고,원본 서버 콘텐츠를 정확히 복제한다는 보장이 없다. 어떤 프락시는 요청이 많이 받는 콘텐츠를 미리 로딩하기도 한다. 요청이 있을 때만 저장하는 프락시 캐시 레이어2 혹은 레이어3 장비(스위치 혹은 라우터)가 중간에 웹 트래픽을 가로채 처리하기도 한다. 가로채기 설정은, 클라와 서버 사이의 모든 HTTP 요청이 물리적으로 캐시를 거치게 네트워크 설정을 할 수 있는지에 따라 달라진다. 콘텐츠는 받는 요청에 따라서 캐시에 분산된다. 4. 웹 사이트 빠르게 만들기 서버 팜이나 분산 크락시 캐시, 대리 서버는 혼잡을 조절하고 네트워크 트래픽을 분산시킨다. 콘텐츠를 분산시키면,그 콘텐츠를 사용자에게 더 가깝게 만들어 주므로,콘텐츠를 서버에서 클라로의 전송하는 시간이 단축된다. 리소스의 로딩속도를 좌우하는 요소 리다이렉션 어떻게 요청과 응답이 클라와 서버 사이에서 연결을 맺고 인터넷을 가로질러 데이터를 전송하는 지. 인코딩 콘텐츠를 인코딩 하는 것. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 Reverse 프록시 관련 캐시 관련","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"hosting","slug":"hosting","permalink":"http://feel5ny.github.io/tags/hosting/"}]},{"title":"내용협상과 트랜스코딩","slug":"HTTP_017","date":"2020-01-20T00:10:10.000Z","updated":"2024-11-23T12:12:24.912Z","comments":true,"path":"2020/01/20/HTTP_017/","permalink":"http://feel5ny.github.io/2020/01/20/HTTP_017/","excerpt":"","text":"HTTP는 클라와 서버가 서로 내용을 협상할 수 있도록 방법을 제공한다. content-negotiation 하나의 url이 여러가지 리소스 중 적합한 것에 대응되도록 할 수 있다. 여기서는 서로 다른 버전을 varient라고 부른다. 서버는 특정 url에 대해 어떤 콘텐츠가 클라에게 보내주기 가장 적절한지에 대한 판단도 할 수 있어야 한다. 트랜스코딩은 http 클라와 서버 사이의 내용 협상에 대한 응답에서 수행된다. 내용 협상 기법 서버에 있는 페이지들 중어떤 것이 클라에게 맞는지 판단하는3가지 방법 클라에게 선택지를 주거나 &#x3D; 클라이언트 주도 협상 HOW: 클라가 요청을 보내면, 서버는 클라에게 선택지를 보내주고, 클라가 선택한다. 장점: 서버 입장에서 가장 구현하기 쉽다. 클라는 최선의 선택을 할 수 있다. 단점: 대기시간이 증가한다. 즉, 올바른 콘텐츠를 얻으려면 최소 두번의 요청이 필요하다. 서버가 자동으로 판단하는 방법 &#x3D; 서버 주도 협상 HOW: 서버가 클라의 요청 헤더를 검증해서 어떤 버전을 제공할지 결정한다. 장점: 클라 주도 협상보다 빠르다. HTTP는 서버가 가장 적절한 것을 선택할 수 있도록 q값 메커니즘을 제공하고,서버가 다운스트림 장치에게 요청이 어떻게 평가되는지 말해줄 수 있도록 하기 위해 Vary 헤더를 제공한다. 단점: 만약 결정이 뻔하지 않으면 (헤더에 맞는 것이 없으면), 서버는 추측을 해야만 한다. 중개자에게 선택하도록 부탁하는 방법 &#x3D; 투명한 협상 HOW: 투명한 중간장치(주로 프락시 캐시)가 서버를 대신하여 협상을 한다. 장점: 웹서버가 협상을 할 필요가 없다. 클라 주도 협상보다 빠르다. 단점: 투명 협상을 어떻게 하는지에 대한 정형화된 명세가 없다. 1. 클라 주도 협상 서버에게 있어 가장 쉬운 방법은 서버가 클라의 요청을 받았을 때,가능한 페이지의 목록을 응답으로 돌려주어클라가 보고 싶은 것을 선택하게 하는 것이다. 서버 입장에서 구현하기 쉽고,최선의 사본이 선택될 것이다. 단점 (기술측면) 각 페이지에 두 번의 요청이 필요하다는 것. 한번은 목록을 얻고 두번째는 선택한 사본을 얻는다. 선택지를 표현하는 2가지 방법 여러가지 버전에 대한 링크와 설명이 담긴 html 300 Multiple Choices 응답코드로 응답을 돌려주는 것. (상태코드 글 참고) (ux측면) 여러개의 url을 요구한다는 점 예)아래처럼 여러 url을 요구할 것이다.https://feel5ny.github.io /koreanhttps://feel5ny.github.io /english 어떤 링크를 메인 링크라고 생각할 것인가? (공유할때나, 북마킹할때 등등) 2. 서버 주도 협상 불필요한 커뮤니케이션 비용을 줄이는 방향으로서버가 어떤 페이지를 돌려줄 것인지 결정하게 하는 것. 클라는 반드시 자신이 무엇을 선호하는지에 대한 충분한 정보를 서버에게 주어서,서버가 현명한 결정을 할 수 있게 해 주어야 한다. HTTP 서버가 클라에게 보내줄 적절한 응답을 계산하기 위해 사용하는 메커니즘은 2가지 내용 협상 헤더들을 살펴본다. 서버는 클라의 Accept 관련 헤더들을 들여다보고, 그에 알맞은 응답 헤더를 준비한다. 내용 협상 헤더 외의 다른 헤더들을 살펴본다. 예_서버는 클라의 User-Agent 헤더에 기반하여 응답을 보내줄 수도 있다. 2.1 내용협상 헤더 Accept : 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다. Accept-Language : 서버가 어떤 언어로 보내도 되는지 알려준다. Accept-Charset : 서버가 어떤 차셋으로 보내도 되는지 알려준다. Accept-Encoding : 서버가 어떤 인코딩으로 보내도 되는지 알려준다. 내용 협상 헤더들은 클라와 서버가 선호 정보를 서로 교환하고, 문서들의 여러 버전 중 하나를 선택하는 것을 도와, 클라의 선호에 가장 잘 맞는 문서를 제공해 주기 위한 목적으로 사용된다. 만약에 클라중 하나가 일본어를 선호한다면한국어을 돌려줘야할까영어를 돌려줘야할까. 한국어를 좀 더 선호한다면,선호한다는 의사 정보를 추가하여 전달할 수 있으면 좋겠다고 생각할 것이다. HTTP는 풍부한 설명을 품질값을 이용해 전달할 수 있는 메커니즘을 제공한다. quality value, 줄여서 q값 2.2 내용 협상 헤더의 품질값 HTTP 프로토콜은 클라가 각 선호의 카테고리마다, 여러 선택 가능한 항목을선호도와 함께 나열할 수 있도록 품질값을 정의하였다.1Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0 q는 0.0부터 1.0까지의 값을 가질 수 있다. 위 상황은 네덜란드어(nl)로 된 문서를 받기 원하고 잇으나영어(en)로 된 문서라도 받아들일 것임을 의미한다. 때때로 서버는 클라의 선호에 대응하는 문서를 하나도 갖고있지 않을 수 도 있다.이 경우, 서버는 클라의 선호에 맞추기 위해문서를 고치거나 트랜스코딩 할 수 있다. 2.3 그 외의 헤더들에 의해 결정 서버는 또한 User-Agent와 같은 클라의 다른 요청 헤더들을 이용해 알맞은 요청을 만들어내려고 시도할 수 있다. 최선에 가장 가까운 대응을 찾아낼 수 있는 q값 매커니즘은 없다. 서버는 정확한 대응을 찾아내거나,그냥 갖고 있는 것을 제공해주어야 한다. 캐시는 반드시 캐시된 문서의 올바른 ‘최선의’ 버전을 제공해주려 해야 하기 때문에,HTTP 프르토콜은 서버가 응답에 넣어 보낼 수 있는 Vary 헤더를 정의한다. Vary 헤더는 캐시에게 서버가 내줄 응답의 최선의 버전을 결정하기 위해어떤 요청 헤더를 참고하고 있는지 말해준다. 3. 투명 협상 클라 입장에서 협상하는 중개자 프락시를 둠으로써,클라와의 메세지 교환을 최소화하는 동시에서버 주도 협상으로 인한 부하를 서버에서 제거한다. 투명한 내용 협상을 지원하기 위해, http에서 정의한 Vary 헤더를 사용한다. 서버는 어떤 요청 헤더를 검사해야 하는지 프락시에게 Vary 헤더를 통해 말해준다. 3.1 캐시와 얼터네이트 alternate 캐시는 클라의 요청을 서버로 그대로 전달하고, 응답을 저장한다. 두번째 요청시 응답은 캐시가 URL에 대응하는 문서를 찾아서 돌려줄 것인데,이때 다른 언어의 문서를 원한다면,캐시는 이번응답과 새로운 응답문서 2가지를 저장해야한다. 이 다른 버전은 베리언트나 얼터네이트라고 불리다.variant (:변형)alternate (:교대로) 3.2 Vary 헤더 HTTP Vary 응답 헤더는서버가 문서를 선택하거나, 커스텀 콘텐츠를 생성할 때 고려한클라 요청 헤더 모두를 나열한다. 새 요청이 도착했을 때, 캐시는 내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾는다. 캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary 헤더가 들어있는지 확인하고,Vary 헤더가 명시하고 있는 헤더들은새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야만 한다. 서버는 클라의 요청 헤더에 따라 그들의 응답이 달라질 수 있기 때문에투명 협상을 구현하기 위해 캐시는 반드시캐시된 variant와 함께클라 요청 헤더와그에 알맞은 서버 응답헤더 양쪽 모두를 저장해야한다. 1Vary: User-Agent, Cookie 서버의 Vary 헤더가 이렇다면, 거대한 수의 다른 User-Agent와 Cookie이 많은 배리언트 variant를 만들어낼 것이다. 캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 한다. 캐시가 검색을 할 때, 먼저 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고 다음에 요청의 배리언트를 캐시된 배리언트와 맞춰본다. 만약 맞는 것이 없으면, 캐시는 문서를 서버에서 가져온다. 맞는 것이 있다면, 해당 콘텐츠를 보내준다. 트랜스 코딩 서버가 클라의 요구에 맞는 문서를 아예 갖고 있지 않다면?이론적으로는 서버는 기존의 문서를 클라가 사용할 수 있는 무언가로 변환할 수도 있다.-&gt; 이 옵션을 트랜스코딩이라고 부른다. HTML 문서 👉 WML 문서 고해상도 이미지 👉 저해상도 이미지 64K색 이미지 👉 흑백 이미지 프레임을 포함한 복잡한 페이지 👉 프레임이나 이미지가 없는 단순한 텍스트 페이지 자바 애플릿이 있는 HTML 페이지 👉 자바 애플릿이 없는 페이지 광고가 있는 페이지 👉 광고가 없는 페이지 포맷 변환 포맷변환은 데이터를 클라가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것이다. 정보 합성 문서에서 정보의 요점을 추출하는 것을 정보 합성이라고 한다. information synthesis 각 절의 제목에 기반한 문서의 개요 생성이나,페이지에서 광고 및 로고 제거를 들 수 있다. 본문의 키워드에 기반하여 페이지를 분류하는더 복잡한 기술은 문서의 핵심을 요약할 때도 역시 유용하다. 이 기술을 포털사이트의 웹페이지 디렉터리와 같은자동화된 웹페이지 분류 시스템에 의해 종종 사용된다. 콘텐츠 주입 포맷 변환과 정보 합성은 문서의 양을 줄이지만주입 트랜스코딩은 오히려 양을 늘린다. 내용 주입 트랜스 코딩의 예로 자동 광고 생성과 사용자 추적 시스템이 있다. 동적으로 문서에 추가된다. 트랜스 코딩 vs 정적으로 미리 생성해놓기 트랜스 코딩의 대안은 웹서버에서 웹페이지의 여러가지 사본을 만드는 것이다. 예_고해상도는 저해상도 이미지를 만든다. 여러가지 이유로 그다지 현식적인 기법이 못된다. 페이지에 대한 어떠한 작은 변화도 여러 페이지의 수정을 요구하게 되고 각 페이지의 모든 버전을 저장하기 위해 더 많은 공간이 필요하게 되며 페이지들을 관리하고, 그것들 중 올바른 것을 골라서 제공해주는 웹서버를 프로그래밍하기 어려워진다. 변환은 더 싼 프락시나 캐시에 있는 외부 에이전트에 의해 수행될 수 있다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 http 콘텐츠 협상","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"vary","slug":"vary","permalink":"http://feel5ny.github.io/tags/vary/"},{"name":"Accept header","slug":"Accept-header","permalink":"http://feel5ny.github.io/tags/Accept-header/"},{"name":"variant","slug":"variant","permalink":"http://feel5ny.github.io/tags/variant/"},{"name":"transcoding","slug":"transcoding","permalink":"http://feel5ny.github.io/tags/transcoding/"}]},{"title":"국제화","slug":"HTTP_016","date":"2020-01-13T00:10:10.000Z","updated":"2024-11-23T12:12:24.913Z","comments":true,"path":"2020/01/13/HTTP_016/","permalink":"http://feel5ny.github.io/2020/01/13/HTTP_016/","excerpt":"","text":"국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원 HTTP에서 엔터티 본문이란 그저 비트들로 가득 찬 상자에 불과하다. 서버는 클라에게 문서의 문자와 언어를Content-Type charset 매개변수와Content-Language 헤더를 통해 알려준다. 클라는 서버에게사용자가 어떤 언어를 이해할 수 있고,어떤 알파벳의 코딩 알고리즘이 브라우저에 설치되어 있는지 말해줄 필요가 있다.**Accept-Charset**과Accept-Language 헤더를 보낸다12Accept-Language: fr, en;q=0.8Accept-Charset: iso-8859-1, utf-8 모국어를 선호하지만, 피치 못할 경우 영어도 사용하는 프랑스어 사용자가 보낸 케이스 iso-8859-1 &#x3D;&gt; 서유럽 차셋 인코딩과utf-8 유니코드 차셋 인코딩을지원할 것이다. q는 품질 인자로 프랑스어보다 영어에 낮은순위를 주었다. (기본은 1.0) 1. 문자 집합과 HTTP1.1 Charset은 글자를 비트로 변환하는 인코딩이다. HTTP Charset 태그는비트들을 글자로 변환하거나 (디코딩)글자를 비트들로 변환하는 (인코딩)알고리즘을 명명한다. IANA 문자집합 몇몇 문자 인코딩 (utf-8이나 iso-2022-jp)은 글자당 비트 수가 일정하지 않아, 더 복잡한 가변길이 코드다. 이런 종류의 코딩은 중국어나 일본어와 같이,많은 글자로 이루어진 문자체계를 지원하기 위해 추가적인 비트를 사용할 수 있게 해준다. 아랍어는 28개의 문자만을 갖는다.8비트 256개의 유일한 값을 제공하므로, 라틴어, 아랍어, 그 밖의 유용한 기호들을 위한 충분한 공간이 된다. 1.2 문자집합과 인코딩은 어떻게 동작하는가 비트들을 문자로 변환하는 디코딩 알고리즘을 지칭하고 적용하는표준화된 방법이 필요하다. 비트 &#x3D;&gt; 문자로 변환 (의미 해석) - 02. HTTP 문자 &#x3D;&gt; 모양으로 표현 (시각적 표현) - 브라우저, 운영체제, 글꼴이 결정 1.3 잘못된 Charset은 잘못된 글자들을 낳는다.브라우저가 본문으로부터 225 (11100001)을 가져온 경우 iso-8859-1 (서유럽 문자 코드) 인코딩 양음 악센트가 붙은 소문자 a &#x3D; á iso-8859-6 (아랍 코드) : FEH &#x3D; ف iso-8859-7 (그리스어) : 알파 &#x3D; α iso-8859-8 (히브리어) : BET &#x3D; ב 1.4 표준화된 MIME Charset 값 특정 문자 인코딩과특정 코딩된 문자집합의 결합을 MIME 차셋이라고 부른다. HTTP는 표준화된 MIME 차셋 태그를Content-Type과 Accept-Charset 헤더에 사용한다. MIME 차셋 인코딩 태그 us-ascii : ascii로도 불리지만, 여러가지 국제 변형때문에 us라는 접두어를 붙이는 것을 선호한다. iso-8856-1(Latin1) : 서유럽 언어를 지원하기 위한 ascii를 확장 iso-8856-2 : (체코어, 폴란드어, 루마니아어와 같은) 중부유럽 혹은 동부유럽 언어에서 사용되는 문자들을 포함시키기 위해 ascii를 확장 iso-8856-5 : (러시아어, 세르비아어, 불가리아어 등에 사용되는) 키릴 문자를 포함하기 위해 ascii를 확장 iso-8856-6 : 아랍 문자들을 포함하기 위해 ascii를 확장 iso-8856-7 : 현대 그리스 문자를 포함하기 위해 ascii를 확장 iso-8856-8 : 히브리어와 이디시어 문자를 위해 ascii를 확장 iso-8856-15(Latin0) : 몇몇 구두점, 분수 기호들을 고대 프랑스어와 핀란드어 글자들로 대체하고, 국제 통화 기호를 새로운 유로 통화 기호로 대체하기 위해 iso-8859-1을 갱신한 것이다. iso-2202-jp : 일본어 전자우편과 웹 콘텐츠를 위해 널리 사용되는 인코딩 euc-jp : 여러 종류의 모드나 이스케이프 문자열 없이 각 글자를 식별하기 위해 명시적 비트 패턴을 사용하는 iso 2022 호환 가변길이 인코딩이다. Shift-JIS : 마소에 의해 개발. 역사적인 호환성문제때문에 복잡, 모든 문자에 대응하지도 못하지만 여전히 흔하게 쓰이고 있다. koi8-r : 러시아어를 위한 인기있는 8비트 인터넷 문자집합 인코딩 이다. utf-8 : 전 세계의 문자들에 대한 보편적인 문자집합인 UCS를 표현하기 위한 흔히 쓰이는 가변길이 문자 인코딩 구조다. windows-1252 : 마소는 자신의 코딩됭 문자집합을 코드 페이지라고 부른다. 윈도우 코드페이지 1252는 iso-8859-1의 확장이다 euc-kr과 utf-8 참고euc-kr 방식은 원래 영어만을 고려한 1byte 길이의 ASCII 라는 인코딩 방식을 확장하여 한글을 사용할 수 있도록 만든 2byte 길이의 국가 언어 코드입니다.국가 언어코드. 즉 우리나라에서만 쓸 수 있도록 만든 코드이며 세계 어디에서나 공통으로 사용되는 인코딩 방식이 아니기 때문에, 다른 언어를 사용하는 환경(외국 등)에서는 한글 페이지를 제대로 볼 수 없는 문제가 발생합니다.이를 해결하기 위해 새로운 인코딩 방식이 개발되었는데, 그중 가장 보편화된 인코딩이 UTF-8입니다. (3byte)예전에는 용량이 작은 euc-kr 방식을 선호하는 곳들도 많았으나, 현재는 용량 문제보다 표준화 및 글로벌 환경을 고려해야 하므로 UTF-8 인코딩 방식을 강력하게 권고하는 바입니다. 1.5 Content-Type charset 헤더와 메타태그 웹 서버는 클라에게 MIME charset 태그를 charset 매개변수와 함께 Content-Type 헤더에 담아 보낸다. 1Content-Type: text/html; charset=utf-8 만약 나열되지 않았다면, 수신자는 문서의 콘텐츠로부터 문자집합을 추측하려고 시도한다. 받은 HTML 파일에서 meto태그중 HTTP-EQUIV라는 속성을 갖고 있는 태그를 찾는다.1234&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; 만약 문서가 html이 아니라면, 혹은meta Content-Type 태그가 없다면,소프트웨어는 언어와 인코딩에 대한 일반적인 패턴을 찾기 위해 실제 텍스트를 스케닝하여 문자 인코딩을 추측한다. 클라가 문자 인코딩을 추측하지 못했다면 iso-8859-1인것으로 가정한다. 1.6 Accept-Charset 헤더 대부분의 클라는 모든 종류의 문자 코딩과 매핑 시스템을 지원하지는 않는다. HTTP 클라는 서버에게 정확히 어떤 문자 체계를 그들이 지원하는지 Accep-Charset 요청 헤더를 통해 알려준다. Accept-Charset 헤더의 값은 클라가 지원하는 문자 인코딩 목록을 제공해준다. 이 문자 인코딩 구조 중 어떤 것으로 콘텐츠를 반환할지는 서버의 자유다. 1Accept-Charset: iso-8859-1, utf-8 2. 다중언어 문자 인코딩에 대한 지침문자집합 용어 문자 : 글쓰기의 최소단위. 글리프 glyph 하나의 글자를 표현하기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태 글자를 여러 방식으로 쓰는 것이 가능하다면, 글리프를 여러 개 가질 수도 있다. 코딩된 문자 coded character 각 글자에 할당된 유일한 숫자 국제 문자 셋트 코드 공간 coding space 각 문자 코드의 비트 개수 ex) UTF-8 인코딩은 유니코드 한 문자를 나타내기 위해 1바이트에서 4바이트까지를 사용한다. 사용 가능 문자집합 character repertoire 글자들에 대한 특정한 작업 집합 코딩된 문자집합 coded character set 사용 가능 문자집합을 받아서, 각 글자에 코드 공간의 코드를 할당해주는 코딩된 문자들의 집합. 실제 글자들에 숫자로 된 문자코드를 대응시킨 것 문자 인코딩 구조 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘. 자세히 알아보기 문자 하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자(중국어에서와 같은), 수학기호, 그 외에 다른 쓰기의 기본 단위 문자는 글꼴이나 스타일에 독립적이다. 같은 글자라도 그 글자가 단어에서 어디에 위치하느냐에 따라 각각 다른 모양을 갖는 표기 체계도 많다. 글리프(glyphs), 연자(ligatures), 표현형태 글리프는 각 글자를 그리는 특정한 방법니다. 글꼴이나 사소한 미적 양식에 의존하지 않는, 글자에 내재된 모양새이다. 연자 ligatures FI 연자 &#x2F; LA연자 코딩된 문자집합 Coded Character Set 코딩된 문자집합은 정수를 글자로 대응시킨다. 코딩된 문자집합은 보통 코드번호로 인덱싱된 배열로 구현된다. 그 배열의 원소들은 문자들이다. US-ASCII (모든 문자집합의 어머니)- 1968년 ANSI 표준 X3.4 ‘정보교환을 위한 미국 표준 코드’로 표준화된 가장 유명한 코딩된 문자집합이다.- 아스키는 오직 코드 값 0~127만 사용한다.- 코드 공간을 전체 표현하는데 7비트만 필요하다.- 다른 국제 변종과 구분하기 위해 ‘US-ASCII‘를 더 선호한다. iso-8859- US-ASCII 의 8비트 확대 집합들이다. 국제적인 글쓰기를 위해 필요한 글자들을 하이비트를 이용하여 추가 추가비트에 의해 제공되는 추가공간은 모든 유럽 글자를 담기에는 충분히 크지 않으므로, iso-8859는 지역에 따라 커스터마이징된 문자집합을 제공한다. iso-8859-1 : 서유럽어 (영어, 프랑스어) (&#x3D; Latin1) - HTML을 위한 기본 문자집합 iso-8859-2 : 중앙 및 동유럽어 (체코어, 폴란드어) iso-8859-3 : 남유럽어 iso-8859-4 : 북유럽어 iso-8859-5 : 키릴 (불가리아어, 러시아어, 세르비아어) iso-8859-6 : 아랍어 iso-8859-7 : 그리스어 iso-8859-8 : 히브리어 iso-8859-9 : 터키어 iso-8859-10 : 노르딕어 (아이슬랜드어, 이뉴잇어) iso-8859-15 : 새로운 유로 통화 문자를 포함하기 위한 iso-8859-1의 변형 JIS X 0201- 일본어 가타카나 반각문자를 더해, 확장한 극단적으로 작은 문자집합- &#x3D; JIS ROMAN 으로 불린다. (JIS &#x3D; Japanese Industrial Standard &#x3D; 일본 산업 표준) JIS X 0208과 JIS X 0212- 일본어는 여러 문자 체계로부터 온 수천개의 글자를 담고 있다.- JIS X 0201의 63개 표음 가타카나 문자보다 완전한 문자집합이 필요하다.- JIS X 0208은 최초의 멀티바이트 일본어 문자집합이다. &#x3D; 일본식 한자인 6879개의 코딩문자를 정의했다.- JIS X 0212 문자집합은 6607개의 문자를 추가했다. UCS- 국제 문자 셋트 Univeral Character Set 은 전 세계의 모든 글자를 하나의 코딩된 문자집합으로 통합하려 노력하는 세계적인 표준이다.- UCS는 ISO 10646으로 정의된다.- 유니코드는 UCS 표준을 따르는 상업적인 컨소시업이다.- UCS는 기본 집합은 단 50,000 글자만으로 이루어져 있음에도 불구하고, 수백만개의 글자를 위한 코드공간을 갖고 있다. 문자 인코딩 구조 숫자로 된 문자 코드를 콘텐츠 비트들로 변환 다른 쪽에서는 그들을 다시 문자코드로 환원한다. 문자 인코딩 구조는 3종류로 분류할 수 있다. (고정폭&#x2F;가변폭(비모달)&#x2F;가변폭(모달)) 고정폭- 각 코딩된 문자를 고정된 길이의 비트로 표현한다.- 빠르게 처리될 수 있지만 공간을 낭비할 우려가 있다. 가변폭 (비모달)- 다른 문자 코드 번호에 다른 길이의 비트를 사용한다.- 자주 사용하는 글자의 비트 길이를 줄일 수 있고, 국제 문자에 대해서는 여러 바이트를 사용하도록 함으로써 이전의 8비트 문자집합과의 호환성도 유지할 수 있다. 가변폭 (모달)- 다른 모드로의 전환을 위해 특별한 escape 패턴을 사용한다.- 예를 들어 어떤 모달 인코딩은 텍스트에서 중첩된 여러가지 문자집합 간의 전환을 위해 사용될 수 있다.- 모달 인코딩은 처리하기 복잡하지만, 복잡한 표기 체계를 효과적으로 지원해 줄 수 있다. [고정폭] 8비트- 간단히 각 문자 코드를 그에 대응하는 8비트 값으로 인코딩한다.- 256개 문자의 코드 범위에 대한 문자집합만을 지원한다.- iso-8859 문자집합군은 8비트 아이덴티티 인코딩을 사용한다. [가변폭(비모달)] UTF-8- 인기있는 UCS를 위해 설계된 문자 인코딩 구조다. (UTF &#x3D; UCS Transformation Format)- 첫 바이트의 서두 비트들은 인코딩된 문자의 길이를 바이트 단위로 나타내고, 그 이후의 바이트들은 각 6비트 코드값을 담는다. (0ccccccc, 110ccccc,…)- 문자 코드 90(아스키 ‘Z’)는 1바이트로 인코딩 되었을 것이며(01011010), 코드 5073(13비트 이진값 100111101001)은 3바이트로 인코딩되었을 것이다. [가변폭(모달)]iso-2022-jp- 일본어 인터넷 문서를 위해 널리 사용되는 인코딩이다.- 128보다 작은 값으로만 이루어진 가변길이 모달 인코딩이다.- 인코딩 콘텍스트는 4가지 미리 정의된 문자집합 중 하나로 설정된다. 특별한 이스케이프 문자열(ESC ( B, ESC ( J, ESC $ @, ESC $ B)은 한 집합에서 다른 집합으로 전환시켜준다. (모달) [가변폭(비모달)]euc-jp- 일본어 인코딩- EUC는 Extended Unix Code의 약자- 유닉스 운영체제에서 아시아 문자들을 지원하기 위해 처음 개발되었다.- 모드간의 전환을 위한 이스케이프 문자열이 없다.- euc-jp는 4가지 코딩된 문자집합을 지원한다. (JIS X 0201, JIS X 0208, 반각 가타카나, JIS X 0212) [가변폭(비모달)]euc-kr- 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩- 2가지 문자집합을 지원한다. (KS X 1003, KS X 1001)- KS X 1001은 총 2350자만 담고 있었고 표현하기에는 부족 이를 보완하기 위해 한글 채움문자를 이용해 한글을 표현하는 방식을 규정하고 있다. Charset은 문자집합이 아닌 매핑 알고리즘의 이름이다. MIME charset 태그는 문자집합을 의미하는 것이 아니다. MIME charset 값은 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름이다.&#x3D; 문자 인코딩 구조 + 코딩된 문자집합 언어태그와 HTTP 영어 en &#x2F; 독일어 de &#x2F; 한국어 ko많은 다른 언어에 대한 언어 태그가 존재한다. 브라질 포르투갈어 pt-BR &#x2F; 미국 영어 en-US &#x2F; 허난 중국어 zh-ziang지역에 따라 변형된 언어나 방언을 표현할 수 있다. Content-Language 헤더 Content-Language 엔터티 헤더 필드는 엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술한다. Accept-Lanugage 헤더 HTTP는 우리에게 우리의 언어 제약과 선호도를 웹 서버에 전달할 수 있게 해준다. Accept-Lanugage와 Accept-Charset을 사용할 수 있다. 언어 태그의 종류 ([RFC 3066] 기준) 언어태그는 다음을 표현하기 위해 사용될 수 있다. 일반적인 언어의 종류 ex_es (스페인어) 특정 국가의 언어 ex_en-GB (영국 영어) 방언 ex_no-bok (노르웨이어의 Book Language를 의미) 지방어 ex_sgn-US-MA (마서스 비니어드 섬의 수화) 그외의 다른 언어의 변형이 아닌 표준언어 (ex_i-navajo) 비표준 언어 ex_x-snowboarder-slang (스노우보드 타는 사람..) 서브태그 언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이루어져 있다. ex_sgn-US-MA 주 서브태그 : 표준화되어 있다. - 알파벳만 두번째 서브태그: 자신만의 이름 표준을 따름 (선택적) - 알파벳 + 숫자가능 (최대 8글자) 서브태그는 등록되어 있지 않다. 첫번째 서브태그 : 이름공간- ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰- 첫번째 서브태그가 두 글자라면, ISO 639와 639-1 표준의 언어코드다. 세 글자라면, ISO 639-2표준과 확장에 열거된 언어코드다. 글자가 i라면, IANA에 등록된 것 글자가 x라면, 특정 개인이나 집단 전용의 비표준 확장 서브태그다.- 한국어 : ko(ISO 639) &#x2F; kor(ISO 639-2)- 영어 : en(ISO 639) &#x2F; eng(ISO 639-2) 두번째 서비태그: 이름공간- ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가토큰이다. IANA에 등록된 다른 문자열일 수도 있다. 두번째 서브태그는 두글자라면 ISO 3166에 정의된 국가&#x2F;지역이다. 3~8 글자라면, IANA에 등록된 것이다. 한글자라면, 문가 잘못된 것.. 일본: JP 인도: IN 나머지 서브태그: 이름공간- 8자 이하의 알파벳과 숫자로 이루어져야 한다는 것을 제외하면 다른 규칙은 없다. 국제화된 URI 오늘날 URI는 US-ASCII의 부분집합으로 구성되어 있다. 국제적 가독성 vs 의미있는 문자들 URI에 들어가고 조작하고, 공유하기 쉽게 하기 위하여설계자들은 매우 제한된 공통 문자집합을 선택했다. 기본적인 라틴 알파벳 문자, 숫자, 특수문자 단점 URI는 비영어권 사람들도 쉽게 사용하고, 기억할 수 있도록 설계되지는 못했다. 전 세계 사람들이 라틴 알파벳을 인식조차 하지 못하기 때문에 URI를 추상화 패턴으로 기억하는 것은 거의 불가능 URI 저자들은 리소스 식별자의 가독성과공유 가능성의 보장이대부분의 의미 있는 문자들로 구성될 수 있도록 하는 것이 더 중요하다고 여겼다. 그래서 아스키 문자들의 제한된 집합으로 이루어진 URI를 갖게 되었다. URI에서 사용될 수 있는 문자들 URI에서 사용할 수 있는 US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, 이스케이프 문자들로 나뉜다. 예약되지 않은 문자들은 일반적으로 사용될 수 있다. 예약된 문자들은 URI에서 특별한 의미를 가지며, 일반적으로는 사용될 수 없다. 예약되지 않은 문자: [A-Za-z0-9] - _ . ! ~ * &#39; ( ) 예약된 문자: ; / ? : @ &amp; = + $ , 이스케이프: % &lt;HEX&gt; &lt;HEX&gt; 이스케이핑과 역이스케이핑 URI 이스케이프는 예약된 문자나 다른 지원하지 않은 글자들(space)을 안전하게 URI에 삽일할 수 있는 방법을 제공한다. 이스케이프 : 퍼센트 글자 하나와, 뒤이은 16진수 글자 둘로 이루어진 3글자 문자열이다. 스페이스 (아스키 32): %20 (20은 32의 16진법 표현이다.) %(아스키 25): %25 URI를 해석할 때, 이스케이핑된 코드 바이트들을 (encodeURIComponent 메서드를 사용하면 URI 인코딩을 진행할 수 있다.) 원래 ASCII 코드 바이트로 변한하여 해석한다. 두번 인코딩 되지 않도록 주의한다. 국제 문자들을 이스케이핑하기 이스케이프 값들은 US-ASCII 코드의 범위(0~127)에 있어야한다. 어떤 어플리케이션은 iso-8859-1 확장 문자들(128~255)을 표현하기 위해 이스케이프 값을 사용하려 한다. 그러나 오늘날에는 아스키 범위 밖의 문자를 인코딩하는 일은 상당히 흔하다. URI에서의 모달 전환 몇몇 URI는 다른 문자집합의 글자를 표현하기 위해 아스키 문자열을 사용한다. 예를 들어 iso-2022-jp 인코딩은 JIS-Roman으로 변경하기 위해 ESC ( J를 삽입할 수 있으며 ESC ( B로 다시 아스키로 돌아올 수 있다. 현재 URI는 그다지 국제화에 친화적이지 않다. 당분간 HTTP 어플리케이션은 아스키와 함께 써야한다. 기타 고려사항 헤더와 명세에 맞지 않는 데이터 HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 한다. 많은 HTTP 어플리케이션은 글자들을 처리하기 위해운영체제와 라이브러리 루틴을 사용한다. 이 모든 라이브러리가 아스키 범위(0~127)를 벗어난 글자를 지원하지 않는다. 날짜 HTTP명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있지만, 모든 웹 서버와 클라가 규칙을 따르고 있지 않음을 주의하라. 도메인 이름 국제화 문자를 포함하는 도메인 이름을 &#x3D; 국제화 도메인 이름 Internationalizing Domain Name 오늘날 대부분의 웹브라우저가 퓨니코드를 이용해 이를 지원한다. punycode 퓨지코드란 유니코드 문자열을 호스트 명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법 (RFC 3492) 웹브라우저들은 이 기법을 이용해, 사용자가 입력한 다국어로 된 도메인 이름을알파벳과 숫자 등으로 된 도메인 이름으로 변환한다.( 한글.com &#x3D;&gt; xn--bj0bj06e.com ) HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 IANA 문자집합","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"internationalization","slug":"internationalization","permalink":"http://feel5ny.github.io/tags/internationalization/"}]},{"title":"인스턴스 조작과 인코딩","slug":"HTTP_015_02","date":"2020-01-05T15:10:10.000Z","updated":"2024-11-23T12:12:24.908Z","comments":true,"path":"2020/01/06/HTTP_015_02/","permalink":"http://feel5ny.github.io/2020/01/06/HTTP_015_02/","excerpt":"","text":"웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다. 같은 리소스를 여러번 요청했지만, 시간이 흐름에 따라 리소스의 다른 인스턴스를 받게 된다. 클라가 자신이 갖고 있는 리소스의 사본이서버가 갖고 있는 것과 정확히 같은지 판단하고,상황에 따라서는 새 인스턴스를 요청할 수 있는 능력을 가질 것을 요구한다. 인스턴스 조작에 대표적으로 범위 요청과 델타 인코딩이 있다. 1. 검사기와 신선도 조건부 요청은 클라가 서버에게 자신이 갖고있는 버전을 말해주고, 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것이다. 1.1 신선도 서버는 클라에게 얼마나 오랫동안 콘텐츠를 캐시하고,그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다. Expires나 Cache-Control 헤더를 통해 정보를제공할 수 있다. Expires 문서가 만료되서 더 이상 신선하다고 간주할 수 없게 되는 정확한 날짜를 명시함 서버와 클라가 시계를 동기화시켜야하는데, 쉽지 않고 때무에 상대시간을 이용하는것을 더 선호한다. Cache-Control 문서의 최대 수명을문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다. 7장 복습 1.2 조건부 요청과 검사기 더이상 신선하지 않다면, 자신이 갖고 있는 사본을 신선한 것으로 만들어야함 항상 다시 갖고 온다면 불필요한 리소스 낭비가 있을 것. 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청을한다. HTTP 요청 메세지이지만, 특정 조건이 참일 때만 수행된다. 예) If-Modified-Since: 날짜 각 조건 헤더마다 검사기 조건이 다르다. If-Modified-Since : Last-Modified - 변한게 있으면 보내달라 If-Unmodified-Since : Last-Modified - 변한게 없으면 보내달라 If-Match : ETag - 같으면 보내달라 If-None-Match : ETag - 다르면 보내달라 HTTP는 강한검사기, 약한 검사기 2개로 구분한다. 약한 검사기 인스턴스를 고유하게 식별하지 못하는 경우도 있다. 바이트의 개수를 세는 방식으로 동작하는 가상의 횟수 검사기 Last-Modified: 최소단위가 1초라서 약한 검사기 (서버는 1초에 수천번이 요청을 처리하기 때문) 강한 검사기 언제나 고유하게 식별한다. 콘텐츠에 대한 암호 체크섬 ETag는 강한 검사기 W/를 붙임으로써 약한 엔터티 태그임을 알릴 수도 있다. 재검사로 인한 대량 전송을 유발하지 않으면서, 겉모양새만 약간 고치고 싶을 수도 있을 경우 2. 범위 요청 클라가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다. 범위요청을 이용하면, HTTP 클라는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써, 다운로드를 중단된 시점에서 재개할 수 있다. 1Range: bytes=4000- 모든 서버가 범위 요청을 맏아들일 수 있는 것은 아니지만, 많은 경우 가능하다. Accept-Range헤더를 포함시키는 방법으로 알려줄 수 있다. 1Accept-Ranges: bytes 3. 델타 인코딩 (델타: 변경된 부분) 객체 전체가 아닌, 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜 확장이다. 클라는 페이지의 어떤 버전을 갖고 있는지 서버에게 말해준다. (ETag) 클라는 자신이 갖고 있는 현재 버전에 델타를 적용하기 위해, (A-IM: Accept-Instance-Manipulation) 어떤 알고리즘을 알고 있는지도 서버에게 말해주어야 한다. 서버는 자신이 클라가 갖고 있는 버전을 갖고 있는지 어떻게 최신 버전과 클라의 버전 사이의 델타를 계산할 것인지 체크해야 한다. 델타를 계산해서 클라에게 보내주고 (ETag) 서버가 델타를 보내고 있음을 클라에게 알려주고 (IM) (226 IM Used) 페이지의 최신 버전에 대한 새 식별자를 명시해야 한다. (ETag) 3.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기 클라는 A-IM 헤더를 사용하여 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다. 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다. IANA에 등록된 인스턴스 조작의 종류 vcdiff: vcdiff 알고리즘을 이용한 델타 diffe: 유닉스 diff-e 명령어를 이용한 델타 gdiff: gdiff 알고리즘을 이용한 델타 gzip: gzip 알고리즘을 이용한 압축 deflate: deflate 알고리즘을 이용한 압축 range identit 문서는 클라에게 반환되기 전에 압축률을 극대화하기 위해 여러번의 인스턴스 조작을 거칠 수 있다. 델타 인코딩은 전송시간을 줄일 수 있지만, 구현하기가 까다로울 수 있다. 문서를 제공하는데 걸리는 시간을 줄이는 대신,서버는 문서의 과거 사본을 모두 유지하기 위해 디스크 공간을 더 늘려야 한다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 RFC3229","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"instance","slug":"instance","permalink":"http://feel5ny.github.io/tags/instance/"},{"name":"Range","slug":"Range","permalink":"http://feel5ny.github.io/tags/Range/"},{"name":"encoding","slug":"encoding","permalink":"http://feel5ny.github.io/tags/encoding/"}]},{"title":"엔터티와 인코딩","slug":"HTTP_015_01","date":"2020-01-05T11:43:10.000Z","updated":"2024-11-23T12:12:24.881Z","comments":true,"path":"2020/01/05/HTTP_015_01/","permalink":"http://feel5ny.github.io/2020/01/05/HTTP_015_01/","excerpt":"","text":"HTTP는 매일 수십억 개의 미디어 객체를 실어 나른다.HTTP는 콘텐츠를 잘 나르기 위한잘 라벨링된 엔터티를 사용한다. 엔터티와 엔터티 헤더들 웹상의 화물을 수송하기 위해 어떤일을 하는지 HTTP가 어떻게 콘텐츠 크기, 타입, 인코딩에 대한 필수적인 값들을 제공하는지 복잡하지만 강력한 기능을 알아본다.HTTP 엔터티, 범위요청(range request), 델타 인코딩(delta encoding), 요약(digest), 청크 인코딩(chunked encoding) 엔터티에 대하여 1. 메세지는 컨테이너, 엔터티는 화물 엔터티는 엔터티헤더 + 엔터티 본문의 조합 1.1 엔터티 헤더 (참고) 3가지 종류의 헤더가 있다 엔터티 정보헤더, 콘텐츠 헤더, 엔터티 캐싱 헤더 1. 엔터티 정보헤더 Allow : 이 리소스에 대해 어떤 요청 메서드가 허용되는지 2. 콘텐츠 헤더 Content-Type : 엔터티에 의해 전달된 객체의 종류 Content-Length : 전달되는 메세지의 길이나 크기 Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어 Content-Encoding : 객체 데이터에 대해 행해진 변형 (압축 등) Content-Location : 요청 시점 기준으로, 객체의 또 다르 위치 Content-Range : 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다. Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크섬(중복검사의 한 형태) 3. 엔터티 캐싱 헤더 Last-Modified : 서버에서 이 콘텐츠가 생성 혹은 수정된 날 Expires : 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각 ETag : 이 인스턴스에 대한 고유한 검사기 1.2 엔터티 본문 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. raw data 다른 정보들은 모두 헤더에 담겨 있다. 엔터티본문은 CRLF (캐리지 리턴 + 개행) 줄 바로 다음부터 시작한다. 2. Content-Length 엔터티의 길이 메세지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다. gzip으로 압축된 텍스트 파일이라면 &#x3D;&gt; 원래 크기가 아니라 압축된 후의 크기 엔터티 본문을 포함한 메세지에서는 필수적으로 있어야 한다. 서버 충돌로 인해 메세지가 잘렸는지 감지하고자 할때 지속 커넥션을 공유하는 메세지를 올바르게 분할하고자 할때 필요 2.1 잘림 검출 옛날 버전의 HTTP: 커넥션이 닫힌 것을 보고 메세지가 끝났음을 인지 Content-Length가 없다면 클라는 커넥션이 정상적으로 닫힌 것인지, 메세지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못함 잘림을 검출하기 위해 Content-Length가 필요로 했다. 메세지 잘림은 캐싱 프락시 서버에서 특히 취약하다. 캐시가 잘린 메세지를 수신했으나 잘렸다는 것을 인식하지 못했다면 캐시는 결함이 있는 콘텐츠를 저장하고 계속 제공하게 될 것이다. 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP본문은 보통 캐시하지 않는다. 2.2 잘못된 Content-Length 공식적으로 HTTP&#x2F;1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어 있다. 2.3 Content-Length와 지속커넥션 Content-Length는 지속커넥션을 위해 필수다. 만약 응답이 지속커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것이다. Content-Length 헤더는 클라에게 메세지 하나가 어디서 끝나고 다음 시작은 어디인지 알려주는데, 커넥션이 지속적일경우 클라가 커넥션이 닫힌 위치를 근거로 메세지의 끝을 인식하는 것은 불가능하므로,Content-Length로 시작과 끝을 가늠한다. 때문에 지속커넥션에서는 Content-Length는 필수이다. 다만, 청크인코딩은 지속커넥션으로 이루어지는데, 이때 Content-Length헤더는 없다. 2.4 콘텐츠 인코딩 HTTP는보안을 강화하거나압축을 통해 공간을 절약할 수 있도록,엔터티 본문을 인코딩할 수 있게 해준다. 인코딩 될 경우 Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의한다. 2.5 엔터티 본문 길이 판별을 위한 규칙switch (true) 본문을 갖는 것이 허용되지 않은 특정타입의 HTTP 메세지 Content-Length는 무시된다. ex_ HEAD 메서드 메세지가 Transfer-Encoding 헤더를 포함하고 있다면 엔터티는 ‘0 바이트 청크’라 불리는 특별한 패턴으로 끝나야 한다. 메세지가 Content-Length 헤더를 갖는다면 본문의 길이를 담게 된다. Transfer-Encoding가 identity가 아닌값을 포함한 메세지를 받았을 경우 Content-Length는 무시된다. (Content-type: multipart&#x2F;byteranges) &amp;&amp; (Content-Length가 정의되어있지 않다면) 멀티파트 메세지의 각 부분은각자 스스로의 크기를 정의할 것이다. 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다. 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지 보내지 말아야 한다… RFC7230 때 삭제됨. (default) 엔터티는 커넥션이 닫힐 때 끝난다. Content-Length를 요구하고 싶을 경우 411 Length Required 응답을 보냄 3. 미디어 타입과 Charset Content-Type은 엔터티 본문의 MIME 타입을 기술한다. IANA에 정리되어있는 MIME타입 IANA: 인터넷 할당 번호 관리기관 Internet Assigned Numbers Authority 주타입: application, audio, font, example, image, message, model, multipart, text, video 3.1 텍스트 매체를 위한 문자 인코딩Content-Type: text/html; charset=iso-8859-7 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 charset 매개변수가 있다. 3.2 멀티파트 미디어 타입 서로 붙어있는 여러 개의 메세지를 포함하며, 하나의 복합 메세지로 보내진다. 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함한다. HTTP는 일부의 경우에 지원한다 폼을 채워서 제출할때 문서의 일부분을 실어 나르는 범위 응답을 할 때 1. 멀티파트 폼 제출 multipart/form-data1Content-Type: multipart/form-data; boundary=[abcdefghijklmnopqrstuvwzyz] boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다. 2. 멀티파트 범위 응답 multipart/byteranges 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다. 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다. multipart&#x2F;byteranges는 브라우저로 회신하는 부분적인 응답 전송의 컨텍스트 내에서 사용된다. 206 Partial Content 상태 코드가 전송된 경우,MIME 타입은 문서가 각각의 요청된 범위들 중 하나인 몇 가지 파트들로 구성되어 있음을 알려주기 위해 사용된다. 다른 멀티파트 타입처럼, Content-Type은 경계선 문자열을 정의하기 위해 boundary 디렉티브를 사용한다.각각의 다른 파트들은 문서의 실제 타입을 가진 Content-Type 헤더와 그들이 나타내는 범위를 가진 Content-Range를 지니고 있다. 전송 전 ~ 전송 후 1. 엔터티 요약 Content-MD5 여러가지 이유로 메세지의 일부분이 전송 중에 변형되는 일이 일어난다. 송신자는 최초 엔터티가 생성될 때 데이터에 대한 체크섬을 생성할 수 있다. 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해, 그 체크섬으로 기본적인 검사를 할 수 있다. Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다. 응답을 처음 만든 서버만이 Content-MD5헤더를 계산해서 보낼 것이다. 중간에 있는 프락시와 캐시는 그 헤더를 변경하거나 추가하지 않을 것이다. (건드릴 경우 무결성 검증 목적을 손상시킴) Content-MD5 헤더는콘텐츠 인코딩은 끝났지만,전송 인코딩은 아직 적용하지 않은 엔터티 본문에 대한 MD5를 담고 있다. 메세지의 무결성을 검증하려는 클라는 먼저 전송 인코딩을 디코딩하고 그 디코딩 된 엔터티 본문에 MD5를 계산해야 한다. 문서를 gzip 알고리즘으로 압축하여 청크 인코딩으로 보냈다면, MD5 알고리즘은 압축된 본문 전체에 대해 수행된다. MD5는 문서의 위치를 빠르게 알아내고, 콘텐츠의 중복저장을 방지하기 위한 해시테이블의 키로 이용될 수 있다. Content-MD5 헤더는 그다지 자주 전송되지 않는다. 2. 콘텐츠 인코딩 Content-Encoding 전송시간을 줄이기 위해 압축하거나 보안을 위해 콘텐츠를 암호화하거나할때 사용한다. 콘텐츠 인코딩은 콘텐츠 포맷과 연관되어있다. 과정 유형 관련 헤더 1. 과정 웹서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메세지를 생성 콘텐츠 인코딩 서버가 인코딩된 메세지 생성 (원서버 or 프록시) Content-Length는 변경된다. 콘텐츠 인코딩 서버는 어떤 방식으로 인코딩했는지 정보가 담겨있는 Content-Encoding 헤더를 인코딩된 메세지에 추가 수신자가 디코딩할 수 있도록 한다. 수신자는 인코딩된 메세지를 디코딩하고 원본을 얻는다. 모던 브라우저에는 gzip 압축해제를 자동으로 해준다. 참고 2. 유형 표준 콘텐츠 인코딩 유형이 정의되어있음. (IANA를 통해 표준화됨) 커스텀으로 확장 인코딩을 추가하는걸 허용해놓음 gzip, compress, deflate 인코딩은 전송되는 메세지의 크기를 정보으 손실 없이 줄이기 위한 무손실 압축 알고리즘이다. Content-Encoding: &#123;유형&#125; gzip : GNU zip 인코딩이 적용되었음을 의미 compress: 유닉스 파일 압축 프로그램인 compress가 실행되었음을 의미 deflate : zlib 포맷으로 압축되었다는 의미 identity : 어떤 인코딩도 수행되지 않았음을 의미. (Content-Encoding 헤더가 존재하지 않는다면, 이 값인 것으로 간주) 3. Accept-Encoding 헤더 서버에서 클라가 지원하지 않는 인코딩을 사용하는 것을 막기 위해,클라가 자신이 지원하는 인코딩의 목록을 Accept-Encoding 헤더에 포함한다. 인코딩에 Q(quality)값을 매개변수로 더해선호도를 나타낼 수 있다. Q의 범위는 원치않음 0.0 ~ 가장선호 1.0 사이이다.12345Accept-Encoding: compress, gzipAccept-Encoding:Accept-Encoding: *Accept-Encoding: compress; q=0.5, gzip; q=1.0Accept-Encoding: gzip; q=1.0, identiy; q=0.5, *; q=0 3. 전송 인코딩과 청크 인코딩 Transfer-encoding 메세지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 3.1 안전한 전송 역사적으로, 전송 인코딩은 안전한 전송을 위해 존재했다. HTTP에서 전송된 메세지의 본문이 문제를 일으킬 수 있는 이유 알수 없는 크기: 몇몇 게이트 웨이 어플리케이션 or 콘텐츠 인코더는 메세지 본문의 최종 크기를 판단할 수 없다. 보안 : 메세지 콘텐츠를 보내기 전에, 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법도 있다. SSL이 있어서 전송 인코딩 보안은 흔하지 않다. 3.2 Transfer-encoding 헤더 전송 인코딩을 제어하고, 서술하기 위해 정의된 헤더는 2개 최신 HTTP 명세는 오직 하나의 전송 인코딩, 청크 인코딩만을 정의했다. 어떤 형태의 전송 인코딩을 선호하는지 표현하는 Q값을 가질 수 있다. 1234GET /new_products.html HTTP/1.1Host: feel5ny.github.ioUser-Agent: Mozilla/4.61 [en] (WinNT; I)TE: trailers, chunked 123HTTP/1.1 200 OKTransfer-Encoding: chunkedServer: Apache/3.0 Transfer-encoding : 안전한 전송을 위해, 어떤 인코딩이 메세지에 적용되었는지 수신자에게 알려준다. TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해, 요청 헤더에 사용한다. 3.3 청크 인코딩 메세지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다. 청크 인코딩을 이용하면, 메세지를 보내기 전에 전체 크기를 알 필요가 없어진다. 청크 인코딩은 본문이 아닌, 메세지의 속성이다. 멀티파트 인코딩은 본문의 속성, 청크 인코딩과는 완전 분리되어있다. 청크 인코딩과 지속 커넥션 지속커넥션에서는, 본문을 쓰기 전에 만드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 한다. 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 동적으로 본문이 생성되면서, 서버는 그 중 일부를 버퍼에 담은 뒤, 그 한 덩어리를 그의 크기와 함께 보낼 수 있다. 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다. 청크 인코딩은 응답 헤더 블록으로 시작하고 이어서 청크의 스트림이 온다. 각 청크는 길이값과 각 청크에 대한 데이터를 담고 있다. 길이값과 청크 데이터는 &lt;CR&gt;&lt;LF&gt;로 분리된다. 마지막 청크는 본문의 끝을 의미하기 위해 길이가 0 이다. 1227&lt;CR&gt;&lt;LF&gt;블라블라블라 ~ 10&lt;CR&gt;&lt;LF&gt; 클라 또한 청크 인코딩된 데이터를 서버로 전송한다. 청크 인코딩된 메세지의 트레일러 다음 중 하나 이상 조건을 만족하면 청크 메세지에 트레일러를 추가할 수 있다. 클라의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우 트레일러가 응답을 만든 서버에 의해 추가되었으며, 트레일러의 콘텐츠는 클라가 이해하고 사용할 필요가 없어서 무시하고 버려도 되는 경우 트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로메세지 시작 시점에서 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다. 트레일러로 보낼 수 있는 헤더의 예로 Content-MD5 헤더가 있다. Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 HTTP 헤더도 트레일러로 보낼 수 있다. 콘텐츠와 전송 인코딩의 조합 콘텐츠 인코딩과 전송인코딩은 동시에 사용될 수 있다. 전송 인코딩 규칙 전송 인코딩 집합은 반드시 chunked를 포함해야 한다. 청크 전송 인코딩이 사용되었다면, 메세지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다. 청크 전송 인코딩은 반드시 메세지 본문에 한 번 이상 적용되어야 한다. 이미지 청크 인코딩 예시 HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"encoding","slug":"encoding","permalink":"http://feel5ny.github.io/tags/encoding/"},{"name":"entity","slug":"entity","permalink":"http://feel5ny.github.io/tags/entity/"}]},{"title":"2019 회고 + 2020 다짐 (feat. 글또)","slug":"Joylog_004","date":"2019-12-22T12:23:55.000Z","updated":"2024-11-23T12:12:24.851Z","comments":true,"path":"2019/12/22/Joylog_004/","permalink":"http://feel5ny.github.io/2019/12/22/Joylog_004/","excerpt":"","text":"아, 2019년도도 어느새.. 너무나 빠르게 지나갔다. 요즘 참 시간이 빠르게 가는 것 같다. 모니터만 보다가 시간 다 가겠다고 농담으로 자주 얘기하는 요즘이다. 그래도 정신 똑띠 차리고 시간을 잘 써야 하니까.. 오늘도 어김없이! 연말정산을 해보려고 한다. 1. 2019 하반기에 다짐한 것, 잘 이루었을까?2019 상반기 회고 + 하반기 다짐 (feat. 글또) ➔ 1.1 기본 실력 키우기상반기 때는 기본 실력의 범위에 대해서만 재정의하였고, 깊이 있는 공부를 진행하지 못했었다. 깊이 있는 공부란.. 깊이 파보기도 하고, 실습도 하고 이론 정리도 하는 것을 생각하는데, 상반기 때는 “이것도 공부해야 하는구나”라는 식의 공부할 거리 알아보고 우선순위 정하기 정도만 진행했었다. 이에 중간 정산 시에 문제 인지를 하여서, 하반기 때는 구체적인 action plan을 그려보았는데,첫째는 웹 네트워크 공부, 두 번째는 기본 공부로써 구글 웹 문서와 mdn 전체 훑어보기를 세웠었다.2019 하반기 뭘 해볼까 (목표 설정) ➔ 1.1.1 웹 네트워크 공부프론트 개발자가 인지할 수 있는 웬만한 네트워크 이슈는 먼저 인지하고 디버킹하고 싶어서 웹 네트워크 지식은 한번 쭉 정리해보고 싶었다. 팀장님이 추천해주신 ‘http 완벽가이드’라는 책을 선택하였다. 제발 책 전체를 다 읽고 싶었는데, 지금까지 경험상 절대 혼자서는 완주를 못 할 것이라는 생각이 들어서, 주변에 같이 스터디할 사람을 찾아보았다. 스터디 운영 고민스터디를 모집하는 이슈도 있었지만, 운영에 대한 고민도 있었다. 과연 이 책을 끝까지 완주할 수 있을까 라는 걱정이 들고, 나조차도 하나의 스터디가 쉬지도 않고 끝까지 달리기에는 무리일 것 같아, 한 챕터씩 쪼개서 챕터마다 모집하는 방법으로 스터디를 구성하였다. 1회차 2019.8.1 ~ 8.26 (4주) 모집 글 2회차 2019.9.2 ~ 10.27 (7주) 모집 글 3회차 2019.11.11 ~ 12.09 (4주) 모집 글 2회차 때는 2달을 진행하니 역시나 버거웠다. 최대한 낙오자가 생기지 않기 위해서 오프라인 모임은 하지 않고, 온라인 모임만으로 진행하며, 일정 금액을 걸고 진행하기로 하였다. 운영에 피로도를 낮추기 위해서 깃헙과 챌린저스라는 앱을 사용하였다. 챌린저스 앱에 정한 예치금을 등록 운영은 “두꺼운 책 뽀개기” 라는 **깃헙 조직**을 만들고 하위에 두꺼운 책마다 **레포**를 만들어서 해당 레포에 과제를 PR로 올려서 해당 PR을 챌린저스라는 앱으로 인증하는 방식으로 진행하였다. 운영자는 글 마감 공지 등을 진행하였다. 스터디 공부 방식 고민 보통의 스터디는 장기 기억을 위해서 개인 공부를 하고, 토론하던가, 발표자를 정해서 일정 기간에 한 번씩 오프라인에서 한 명 혹은 각자가 발표하는 식으로 진행하지만 개인적으로 발표 준비라는 것은 콘텐츠 제작과 + 발표라는 2가지 전달 방법을 만들어야 하고,이는 스터디를 부담스럽게 만드는 요인이라고 생각이 들었다. 발표로 진행하는 스터디는 장기기억을 위해서 (듣는이가 있는) 발표자료를 준비하고 발표라는 러버덕 비슷한 학습 방법을 사용하는데 이를 대체하는 방법이 무엇일까 고민했을 때 TIL 수준보다 좀 더 읽는 이를 고려야 하는 블로그 글을 정리 매개체로 하고,블로그 글 자체를 콘텐츠를 만드는 수준으로 끌어올려서 글을 작성하게 하면린한 기획이 선행되어야 하기 때문에 기억에 오래 남지 않을까 하여,해당 방식의 글 작성 조건으로 모집 글을 작성하였다. 또한, 다른 사람의 글을 첨삭해주면서 글을 몇 번이라도 더 복습하며 볼 수 있다고 생각하여짝궁 리뷰도 필수로 하게끔 진행하였는데,진행해보니 ‘글을 읽어서 학습하며 첨삭한다’가 아니라 주객이 전도되는 상황이 벌어져서,다음에는 리뷰하는 것은 제외하였다. 현재 상황을 봤을 때는, 콘텐츠 같은 정리 글을 쓴다기보다는 글에 있는 내용을 요약정리하는 수준으로 되었지만, 정리에서 오는 학습효과 정도는 가져갈 수 있었던 것 같다. 그래서 공부는? 현재 20주 정도로 진행하여서 책의 60% 정도 진행하였다. HTTP에 대해서 기본정리를 차근차근히 할 수 있어서 시작하길 잘했다는 생각을 매번 하고 있다. 최근에는 코드스피츠에서 **[리얼월드 http]**를 선물 받아서, 해당 책으로 실습을 병행하고자 한다. 공부해야겠다 마음을 먹고 스터디 진행까지 실행을 하고 나니, 중간회고가 굉장히 도움이 된다는 생각을 자주 하게 되었다. 자기객관화를 지속해서 해야겠다는 마음이 들었다. 1.1.2 기본 공부 (프론트개발) 웹 네트워크 공부 때문에 계획했던 기본공부 action plan을 수행하지 못했다. action plan으로 구글 웹 문서와 mdn 전체를 훑어보기로 세웠었는데,사전 같은 문서를 훑어보는 것은 유익하겠지만재미가 없을 것 같고.. 꾸준히 하지 못 할 것 같아서, 더 구체적인 plan을 세우려고 한다. 1.2 디자인 시스템 이해도 높이기상반기 때는 디자인 시스템을 적용하기 전에 팀원들에게디자인 시스템이 어떤 생산성을 주는지에 대해 알리기 위해 사내 발표를 진행했었다. 사내 발표 때 디자인시스템의 기본 구조를 아토믹 패턴 개념을 기반으로 설명했었는데,발표 피드백으로 어느 수준까지 쪼개야 하는지에 대해서 잘 모르겠다는 의견이 나왔고 이점을 보완하여서 개념을 재정리하였다. 그러던 중에 감사하게도 GDG-devfest 발표기회가 찾아와서 정리한 부분을 발표하게 되었다.(발표 회고 글도 작성해야 하는데 언제 하지 8ㅅ8) 발표자들의 이해를 돕기 위해서 실제로 적용하는 예시까지 정리해드렸는데,이때 스스로 다시 한번 개념에 대해서 정리하게 되었고, 이를 바탕으로 회사 프로젝트의 구조도 수정할 수 있게 되었다.확실히 연필 놓고 멀리서 바라보는 시간은 중요한 듯하다. 1.3 포트폴리오 작업하기으… 포트폴리오 작업은 이번에도 이루지 못했다.헥소 블로그 테마 만들기라도 하자고 action plan을 잡았었는데, 진행하지 못했다.아무래도 공부하는 것을 더 우선순위로 잡아놔서 개인 포폴작업용으로 개발하는 것은 우선순위가 내려간 듯하다.회사 업무와 관련된 토이프로젝트를 만들 생각으로 다시 접근해야겠다는 생각이 들었다. 2. 2019 하반기 뭘 했을까 2.1 👥 외부 활동2.1.1 글또 3기 (글쓰기 활동) 글또는 예치금을 걸어두고 2주마다 블로그 글을 작성하는 모임이다. 상반기 글또2기 마무리에 이어서 3기도 참여하게 되었다. 이번 기수에는 회사 팀원들도 함께 참여하였다! http완벽가이드 스터디와 스터디원도 겹치고, 일정도 겹치는 상황이라,거의 스터디 글을 올리곤 했어서 다양한 글을 작성하지 못해서 아쉬웠다. 역시 글 작성은 일주일에 2개는 무리인듯하다..그래도 스터디 글이 아닌 주제로 작성했던 글들이평소에 작성하고 싶었던 글 목록에 있던 글들이라, 작성할 때 만큼은 재미있었다. 이번 기수에는 포지션끼리 그룹핑하여 피드백하는 방식이어서네트워킹도 되고 기술공유도 되어서 유익하였다. 4기도 해야지! 끝까지 해서 고인물이 되어야겠다. 2.1.2 발표WTM GDG 클라우드 부산 발표기록하며 성장하기라는 주제로 개인 성장기? 공부 방법 등을 공유해 드렸다. ➔취준생분들이 많이 오셔서 도움이 되셨다는 피드백을 많이 주셨다. 🙏 GDG devfest 발표발표에 대한 경험담과 준비 과정은 따로 글로 작성하려고 한다.요약하자면 처음 하는 대규모 발표였기 때문에 정신이 혼미했었다..는 것.. 생각보다 발표를 듣고 긍정적인 피드백을 주신 분들이 많으셨다.개인적으로 아토믹 패턴 기반은 아니더라도디자인 시스템은 업무의 생산성과 프로덕트 브랜딩을 위해서다른 회사들에도 꼭 적용되면 좋겠다는 생각이 들어서,해당 개념이 한 사람이라도 더 알게 하는 데에 기여를 했다는 것에 의미를 두었다. 🙏 2.1.3 코드 스피츠 수업 참여 (원론 수업)좋아하는 코드 스피츠 강의를 1개 참여했다. 거침없는 자바스크립트 (10월) 하반기 때는 너무 코드스피츠 이론 수업에 매달리지 말고 복습이나 실습을 좀 해야겠다는 생각 때문에 다른 강의는 참여하지 않았다 (못했다..는 아니다.) 그러다 강남에서 열린다는 소문을 듣고 +_+ 부랴부랴 신청하게 되었다.(ㅎ.ㅎ)강의장에서 http 완벽가이드 스터디원들도 오프라인에서 얼굴도 한 번씩 뵙기도 했다. 이번 강의는 3회 강의가 정말 알참 of 알참이었는데 알참을 넘어서 나에게는 overflow한 개념이었다.그래도 제너레이터를 왜 사용해야 하는지, 넌블럭킹에 대한 개념 등을 알 수 있어서 좋긴 했지만아직 3개의 강의를 복습하지 못했다.. 올해 가기 전에 해야 하눈데!! ㅠ 저번 회고 글에서도 작성했지만, 실습 위주로 복습해야 진짜 내 것이 될 텐데자꾸 코드스피츠 수업은 그것을 못 하게 된다ㅠ 리소스 부족도 사치겠지.. 복습하고 꼬옥 실습을 진행하자. 단기목표 이번 거침없이 자바스크립트 복습하고 제너레이터 실습해보기 2.1.4 패캠 모의 면접관 패스트 캠퍼스의 웹 프로그래밍 스쿨 모의 면접관 제안이 들어와서 10월부터 12월까지 진행하게 되었다.예전 공부했을 때 생각도 나고, 취준했을 때도 생각나서 나름 열심히? 상담 + 모의 면접을 진행하였다.단기간에 학습하느라 힘드실 텐데, 다들 열의도 넘치시고 그 뭐랄까 열정!!이 느껴져서 어떻게든 더 많이 알려드리려고 노력했다. 2.2 🍖어떤 공부를 했늬 삽질하며 공부하기 올해도 여전히 장벽을 부딪쳐가며 공부해 나갔다. 특히나 실 서버 배포가 이루어지면서 대응하면서 공부한 부분도 꽤 많았다.(먼 산..) 함께 공부하기 바닐라JS 스터디: 적극적인 코드리뷰가 제일 좋았다. (핑퐁🏓) HTTP 완벽가이드 스터디: 요즘 인증서 공부를 하고 있는데 공인인증서랑 관련도 있어서 신기하고 재밌게 배우고 있다.ㅎㅎ 파이썬 스터디 사내에서 파이썬 스터디를 진행하고 있어서 참여해보았다. 새로운 언어를 공부해보니 자바스크립트가 다르게 보이는 점도 있었다. **깃북**으로 공부한 부분을 정리하였다.진짜… 깃북 편집하는데 UX가 화딱지나게 생겨서 힘들었었다.. 개발 외 공부하기비즈니스를 데이터 기반으로 살펴보고,퍼널별로 웹 개발자가 내놓을 수 있는 인사이트를 얻기 위해 공부하고 있다 데이터 겅부: 시각화 기획 방법(?), 분석 방법, 툴 익히기, … 마케팅 용어 이해하기 @_@: 마케팅용어에는 왜 이렇게 축약어가 많을까ㅠ 대단한 사람들.. 사실 요즘에 개발 공부도 개발 공부지만 데이터 공부도 너무 재밌다. 다음에 웹 리포팅 형식으로 토이프로젝트를 진행하려고 한다. 이번 연도에는 실무에서 겪은 것으로 공부하고, 같이 공부하는 스터디 참여, 개발 외적인 부분도 공부하려고 하였다. 확실히 이론 공부보다 실무에서 필요한 공부 위주로 방향을 잡아 공부하니 학습속도가 개인 공부 때보다는 빠른듯하다. 개발 이외의 공부를 해도 좋으나 개발 공부를 소홀히 하지 않는 선에서 진행해야겠다. (라고했지만, 그렇게 되면 속도가 느려져서 답답하다.)두꺼운 책은 부담스러워서 항상 완주하지 못했었는데, 위 스터디 방식대로 진행하고, 현재 완주가 눈앞에 보이니, 앞으로 두꺼운 책 공부는 이런 식으로 공부하면 되겠다 싶다. 2.3 ✍️ 어떤 글을 썼을까? (17)글 갯수는 중요하지 않지만!! 너무 한쪽 방향으로만 글을 쓰면 좋지 않으니까.하반기에 어떤 글을 썼는지 알아보고 다시 계획을 잡아보자. 📚 공부 정리 글 15 (코드스피츠4, 스터디 글 11) 💡 작업하다가 내 것이 된 지식 1 🙆 내가 알고 있는 부분 정리 1 2기 때 글의 카테고리를 이렇게 정리했었다. 📚: 공부하자! 내 스타일로 메모 💡: 작업하다가 삽질해서 내 것이 된 지식을 정리하자. 🙆: 내가 알고 있는 부분을 정리해보자. 🏃: 세미나 다녀왔습니다. 2기 때 잡은 카테고리를 기준으로 3기 때는 1번 5개&#x2F; 2번 3개&#x2F; 3번 2개&#x2F; 4번 2개 작성을 목표로 잡았었다. 😅 이번에는 1번에 굉장히 쏠려버렸다.삽질한 업무들이 많아서 개인적으로 글감을 정리하고 있었는데,너무 스터디 글만 올리는 것 같다고 인지될 때마다 글감에서 꺼내서 작성하였다. 그나마 2개..ㅎㅎ 세미나 다녀와서 글 쓰는 건.. 정말 손에 안 잡히나보다 😂😂HTML 컨퍼런스랑 구글 SEO는 작성해야 하는데 :(스터디 끝나면 글감에 있는 글 하나씩 꺼내서 작성하자! 3. Action Plan - 2020년에는 큰 거2개&#x2F;작은 거2개&#x2F;토이2개2019년도에는 대부분의 목표달성 계획에 추상적이고 모호하게 잡았던 듯하다.물론 지금 이렇게 계획한다고 해서! 100% 지키면 나는 로봇이겠지만.. 최대한 계획한 것을 지키면서 지내보자. 3.1 👤 개인 공부 (장&#x2F;단기) 장기목표: 2020년도에 하고 싶은 내용 토이프로젝트: 데이터 기반 특정 주제에 대한 리포팅 웹페이지 제작 big: 자료구조 공부 (상반기) big: 디자인 패턴 공부 (하반기) small: 구글 web fundamentals small: 자바스크립트 (프레임워크&#x2F;라이브러리) 단기목표: 2020년도 상반기에 하고 싶은 내용 토이프로젝트: 특정 주제에 대한 리포팅 웹페이지 제작 big: 자료구조 공부 (파이썬) small: 구글 web fundamentals ➔ 3.2 💁‍ 2020 다짐 개인적으로 2020년에는 외부활동은 적당히 하고 내공을 다지는 해로 컨셉을 잡자. 휴식을 잘 가져보자. 장기전으로 일하려면 제대로 된 휴식도 필수.. 해외 두군데는 가보자. 겨울에 더운 나라 가기 개발 책 말고 다른 분야 책 3권을 읽어보자. 필라테스 다시 시작하자!","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"Joy","slug":"Joy","permalink":"http://feel5ny.github.io/tags/Joy/"},{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/tags/blog/"}]},{"title":"HTTPS의 세부사항","slug":"HTTP_014_02","date":"2019-12-08T11:43:10.000Z","updated":"2024-11-23T12:12:24.914Z","comments":true,"path":"2019/12/08/HTTP_014_02/","permalink":"http://feel5ny.github.io/2019/12/08/HTTP_014_02/","excerpt":"","text":"최근 인증서 관련 이슈를 만난적이 있었는데,이번 장을 통해서 조금이나마 이해가 될 수 있게 되었다 :) HTTPS는 HTTP의 가장 유명한 보안 버전이다. HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다. HTTPS는 웹 기반 전자상거래의 고속 성장을 이끄는 주력이다. HTTPS 세부사항 HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다. HTTPS는 HTTP 메세지를 TCP로 보내기 전에먼저 그것들을 암호화하는 보안계층으로 보낸다. 오늘날 HTTPS의 보안계층은 SSL과 TLS로 구현되었다. 1. HTTPS 스킴 보안 HTTP는 선택적이다. 웹 서버로의 요청을 만들때, 웹서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다. 이것은 URL의 스킴을 통해 이루어진다.1https://feel5ny.github.io 만약 URL이 http 스킴을 갖고 있다면클라는 서버에 80번 포트로 연결하고평범한 HTTP 명령을 전송한다. 만약 URL이 https 스킴을 갖고 있다면클라는 서버에 443번 포트로 연결하고서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서핸드셰이크를 하고,암호화된 HTTP 명령이 뒤를 잇는다. SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP와는 완전히 다르다. 그 트래픽은 다른 포트로 전달된다.(SSL은 보통 443포트) 2. 보안 전송 셋업HTTPHTTP에서는 클라는 웹서버의 80번 포트로 TCP 커넥션을 열고, 요청메세지를 보내고, 응답메세지를 받고, 커넥션을 닫는다. HTTPSHTTPS에서는 클라는 웹서버의 443번 포트로 연결한다. TCP 연결이 되고나면, 클라와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다. 핸드셰이크가 완료되면 SSL 초기화는 완료되며 클라는 요청 메세지를 보안계층에 보낼 수 있다. 이 메세지는 TCP로 보내지기 전에 암호화된다. 암호화된 요청을 보낸다. SSL을 통해 보내진 HTTP 요청 &#x2F; TCP를 통해 보내진 암호화된 요청 SSL 닫힘을 통지한다. TCP 커넥션이 닫힌다. 3. SSL 핸드셰이크 암호화된 HTTP 메세지를 보낼 수 있게 되기 전에클라와 서버는 SSL 핸드셰이크를 할 필요가 있다. 핸드셰이크에서 일어나는 일 프로토콜 버전 번호 교환 양쪽이 알고 있는 암호 선택 양쪽의 신원을 인증 채널을 암호화하기 위한 임시 세션 키 생성 SSL 핸드셰이크를 단순화한 버전이다. SSL이 어떻게 사용되는가에 따라 핸드셰이크는 보다 복잡해질 수 있다. 실제로 좀더 자세히 보면.. 출처 3.1 예시로 알아보기www.bing.com에 접속할 때 SSL 핸드쉐이크 과정을 와이어 샤크를 보면서 알아보자. (클 &#x3D;&gt; 서버) Client Hello (서버 &#x3D;&gt; 클) Server Hello (서버 &#x3D;&gt; 클) Certificate (서버 &#x3D;&gt; 클) Certificate Status (서버 &#x3D;&gt; 클) Server Key Exchange (서버 &#x3D;&gt; 클) Server Hello Done (클 &#x3D;&gt; 서버) Client Key Exchange (클 &#x3D;&gt; 서버) Change Cipher Spec (클 &#x3D;&gt; 서버) Encrypted Handshake Message (서버 &#x3D;&gt; 클) Change Cipher Spec (서버 &#x3D;&gt; 클) Encrypted Handshake Message 1. (클 &#x3D;&gt; 서버) Client Hello 사용자가 bing에 접속하기 위해 bing 서버쪽에 통신을 요청 TLS 버전, 자신이 지원하는 cipher리스트, 클라이언트가 생성한 난수 정보를 보낸다. 2. (서버 &#x3D;&gt; 클) Server Hello 서버는 자신의 SSL버전 자신이 만든 임의의 난수와 클라이언트의 cipher 리스트 중 하나의 선택하여 그 정보를 클라이언트에게 보낸다. 3. (서버 &#x3D;&gt; 클) Certificate 서버는 자신이 갖고있는 인증서정보를 전송한다. 첫번째는 서버의 인증서 이고두번째는 CA 인증서이다. 4. (서버 &#x3D;&gt; 클) Certificate Status 갖고있는 인증서의 유효성 정보를를 전송한다. OCSP는 온라인 인증서 상태 프로토콜의 약자로, 인증서 유효성 확인을 제공하는 방법이다. 5. (서버 &#x3D;&gt; 클) Server Key Exchange 서버는 ECDHE 키 쌍을 만들어서 클라에게 public 키를 전송한다. 이 키는 클라의 public키를 이용해서 ECDHE shared secret을 만들기 위해 사용된다. ECDHE : Elliptic Curve 및 Ephermeral 을 지원하는 디피 헬만 (Diffie Hellman) 방식 (PFS, Perfect Foward Secrecy 지원) 출처 6. (서버 &#x3D;&gt; 클) Server Hello Done 서버의 말이 끝남 7. (클 &#x3D;&gt; 서버) Client Key Exchange 클라는자신이 마든 난수와 + 서버가 만든 난수를 통해&#x3D; pre-master-secret을 생성한다. 서버의 공개키를 통해 암호화하여 서버로 전송한다. (아까 5번에서 받은 public key) 즉, 해당과정을 통해 실질적으로 암호화에 사용하는 대칭키가 생성된다. 8. (클 &#x3D;&gt; 서버) Change Cipher Spec 클라이언트가 성공적으로 공유키를 생성했으며,이후 메시지는 암호화 하여 전송할 것을 알리는 메시지를 전송한다. 9. (클 &#x3D;&gt; 서버) Encrypted Handshake Message(Finished) 클라이언트는 서버에게 핸드셰이크가 성공적으로 완료되었음을 알린다. 10. (서버 &#x3D;&gt; 클) Change Cipher Spec 서버도 성공적으로 공유키를 생성했음을 알린다. 11. (서버 &#x3D;&gt; 클) Encrypted Handshake Message(Finished) 서버도 클라에언트에게 핸드셰이크가 성공적으로 완료되었음을 알린다. 12. 어플리케이션 데이터 서로 상대방에게 전송할 데이터를 암호화하여 전송한다. 4. 서버 인증서 SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. SSL은 서버 인증서를 클라로 나르고다시 클라 인증서를 서버로 날라주는 상호 인증을 지원한다. 오늘날 클라 인증서는 흔히 쓰이지 않는다. 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 서버 인증서는 X.509 v3에서 파생되 인증서이다. 디지털 인증서 5. 사이트 인증서 검사 SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만,최신 웹브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다. 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘 수행 단계는 다음과 같다. 날짜 검사 서명자 신뢰도 검사 서명 검사 사이트 신원 검사 1. 날짜 검사 브라우저는.인증서가 여전히 유효함을 확인하기 위해인증서의 시작 및 종료일을 검사한다. 만료되었거나 활성화되지 않았다면인증서 검사는 실패. 브라우저는 에러를 보여준다. 2. 서명자 신뢰도 검사 모든 인증서는 서버를 보증하는 어떤 인증기관에 의해 서명되어 있다.CA &#x3D; Certificate Authority 여러가지 수준의 인증서가 있는데, 각각은 다른 수준의 배경 검증을 요구한다. 전자상거래 서버 인증서를 발급받고자 한다면,사업체로서의 법인에 대한 법적 증명을 제시해야 한다. 누구나 인증서를 생성할 수 있지만 몇몇 CA는인증서 지원자의 신원 및 사업의 선량함을 입증하는알기쉬운 절차를 갖춘 잘 알려진 기관이다. 이러한 이유료, 브라우저는 신뢰할 만한 서명 기관의 목록을 포함한 채로 배포된다. 브라우저마다 다르게 셋팅되어있다. 출처 Firefox Chrome: it uses the certificates included with the OS. Opera: it install the most uses CA within installing the application, you can find the rest in the online root repository iOs 만약 브라우저가 알려져 있지 않은 인증기관으로부터 서명된 인증서를 받았다면브라우저는 보통 경고를 보여준다. 브라우저는 신뢰할만한 CA가 간접적으로 서명한 인증서를 받아들이는 것을 선택할 수 있다 신뢰할만한 CA가 ‘필오의 개발일지’를 위한 인증서에 서명을 하고필요의 개발일지는 어떤 사이트 인증서에 서명을 한다면,브라우저는 그 인증서를 올바른 CA 경로에서 파생된 것으로 보고 받아들일 수 있다. 3. 서명 검사 한번 서명 기관이 믿을 만하다고 판단되면,브라우저는 서명기관의 공개키를 서명에 적용하여,그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다. 4. 사이트 신원 검사 서버가 누군가 다른 이의 인증서를 복사하거나,그들의 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는인증서의 도메인 이름이대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다. 서버 인증서에는 보통 단일 도메인 이름이 들어있지만몇몇 CA는 서버 클러스터나 서버 팜을 위해서버 이름의 목록이나 서버 이름들에 대한 와일드카드 표현이 들어있는 인증서를 만든다. 서버 클러스터란? (IT솔루션 by 올파) 서버 클러스터란 각기 다른 서버(Server Enterprise or server Datacenter)들을 하나로 묶어서 하나의 시스템같이 동작하게 함으로써, 클라이언트들에게 고가용성의 서비스를 제공하는것을 말한다. 클러스터로 묶인 한시스템에 장애가 발생하면, 정보의 제공 포인트는 클러스터로 묶인 다른 정상적인 서버로 이동한다. 서버클러스터는 사용자로 하여금 서버 기반 정보를 지속적이고, 끊기지않게 제공받을수 있게 한다 서버 팜이란? 서버 클러스터라고 불리기도 하는 서버팜은 컴퓨터 서버와 운영 시설을 한곳에 모아 놓은 곳 허가받지 않은 외부에선 접근이 불가능 임의의 서버가 중단되더라도 다른 서버로 대체되어 원할한 서비스를 제공한다. 와일드 카드란? 파일을 지정할 때, 구체적인 이름 대신에 여러 파일을 동시에 지정할 목적으로 사용하는 특수 기호. ＊&#39;,？&#39; 따위. 만약 호스트명이 인증서의 신원과 맞지 않는다면,사용자를 우선으로 생각하는 클라이언트는 반드시 이 사실을 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야 한다. 6. 가상 호스팅과 인증서 잘 모르겠다. 가상 호스트(하나의 서버에 여러 호스트명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다. 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다. HTTPS 예시 (feat. OpenSSL) SSL은 복잡한 바이너리 프로토콜이다. 가공되지 않은 SSL 트래픽을 직접보는 것은 어렵다. 몇가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다. OpenSSL OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다. HTTP://www.openssl.org SSLeay도 있다. 온라인 중개소의 홈페이지에 접속했을 때clients1.online.msdw.com 의 사이트라고 가정 SSL 컨텍스트가 초기화 되었다. clients1.online.msdw.com의 IP주소: 63.151.15.11 호스트 clients1.online.msdw.com, 포트 443으로 TCP 커넥션을 열었다. SSL endpoint가 생성되었으며 핸드셰이크 완료 다음의 암호로 SSL 연결이 됨: DES-CBC3-MD5 서버 인증서를 받았다. 12대상: /C=US/ST=Utah/L=Salt Lake City/O=Morgan Stanley/OU=Online/CN=clients1.online.msdw.com발급자: /C=US/O=RSA Data Security, Inc./OU=Secure Server Certification Authority 암호화된 채널을 통해 HTTP 요청을 보냈다.123GET / HTTP/1.0Host: Clients1.online.msdw.com:443Connection: close HTTP응답에서 615바이트를 가져왔다.12345678HTTP/1.1 302 FoundDate: Sat, 09 Mar 2002 09:43:42 GMTServer: ...Location: ...Connection: closeContent-Type: text/html; ...... 모두 끝났으므로 커넥션을 닫고 정리한다. 프락시를 통한 보안 트래픽 터널링 (HTTPS SSL 터널링 프로토콜) 클라는 종종 웹 프락시 서버를 이용한다. 그러나 클라가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다. 만약 프락시가 HTTP 헤더를 읽을 수 없다면, 요청을 어디로 보내야 하는지 알 수 없게 된다. 해결 방법 중에 인기있는 방법은 HTTPS SSL 터널링 프로토콜이다. 클라는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다. 클라는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해준다. HTTP는 CONNECT라 불리는 새로운 확장 메서드를 이용해서 평문으로 된 endpoint 정보를 전송하기 위해 사용된다. CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며그것이 완료되면 클라와 서버 사이에서데이터가 직접적으로 오갈 수 있게 해주는 터널을 만든다.1234CONNECT home.netscape.com:443 HTTP/1.0User-agent: Mozilla/1.1N&lt;SSL로 암호화된 데이터가 이 다음에 온다..&gt; 클라는 프락시로부터의 응답을 기다릴 것이다. 프락시는 요청을 평가하여 그것이 유효하고,사용자가 그러한 커넥션을 요청할 수 있도록 허가를 받앗는지 확인한다. 모든 것이 적법하다면 프락시는 목적지 서버로 연결하고성공하면 200 Connection Established HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 SSL 핸드셰이크1 인증서 ocsp SSL 핸드셰이크2 ECDHE 생활코딩 - 02. HTTPS와 SSL 인증서","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"https","slug":"https","permalink":"http://feel5ny.github.io/tags/https/"},{"name":"openSSL","slug":"openSSL","permalink":"http://feel5ny.github.io/tags/openSSL/"},{"name":"sslHandShake","slug":"sslHandShake","permalink":"http://feel5ny.github.io/tags/sslHandShake/"},{"name":"ca","slug":"ca","permalink":"http://feel5ny.github.io/tags/ca/"}]},{"title":"HTTPS 이해를 위한 디지털 암호학","slug":"HTTP_014_01","date":"2019-12-01T11:43:10.000Z","updated":"2024-11-23T12:12:24.877Z","comments":true,"path":"2019/12/01/HTTP_014_01/","permalink":"http://feel5ny.github.io/2019/12/01/HTTP_014_01/","excerpt":"","text":"최근 인증서 관련 이슈를 만난적이 있었는데,이번 장을 통해서 조금이나마 이해가 될 수 있게 되었다 :) HTTP를 안전하게 만들기 사람들은 웹 트랜잭션을 중요한 일에 사용한다. 강력한 보안이 없다면, 사람들은 온라인 쇼핑이나 인터넷뱅킹을 할 때 안심할 수 없을 것이다. 기본인증이나 다이제스트 인증은 대량구매, 은행 업무, 보안자료 접근에는 강력하지 않다. HTTP와 디지털 암호화 기술을 결합해야한다. HTTP 보안 버전은 효율적이고 이식성이 좋아야 하고, 관리가 쉬워야 하며 현실세계의 변화에 대한 적응력이 좋아야 한다. 사회와 정부의 요구사항에도 맞아야한다. 다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요하다. 서버인증: 클라는 자신이 위조된 서버가 아닌 진짜 서버와 소통하고 있음을 알 수 있어야 함. 클라 인증: 서버는 자신이 가짜가 아닌 진짜 사용자와 소통하고 있음을 알 수 있어야 한다. 무결성: 클라와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다. 암호화: 클라와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다. 효율: 알고리즘은 빨라야 한다. 편재성 Ubiquity: 프로토콜은 거의 모든 클라와 서버에서 지원되어야 한다. 편재성은 자원을 뜻할때 주로 쓰이는 성질이다.자원의 민족주의\u001b. 도처에 존재하는 성질이라고 이해하면 됨 관리상 확장성: 누구든, 어디서든, 즉각적인 보안 통신을 할 수 있어야 한다. 적응성: 현재 알려진 최선의 보안방법을 지원해야 한다. 사회적 생존성: 사회의 문화적, 정치적 요구를 만족시켜야 한다. HTTPS HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다. S는 Over Secure Socket Layer의 약자이다. HTTPS를 사용할 때,모든 HTTP 요청과 응답 데이터는네트워크로 보내지기 전에 암호화 된다. HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층에 의해 동작한다. 이 보안계층은안전소켓계층, (Secure Sockets Layer, SSL)전송 계층 보안(Transport Layer Security, TLS)을 이용하여 구현된다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다.TLS 1.0은 SSL 3.0을 계승한다.하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다. 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에 보안 HTTP를 사용하기 위해, 웹 클라와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다. 디지털 암호학 SSL과 HTTPS에서 이용되는 암호 인코딩 기법에 대해 잠깐 알아본다. 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘 키: 암호의 동작을 변경하는 숫자로 된 매개변수 대칭키 암호 체계: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘 비대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘 공개키 암호법: 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템 디지털 서명: 메세지가 위조 혹은 변조되지 않았음을 입증하는 체크섬 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보 1. 비밀코드의 기술과 과학암호법 cryptography는 메세지 인코딩과 디코딩에 대한 과학이자 기술이다. 비밀 메세지 &#x2F; 도청, 변조 방지 &#x2F; 저자 증명 사람들은 암호법의 방법론을 비밀 메세지를 보내는데에 적용해 왔다. 도청이나 메세지의 변조를 방지하기 위해 사용할 수 있다. 암호법은 누군가가 정말로 어떤 메세지나 트랜잭션의 저자임을 증명하는 데도 사용될 수 있다. 2. 암호 cipher 암호법은 암호라 불리는 비밀코드에 기반한다. 암호란,메세지를 인코딩하는 어떤 특정한 방법과그 비밀 메세지를 디코딩하는 방법이다. 텍스트, 평문: 인코딩 되기 전의 원본 메세지 암호문: 암호가 적용되어 코딩된 메세지 2.1 암호 기계 암호는 상대적으로 간단한 알고리즘으로 시작했는데,사람이 직접 인코딩하고 디코딩해야 했기 때문이다. 기술이 진보하면서, 복잡한 암호로 메세지를 빠르고 정확하게 인코딩하고 디코딩하는기계를 만들기 시작했다. 예_2차 세계대전의 에니그마 암호기계 2.2 키가 있는 암호 코드 알고리즘과 기계가 적의 손에 들어갈 수 있기 때문에,대부분의 기계들에는 암호의 동작방식을 변경할 수 있는큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다. 올바른 다이얼 설정(키 값)이 없이는 디코더가 동작하지 않을 것이다. 이러한 암호 매개변수를 키라고 부른다. key 암호 키는 하나의 암호 기계를여러 가상 암호 기계의 집합처럼 만들어준다. 2.3 디지털 암호 디지털 계산의 도래로, 두가지 발전이 있다 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다. 단일 암호 알고리즘으로 키의 값마다서로 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다. 키가 길수록 인코딩의 많은 조합이 가능해지고,무작위로 추측한 키에 의한 크래킹이 어려워진다. 평문메세지 P, 인코딩 함수 E, 디지털 인코딩 키 e가 주어지면 부호화된 암호문 C를 생성할 수 있다. 암호문 C를 디코더 함수 D와 디코딩 키 d를 사용해서 원래의 평문 P로 도로 디코딩할 수 있다.12C = E(P,e)P = D(C,d) 3. 대칭키 암호법 많은 디지털 암호 알고리즘은 대칭키 암호라고 불림 인코딩을 할 때 사용하는 키가 디보딩을 할 때와 같기 때문 (e &#x3D; d, k라 부르자) 대칭키 암호에서, 발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있다. 발송자는 공유된 비밀 키로 메세지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용한다. 수신자도 암호문을 키를 사용하여 원래의 평문으로 복원한다. 잘 알려진 대칭키 암호 알고리즘 DES(Data Encryption Standard), Triple-DES, RC2, RC4 DES는 취약하다는 결론 &#x3D;&gt; 요즘은 AES를 사용한다. AES, Advanced Encryption Standard: 고급 암호화 표준 3.1. 키 길이와 열거 공격 Enumeration Attack 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다. 무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다. 128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주된다. 미국 국가안보국에서는 긴 키를 사용하는 암호화 소프트웨어의 수출을 통제한다. 깨뜨릴 수 없는 암호문을 적대적인 조직이 만들어 낼 가능성을 차단하기 위해 3.2. 공유키 발급하기 대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다. 만약 누군가 쇼핑몰에서 private 대화를 다누려면 개인 비밀 키가 발급되어야 한다. 관리해야하는 사람 입장에서는 모든 키를 관리해야하므로 복잡성이 올라간다. 3.3. 대칭키 만들어보기12echo &#x27;this is the plain text&#x27; &gt; plaintext.txt;openssl enc -e -des3 -salt -in plaintext.txt -out ciphertext.bin ‘this is the plain text’ 문자열이 들어간 plaintext.txt가 만들어진다 plaintext.txt 안의(-in) 내용들을 des3방식으로 암호화를 하고, ciphertext.bin이라는 파일로 산출할(-out) 것이다 라는 뜻. 비밀번호를 요구하는 input이 나온다. &#x3D;&gt; 요게 대칭키! 이런식으로 암호화된다. 1openssl enc -d -des3 -in ciphertext.bin -out plaintext2.txt; ciphertext.bin 안의 내용을 des3 방식으로 복호화(디코딩)(-d) 하여서 plaintext2.txt 파일에 산출할 것이다 라는 뜻. 4. 공개키 암호법 공개키 암호 방식은 2개의 비대칭 키를 사용한다. 하나는 호스트의 메세지를 인코딩하기 위한 것다른 하나는 그 호스트의 메세지를 디코딩하기 위한 것이다. 인코딩 키는 모두를 위해 공개되어 있다.하지만 호스트만이 개인 디코딩 키를 알고 있다. 키의 분리는, 메세지의 인코딩은 누구나 할 수 있도록 해주는 동시에메세지를 디코딩하는 능력은 소유자에게만 부여한다. 표준화된 공개키 기술 묶음을 만드는 것의 중요성 때문에거대한 공개 키 인프라 표준화 작업이 계속되고 있다.Public-Key Infrastructure, PKI PKI란, 공개 키 암호 방식을 바탕으로 한 디지털 인증서를 활용하는 소프트웨어, 하드웨어, 사용자, 정책 및 제도 등을 총칭하여 일컫는다. 4.1 RSA (Ribest Shamir Adelman) 공개키 비대칭 암호의 과제는,악당이 아래 내용을 알고 있다고 하더라도비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이다. 공개키 가로채서 얻은 암호문의 일부 - 네트워크를 스누핑해서 메세지와 그것을 암호화한 암호문 - 인코더에 임의의 텍스트를 넣고 실행 이 모둔 요구를 만족하는 공개키 암호 체계중 유명한 하나는RSA 알고리즘이다. &#x3D; Ribest Shamir Adelman &#x2F; 발명한 세 명의 이름 첫글자를 따온 이름 4.2 혼성 암호 체계와 세션 키 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다. 예 공개키 암호를 사용하고 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화 할때는 빠른 대칭키를 사용하는 방식 5. 디지털 서명 암호 체계는누가 메세지를 썻는지 알려주고그 메세지가 위조되지 않았음을 증명하기 위해메세지에 서명을 하도록 하는 데에 이용될 수 있다. 디지털 서명 digital signing 이라 불리는 이 기법은인터넷 보안 인증서에게 중요하다. 5.1 서명은 암호 체크섬이다. 디지털 서명은 메세지에 붙어있는 특별한 암호 체크섬이다. 두가지 이점이 있다. 서명은 메세지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에,오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 서명처럼 동작한다. 서명은 메세지 위조를 방지한다. 송신 중에 누군가 메세지를 수정했다면,체크섬은 더 이상 그 메세지와 맞지 않게 될 것이다. 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에침입자는 그 위조된 메세지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다. 디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인 키는 오직 소유자만이 알고 있기 때문에저자의 개인 키는 일종의 지문처럼 사용된다. 예시노드A가 노드B에게 메세지를 보내고, 그것을 서명하는 전체 플로우. 노드 A는 가변 길이 메세지를 정제하여 고정된 길이의 digest로 만든다. 노드 A는 그 digest에 서명 함수를 적용한다. (서명함수: 사용자의 개인 키를 매개변수로 하는 함수) 오직 그 사용자만이 개인 키를 알고 있기 때문에,올바른 서명 함수는 서명자가 소유자임을 보여준다. 서명함수가 이미 개인 키를 입력으로 취했기 때문에 디코더 함수를 사용한다. 한번 서명이 계산되면, 노드 A는 그것을 메세지의 끝에 덧붙이고, 메세지와 그에 대한 설명을 둘다 노드 B에 전송한다. 메세지를 받은 노드 B가, 만약 그 메세지를 쓴 것이 정말로 노드 A이며, 위조되지도 않았다는 것을 확인하길 원한다면, 노드 B는 서명을 검사할 수 있다. 노드 B는 개인 키로 알아보기 어렵게 변형된 서명에공개키를 이용한 역함수를 적용한다. 만약 풀어낸 요약이 노드 B가 갖고 있는 버전의 요약과 일치하지 않는다면, 메세지가 송신 중에 위조되었거나, 아니면 발송자가 노드 A의 개인 키를 갖고 있지 않은 것이다. 6. 디지털 인증서 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다. (디지털 인증서는 흔히 certs라고 불린다.) 여권처럼 신뢰할 수 있는 형태의 신원증명은 서명이 되어있고, 특별한 종이 위에 정부가 새긴 도장이 찍혀있다. 이것들은 위조하기 어렵고, 본질적으로 더 높은 수준의 신뢰를 받게 된다. 6.1 인증서의 내부 디지털 인증서에는 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨있다. 대상자 이름 (사람, 서버, 조직 등) 유효 기간 인증서 발급자 (누가 이 인증서를 보증하는가) 인증서 발급자의 디지털 서명 디지털 인증서는대상과 사용된 서명 알고리즘에 대한 서술적인 정보, 대상의 공개키도 담고 있다. 누구나 디지털 인증서를 만들 수 있지만,(모두가 인증서의 정보를 보증하고인증서의 개인 키로 서명할 수 있는,)널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다. 6.2 X.509 v3 인증서 디지털 인증서에 대한 전 세계적인 단일 표준은 없다. 여러가지 미묘하게 다른 스타일의 디지털 인증서들이 존재한다. 오늘날 사용되는 대부분의 인증서가X.509라 불리는 표준화된 서식에 그들의 정보를 저장하고 있다는 것이다. 공인인증서 대부분은 X.509 인증서 표준을 기반으로 한다. X.509기반 인증서에는웹서버 인증서 &#x2F; 클라 이메일 인증서 &#x2F; 스프트웨어 코드사인 인증서 &#x2F; 인증기관 인증서를 비롯한 몇가지 변종이 있다. X.509 v3 인증서는인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공한다. X.509 위키피디아 설명 버전: 이 인증서가 따르는 X.509 인증서 버전의 번호 (보통은 v3) 일련번호: 인증기관에 의해 생성된 고유한 정수 서명 알고리즘 ID: 서명을 위해 사용된 암호 알고리즘(예_RSA 암호화를 이용한 MD2 digest) 인증서 발급자: 인증서를 발급하고 서명한 기관의 이름(CA: certificate authority) 유효기간: 인증서가 유효한 기간. 시작일과 종료일로 정의 대상의 이름: 인증서에 기술된, 사람이나 조직과 같은 엔터티. 대상의 공개 키 정보: 인증 대상의 공개키, 공개키에 사용된 알고리즘, 추가 매개변수 발급자의 고유 ID: 발급자의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한 식별자 대상의 고유 ID: 대상의 이름이 겹치는 경우를 대비한, 인증 대상에 대한 선택적인 고유한 식별자 확장: 각 확장 필드는 중요한 것인지 그렇지 않은지가 표시되어 있음 기본제약 &#x2F; 인증서 정책 &#x2F; 키 사용 인증기관 서명: 인증기관의 디지털 서명, 명시된 서명 알고리즘을 사용한다. 6.3 서버 인증을 위해 인증서 사용하기 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때,최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다. 서버 인증서는 다음을 포함한 많은 필드를 갖고 있다. 웹사이트의 이름과 호스트 명 웹 사이트의 공개키 서명 기관의 이름 서명 기관의 서명 출처 Network-3:HTTPS란? 브라우저가 인증서를 받으면, 서명 기관을 검사한다. 만약 그 기관이 신뢰할만한 서명 기관이라면,브라우저는 그것의 공개키를 이미 알고 있을 것이며(브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출하된다),브라우저는 그 서명을 검증할 수 있다. 만약 서명 기관이 모르는 곳이라면,브라우저는 그 서명 기관을 신뢰해야 할지 확신할 수 없으므로,대개 사용자가 서명 기관을 신뢰하는지 확인하기 위한대화상자를 보여준다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 AES PKI RSA Network-3:HTTPS란? 생활코딩 - 02. HTTPS와 SSL 인증서 암호학","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"https","slug":"https","permalink":"http://feel5ny.github.io/tags/https/"},{"name":"cryptography","slug":"cryptography","permalink":"http://feel5ny.github.io/tags/cryptography/"},{"name":"X.509","slug":"X-509","permalink":"http://feel5ny.github.io/tags/X-509/"}]},{"title":"다이제스트 인증(2) - 실제 다이제스트 인증과 보안","slug":"HTTP_013_02","date":"2019-12-01T01:43:10.000Z","updated":"2024-11-23T12:12:24.908Z","comments":true,"path":"2019/12/01/HTTP_013_02/","permalink":"http://feel5ny.github.io/2019/12/01/HTTP_013_02/","excerpt":"","text":"점점 번역이 이해하기 더 어려워질 정도로 직역형태다.. 1. 실제 상황에 대한 고려TL;DR 다이제스트 인증 요구 qop: 가장 강력한 인증 매커니즘 선택하기 오류 처리: 400 Bad Request 보호 공간 realm: 일반적으로 원 서버에 의해 할당되는 문자열 URI 다시 쓰기: 프락시는 구문만 고쳐서 URI를 다시 쓰기도 한다 캐시: must-revalidate나 public 1.1 다중 인증 요구 qop 서버는 한 리소스에 대해 여러 인증을 요구할 수 있다. 보통은 WWW-Authenticate에 qop필드에 쉼표로 구분하여 인증방법을 보내준다. 클라는 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다. 다양한 인증 옵션을 제공할 때,클라가 강력한 인증 메커니즘을 지원하지 못한다면, 사용자에게 보안에 대해 경고를 해야 한다. 1.2 오류 처리 다이제스트 인증에서,지시자나 그 값이 적절하지 않거나,요구된 지시자가 빠져있는 경우400 Bad Request 로그를 남기자비밀번호가 반복적으로 실패할 경우,공격자의 비밀번호 추측의 시도가 있을 수 있으므로 로그를 남기는게 좋다. URI 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야한다. (중간 프락시가 변조할 수도 있음) 요청줄에 명시된 리소스는 domain필드에 같이 명시해준다. 1.3 보호 공간 realm 영역 값은, 접근한 서버의 루트 URL과 결합하여, 보호 공간을 정의한다. 영역은 보호 영역의 집합으로 분할할 수 있도록 해준다. (보호 영역으로 따로 구분해둔다..) 번역이해가 어려워서 나름 위 문장대로 이해함..원문: 영역은 서버의 보호된 리소스들을 자신만의 인증제도와 인가 데이터베이스 어느 한쪽 혹은 양쪽 모두를 가진 보호 영역의 집합으로 분할 할 수 있도록 해준다. 영역의 값은 일반적으로 원 서버에 의해 할당되는 문자열이다.(인증 제도에 추가적인 의미를 더한다.) 보호공간은 어떤 자격이 자동으로 적용되는 영역을 결정한다. 이전 요청이 인가되면,같은 자격은 인증제도, 매개변수, 사용자 설정 중 한가지 이상에 의해 정해진 시간 동안 재사용 될 것이다. 보호공간의 구체적인 계산은 인증 메커니즘에 달려있다. 기본 인증 클라는 요청 URI와 그 하위의 모든 경로는같은 보호 공간에 있는 것으로 가정한다. 클라는 이 공간에서 서버로부터의 또 다른 인증 요구를 기다리지 않고, 미리 리소스에 대한 인가를 받을 수 있다. 다이제스트 인증 WWW-Authenticate: domain 필드는보호 공간을 보다 엄밀하게 정의한다. domain 필드는 작은 따옴표로 묶인 URI의 공백으로 분리된 목록이다.1domain = &quot;&#x27;/cart&#x27; &#x27;/main&#x27;&quot; 이 domain 목록의 모든 URI와논리적으로 그 하위에 위치한 모든 URI는같은 보호 공간에 있는 것으로 가정한다. 만약 domain 필드가 없거나 빈 값이라면,인증을 요구하는 서버의 모든 URI는 그 보호 공간에 있는 것이다. 1.4 URI 다시 쓰기 (feat. 프락시) 프락시는가리키는 리소스의 변경 없이구문만 고쳐서 URI를 다시 쓰기도 한다. 예 호스트 명은 정규화괴거나 IP주소로 대체될 수 있다. 문자들은 % escape 형식으로 대체될 수 있다. 특정 원서버로부터 가져오는 리소스에 영향을 주지 않는,타입에 대한 추가 속성이URI의 끝에 붙거나 중간에 삽입될 수 있다. 프락시가URI를 변경할 수 있는 동시에다이제스트 인증은 URI 값의 무결성을 검사하므로다이제스트 인증은 이러한 변경에 의해 실패할 수 있다. 1.5 캐시 어떤 공유가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우,두 Cache-Control 지시자 must-revalidate나 public 중 하나가 응답에 존재하지 않는 한다른 요청에 대해 그 응답을 반환해서는 안된다. 만약 원서버의 응답이 must-revalidate Cache-Control 지시자를 포함한 경우, 캐시는 그 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용할 것이다. 그러나 원 서버가 새 요청을 인증할 수 있도록,우선 그 요청의 헤더를 이용해서 재검사를 수행해야한다. 만약 원서버의 응답이 public Cache-Control 지시자를 포함한 경우,응답 엔터티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환될 수 있다. 2. 보안에 대한 고려사항TL;DR 헤더 부당 변경: 양종단 암호화 &#x2F; 디지털 서명 재전송 공격: 매 트랜잭션마다 유일한 난스값 다중 인증 매커니즘: 가장 강력한 인증 제도만을 유지하는 프락시 서버 사용 사전 공격: 복잡한 비밀번호사용 및 비밀번호 만료 정책 악의적인 프락시와 중간 공격: SSL을 사용하는 것 선택 평문 공격: 선택적 c난스 사용 &#x2F; 만료매커니즘 &#x2F; 강력 비밀번호 비밀번호 저장: - 헤더 부당 변경 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서양 종단 암호화나헤더에 대한 디지털 서명이 필요할 것이다. 재전송 공격 재전송 공격이란, 누군가 어떤 트랜잭션에서 엿들은 인증자격을다른 트랜잭션을 위해 사용하는 것을 말한다. GET 요청에 대한 이슈이긴 하지만POST나 PUT 요청에 대한 재전송 공격에 대해서도 항상 잘 동작하는 예방책은 필수적으로 가지고 있어야 한다. 재전송 공격을 완전히 피할 수 있는 한 방법은매 트랜잭션마다 유일한 난스 값을 사용하는 것이다. 이 구현에서는 매 트랜잭션마다 서버는 유일한 난스를 타임아웃 값과 함께 발급한다. 발급된 난스 값은 그때의 트랜잭션과 주어진 타임아웃 값의 기간 동안만 유효하다. 다중 인증 메커니즘 서버가 다중 인증 제도를 지원할때, 선택지를 제공할 것이다.클라에게 가장 강력한 인증 메커니즘을 선택해야 할 의무가 있는 것은 아니기 때문에,결국 인증의 강도는 선택지 중 가장 약한 것과 같다고 보아야 한다. 클라가 언제나 가능한 한 가장 강력한 인증제도를 선택하면 문제가 해결하면 되지만,현실적으로 불가능하다면,가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하여 해결하는 것이다. 그러나 이런 접근은 오직 모든 클라가 우리가 선택한 강력한 인증 제도를 지원할 수 있다고 알려진 경우에만 실현 가능하다. 사전 공격 dictionary 사전공격은 전형적인 비밀번호 추측 공격이다. 악의적인 사용자는 트랜잭션을 엿들을 수 있고,난스&#x2F;응답 쌍에 대해 (흔히 구할 수 있는) 비밀번호 추측 프로그램을 사용할 수 있다. 크래킹하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는 것과괜찮은 비밀번호 만료 정책 외에는 실질적으로 없다. 악의적인 프락시와 중간 공격 Man in the Middle Attack 리다이렉션 기술과 차단 프락시의 도입으로 사용자는 그의 요청이 프락시를 통과한다는 것조차 눈치 채지 못하고 한다. 만약 이들 프락시 중 하나가 악의적이거나 보안이 허술하다면,클라는 중간자 공격에 취약한 상태가 될 가능성이 있다. 해결할 좋은 방법은 없지만, 가능한 해결책은, 클라가 사용자에게 인증의 강도를 시각적으로 보여주는 것 클라가 언제나 가능한 한 가장 강력한 인증을 선택하도록 설정하는 것 등이 있다. 공격을 방어하는 제일 좋은 방법은 SSL을 사용하는 것이다. 선택 평문 공격 다이제스트 인증을 사용하는 클라는 응답을 생성하기 위해 서버가 제공한 난스를 사용한다. 그러나 악의적인 서버나 프락시가 있을 중간에 있을 경우클라 응답 게산을 하기 위한 난스를 제공할 수 있다.&#x3D; 선택적 평문 공격 미리 계산된 사전 공격- 사전공격과 선택 평문 공격의 조합1. 공격서버는 미리 결정된 난스와 자주 쓰이는 비밀번호들로 응답의 집합을 생성하고, 사전을 만든다.2. 공격 서버&#x2F;프락시는 트래픽을 차단하고 미리 결정된 난스를 클라로 전송하기 시작한다.3. 클라로부터 응답을 받을 때, 공격자는 대응되는 항목을 사전에서 찾는다.4. 대응되는 것이 있으면, 공격자는 특정 사용자의 비밀번호를 손에 넣은 것 자동화된 무차별 대입 공격- 많은 컴퓨터를 동원하여 주어진 범위에서 가능한 모든 비밀번호를 열거한다. 이런 공격으로 인한 위협을 방어하는 방법 서버에서 제공된 난스 대신선택적 c난스 지시자를 사용하여 응답할 수 있도록 한다. 만료 메커니즘이나강력한 비밀번호를 강제하는 정책이 있으면 더 높은 방어가 가능 비밀번호 저장 다이제스트 인증 메커니즘은 사용자 응답을서버 내부에 저장된 것과 비교한다. 비밀번호가 유출되는 문제를 완화하는 몇가지 방법 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다. (?) 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도, 피해를 특정 영역으로 국소화한다. 호스트와 도메인을 포함한 완전한 영역 이름을 이 요구를 만족한다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 RFC7235-realm","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"digest","slug":"digest","permalink":"http://feel5ny.github.io/tags/digest/"},{"name":"authorization","slug":"authorization","permalink":"http://feel5ny.github.io/tags/authorization/"}]},{"title":"다이제스트 인증 (1) - 다이제스트 인증과 특징","slug":"HTTP_013_01","date":"2019-11-24T14:43:10.000Z","updated":"2024-11-23T12:12:24.882Z","comments":true,"path":"2019/11/24/HTTP_013_01/","permalink":"http://feel5ny.github.io/2019/11/24/HTTP_013_01/","excerpt":"","text":"기본 인증은 편리하고 유연하지만, 전혀 안전하지 않다. 메세지를 위조하지 못하게 보호하려는 어떠한 시도도 하지 않는다. 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발되었다. 다이제스트 인증은 널리 쓰이지는 않지만, 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용하다. TL;DR 자세히……. 다이제스트 인증은 그다지 사용되고 있지 않다. 기본 인증의 개선한 다이제스트 인증 좌우명: 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다. 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다. 구현하기에 따라서, 메세지 내용 위조를 막는것도 가능하다. 그 외 잘 알려진 형태의 공격을 막는다. 가장 안전한 프로토콜은 아니다. 공개키 기반 메커니즘과 비교했을 때, 그다지 강력한 인증 매커니즘을 제공하진 않는다. 요청과 응답의 나머지 부분에 대해서는 다른 누군가가 엿보는 것이 가능하다. 안전한 HTTP 트랜젝션을 위한 많은 요구사항을 만족하지 못한다.그러한 요구사항들에는 전송계층 보안 (TLS)와 보안 HTTP(HTTPS)가 더 적합한 프로토콜이다. 다른 인터넷 서비스를 위해 제안된 많은 인기 있는 보안 체계들 보다 더 강력하다 LDAP, CRAM-MD5 언뜻 보면 복잡해서 보안 레벨이 높아보이지만 사실 Hash 알고리즘으로 MD5를 사용하는데,이 MD5는 보안 레벨이 낮기 때문에 미정부 보안 인증 규격인 FIPS인증 에서 인증하고 있지 않다. FIPS 인증에서는 최소한 SHA-1,SHA1-244,SHA1-256 이상의 해쉬 알고리즘을 사용하도록 권장하고 있다. MD5 해쉬의 경우에는 특히나 Dictionary Attack에 취약한데,Dictionary Attack이란, Hash된 값과 원래 값을 Dictionary (사전) 데이터 베이스로 유지해놓고, Hash 값으로 원본 메시지를 검색하는 방식(출처: 조대협의 블로그) 1. 다이제스트 인증의 특징 좌우명: “절대로 비밀번호를 네트워크를 통해 보내지 않는다.” 비밀번호를 보내는 대신,클라는 비밀번호를 비가역적으로 뒤섞은지문 fingerprint 혹은 요약 digest 을 보낸다. 클라 서버 둘다 비밀번호를 알고 있으므로,서버는 클라가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다. 1.1 단방향 요약 요약은 정보 본문의 압축이다. 여기서도 압축의 개념이다. 요약은 단방향 함수로 동작한다. 일반적으로 입력가능한 무한 가지의 모든 입력값들을유한한 범위의 압축으로 변환한다. 인기있는 요약 함수 중 하나인 MD5는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다. MD5: 메세지 다이제스트 #5의 약어SHA 보안 해시 알고리즘: 다른 다이제스트 함수 요약함수는 보통 암호 체크섬 cryptographic checksums으로 불린다. 단방향 해시함수이거나 지문함수이다. MD5 해시 생성기 1.2 재전송 방지를 위한 난스 사용 nonce 요약을 가로채서 서버로 몇번이고 재전송할 수 있기 때문에 안전하지 않다. 재전송 공격을 방지하기 위해 서버는 클라에게 난스라고 불리는자주 바뀌는 (대략 1ms마다, 혹은 인증할 때마다) 증표를 건네준다. 난스를 비밀번호에 섞으면난스가 바뀔 때마다 요약도 바뀌게 만들어준다. 저장된 비밀번호 요약은특정 난스값에 대해서만 유효하고,비밀번호 없이 공격자가 올바른 요약을 계산하는 것은 가능하지 않기 때문이다. 다이제스트 인증은 난스를 사용할 것을 요구한다. 난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라로 넘겨진다. 2. 다이제스트 인증 핸드셰이크 HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는,강화된 버전의 인증이다. 다이제스트 인증의 3단계 핸드셰이크를 보자 1단계 서버는 난스값을 계산한다. 2단계 서버는 난스를 WWW-Authenticate 인증요구 메세지에 담아,서버가 지원하는 알고리즘 목록과 함께 클라에 전송한다. 3단계 클라는 알고리즘을 선택하고, 비밀번호와 그 외 데이터에 대한 요약을 계산한다. 4단계 클라는 Authorization 메세지에 요약을 담아 서버에게 돌려준다. 만약 서버가 인증을 원한다면 난스를 보낼 수 있다. 5단계 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고, 클라가 했던 그대로 요약을 계산한다. 서버는 그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인한다. 만약 클라가 대칭적으로 서버에게 클라 난스를 갖고 인증을 요구했다면,클라 요약이 만들어진다. 서버는 클라가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라에게 넘겨줄 수도 있다. 3. 요약 계산 다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다. RFC7616 2617 3.1 요약 알고리즘과 입력 데이터요약은 다음 3가지 요소로부터 계산된다.A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리됨 action: 함수들 단방향 해시 함수 H(d) 요약 함수 KD(s,d) &#x2F;&#x2F; s는 비밀, d는 data core: 데이터 보안정보 데이터- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 (A1이라 칭하자) 요청메세지의 비밀 외의 속성 데이터- 요청 메세지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리 (A2이라 칭하자) 보안 관련 데이터 A1 A1 데이터에는사용자 이름 &#x2F; 비밀번호 &#x2F; 보호 영역 &#x2F; 난스가 포함된다. “&lt;알고리즘&gt;”인 경우 (예 : “SHA-256”),A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다.1A1 = &lt;사용자&gt;:&lt;영역&gt;:&lt;비밀번호&gt; &lt;알고리즘&gt; -sess인 경우 (예 : “SHA-256-sess”),A1은 서버의 인증 요청에 제공된 nonce 값과 다음 클라이언트 요청의 cnonce 값을 사용하여 계산됩니다12A1 = H( unq(username) &quot;:&quot; unq(realm) &quot;:&quot; passwd ) &quot;:&quot; unq(nonce-prime) &quot;:&quot; unq(cnonce-prime) 메세지 관련 데이터 A2 A2 데이터에는 메세지 자체의 정보를 나타냄URL &#x2F; 요청메서드 &#x2F; 메세지 엔터티 본문 메서드, 리소스, 메세지의 위조를 방지하기 위해 사용됨 RFC7616 2617은 **선택된 보호 수준 (quality of protection, qop)**에 따른A2의 두가지 사용법을 정의하고 있다. HTTP 요청 메서드와 URL만 포함하는 것이다. 이것은 기본값이기도한 qop&#x3D;”auth”일 때 사용된다. 1A2 = Method &quot;:&quot; request-uri 메세지 무결성 검사를 제공하기 위해 메세지 엔터티 본문을 추가하는 것 qop&#x3D;”auth-init”일 때 사용된다. 1A2 = Method &quot;:&quot; request-uri &quot;:&quot; H(entity-body) H와 KD 알고리즘 다이제스트 인증은 여러가지 요약 알고리즘을 선택할 수 있도록 지원한다. MD5와 MD5-sess, SHA-256 등이 있다. 123// 개인적으로 빠른 인지를 위해 자바스크립트 문법 사용KD = (비밀, 데이터) =&gt; H(연결(비밀:데이터)) // 요약 함수H = (데이터) =&gt; MD5(데이터) // 해시함수 요약 알고리즘 전반RFC7616 2617은 주어진 H, KD, A1, A2로 요약을 계산하는 방법에는,**난스 횟수 집계(nc) 및 대칭 인증의 지원(qop)**을 포함한다. 123456response = &lt;&quot;&gt; &lt; KD ( H(A1), unq(nonce) &quot;:&quot; nc &quot;:&quot; unq(cnonce) &quot;:&quot; unq(qop) &quot;:&quot; H(A2) ) &lt;&quot;&gt; 3.2 다이제스트 인증 세션 어떤 보호 공간을 위한 WWW-Authenticate 인증요구에 대한 클라 응답은,그 보호 공간에 대해 인증 세션을 시작하게 한다. 보호 공간은 접근 중인 서버의 루트(canonial root)와 영역의 결합으로 정의된다. (?) 무슨말이지 인증세션은 클라가 보호공간의 다른 서버로부터 또 다른 WWW-Authenticate 인증요구를 받을 때까지 지속된다. 클라는 아래 값들을 기억해야한다.사용자 이름, 비밀번호, 난스, 난스 횟수, 인증세션과 관련된 알아보기 힘든 값들 난스가 만료되면,서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고,오래된 Authorization 헤더 정보를 받아들이는 것을 택할 수 있다.아니면 서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다. 이때 응답 헤더의 WWW-Authenticate에 stale=true로 정의함으로써,서버는 클라에게 사용자 이름과 비밀번호를 새로 입력하도록 창을 띄울 필요 없이새 난스 값으로 요청을 다시 보내라고 말해줄 수 있다. 3.3 사전 인가 preemptive 일반적인 인증에서는, 각 요청은 트랜잭션이 완료되기 전에요청&#x2F;인증 요구 사이클을 필요로 한다. 만약 클라가 다음 난스가 무엇이 될지 미리 알고 있어서,서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면,이 요청&#x2F;인증요구 사이클은 생략할 수 있다. 브라우저는 흔히 사용자 이름과 비밀번호 들에 대한 클라 측 데이터베이스를 관리한다. 사용자가 어떤 사이트에 한번 인증을 하면,브라우저는 흔히 그 URL에 대한 다음번 요청 때 올바른 Authorization 헤더를 전송한다. 다이제스트 인증에서 사전 인가는 약간 더 복잡한데,왜냐하면 난스 기술은 재전송 공격을 저지하기 위한 것이기 때문에다. 서버는 임의의 난스를 생성하기 때문에,인증요구를 받기 전에는 클라가 무엇이 올바른 Authorization 헤더인지 알 방법이 없다. 다이제스트 인증은 여러 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇 가지 방법을 제안한다. 클라가 새 WWW-Authenticate 인증요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법이 몇가지 있다. 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다. 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다. 클라가 서버와 동기화되어 있고 예층 가능한 난스 생성 알고리즘을 사용한다. 1. 다음 난스 미리 생성하기 서버는 Authentication-Info 성공헤더를 통해 다음 난스 값을 미리 제공할 수 있다.1Authentication-Info: nextnonce=&quot;&lt;난스 값&gt;&quot; 주어진 다음 난스로 클라는 Authorization 헤더를 미리 만들어 둘 수 있다. 장&#x2F;단점 장점: 트랜잭션 속도 향상 단점: 다음요청 보내기 전에 반드시 다음 난스 값을 받아야하기 때문에다중요청을 파이프라이능하는 능력은 실질적으로 쓸모없어진다.(?) 파이프라이닝은 회전지연 latency 회피를 위한 기반 기술이기 때문에 성능상 불이익은 더 커진다. 2. 제한된 난스 재사용 난스를 제한적으로 재사용하는 것이다. 예) 서버는 한 난스를 5번만 사용가능하게한다. 예) 서버는 한 난스를 10초간 재사용하도록 허가한다. 클라는 난스를 미리 알 수 있으므로, 자유롭게 Authorization 헤더와 함께 요청을 발행하여 파이프라이닝 할 수 있다. 난스가 만료되면 서버는 서버에게 401 Unauthorized 인증요구를 보낼 것이다.(WWW-Authenticate에 stale=true로 정의) 장&#x2F;단점 단점: 공격자의 재전송 공격이 성공하기 쉬워지므로 보안성이 감소된다. 3. 동기화된 난스 생성 제 3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서클라와 서버가 순차적으로 같은 난스를 생성할 수 있도록시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다. 3.4 nonce 어떻게 사용할까 선택. 난스의 내용은 불투명하고 구현 의존적이다. 12// RFC 7616 기준BASE64(time-stamp H(time-stamp &quot;:&quot; ETag &quot;:&quot; secret-data)) 타임스탬프는 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값이면 된다. ETag는 요청된 엔터티에 대한 ETag 헤더값 비밀 데이터는 서버만 알고 있는 데이터 서버는 클라 인증 헤더를 받은 뒤,위 공식에서 해시 부분을 재계산 해보고 클라 인증 헤더의 난스와 일치하지 않거나 타임스탬프가 오래되었다면, 요청을 거절한다. 이 방법에서 서버는 난스의 유효 기간을 제한할 수 있다. 재전송 공격을 방지하기 위해, 어떤 구현은 이전에 사용된 난스나 요약을 받아들이지 않도록 결정할 수 있다. 혹은 POST나 PUT 요청을 위해 일회성 난스나 요약을 사용하고GET 요청을 위해 타임스탬프를 사용할 수도 있다. 3.5 상호 인증 서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록,클라 난스(c난스) 값을 제공함으로써 가능해진다. 이후 서버는 이 요약을 Authentication-Info 헤더를 통해 클라에 전달한다. 4. 보호 수준 향상 Quality of Protection qop 필드는 클라와 서버가어떤 보호 기법을어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다. 서버는 우선 WWW-Authenticate 헤더에 qop 옵션을 수비표로 구분된 목록 형태로 내보낸다. 클라는 그 옵션들 중 지원할 수 있으면서 동시에 자신의 요구에도 맞는 것을 선택하고 Authorization 헤더의 qop 필드에 담아 돌려준다. 인증을 의미하는 auth 와메세지 무결성 보호를 의미하는 auth-init이 있다. 메세지 무결성 보호 auth-init 무결성 보호가 적용되었을 때 계산되는 **H(엔터티 본문)**은, 메세지 본문의 해시가 아닌 엔터티 본문의 해시이다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 API 보안 RFC7616 조대협의 블로그","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"digest","slug":"digest","permalink":"http://feel5ny.github.io/tags/digest/"},{"name":"authorization","slug":"authorization","permalink":"http://feel5ny.github.io/tags/authorization/"}]},{"title":"기본 인증","slug":"HTTP_012_01","date":"2019-11-23T11:23:55.000Z","updated":"2024-11-23T12:12:24.908Z","comments":true,"path":"2019/11/23/HTTP_012_01/","permalink":"http://feel5ny.github.io/2019/11/23/HTTP_012_01/","excerpt":"","text":"TL;DR 인증 🔐 완벽한 인증이란 없다. 비밀번호는 유출될수있고, 신분증은 위조될 수 있다. 하지만 당신에 대한 여러 데이터는 당신이 누구인지 판단하는데 도움이 된다. 1.1 HTTP의 인증요구&#x2F;응답 프레임워크 HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구&#x2F;응답 프레임워크를 제공한다. 웹앱이 HTTP 요청 메세지를 받으면,서버는 요청을 처리하는 대신에,현재 사용자가 누구인지를 알 수 있게 비밀번호 같이,개인정보를 요구하는 인증요구로 응답할 수 있다. 사용자가 다시 요청을 보낼때는 인증정보를 첨부해야한다. 인증 정보가 맞지 않으면 서버는 클라에 다시 인증요구를 보내거나 에러를 낼 수 있다. 1.2 인증 프로토콜과 헤더 HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해,다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다. HTTP에는 기본인증 다이제스트 인증 이라는 두가지 공식적인 인증 프로토콜이 있다. 미래에는, 사람들이 HTTP 인증요구&#x2F;응답 프레임워크를 사용해 새로운 프로토콜을 고안해 낼 수 있을 것이다. 현대에 HTTP의 인증요구&#x2F;응답 프로토콜을 사용하는 인증 프로토콜로는 OAuth가 있다.OAuth는 모바일 기기같은 다양한 어플리케이션에서 API 인증을 위해 사용하는 최신 인증 프로토콜이다. (RFC6749) 요청 단계 - 인증정보 없음 인증 요구 - 401과 함께 요청 반려. WWW-Authenticate 헤더에 해당 영역을 설명해 놓는다. 인증 단게 - Authorization 헤더를 함께 보냄 성공 단계 - 성공 1WWW-Authenticate: Basic realm=&quot;Access to the staging site&quot; 1.3 보안영역 HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 알아보자. 웹 서버는 기밀문서를 보안 영역 realm 그룹으로 나눈다. 보안 영역을 저마다 다른 사용자 권한을 요구한다. 1. 기본 인증 👮‍♀️ 기본 인증은 가장 잘 알려진 HTTP 인증 규약이다. 거의 모든 주요 클라와 서버에 기본 인증이 구현되어 있다. 기본인증에서, 웹 서버는 클라의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다. 서버는 401 상태코드와, 클라가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 응답하여, 인증요구를 시작한다. 1.1 Base-64 사용자 이름&#x2F;비밀번호 인코딩 🧞‍♂️ HTTP 기본 인증은사용자 이름과 비밀번호를 콜론:으로 이어서 합치고,base-64 인코딩 메서드를 사용해 인코딩한다. cf__1 Base-64 인코딩 base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환한다.각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택된다. base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터를 문자열로 받아서 전송할 수 있게,그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. base-64 인코딩은 국제 문자나 HTTP 헤더에서 사용할 수 없는 문자(큰따옴표, 콜론, 캐리지 리턴)을 포함한 사용자 이름이나 비밀번호를 보내야할 때 유용할 수 있다. 1.2 프락시 인증 🐝 중개 프락시 서버를 통해 인증할 수도 있다. 프락시 서버에서 접근 정책을 중앙 관리할 수 있는 장점이 있음 상태코드: 407 Proxy-Authenticate (like WWW-Authenticate) Proxy-Authorization (like Authorization) 1.3 기본 인증의 보안 결함 🤦‍♀️ 기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나,SSL 같은 암호 기술과 혼용한다. 1. 누구나 디코딩할 수 있다. 기본인증은 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다. 메모하기 어렵지 않은 일반 문자열로 보내진다. base-64로 인코딩된 비밀번호는 사실상 비밀번호 그대로 보내는 것과 다름없다. HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좃다. 2. 재전송 공격을 예방하지 않는다. 복잡한 방식으로 인코딩 되어있더라도, 해당 인코딩 문자열을 캡쳐한 다음,그대로 원 서버에 보내서 인증을 성공하고 서버에 접근할 수 있다. 기본인증은 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다. 3. 한번 뚫리면.. 사용자는 대부분의 사이트에 같은 아이디와 비밀번호를 사용한다. 한번 도용되면 중요한 사이트에서도 접근할 수 있다. 4. 기본인증의 정상동작 보증 못함메세지의 인증헤더를 건드리지는 않지만,그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는프락시나 중개자가 중간에 개입하는 경우,기본 인증은 정상적인 동작을 보장하지 않는다. 5. 가짜 서버 기본인증은 가짜 서버의 위장에 취약하다. 가짜 서버에 연결되어 있지만, 사용자는 검증된 서버에 연결되어있다고 믿고, 개인정보를 노출할 수 있다. 기본인증은 다른 사람들이 보지 않기를 원하긴 하지만,보더라도 치명적이지 않은 경우에는 여전히 유용하다.기본 인증보다 더 복잡하고 강력한 보안 관련 속성인 다이제스트 인증을 다음 포스팅에서 알아보자. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 Oauth와 춤을 Oauth1 관련 글 RFC6749 HTTP 인증","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"authentication","slug":"authentication","permalink":"http://feel5ny.github.io/tags/authentication/"}]},{"title":"쿠키 🍪","slug":"HTTP_011_02","date":"2019-11-16T14:23:55.000Z","updated":"2024-11-23T12:12:24.908Z","comments":true,"path":"2019/11/16/HTTP_011_02/","permalink":"http://feel5ny.github.io/2019/11/16/HTTP_011_02/","excerpt":"","text":"현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어 한다.개인화를 하는 방법은 여러 가지가 있다. 개별 인사 &#x2F; 사용자 맞춤 추천 &#x2F; 저장된 사용자 정보 세션 추적: 웹사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다. 사용자 식별 관련 정보를 전달하는 HTTP 헤더 IP 주소로 사용자를 식별 사용자 로그인 인증을 통한 사용자 식별 URL에 식별자를 포함하는 뚱뚱한 URL 식별 정보를 지속해서 유지하는 쿠키 쿠키 🍪 쿠기는 사용자를 식별하고 세션을 유지하는 방식 중 현재까지 가장 널리 사용하는 방식이다. 쿠키는 넷스케이프가 최초로 개발했지만, 지금은 모든 브라우저에서 지원한다. 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱 하지 않는다. 1. 💁‍♀️ 쿠키의 타입 type 출처 세션 쿠키와 지속 쿠키의 차이점은 파기되는 시점뿐이다. 쿠키는 Discard 파라미터가 설정되어 있거나,Expires, Max-Age같은 파기되기까지의 남은 시간을 표현하는 파라미터가 없으면 세션 쿠키가 된다. 세션 쿠키 session cookie 사용자가 사이트를 탐색할 때,관련한 설정과 선호 사항들을 저장하는 임시 쿠키다. 세션 쿠키는 사용자가 브라우저를 닫으면 삭제된다. 지속 쿠키 persistent cookie 삭제되지 않고 더 길게 유지될 수 있다. 지속 쿠키는 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다. 지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한설정 정보나 로그인 이름을 유지하려고 사용한다. Secure cookie 암호화된 연결 HTTPS로만 전송할 수 있다. Secure 플래그를 추가해서 생성하며,HTTPS로 전송하기 때문에 쿠키를 열어보는 걸 방지할 수 있다. Http-only cookie 자바스크립트 같은 클라이언트 사이드 API를 통해 접속할 수 없는 쿠키이며, XSS 위협을 없애준다. cross-site tracing(XST)와cross-site request forgery(XSRF) 공격에 공격받기 쉽다. HTTPOnly 플래그를 쿠키에 추가하여 생성한다. Same-site cookie 구글 크롬 버전 51에서 새로 소개된 쿠키이다. 쿠키를 생성한 도메인과 같은 출처일 때만 쿠키를 전송한다. third-party cookie 현재 방문하고 있는 사이트가 아닌 다른 사이트의 쿠키 광고와 같은 외부 웹사이트의 컨텐츠가 있을 때 생성되며이 쿠키를 이용하여 사용자를 추적하고, 광고를 제공하는 데 사용한다. 좀비 cookie 쿠키에 대한 좀 더 급진적인 해결책은삭제 이후에 다시 생성되는 좀비 쿠키 혹은 “Evercookies” 의도적으로 영원히 제거하는 것이 어려운 쿠키이다. 그들은 쿠키가 존재 여부와 관계없이 그들 자신을 다시 만들어내기 위해 웹 스토리지 API, Flash 로컬 공유 객체 그리고 다른 기술들을 사용하고 있다. 2. 🧐 쿠키는 어떻게 동작하는가 HOW 쿠키는 서버가 사용자에게 붙이는 스티커와 같다. 사용자가 웹 사이트에 반문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다. 처음에 사용자가 웹사이트에 방문하면, 웹 서버는 사용자에 대해서 아무것도 모른다. 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다. 쿠키는 임의의 이름=값 형태의 리스트를 가지고,그 리스트는 Set-Cookie 혹은 Set-Cookie2 같은 HTTP응답 헤더에 기술되어 사용자에게 전달한다. 참고 Set-Cookie2은 더 이상 사용되지 않는다. 쿠키는 어떤 정보든 포함할 수 있지만, 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다. 서버는 이 쿠키 값으로 DB에서 사용자의 정보를 찾는데 사용할 수 있다. 브라우저는 서버로 온 Set-Cookie 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 DB에 저장한다. 사용자가 미래에 같은 사이트를 방문하면,브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie요청 헤더에 기술해 전송한다. 그니까 쿠키는 어떻게 동작? 정리 유저가 서버에 페이지를 요청한다. 서버에서 응답과 함께 Set-Cookie 헤더를 전송한다. 브라우저(User Agent)가 Set-Cookie 헤더에서 전달된 값을 갖고 쿠키를 생성해서 (브라우저에) 저장한다. 이렇게 생성된 쿠키는 클라가 서버에 요청할 때마다 브라우저가 같이 전송해준다. 3. ⏳쿠키 상태 관리3.1 클라이언트 측 상태 쿠키의 기본적인 발상은브라우저가 서버 관련 정보를 저장하고,사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다. 브라우저는 쿠키 정보를 저장할 책임이 있다.&#x3D; 클라이언트 측 상태&#x3D; HTTP 상태 관리체계 (HTTP State Management Mechnism) 각 브라우저는 각기 다른 방식으로 쿠키를 저장한다. 3.2 Domain 별 쿠키 상태 관리 브라우저는 수백수천 개의 쿠키를 가지고 있을 수 있지만,브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다. 브라우저는 보통 각 사이트에 2개 혹은 3개의 쿠키만 보낸다. 🔥 쿠키를 모두 전달하면 성능이 크게 저하된다. 쿠키를 모두 전달하면, 브라우저는 실제 콘텐츠의 바이트보다 더 많은 쿠키 바이트를 전달하게 될 것이다. 🤷‍♂️ 해당 도메인과 상관없는 쿠키를 보내면 무의미하다. 이 쿠키들은 대부분은 서버에 특화된 이름&#x2F;값 쌍을 포함하고 있기 때문에,대부분 사이트에서는 인식하지 않는 무의미한 값이다. 모든 사이트에 쿠키 전체를 전달하는 것은,특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서,잠재적인 개인 정보 문제를 일으킬 것이다. 보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다. 쿠키는 일종의 상태 정보라고 할 수 있으며 서버가 생성하여 클라에 전달하고 클라는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리한다. 많은 웹 사이트는 광고를 관리하는 협력업체와 계약을 한다. (third-party 쿠키) 이 광고들은 웹사이트 자체의 일부인 것처럼 제작되고, 지속 쿠키를 만들어낸다. 같은 광고사에서 제공하는 서로 다른 웹사이트에 사용자가 방문하면,브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송한다. 광고사는 이 기술에 Referer헤더를 접목하여,사용자의 프로필과 웹사이트를 사용하는 습관에 대한 방대한 데이터를 구축할 수 있다. 쿠키 Domain 속성 서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에Domain 속성을 시술해서, 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다. 도메인에 해당하는 사이트를 방문하면 Cookie 헤더가 항상 적용될 것이다. 아래 브라우저에 저장되어 있던 쿠키 내용을 해당 도메인과 같을 경우 요청 헤더의 Cookie에 포함시킨다. 쿠키 Path 속성 웹 사이트 일부에만 쿠키를 적용할 수 있다. HTTPs://www.google.com/ + /search/search 여기에만 해당하는 쿠키! 4. 🧩 쿠키 구성요소 현재 사용되는 쿠키 명세에는Version0 쿠키 (&#x3D; 넷스케이프 쿠키)Version1 쿠키 (RFC 2965 &#x3D;&gt; RFC 2965 &#x3D;&gt; RFC 6265) Version1 쿠키는 Version0 쿠키의 확장으로널리 쓰이지는 않는다. Version0과 Version1 쿠키 명세 모두 HTTP&#x2F;1.1 명세 일부로 기술되어 있지는 않는다. Version 01. Set-Cookie 헤더 Set-Cookie 헤더는 쿠키의 이름과 값을 가져야 한다. 이는 쿠키 옵션 속성들에 ;으로 이어 기술한다. 이름=값: 필수 값 Expires: 선택적인 속성. 쿠키의 생명주기를 가리키는 날짜 문자열 요일, DD-MM-YY HH:MM:SS GMT 사용할 수 있는 타임존은 GMT 쿠키에 Expires를 명시하지 않으면 그 쿠키는 사용자의 세션이 끝날 때 파기될 것이다. Domain: 선택적인 속성. 브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송한다. 이는 서버가 해당 도메인에만 쿠키를 제한적으로 전달하게 한다. 도메인이 명시되어 있지 않으면, Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 사용한다. Path: 선택적인 속성. 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다. /foo경로는 /foobar와 /foo/bar.html에 들어맞는다. /는 모든 것에 들어맞는다. 경로를 명시하지 않으면, Set-Cookie 응답을 전달하는 URL의 경로가 사용된다. Secure: 선택적인 속성. 쿠키는 HTTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송한다. HttpOnly: HttpOnly는 쿠키의 범위를 HTTP 요청으로 제한한다.HttpOnly가 설정된 경우 클라이언트 사이드 API로는 쿠키에 접근하지 못한다. 2. Cookie 헤더 클라가 서버에 요청을 보낼 때는, Domain, Path, Secure 필터들이 현재 요청하려고 하는 사이트에 들어맞으면서, 아직 파기되지 않은 쿠키들을 함께 보낸다. Cookie 헤더에 이어 붙여서 보낸다. Version 1 쿠키 버전 1은 RFC 2109를 뜻한다. RFC 2109는 기존 넷스케이프 쿠키의 스펙을 체계적으로 정리하고 수정하려고 시도한 것 Version0 쿠키 속성은 Name, Value, Expires, Domain, Path, Securer가 있다. Version1 쿠키 속성은 Name, Value, Comment, Domain, Max-Age, Path, Secure, Version이 있다. Comment: 서버가 쿠키의 용도를 기록해두기 위한 속성 Version: 쿠키가 어떤 명세서를 따르는지 버전을 나타낸다. RFC 6265와 RFC 2109 쿠키의 차이 RFC 6265가 나오면서 RFC 2109, RFC 2965는 폐기 둘디 Set-Cookie 헤더를 사용합니다. RFC 2109는 Name, Value, Comment, Domain, Max-Age, Path, Secure, Version RFC 6265는 Name, Value, Expires, Domain, Max-Age, Path, Secure, HttpOnly Max-Age를 설정하면 자동으로 Expires가 정해진다. HTTPOnly: 비 HTTP 요청을 막는다. 구현 고려 사항 RFC 2109는 유저 에이전트가 최소 300개의 쿠키,쿠키마다 적어도 4096바이트,한 호스트나 도메인마다 최소 20개를 지원해야 한다. RFC 6265는 유저 에이전트가 최소 3000개의 쿠키쿠키마다 적어도 4096바이트,도메인 당 최소 50개의 쿠키를 저장 가능해야 한다고 명시. Set-Cookie2 헤더Cookie2 헤더Set-Cookie2와 Cookie2 헤더는 더 이상 사용되지 않으므로 패스 5. 👀 쿠키 목적별 사용 쿠키는 웹사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다. 5.1 쿠키와 세션 추적Amazon.com의 예를 통해 살펴보자. 브라우저가 Amazon.com의 루트 페이지를 처음 요청한다 12GET / HTTP/1.0Host: www.amazon.com 서버는 클라를 전자상거래 소프트웨어 URL로 리다이렉트 시킨다. 12HTTP/1.1 302 FoundLocation: http://www.amazon.com:80/exec/abidos/subst/home/redirect.html 클라는 리다이렉트 URL로 요청 보낸다. 12GET /exec/abidos/subst/home/redirect.html HTTP/1.0 302 FoundHost: http://www.amazon.com 서버는 응답에 두 개의 세션 쿠키를 기술하고 (Set-Cookie &#x3D; 요 쿠키 브라우저에 넣어두세요) 사용자를 다른 URL로 리다이렉트 시키며 클라는 다시 이 쿠키들을 첨부하여 요청을 보낸다.(Cookie) 새로운 URL(http://www.amazon.com/exec/abidos/subst/home/redirect.html/002-1135265-8016838)은 자체에 상태 정보를 갖고 있으므로 &#x3D; 뚱뚱한 URL 1234HTTP/1.1 302 FoundDate: Sun, 02 Dec 2001 03:20:47 GMTSet-Cookie: session-id=002-1135265-8016838; path=/; domain=.amazon.com; expires=Suday, 09-Dec-2001 08:00:00 GMTSet-Cookie: session-id-time=1007884800; path=/; domain=.amazon.com; expires=Suday, 09-Dec-2001 08:00:00 GMT 클라는 새로운 URL을 요청을 요청받았던 두 개의 쿠키와 함께 보낸다. 123GET /exec/abidos/subst/home/redirect.html/002-1135265-8016838 HTTP/1.0Host: http://www.amazon.comCookie: session-id=002-1135265-8016838; session-id-time=1007884800 서버는 home.html 페이지로 리다이렉트 시키고, 쿠키 두 개를 더 첨부한다. 12345HTTP/1.1 302 FoundDate: Sun, 02 Dec 2001 03:45:40 GMTSet-Cookie: ubid-main=430-8248051-6231206; path=/; domain=.amazon.com; expires=Tuesday, 09-Dec-2001 08:00:00 GMTSet-Cookie: x-main=hQ...Bf; path=/; domain=.amazon.com; expires=Tuesday, 09-Dec-2001 08:00:00 GMTLocation: http://www.amazon.com/exec/abidos/subst/home/home.html/002-1135265-8016838 클라는 home.html 페이지를 가져오고, 총 4개의 쿠키를 전달한다. 123GET /exec/abidos/subst/home/home.html/002-1135265-8016838 HTTP/1.0Host: http://www.amazon.comCookie: session-id=002-1135265-8016838; session-id-time=1007884800; ubid-main=430-8248051-6231206; x-main=hQ...Bf 서버는 콘텐츠를 보낸다. 쿠팡 첫 화면 진입 시 진행되는 광고 솔루션 크리테오 세션 추적 과정 중 일부 6. 👮‍ 쿠키 사용 시 주의사항6.1 쿠키와 캐싱 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나,누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수도 있다. 캐시 되지 말아야 할 문서가 있다면 표시하라 Control: no-cache=&quot;Set-Cookie&quot; Set-Cookie 해더를 캐시 하는 것에 유의하라 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면 사용자 추적에 실패할 것이기 때문 어떤 캐시는 응답을 저장하기 전에 Set-Cookie 헤더를 제거하기 때문에, 그 캐시 데이터를 받은 클라는 Set-Cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다. 캐시가 모든 요청마다 원 서버와 재검사시켜 클라로 가는 응답에 Set-Cookie 헤더 값을 기술하여 이 문제를 개선할 수 있다. (참고)1Cache-Control: must-revalidate, max-age=0 Cookie 헤더를 가지고 있는 요청을 주의하라 클라 요청에 Cookie 헤더가 함께 오면,결과 콘텐츠가 개인 정보를 담고 있을 수도 있다는 힌트다. 개인 정보는 캐시 되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있다. 보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 가는 문서는 캐시 하지 않을 것이다. 6.2 쿠키, 보안 그리고 개인 정보 쿠키를 사용하지 않도록 비활성화 시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것도 가능하므로, 그 자체가 보안상으로 엄청나게 위험한 것은 아니다. 원격 DB에 개인 정보를 저장하고,해당 데이터의 키값을 쿠키에 저장하는 방식을 표준으로 사용하면,클라와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있다. 쿠키에 대한 부정적인 여론이 많기는 하지만,제공하는 개인 정보를 누가 받는지 명확히 알고, 사이트의 개인 정보 정책에만 유의한다면, 쿠키에 관련한 위험성보다세션 조작이나 트랜잭션 상의 편리함이 더 크다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 mdn 쿠키글 HTTP 쿠키와 톰캣 버전별 이슈 RFC 6265","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"cookie","slug":"cookie","permalink":"http://feel5ny.github.io/tags/cookie/"}]},{"title":"클라이언트 식별","slug":"HTTP_011_01","date":"2019-11-15T14:23:55.000Z","updated":"2024-11-23T12:12:24.919Z","comments":true,"path":"2019/11/15/HTTP_011_01/","permalink":"http://feel5ny.github.io/2019/11/15/HTTP_011_01/","excerpt":"","text":"현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어한다.개인화를 하는 방법은 여러 가지가 있다. 개별 인사 &#x2F; 사용자 맞춤 추천 &#x2F; 저장된 사용자 정보 세션 추적: 웹사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다. 사용자 식별 관련 정보를 전달하는 HTTP 헤더 IP 주소로 사용자를 식별 사용자 로그인 인증을 통한 사용자 식별 URL에 식별자를 포함하는 뚱뚱한 URL 식별 정보를 지속해서 유지하는 쿠키 1. HTTP 헤더 From (요창): 사용자 이메일 주소 User-Agent (요청): 사용자의 브라우저 Referer (요청): 사용자가 현재 링크를 타고 온 근원 페이지 From 사용자의 이메일 주소를 포함한다. 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From 헤더를 보내는 브라우저는 많지 않다. 로봇이나 스파이더는 데이터를 수집하는 과정에서본의 아니게 웹 사이트에 문제를 일으켰을 때, 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 From 헤더에 이메일 주소를 기술한다. User-Agent 사용자가 쓰고 있는 브라우저의 이름과 버전 정보 운영체제에 대한 정보까지 포함하여 서버에게 알려준다. 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다. Referer 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다. 사용자의 웹 사용 형태나 사용자이 취향을 더 잘 파악할 수 있다.(?) 2. 클라이언트 IP 주소 초기 웹 선구자들은 사용자 식별에 클라이언트 IP 주소를 사용하려 했다. 주소가 좀처럼 바뀌지 않고, 웹 서버가 요청마다 클라의 IP를 알 수 있다면 문제없이 동작한다. 웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다. 이 방식을 제대로 동작하지 않아서 사용하지 않는다. 단점 IP 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킨다.즉, 여러 사용자가 같은 컴퓨터를 사용하면 식별할 수 없다. ISP(인터넷 서비스 제공자)는 사용자가 로그인하면 동적으로 IP 주소를 할당한다.로그인 시간에 따라 사용자는 매번 다른 주소를 받으므로, 웹 서버는 사용자를 IP 주소로 식별할 수 없다. 보안을 강화하고, 부족한 주소를 관리하려고 많은 사용자가 네트워크 주소 변환 방화벽을 통해 인터넷을 사용한다. (Network Address Translation, NAT) 이 NAT 장비들은 클라의 실제 IP 주소를 방화벽 뒤로 숨기고,클라의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP 주소로 변환한다. HTTP 프락시와 게이트웨이는 원서버에 새로운 TCP 연결을 한다.웹 서버는 클라 IP 주소 대신 프락시 서버 IP 주소를 본다. 일부 프락시는 원본 IP 주소를 보존하려고 Client-ip나 X-Forwarded-For같은 확장 헤더를 추가하여 이 문제를 해결하려 했다. X-Forwarded-ForHTTP 프록시나 로드 밸런서를 통해 웹 서버에 접속하는 클라이언트의 원 IP 주소를 식별하는 사실상의 표준 헤더다. 모든 프락시가 이런 식으로 동작하진 않는다. 3. 사용자 로그인 인증 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서, 사용자에게 명시적으로 식별 요청을 할 수 있다. 웹 사이트 로그인이 더 쉽도록 WWW-Authenticate와 Authorization헤더를 사용해 웹 사이트에 사용자 이름이 전달하는 자체적인 체계를 가지고 있다. WWW-Authenticate AuthorizationHTTP Authorization 요청 헤더는 서버의 사용자 에이전트임을 증명하는 자격을 포함하여, 보통 서버에서 401 Unauthorized 상태를 WWW-Authenticate 헤더로 알려준 이후에 나옵니다. 한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로, 웹서버느 그 로그인 정보는 항상 확인할 수 있다. 서버에서, 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 HTTP 401 Unauthorized 응답코드를 브라우저에 보낼 수 있다. www.joy.com 사이트로 요청 사용자의 식별 정보를 알지 못하므로 401 Unauthorized 코드를 내리고, WWW-Authenticate헤더를 반환하여 로그인하라고 요청한다. 로그인 후 Authorization헤더에 토큰을 포함하여 전송하여, 사용자 식별을 시도한다. 한번만 로그인하면, 브라우저는 요청마다 해당 사용자의 식별 토큰을 Authorization헤더에 담아서 서버로 전송해서, 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지한다. 4. 뚱뚱한 URL 사용자의 URL마다 버전을 기술하여 사용자를 식별하고, 추적하였다. 사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 부른다. 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을하나의 ‘세션’ 혹은 ‘방문’으로 묶는 용도로뚱뚱한 URL을 사용할 수 있다. 사용자가 웹사이트에 처음 방문하면 유일한 ID가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라를 이 뚱뚱한 URL로 리다이렉트 시킨다. 서버가 뚱뚱한 URL을 포함한 요청을 받으면,사용자 아이디와 관련된 추가적인 정보를 찾아서 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꾼다. 단점사용자를 식별하는 데 사용할 수 있지만, 문제가 있다. 😵못생긴 URL 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다. 🙅‍개인 정보때문에 공유하지 못하는 URL 뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함하기 때문에 외부 공유 시 개인 정보를 공유하게 된다. 🔥부하 📦캐시를 사용할 수 없음URL로 만든 것은, URL이 달라지기 때문에 기존 캐시에 접근할 수 없다. 서버 부하 가중뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다. 🏃‍♀️이탈 초기화사용자가 링크를 타고 다른 사이트로 이동하거나, 특정 URL을 요청해서의도치 않게 뚱뚱한 URL 세션에서 이탈하기 쉽다.이탈하게 되면 모든 진척사항들이 초기화되고 다시 처음부터 시작해야 될 것이다. 세션 간 지속성의 부재북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃는다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 WWW-Authenticate (:mdn)","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"Identification","slug":"Identification","permalink":"http://feel5ny.github.io/tags/Identification/"}]},{"title":"코드스피츠85 2회-(2) 동시성 모델을 직접 구현하며 이해하기.","slug":"JS_26_2","date":"2019-11-11T11:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/11/11/JS_26_2/","permalink":"http://feel5ny.github.io/2019/11/11/JS_26_2/","excerpt":"","text":"코드스피츠 85에서는 none blocking에 대한 이야기와자바스크립트를 짜는 근본적인 방법에 대한 고찰을 이야기해본다. 🌕🌑🌑 TL;DRsetTimer에서부터 promise까지 동시성 모델을 기반으로 구현하며, 루프 제어권의 통제에 대하여 알아본다. 1. setTimer를 구현해보기entity Item 실행될 시간과실행할 시간을 갖고 있는 객체 queue callback queue 역할을 하는 큐 객체 리스트 형태인 Set으로 생성 12345678910const Item = class &#123; time: number; // 몇초 후에 실행할지 block: Function; // 몇초 후에 실행할 함수 constructor(block, time)&#123; this.block = block; this.time = time + performance.now(); &#125;&#125;const queue = new Set; cf__1. performace, Set, value performance.now() 브라우저가 실행되 이후에 지난 시간 date.now()보다 좋은 점은 나노초까지 볼 수 있다. Set 배열에 담을 수 있는건 값만 담을 수 있다. 같은 객체가 중복으로 들어가지 않는다. 객체를 담는 리스\u001c트 value 불변 자체의 값으로 판단한다. 값으로 식별된다. Core Action callback 큐를 지속적으로 체크한다. 큐에 호출시간보다 작으면 실행하지 않는다. 큐에 호출시간보다 크면 실행하고 삭제한다. 123456789101112@params time 현재시간const checkQueue = (time: number) =&gt; &#123; queue.forEach((item: &#123;time: number, block: Function&#125;) =&gt; &#123; if(item.time &gt; time) return; // 현재시간이 호출시간보다 작다면 실행하지 않음. else &#123; // 현재시간이 호출시간보다 작다면 실행. queue.delete(item); // 실행할 예정이기때문에 삭제 item.block(); // 실행 &#125; &#125;); requestAnimationFrame(checkQueue);&#125;requestAnimationFrame(checkQueue); cf__2 requestAnimationFrame 브라우저에게 수행하기를 원하는 애니메이션을 알리고, 다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출하게 한다. 리페인트 이전에 실행할 콜백을 인자로 받는다. 엔진이 렌더링이 끝나면 직접 발생시키는 함수 트리거12const timeout = (block: Funtion, time:number) =&gt; queue.add(new Item(block, time)) 확인해보자.1timeout(_ =&gt; console.log(&quot;hello&quot;), 1000); 정리방금 구현한 setTimer를 동시성 모델로 구현해보면? 좀더 큰 그림에서 보면? 동시성을 만들어내는 이벤트 루프 안에작은 이벤트 루프를 만들어낸 것. 2. Non Blocking For 구현해보기1234567891011121314151617181920212223242526const working = _ =&gt; &#123;&#125;;for(let i=0; i &lt; 100000; i++) working();@params max 최대 루프수@params load 한번에 로드할 카운트@params block 실행할 함수const nbFor = (max:number, load: number, block: Function) =&gt; &#123; let i = 0; const f = (time:number) =&gt; &#123; let curr = load; // 한번에 로드할 카운트를 상태로 받기 위해 변수에 할당 while(curr-- &amp;&amp; i &lt; max) &#123; // 1. 1회돌때마다 현재 상태를 하나씩 뺀다. block(); // 2. 실행 i++; &#125; console.log(i); if(i &lt; max-1) requestAnimationFrame(f) &#125; requestAnimationFrame(f); // --- (1)&#125; requestAnimationFrame으로 내부함수 f가 실행 load기준으로 반복 카운트가 chunk된다. while문이 한 셋트가(load 카운트가 종료) 끝나면, requestAnimationFrame으로 f함수를 다시 실행시킨다. 하나의 프레임이 끝나면 제어권을 다시 엔진에게 돌려준다. 다시 max까지 루프가 끝나면 더이상 f를 실행하지 않음. 하나의 프레임이 끝나면 제어권을 다시 엔진에게 돌려준다. 클로저 패턴이 존재, i가 상태를 물고 있음 3. Generator 구현해보기 제너레이터 글참고12345const infinity: Iterator = (function*()&#123; let i = 0; while(true) yield i++;&#125;)();console.log(infinity.next()) 1234567891011// lib.es2015.iterable.d.tsinterface IteratorResult&lt;T&gt; &#123; done: boolean; value: T;&#125;interface Iterator&lt;T&gt; &#123; next(value?: any): IteratorResult&lt;T&gt;; return?(value?: any): IteratorResult&lt;T&gt;; throw?(e?: any): IteratorResult&lt;T&gt;;&#125; 제너레이터는 유사 iterable이다. 제너레이터 자체는 iterable이 아니다. iterable은 iterator라는 함수([Symbol.iterator]())를 호출하면 iterator \b객체를 주는데,generator를 호출하면 iterator가 반환된다. generator는 for...of를 사용하지 못한다.for…of는 iterable이 와야하기 때문에 yield가 일어날 때마다 next로 다음 턴을 줄 수 있다. function* 내부적으로 suspend 구간을 생성한다. 동기명령은 절대로 멈출 수 없다. generator는 멈출 수 있다. generator는 중간에 끊을 수 있다. yield를 호출하면 suspend가 일어난다. 멈춘다. 다음번 next 호출시 내부적으로 다시 재개되어서 루프돈다. next 호출할때마다 suspend가 일어난 곳에서 resume이 일어난다. 멈추는 것: suspend 다시 재개: resume 12345678910111213const gene = function*(max:number, load:number, block:Function)&#123; let i = 0, curr = load; while(i &lt; max) &#123; if(curr--)&#123; block(); i++; &#125; else &#123; curr = load; // curr을 초기화하고 console.log(i); yield; // 제어권을 밖에 둔다. &#125; &#125;&#125; suspend로 멈춰서 제어권을 외부에 위임할 수 있다. gene.next() 12345const nbFor = (max, load, block) =&gt; &#123; const iterator: Iterator = gene(max, load, block); const f = _ =&gt; iterator.next().done || timeout(f); timeout(f); // timeout을 쓰는 위치를 밖으로 옮겼다.&#125; 제어 시스템의 반제어권을 외부에 줌으로써내부에서 제어와 관련된 로직을 분리시킬수 있게 된다는게제너레이터의 장점 4. Promise 구현해보기 비동기 반제어 트리거를 걸었음 서버가 3초만에 데이터를 줬음 3초 안에는 제어할 권한이 없음 3초 이후에는 제어할 권한이 있음 Promise에 바로 then을 사용하는 것은반제어권이 이점을 활용하지 않고 콜백처럼 쓰는 형태 내가 원할때 then을 호출할 수 있다. 1234567891011121314const gene2 = function*(max, load, block) &#123; let i = 0; while(i &lt; max)&#123; yield new Promise(res =&gt; &#123; let curr = load; while(curr-- &amp;&amp; i &lt; max) &#123; block(); i++; &#125; console.log(i); timeout(res, 0) &#125;) &#125;&#125; yield를 보낼때 Promise로 감싸서 보내고 있다. 제어권을 완전 양도했었지만위 코드는 capsulizing해서 Promise안의 작업이 끝나면 then을 호출할 수 있게끔 반제어권을 주었음. 123456const nbFor = (max, load, block) =&gt; &#123; const iterator:Iterator&lt;Promise&gt; = gene2(max, load, block); const next = (&#123;value, done&#125;) =&gt; dome || value.then(v =&gt; next(iterator.next())); next(iterator.next());&#125; nbFor에서는 트리거 역할만하는 것이고, 제어는 Promise가 한다. co함수, redux-saga, … 참고자료 requestAnimationFrame","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"codeSpitz","slug":"codeSpitz","permalink":"http://feel5ny.github.io/tags/codeSpitz/"}]},{"title":"코드스피츠85 2회-(1) 자바스크립트의 동시성","slug":"JS_26_1","date":"2019-11-10T11:20:19.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2019/11/10/JS_26_1/","permalink":"http://feel5ny.github.io/2019/11/10/JS_26_1/","excerpt":"","text":"코드스피츠 85에서는 none blocking에 대한 이야기와자바스크립트를 짜는 근본적인 방법에 대한 고찰을 이야기해본다. 🌕🌑🌑 TL;DR 자바스크립트의 동시성 모델에 대해서 알아본다. 동시성이라는 단어를 이해하기 전에 병렬 모델을 먼저 알아본다. 병렬모델과 동시성 모델의 차이점은 워커가 하나 이상 있냐의 차이이다. 동시성 모델은 브라우저의 이벤트 루프와 테스크 큐를 예시로 알아보았다. Concurrency 동시성 동시에 한다는 뜻이 아니라 시간을 쪼개서 진행한다는 뜻. ex. 이벤트 루프 1. Parallelism 병행성,병렬성 진짜로 2개를 동시에 하는 것 병렬성을 이해해야 동시성을 이해하기 쉬워서 다뤄본다. 1.1 예시_프론트에서 발견할 수 있는 병렬 처리는? 네트워크에 작업을 요청하면 병행처리가 일어남. 네트워크쪽 서버에도 프로세스가 진행되고 있음. 클라이언트도 다른 프로세스가 진행되고 있음. 1.2 \b핵심은 테스크에 할당되는 각각의 워커가 별도로 존재해서,자기만의 속도와 자기만의 스케쥴에 따라서 일을 처리한다. 1.3 메모리의 개념과 함께 생각해보자각각의 테스크가 같은 메모리를 바라볼 경우 문제가 생긴다.즉, 동시성은 같이 쓰는 메모리를 어떻게 할지가 가장 어렵다. Blocking으로 해결한다. A가 선점하고 있는동안 Blocking을 걸어서 다른 워커가 접근하지 못하도록한다. 접근 못하는 워커는 메모리 접근을 위해 2가지 방법을 할 수 있다. 강제로 제어권을 뺏오는 방법 대기 한다. 언어에 따라 할 수 있는 방법이 다르다. ex. 자바: 오브젝트에 대기라는 방법은 사용하도록 wait라는 개념만 있다. 자바스크립트에서 동시성은.. 자바스크립트 창조자는 ES2018까지 병행성 자체를 막아버렸다. ES2018 이후, shared memory와 atomic이라는 개념으로 병행성 가능해짐. 프로그래밍 패러다임 중 함수형 프로그래밍은 ‘공유를 하지마’로 해결한다. 객체지향 프로그래밍에서는 공유하는 메모리를 인정한다. 2. Concurrency동시성에서 우리가 일을 시킬 수 있는 워커는 하나다. A에서 일을 조금 하고, A에 마킹을하고 B에 가서 작업을 한다. 메모리를 동시에 쓰는 일이 없다. 우리가 보통 작업했던 자바스크립트는 한번에 메모리 블럭을 하나만 접근하기 때문에여태까지 메모리에 대한 synchronized 문제를 어떻게 해결할지를 경험하지 않았다. 자바스크립트는 병행성을 갖고 있지 않고, 동시성만 갖고 있다. 병행성과 동시성의 차이는우리가 컨트롤 할 수 있는 워커가 몇 개 인가에 차이가 있다. 2.1 현실세계의 동시성 사람이 컨트롤하기에 동시성도 충분히 어렵다. 동시성에 대해서도 관심을 가지고 프로그래밍하지 않으면 복잡성이 올라간다. 동시성을 지원하는 다양한 자바스크립트의 메서드를 알아본다. 2.2 자바스크립트의 동시성자바스크립트 엔진을 동시성 모델로 표현해보자. engine work: 브라우저 엔진은 초기 작업을 진행한다. 렌더링을 포함한 다양한 엔진이 수행해야하는 일들을 한다. 멀티스레드로 풀어서 초기 작업을 진행한다. engine이 일하는 내용이 우리의 자바스크립트 코드나 메모리에 영향을 미치기때문에 싱글스레드 안에 들어오려고 동시성 패키지안에 들어와있는 것 뿐. 크롬은 백그라운드 thread에서 수많은 일을 함 queue를 체크한다. (ex. 이벤트 루프) 자바스크립트 명령어를 적재해 놓은 것이 있냐 없냐를 체크한다. queue는 callback queue(테스크 큐)를 바라본다. 브라우저에 로딩한 스크립트, 이벤트 리스너, ajax에 걸어놓은 완료 리스너도 다 콜백 큐에 들어간다. 콜백을 실행한다. 콜백 큐를 검사해서, 큐에 이번에 실행할 명령이 있는지 확인해서 꺼내서 실행하고 실행한 콜백큐를 제거한다. 실행 이후에는 다시 렌더링을 진행한다. 계속 반복 큐에 실행할 일이 걸리면 실행하게 된다. 실행이 끝나면 다시 렌더링한다. 모든 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다. 이벤트 루프는 ‘현재 실행중인 태스크가 없을 때’(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다. 각각의 스탭은 병행적으로 일어나지 않고,하나의 토큰이 계속 1, 2, 3 과정을 돌면서 실행한다. 특정 단계에 시간 지연이 있을 경우 다음 단계에 영향을 준다. 즉, 우리의 코드가 느리게 되면, 렌더링도 느려지고 큐 체크도 느려진다. 이벤트 루프와 테스크 큐의 관계 멀티스레드에서 생산자 &lt;-&gt; 소비자 패턴 (Producer-Consumer패턴) 하나의 소비자가 메모리(생산자)에서 읽기만 한다 즉, 메모리 동시성 문제는 일어나지 않는다. 한명만 소비하는 패턴 &#x3D; 파이프 패턴 브라우저가 갖고 있는 다른 thread network: ajax 요청때 사용 timer- setTimeout, setInterval- 현재의 크롬은 타이머를 처리하는 별도 스레드를 갖고있다. message- window.postmessage , localstrage-sessionstorage 간의 메세지 등등- 브라우저 통신 메세지 dom event 멀티 스레드 문제도 synchronized문제가 생기기때문에콜백 큐처럼 guard를 두어서 guard가 처리하게끔 설계함. 참고자료 이벤트 루프","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"codeSpitz","slug":"codeSpitz","permalink":"http://feel5ny.github.io/tags/codeSpitz/"},{"name":"concurrency","slug":"concurrency","permalink":"http://feel5ny.github.io/tags/concurrency/"},{"name":"Parallelism","slug":"Parallelism","permalink":"http://feel5ny.github.io/tags/Parallelism/"}]},{"title":"코드스피츠85 1회-(2) Runtime때 일어나는 일들","slug":"JS_25_2","date":"2019-11-01T11:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/11/01/JS_25_2/","permalink":"http://feel5ny.github.io/2019/11/01/JS_25_2/","excerpt":"","text":"코드스피츠 85에서는 none blocking에 대한 이야기와자바스크립트를 짜는 근본적인 방법에 대한 고찰을 이야기해본다. 🌕🌑🌑 TL;DR 작년 글 ProgramProgram &amp; Timing Language code Machine language로 트랜스파일한다. 여기서 machine이란.. 자기 언어가 실행되는 환경 File로 내린다. (Load) 메모리에 적재되어 있는 File을 실행한다. (Run) 실행이 끝나고나면 종료된다. (Terminate) 1. Runtime1.1 Runtime Execution Loading: 적재되는 중 파일을 실행하면 메모리에 적재된다. 파일은명령과 값으로 분리되어서 메모리에 적재된다. instruction - fetching &amp; decoding 여기서부터는 OS가 하는 일 instruction: CPU에서 해석할 수 있는 명령체계로 우리의 코드를 바꿔놓는 것 메모리의 첫번째 명령을 실행한다. instruction을 로딩할 때 fetching이라는 과정을 통해실제로는 제어유닛의 디코더로 로드하고,디코딩을 통해서 cpu가 원하는 명령어로 바꾼다. 연산유닛에서 값이 필요한 연산일 경우 메모리에 있는 값을 로드해야하는데,이때 데이터 유닛에 값을 로드해온다. 데이터 유닛에서 받은 값을 연산유닛으로 다시 보내준다. execution 명령을 처리한다. 결과를 정리하여 반환해야한다는 명령이 있을 경우다시 메모리의 값에 결과값을 보내준다 폰 노이만 머신 첫번째 명령이 끝나면 두번째 명령이 실행되고이렇게 메모리에 적재된 명령이 순차적으로 처리되어 없어지게된다.모든 명령이 끝나면 terminate가 일어난다. 폰 노이만 머신은 내장 메모리 순차처리 방식으로서,데이터 메모리와 프로그램 메모리가 구분되어 있지 않고하나의 버스를 가지고 있는 구조를 말한다. 위키, 참고 결국 런타임이란! 이 과정이 반복되고 모든 명령어를 소비하면 실행이 끝난다. 런타임이란로딩 이후에 instruction fetching - instruction decoding - execution 계속반복되어서terminate가 일어나는 그 사이 동기명령 sync flow순차적으로 실행되는 동안 아무것도 못하고 구경하는 행위 메모리에 sync flow를 태워서 flow대로 흐르는 것 1.2 Runtime Details essential definition loading 우리의 코드가 실행되기 위해서는우리가 정의한 클래스, 함수 인터페이스가 다 떠있어야함 실행코드에 앞서, 핵심적인 정의사항들이 올라감. vtable mapping (variables table) 현대의 있는 컴파일러들은 우리가 정의한 메모리공간을 사용할때 가상 메모리 공간을 사용한다. 컴파일러가 나의 변수를 가상으로 매핑해서 컴파일 했음진짜 메모리와 컴파일러가 만든 가상의 변수와 매핑을 해줘야한다. 내가 정의한 모든 변수를 실제 메모리에 매핑해주는 과정이 필요하다. run runtime definition loading run 4번과 5번은 반복 자바스크립트의 런타임자바스크립트의 런타임은 브라우저 로드에서부터 런타임으로 친다. browser load browser parsing run 기초적인 정의를 로딩한다. 우리가 정의한 확장된 정의를 로딩한다. (상대적으로 여기까지를 declare time) 실행한다. (상대적으로 여기서부터를 runtime으로 ) 2. State Control 메모리 관리의 어려운 점을 이야기하는 것도 있다. 값이라는 것은 계속 변하기 때문에 상태라고 부른다. Directive Reference 직접참조12345678a = &#x27;TEST&#x27;a주소 = 00, a크기 = 4b = &amp;a // b에 a의 주소값을 할당c = &amp;b // c에 b의 주소값(a의 주소값)을 할당.a = b &amp; b =c (a=c) // 결국 a와 c도 같은 상황d = &#x27;ABC&#x27;b = &amp;d // b에 d의 주소를 재할당b = d &amp; b != c (a=c) 마지막은 b와 d는 같고b는 d의 주소값을 갖고 있기때문에b는 c와 같은 상태가 아니다.하지만 a와 c는 아직 같은 상태 b와 d는 같다는것이 바로 인지되지만,b에 다른 값을 넣었을 때 변하는 b와 c가 같지 않다 라는 사실을 바로 이해하고 인지할 수 있을까? 추적을 못한다. 🙅 c를 사용하는 동네는 다 망가짐 전파, 여파.. 직접 참조를 쓸때는 내 참조변수가 외부에 공유됐으면 변수의 값을 바꾸면 안된다. 협소하게 움직일 수 밖에 없고, 개발에 제약이 생긴다. 이를 해결하기 위해 간점참조를 사용한다. Indirective Reference 간접참조 중간에 쿠션을 두는 개념123456a = &quot;TEST&quot;a주소 = 00, a크기 = 4b = &#123; target: &amp;a &#125;c = &amp;bd = &#x27;ABC&#x27;b.target = &amp;d // b를 직접 바꾸지 않기 때문에 더이상 싱크가 깨지는 문제가 일어나지 않는다. .: 쿠션을 친다. 런타임에 계산된다. 비용이 든다. 연산비용과 안정성을 바꿨다고 보면 된다. 사람이 인지하고 있는 멘탈모델과 컨텍스트가 깨지지 않는다. 이 원리를 사용하여 linked list, 디자인패턴, 객체지향의 추상클래스도 만든다. 사실 자료구조는 아래 2가지 원리에서 시작된다 메모리를 통으로 쓰는 배열과 linked list형식을 빌린.. 참조포인터를 이용하여 쿠션을 치는 3. Flow Control 명령 관리의 어려운 점을 이야기하는 것도 있다. state 관리 + 명령진행에 대한 어려움 2가지 모두 챙겨야하기때문에 상태관리보다 더 어렵다. Sync flow Control자세한건 여기! sync flow: 메모리에 적재된 명령이 순차적으로 실행됨 sync flow control: goto를 통해 명령의 위치를 이동함 goto라는 명령어를 통해서 sync flow의 작동을 제어할 수 있다. 메모리의 state에 따라서 분기를 한다. sync flow control 핵심은 해당 시점의 메모리의 값 (분기칠때의 상태에 의존된다) condition control &#x3D;&gt; 여기서 condition은 메모리의 상태값 cf__1 의존성 역전 &#x2F; 제어 역전 의존성 역전: 추상적인 것에 의존하겠어. 제어 역전: 추상적인 행동을 할 것이라고 전제하여 제어문을 짜는 것. sub flow (&#x3D;&#x3D; sub routine: 반복적으로 사용할 수 있는 sync flow): 함수 등을 통해 별도의 명령set을 여러번 실행함 Blocking Sync flow가 실행되는 동안 다른 일을 할 수 없는 현상 우리가 짠 모든 코드가 blocking 코드. 때문에 우리가 할 수 있는건 blocking 줄이기 Blocking 줄이기 sync flow를 짧게 하기 다른 thread에 sync flow를 떠넘기기 현대브라우저는 병행적 프로그래밍을 요구한다. 이벤트 루프: 동기화 명령 사이사이에 이벤트 루프가 작동해서, 다른 thread 작업을 기다리게된다. 그럼 Non Blocking이란?Sync Flow가 납득할 만한 시간 내에 종료되는 것 우리의 코드는 보다 더 none blocking으로 향하는 길 빠른 thread로 빼내어서 main thread를 얼만큰 줄이느냐가 none blocking의 주제 4. AsyncSync &amp; Async 앞에서 말한 sync flow와는 다른 개념이다. Sync: 서브루틴이 즉시 값을 반환하는 것 Async: 서브루틴이 다른 수단으로 값을 반환하는 것 우리가 원하는 값\b을 즉시 리턴하지 않는 모든 함수가 async 함수 다른수단이란? Promise callback function iterations Async 단점 호출결과가 즉시 반환되지 않으므로,현재의 sync flow가 종료됨그 결과 현재의 어휘공간(컨텍스트) 내의 상태를결과시점에 사용할 수 없음 요청 시의 상태를 별도로 결과시점에 전달할 부가장치 필요 sync 라는 순차적으로만 짤 수 있다는 식으로 처음부터 배웠기 때문에우리는 async가 어색한 것이다. Sync의 장점 + Async의 장점 sync 로직으로 async를 사용할 수 있게 함 하지만 sync flow가 어긋나므로,이전 sync flow의 상태를 기억하여 이어줄 장치 필요 상태를 기억하고 이어주는 장치: Continuation (컨텍스트라고 생각해되 된다.) 이를 활용하는 프로그래밍 스타일: Continuation Passing Style Generator, Async, Asynchrous Iterators","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"codeSpitz","slug":"codeSpitz","permalink":"http://feel5ny.github.io/tags/codeSpitz/"}]},{"title":"코드스피츠85 1회-(1) JavaScript Now","slug":"JS_25_1","date":"2019-10-27T11:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2019/10/27/JS_25_1/","permalink":"http://feel5ny.github.io/2019/10/27/JS_25_1/","excerpt":"","text":"코드스피츠 85에서는 none blocking에 대한 이야기와자바스크립트를 짜는 근본적인 방법에 대한 고찰을 이야기해본다. 🌕🌑🌑 TL;DR오늘날의 자바스크립트 동향과 ECMAScript에 대해서 알아본다. ECMAScript가 버전업이 될때의 과정과, ES6 이후(~ES10)에 표준이 된 스펙들 중 일부를 알아본다. 또한 proposal에 올라온 목록과 체택되진 않았지만 이미 몇몇 브라우저에 적용된 개념들에 대해서 알아본다. JavaScript PipeLine자바스크립트의 ECMAScript를 알아보기전에 우리는 프론트 개발자로써 어느 과정까지 건드리고 있는지를 알아보고, ECMAScript에 조금 더 집중할 수 있는 상황에 대해서 알아본다. Code 코드를 작성한다. ES3.1 ~ 5, 6 ~ &#x2F; TypeScript &#x2F; Kotlin &#x2F; Dart &#x2F; CoffeeScript &#x2F; … Transpiler 컴파일러와는 다르다. 글 참조 트랜스파일러라는 것을 이용해서 코드를 자바스크립트로 번역한다. (1단계) 언어마다 컴파일러가 있다.- (타입스크립트) tsc &#x2F; (코들린) kotlinc &#x2F; … (2단계) 원하는 형태의 자바스크립트로 바꾸거나, 원하는 버전의 자바스크립트로 바꿔줌- babel Packaging : 최적화 과정. (webpack) CI : 테스트..등등의 여러 job Deploy : 최종 deploy 호환성이라던지, 브라우저에서 어떻게 실행할지는트랜스파일러나 패키징이 알아서 책임지게 하고,개발자가 코드에 집중할 수 있는 환경이 만들어졌다고도 할 수 있다. ECMAScript ECMA스크립트는 차기버전을 정하는 순서가 그 해의 상반기에 정해진다.내년 상반기에 확정될 ES11에 대한 draft작업이 되고 있음 (2019년 10월기준) 2019가 재정되자마자 공식문서 레포에는 다음버전의 레포가 떠진다. 현재 표준은 당연히 ES10이다 이번 강의에서는 ES11을 배울 것이다. 알고 있는 자바스크립트는 옛날 기준의 자바스크립트이다. 자바스크립트는 1년 기준으로 변한다. 최신버전의 언어는 그 전에 비해 작성법부터 달라진다. 새로운 버전의 자바스크립트로 자바스크립트를 새로 배운다고 생각해도 된다. 지금 알고 있는 지식은 IE11때까지의 지식이구나 라고 알고 있어도 된다. ECMAScript Standard자바스크립트라는 언어를 따라가기 위해 표준에 대해 알아보고 이해한다. 유럽 표준의원회에서 지정하고 있다. 자바스크립트를 한번 배우면 계속 쓴다는 생각을 버려야한다. 변화를 어떻게 따라잡을까. 이 언어가 어떤 식으로 변화를 일으키는지 이해해야지만 같이 찾아보고 따라잡을 수 있다. C#이후에 업데이트가 가장 많이 일어나는 언어이다. 매년 상반기 새로운 버전을 출시함 버전과 연도가 1차이ES6 &#x3D; ES2015 현재는 ES11 (ES2020)이 최종 조정중 (2019년 10월기준) ES6 이후 급격한 언어의 변화를 지양하고 점진적인 버전업을 진행 새롭게 반영될 내용은 Stage0 ~ 3까지 단계별 승격을 통해 정식 반영시 Stage4가 됨 공개적으로 스펙을 원하는 사람이 발제를 하면 stage0이라는 최초의 proposal로 보고, 위원회가 회의를 거쳐서 승격을 시켜줌. 현재 제안 중이 내용의 상태 확인 대부분은 사장된다. 실제로는.. tc39위원회에서 회의를 통해 결정되며, 위원회는 다양한 업계와 관계자로 구성됨 stage0이던 1이던 tc39에 프로포절을 제안하기 위해서는챔피온이라는 사람을 끼고 발제를 하게 되어있다. 실제 각 제안의 담당자(챔피온)가 구글관련 개발자인 경우가 많음 Stage4기준 보다 구글이 원하는 순서대로 크롬에 빨리 반영되는 경우가 많음 크롬 업데이트 많은 스펙들은 회사의 사정에 따라 움직이고 있다. 예) 꼬리물기 최적화를 제안한 애플직원의 프로포절은 반영되지 않았지만, 사파리에는 반영되었다. CSS나 W3C도 비슷한 사정 최신판을 쓰기 위해서는 크롬을 사용해야하고, 크롬에서만 반영된 스펙을 안볼 수 없다. 1. ECMAScript 6ES5이후에 중요한 부분 Class, Object Literal, getter, setter … Arrow (순수하게 함수만 지향, 가벼운 객체를 만들 수 있다.) Iterator, Generator(코루틴 시스템), For of const, let (순차적인 컨텍스트를 생성해줌) destructuring, rest, spread Template String 내장객체: (클래스 라이브러리)Symbol, Promise, Map, Set, WeakMap, WeakSet, Proxy, Reflect cf__1) 클래스는 설탕문법이다? ES6의 클래스는 절대로 ES5를 흉내낼 수 없다. 단적인 증거가, ES5에서 함수를 상속받거나 배열을 상속받는 클래스를 만들 수 없다. 근본적으로 생성하는 방식서에부터 사용하는 방식까지 ES6이전과 이후가 다르다. 참고: ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가? ECMAScript 7 ~ 10, Stage3(11) 2. ECMAScript 7 중첩된 rest해체: rest안에 rest로 해체가 가능한 것. 참고:변수에 배열의 나머지를 할당하기12const [a, ...[b, ...c]] = [1,2,3,4]// a=1, b=2, c=[3,4] 3. ECMAScript 8 async&#x2F;await shared memory atomics 참고: SharedArrayBuffer 객체와 Atomics 객체를 사용한 메모리 공유 shared memory와 atomics를 알아보기 전에 알아야할 웹 워커 개념 cf__2) web worker와 main thread 웹 워커는 스크립트 실행을 메인 쓰레드가 아니라 백그라운드 쓰레드에서 실행할 수 있도록 해주는 기술 무거운 작업을 분리된 쓰레드에서 처리할 수 있다. 메인 쓰레드(일반적으로 UI 쓰레드)는 멈춤, 속도저하 없이 동작할 수 있게 된다. Worker는 Worker() 생성자를 통해 생성된다. JavaScript 파일에 포함된 코드를 워커스레드에서 실행한다. Worker는 현재 Window와 분리된 DuplicatedWorkerGlobalScope 라는 별도의 Global context에서 동작한다. 몇가지 제한사항 DOM을 직접 다룰 수 없다. Window의 기본 메서드와 속성을 사용할 수 없다. 웹 워커 종류 Dedicated Worker Message System을 통해 Worker와 메인 스레드 간에 데이터를 교환할 수 있다. Worker.postMessage() 메세지 전송 Worker.onmessage 응답 Shared worker 참고 Shared Worker는 Dedicated worker보다 좀더 복잡성을 가지고 있다. 윈도우 창이나 iframe, 워커등의 다른 브라우징 컨텍스트에서도 접근이 가능한 특정 종류의 워커를 의미한다. 기존의 다른 종류의 워커들과 다른 전역 스코프를 갖는 인터페이스를 구현합니다. (SharedWorkerGlobalScope) Shared Worker는 웹 어플리케이션 사이의 Proxy Server와 브라우저로서 역할을 하며 (만약 가능하다면)통신을 구축한다. Chrome Worker Chrome Worker는 Firefox에서만 사용가능한 worker유형 Audio Workers 직접적인 오디오 처리를 web worker에서 처리할 수 있도록 해준다. 참고1: 복잡성 감소 또는 Web Workers 사용참고2: Web Workers API shared memory와 atomics 웹 어셈블리어에서 적극적으로 사용 중. 웹 워커는 멀티 스레드 패턴이 아닌 워커 스레드 패턴 컨텍스트를 하나만 가지기 때문에 동기화 문제가 일어나지 않는 패턴이다. 밖의 쓰레드는 언제나 별도의 작업을 한 이후에 싱크로 문제되지 않는 새 객체를 전달해야한다. 새 객체로 공유하기 때문에 동기화 문제가 일어나지 않는다. 웹워커가 만들어졌을 때는 스레드를 여러개 지원하지만싱글 스레드라는 컨텍스트를 깨먹지 않도록 설계되었다. 문제점은 느리다. 예를들어 큰 용량의 이미지 처리를 위해서 이미지를 복제하여 넘길 때 넘기는 것 부터가 부하이다. 복제를 하지 않고 워커스레드에 넘길까. 메인스레드에 있는 값을 share하여 해결한다. : sharedMemory 당연하게도 동시성 문제가 생긴다. 같은 shared memory를 보는 스레들들에서 지울수도, 수정하려고하고, 읽으려고 .. 이 문제를 해결하기 위해 atomics는 lock을 걸어준다. 자바의 lock 기능에 비해서는 저수준의 기능이다. 4. ECMAScript 9 object 해체 asynchronous iterators generator의 장점과 async&#x2F;await의 장점을 합쳐서비동기적인 코루틴을 만들 수 있는 구조를 제공한다. 현대의 크롬 브라우저는 이 기능을 사용하기 위한 성능 최적화를 이미 구현해 두었다. 5. ECMAScript 10 Optional catch123456try &#123; &#125; catch(err)&#123; // 새로운 어휘공간으로 되어서 err를 사용할 수 있도록했지만 // 불필요한 컨텍스트&#125; 12345try &#123; &#125; catch &#123; // err 인자 없이 사용가능&#125; 6. Stage3 (ECMAScript 11)아래 것은 크롬이 이미 구현 BigInt globalThis top level await class field private field (#을 붙여서 사용한다.) private method (#을 붙여서 사용한다.) Optional chaining ?. null로 통일 가능. 안전한 기능 nullish coalescing ?? 앞의 값이 null일때 ??쓰면 뒤의 값을 사용 WeakReference 자바스크립트는 현대 나온 언어 중에 가장 어렵다. 현대 모든 언어 중에 제일 장점이라고 불리는 것을 연마다 넣고 있다. 언어에서 어려운 개념을 다 넣고 있다.. 광범위한 언어적 지식을 요구하고 있다. 참고자료 ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가? SharedArrayBuffer 객체와 Atomics 객체를 사용한 메모리 공유 ECMAScript 발제 레포 변수에 배열의 나머지를 할당하기 SharedWorker 복잡성 감소 또는 Web Workers 사용 Web Workers API","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"codeSpitz","slug":"codeSpitz","permalink":"http://feel5ny.github.io/tags/codeSpitz/"}]},{"title":"WIP_웹 로봇","slug":"HTTP_009","date":"2019-10-21T14:23:55.000Z","updated":"2024-11-23T12:12:24.913Z","comments":true,"path":"2019/10/21/HTTP_009/","permalink":"http://feel5ny.github.io/2019/10/21/HTTP_009/","excerpt":"","text":"웹 로봇(스스로 움직이는 사용자 에이전트)에 대해서 알아본다.웹 로봇은 사람과의 상호작용 없이 연속된 웹 트랜잭션들을 자동으로 수행하는 소프트웨어 프로그램이다. 방식에 따라 크롤러, 스파이더, 웜, 봇 등 각양각색의 이름으로 불린다. 주식 그래프 봇 (매분 HTTP GET 요청을 보내 얻은 데이터로 그래프 생성)웹 통계조사 로봇 (통계 정보를 수집)검색엔진 로봇 (모든 문서를 수집)가격 비교 로봇 (상품 가격 DB를 만들기 위해 온라인 쇼핑몰 웹페이지 수집) 1. 크롤러와 크롤링 웹 크롤러는 먼저 웹페이지를 한 개 가져오고, 그 다음 그 페이지가 가리키는 모든 웹페이지를 가져오고, 다시 그 페이지를 가리키는 모든 웹페이지들을 가져온다. 이런 재귀적으로 반복하는 방식으로 웹을 순회하는 로봇이다. 크롤러 (스파이더): 웹 링크를 재귀적으로 따라가는 로봇 HTML 하이퍼링크로 만들어진 웹을 따라 기어다니기(crawl) 때문이다. 인터넷 검색엔진은 웹을 돌아다니면서 만나는 모든 문서를 끌어오기 위해 크롤러를 사용한다. 그렇다면 크롤러들은 어떻게 동작할까? 1.1 시작은 ‘루트 집합’에서 🏃 출발지점을 주어야한다. 루트 집합 (root set): 크롤러가 방문을 시작하는 URL들의 초기 집합 루트 집합을 고를때,모든 링크를 크롤링하면서 관심있는 웹페이지들을 많이 가져올 수 있도록,URL들을 선택해야한다 S,T,U는 아직 누구도 찾아내지 못한 것들일 것이다. 혹은 정말 오래되었거나 오직 A,G,S가 루트집합에 있기만 하면 모든 페이지에 도달할 수 있다. 좋은 루트 집합 크고 인기 있는 웹사이트 (like 유투브) 새로 생성된 페이지들의 목록 자주 링크되지 않는 잘 알려져 있지 않은 페이지들의 목록 페이지들을 추가하는 기능을 제공 대규모 크롤러 제품들은 (인터넷 검색엔진에서 쓰이는 것과 같은)루트 집합에 새 페이지나 사용자들에게 잘 알려져 있지 않은 페이지들을 추가하는 기능을 제공한다. 이 루트집합은 시간이 지남에 따라 성장하며 새로운 크롤링을 위한 seed 목록이 된다. 1.2 링크 추출과 상대 링크를 절대링크로 크롤러는 검색한 각 페이지 안에 들어있는 URL 링크들을 파싱해서 크롤링할 페이지들의 목록에 추가해야한다. 크롤러가 크롤링을 진행하면서 탐색해야 할 새 링크를 발견함에 따라 &#x3D;&gt; 이 목록은 보통 급속히 확장된다. 상대 링크를 발견할 경우 절대 링크로 변활할 필요가 있다. 1.3 순환 피하기 로봇이 웹을 크롤링할때, 루프나 순환에 빠지지 않도록 조심해야한다. 로봇들은 순환을 피하기 위해 반드시 그들이 어디를 방문했는지 알아야 한다. 1.3.1 순환이 해로운 이유순한은 크롤러에게 해롭다. 같은 페이지들을 반복해서 가져오는데 모든 시간을 허비하게 만들 수 있다. 네트워크 대역폭을 다 차지하고 때문에그 어떤 페이지도 가져올 수 없게 되어버릴 수 있다. 웹 서버에 부담이 된다. 크롤러의 네트워크 접근 속도가 빠르다면,웹사이트를 압박하여 어떤 실제 사용자도 사이트에 접근할 수 없도록 막아버리게 될 수도 있다. 루프 자체가 문제가 되지 않더라도, 크롤러는 많은 수의 중복된 페이지들을 가져오게 된다. dups 크롤러의 어플리케이션은 자신을 쓸모없게 만드는 중복된 콘텐츠로 넘쳐나게 될 것이다. 1.3.2 빵순환을 피하기 위해 방문을 기록 (부스러기의 흔적 Breadscrumb) 방문한 곳을 지속적으로 추적하는 것은 쉽지 않다. URL이 상당히 많기 때문에, 어떤 URL을 방문했는지 빠르게 판단하기 위해서는복잡한 자료 구조를 사용할 필요가 있다. 자료구조는 속도와 메모리 사용 면에서 효과적이어야 한다. 검색 트리나 해시 테이블을 필요로 할 것이다. 트리와 해시테이블 &#x2F; 느슨한 존재 비트맵 &#x2F; 체크포인트 &#x2F; 파티셔닝 트리와 해시테이블 방문한 URL을 추적하기 위해 검색 트리나 해시 테이블을 사용했을 수도 있다. 느슨한 존재 비트맵 Lossy presence bit maps 모르겠다.url을 숫자형태의 비트로 만들어서 저장하고, 같은 존재비트가 있으면 이미 크롤링되었다고 간주하는 듯 느슨한 자료구조 각 URL은 해시 함수에 의해 고정된 크기의 숫자로 변환되고,배열 안에 대응하는 존재 비트를 갖는다. presence bit URL이 크롤링 되었을 때, 해당하는 존재 비트가 만들어진다.존재비트가 이미 존재한다면 크롤러는 그 URL을 이미 크롤링 되었다고 간주한다. 체크포인트 checkpoint 로봇 프로그램이 갑작스럽게 중단될 경우를 대비해,방문한 URL의 목록이 디스크에 저장되었는지 확인한다. 파티셔닝 Partitioning 웹이 성장하면서 한대의 컴퓨터에서 하나의 로봇이 크롤링을 완수하는 것이 불가능 로봇들이 서로 도와 웹을 크롤링한다. 개별 로봇들은 URL들을 이리저리 넘겨주거나,오동작하는 동료를 도와주거나,그 외의 이유로 그들의 활동을 조정하기 위해 커뮤니케이션을 한다. 1.4 URL 정규화별칭(alias)과 로봇 순환 올바른 자료 구조를 갖추었더라도, URL이 별칭을 가질 수 있는 이상어떤 페이지를 이전에 방문했었는지 말해주는 게 쉽지 않을 때도 있다. 한 URL이 또 다른 URL에 대한 별칭이라면,그 둘이 서로 달라 보이더라도 사실은 같은 리소스를 가리키고 있다. 같은 문서를 가리키는 다른URL들 기본 포트가 80번일 때 HTTP://www.foo.com/bar.html HTTP://www.foo.com:80/bar.html 이스케이프 문자가 원래 문자와 같을때 HTTP://www.foo.com/~fred HTTP://www.foo.com/%7fred 태그에 따라 페이지가 바뀌지 않을 때 HTTP://www.foo.com/x.html#early HTTP://www.foo.com/x.html#middle 서버가 대소문자를 구분하지 않을 때 HTTP://www.foo.com/readme.htm HTTP://www.foo.com/README.HTM 기본 페이지가 index.html일 때 HTTP://www.foo.com/ HTTP://www.foo.com/index.html 도메인과 ip 주소 HTTP://www.foo.com/index.html HTTP://209.231.87.45/index.html URL 정규화를 통해 alias 회피 웹 로봇은 URL들을 표준 형식으로 정규화 함으로써다른 URL과 같은 리소스를 가리키고 있음이 확실한 것들을 미리 제거하려 시도한다. WIP.. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"robot","slug":"robot","permalink":"http://feel5ny.github.io/tags/robot/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"}]},{"title":"캐시의 원리와 제어방법","slug":"HTTP_007-2","date":"2019-10-05T14:23:55.000Z","updated":"2024-11-23T12:12:24.873Z","comments":true,"path":"2019/10/05/HTTP_007-2/","permalink":"http://feel5ny.github.io/2019/10/05/HTTP_007-2/","excerpt":"","text":"캐시의 원리와 제어방법을 알아본다.클라가 요청 메시지를 받은 이후의 처리단계를 기준으로 캐시는 어떤 원리로 사본을 관리하는지, 단계별로 어떤 제어가 가능한지를 알아보려고 한다. 7. 캐시 처리 단계처리단계는 7단계로 이루어져 있다. 단계1: 요청받기네트워크 커넥션에서의 활동을 감지하고,들어오는 데이터를 읽어들인다. 단계2: 파싱요청 메세지를 여러 부분으로 파싱하여헤더 부분을 조작하기 쉬운 자료 구조에 담는다. 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어 준다. 단계3: 검색URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다. 메모리에 저장되어있을 수도 있고,디스크나근처 다른 컴퓨터에 있을 수 있다. 문서를 로컬에서 가져올 수 없다면, 상황이나 설정에 따라서원서버나 부모프락시에서 가져오거나혹은 실패를 반환한다. 캐시 된 객체는 서버 응답 본문과 원서버 응답 헤더를 포함하므로캐시 적중 동안 올바른 서버 헤더가 반환될 수 있다. 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지 알려주는 기록이나얼마나 자주 사용되었는지 등에 대한몇몇 메타데이터를 포함한다. 단계4: 신선도 검사HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다. 이 기간 동안 문서는 신선한 것으로 간주되고,캐시는 서버와의 접촉 없이 이 문서를 제공할 수 있다. 너무 오래 갖고 있었다면 그 객체는 신선하지 않은 것으로 간주캐시는 그 문서를 제공하기 전에 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야 한다. (304 Not Modified) 신선도 검사 알고리즘은 아래에. 단계5: 응답 생성캐시 된 응답을 원서버에서 온 것처럼 보이게 하고 싶기 때문에캐시는 캐시 된 서버 응답 헤더를 토대로 응답 헤더를 생성한다. 이 기저 헤더들은 캐시에 의해 수정되고 늘어난다. 캐시는 클라에 맞게 이 헤더를 조정해야 하는 책임이 있다. 캐시는 캐시 신선도 정보를 삽입하며(Cache-Control, Age, Expires 헤더) 요청이 프락시 캐시를 거쳐갔을 경우 Via 헤더를 포함시킨다. Date 헤더는 그 객체가 원서버에서 최초로 생겨난 일시이기 때문에 조정해서는 안된다. 단계6: 전송단계7: 로깅대부분의 캐시는 로그 파일과 캐시 사용 통계를 유지한다. 각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신한다. 로그 파일에 요청 종류, URL 무엇이 일어났는지 알려주는 항목을 추가한다. 캐시 로그 포맷 스퀴드 로그 포맷 Squid log format 참고 넷스케이프 확장 공용 로그 포맷 Netscape extended common log format 많은 캐시 제품이 커스텀 로그 파일을 허용한다. 전체 Flow 8. 사본을 신선하게 유지하기HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도,캐시 된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 매커니즘을 갖고 있다.매커니즘은 문서 만료와 서버 재검사라고 부른다. 8.1 문서만료HTTP는 Cache-Control과 Expires라는 헤더들을 이용하여원서버가 각 문서에 유효기간을 붙일 수 있게 해준다. 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우한다. 캐시 문서가 만료되기 전에,캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있다. 캐시 된 문서가 만료되면,캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하며, (변경이 없으면 304 Not Modified) 만약 그렇다면 신선한 사본을 얻어와야 한다. (새 유효기간과 함께) 유효기간과 나이Expires와 Cache-Control:max-age 헤더는 기본적으로 같은 일을 하지만,절대 시간은 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구한다. Cache-Control:max-age max-age 값은 문서의 최대 나이를 정의한다. 최대 나이는문서가 처음 생성된 이후부터,제공하기엔 더 이상 신선하지 않다고 간주될 때까지경과한 시간의 합법적인 최댓값(초단위)이다. 현재시간과 expires 시간의 남은 시간을 나이로 측정한다. Expires절대 유효기간을 명시한다.만약 유효기간이 경과했다면, 그 문서는 더 이상 신선하지 않다. 8.2 서버 재검사 reValidation 캐시 된 문서가 만료되었다는 것은,그 문서가 원서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않으며,이제 검사할 시간이 되었음을 뜻한다. 캐시가 원서버에게 문서가 변경되었는지의 여부를 묻는 것 콘텐츠가 변경되었다면: 캐시는 그 문서의 새로운 사본을 가져와 새로 저장한 뒤 클라에게도 보낸다. 콘텐츠가 변경되지 않았다면: 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다. 캐시는 문서의 신선도를 매 요청마다 검증할 필요가 없다. 문서가 만료되었을 때, 한 번만 서버와 재검사하면 된다. 신선하지 않은 콘텐츠는 제공하지 않으면서도,서버의 트래픽을 절약하고 사용자 응답 시간을 개선한다. HTTP 프로토콜은 캐시가 다음 중 하나를 반환할 것을 요구한다. 충분히 신선한 캐시 된 사본 원서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시 된 사본 에러메시지 (재검사헤야 하는 원서버가 죽을 경우) 경고 메세지가 부착된 캐시 된 사본(부정확시) 조건부 메서드와 재검사HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.HTTP는 캐시가 서버에게 조건부 GET이라는 요청을 보낼 수 있도록 해준다. 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다를 경우에만객체 본문을 보내달라고 하는 것이다. 신선도 검사와 객체를 받아오는 것은 하나의 조건부 GET으로 결합된다. 조건부 GET은 GET 요청 메세지에 특별한 조건부 헤더를 추가함으로써 시작된다. 웹 서버는 조건이 참인 경우에만 객체를 반환한다. HTTP는 캐시 재검사 시 가장 유용한 2가지 조건부 요청 헤더를 정의한다. If-Modified-Since If-None-Match 1. If-Modified-Since: 날짜 재검사1If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT 줄여서 IMS 요청으로 불린다. 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다. 만약 문서가 주어진 날짜 이후에 변경되지 않았다면, 조건은(If-Modified-Since) 거짓이고서버는 304 Not Modified 응답메세지를 클라에게 돌려준다. 효율을 위해 본문은 보내지 않는다. 응답 헤더들을 포함하지만, 원래 돌려줘야 할 것에서 갱신이 필요한 것만을 보내준다. (보통 새 만료 날짜만 보내준다.) If-Modified-Since 헤더는 Last-Modified 헤더와 함께 동작한다. 원서버는 제공하는 문서에 최근 변경 일시를 붙인다. 마지막 배포 시간이 Last-Modified로 내려온다. 캐시가 캐시 된 문서를 재검사하려고 할때,캐시 된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since헤더를 포함한다. 1If-Modified-Since: &lt;캐시 된 마지막 수정일&gt; 몇몇 웹서버는 If-Modified-Since를 실제 날짜 비교로 구현하지 않는다. 대신 IMS 날짜와 최근 변경일 간의 문자열 비교를 수행한다. 정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면 이라는 의미로 동작한다. GET 또는 HEAD에서만 사용 가능하다. 일반적인 사용예) ETag가 없는 캐시 된 \b엔티티로 업데이트한다. If-None-Match와 함께 사용 시 무시된다. 2. If-None-Match: 엔터티 태그 재검사서버는 무서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공할 수 있다.(ETag)캐시 된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리한다. 최근 변경일시 재검사가 행해지기 어려운 상황이 있다. 일정 시간 간격으로 다시 쓰여지지만, 같은 데이터를 포함한다. (내용변화가 없음) 어떤 문서들의 변경은 다시 읽어들이기엔 사소한 것 (철자나 주석) 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다. 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다. 123조건부 요청GET /index.html HTTP/1.0If-None-Match: &quot;v2.6&quot; 12345응답HTTP/1.0 304 Not ModifiedDate: Wed, 03 Jul 2002, 19:18:23 GMTETag: &quot;v2.6&quot;Expires: Fri, 05 Jul 2002, 05:00:00 GMT 만약 서버의 엔터티 태그가 변경되었다면(v3.0)서버는 200 OK 응답으로 새 콘텐츠를 새 ETag와 함께 반환했을 것이다. 약한 검사기와 강한 검사기 캐시는 캐시 된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티 태그를 사용한다. 엔터티 태그와 최근 변경일시는 둘 다 캐시 검사기다. 서버는 때때로 모든 캐시 된 사본을 무효화시키지 않고,문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있다. HTTP&#x2F;1.1은 콘텐츠가 조금 변경되었더라도, 그 정도면 같은 것이라고 서버가 주장할 수 있도록 해주는 약한 검사기를 지원한다. 강한 검사기는 콘텐츠가 바뀔 때마다 바뀐다.약한 검사기는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경된다. 서버는 W/ 접두사로 약한 검사기를 구분한다. 12ETag: W/&quot;v2.6&quot;If-None-Match: W/&quot;v2.6&quot; 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가 HTTP&#x2F;1.1 클라는 만약 서버가 엔터티 태그를 반환했다면,반드시 엔터티 태그 검사기를 사용해야 한다. Last-Modified 값만을 반환했다면클라는 If-Modified-Since 검사를 사용할 수 있다. 만약 HTTP&#x2F;1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그, 조건부 헤더를 모두 받았다면,요청의 모든 조건부 헤더 필드의 조건에 부합해야 200을 반환해야 한다. 9. 캐시 제어아래는 HTTP는 문서가 얼마나 오랫동안 캐시될 수 있게 할 것인지,서버가 설정할 수 있는 여러 가지 방법이다. Cache-control: no-cache Cache-control: no-store Cache-control: must-revalidate Cache-Control: max-age=&lt;seconds&gt; Cache-control: s-maxage=&lt;seconds&gt; Expires 날짜 헤더를 응답에 첨부할 수 있다. 아무 만료 정보도 주지 않고, 캐시가 스스로 체험적인(휴리스틱 heuristic) 방법으로 결정하게 할 수 있다. 9.1 no-cahce와 no-store 응답 헤더캐시가 검증되지 않은 캐시 된 객체로 응답하는 것을 막는다. Cache-control: no-store: 캐시가 그 응답의 사본을 만드는 것을 금지한다. Cache-control: no-cache: 로컬 캐시 저장소에 저장될 수 있다. 다만, 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라로 제공될 수 없을 뿐이다. Do Not Serve From Cache Without Revalidation (재검사 없이 캐시에서 제공하지 마라) Pragma: no-cache: HTTP&#x2F;1.0+ 하위 호환성을 위해 HTTP&#x2F;1.1에 포함되어있다. 웬만하면 Cache-control: no-store 9.2 Max-Age 응답 헤더 max-age 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간 초로 나타낸다. s-maxage 헤더는 공유된 캐시에만 적용된다. 서버는 maximum aging(최대 나이먹음)을 0으로 설정함으로써,캐시가 매 접근마다 문서를 캐시하거나 리프레시 하지 않도록 요청할 수 있다. 9.3 Expires 응답헤더 더 이상 사용하지 않기를 권하는 Expires 헤더는 실제 만료 날짜를 명시한다. HTTP 설계자들은 많은 서버가 동기화되어있지 않거나부정확한 시계를 갖고 있기 때문에,만료를 절대 시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단했다. 신선도 수명의 근삿값은 만료일과 생성일의 초 단위 시간차를 계산하여 얻을 수 있다. \b 9.4 Must-Revalidate 응답 헤더 캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정될 수 있다. 만약 캐시가 만료 정보를 엄격하게 따르길 원한다면 must-revalidate 응답 헤더 캐시가 이 객체의 신선하지 않은 사본을원서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미한다. 만약 캐시가 must-revalidate 신선도 검사를 시도했을 때 원서버가 사용할 수 없는 상태라면캐시는 반드시 504 Gateway Timeout error를 반환해야 한다. 9.5 휴리스틱 만료 만약 응답이 Cache-control:max-age 헤더나 expires 헤더들을 포함하지 않고 있다면캐시는 경험적인 방법으로 heuristic 최대 나이를 게산할 것이다. 계산 결과, 얻은 최대 나이 값이 24시간보다 크다면,Heuristic Expiration 경고(경고13) 헤더가 응답 헤더에 추가되어야 한다. 이 경고 정보를 사용자가 볼 수 있게 해주는 브라우저는 없다. LM(last-modified) 인자 알고리즘 (휴리스틱 만료 알고리즘) 문서가 최근 변경일시를 포함하고 있다면 사용할 수 있다. LM 인자 알고리즘은 최근 변경일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용한다. 캐시 된 문서가 마지막으로 변경된 것이 엄청 예전이라면, &#x3D;&gt; 안정적인 문서일 것이다 &#x3D;&gt; 갑자기 바뀔 일을 크지 않을 것이고 &#x3D;&gt; 캐시에 더 오래 보관하고 있어도 안전하다. 캐시 된 문서가 최근 변경되었다면 &#x3D;&gt; 자주 변경될 것이고, &#x3D;&gt; 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 한다. 12$마지막_수정이후로_경과한_시간 = max(0, $서버의_Date - $서버의_Last_Modified)$서버_신선도_한계 = int($마지막_수정_이후로_경과한_시간 * $lm_인자) 일반적으로 사람들은 휴리스틱 신선도 유지 기간에 상한을 설정하여지나치게 커지는 것을 막는다. 보통 1주일로 하지만, 보수적인 사이트는 하루도 설정한다. 캐시는 일반적으로 신선도에 대한 아무런 단서가 없는 문서에 대해 기본 신선도 유 지기간을 설정한다.보통 한 시간이나 하루로. 더 보수적인 캐시는 보통 이 휴리스틱 문서들에 대해 0의 신선도 수명을 설정하여캐시가 클라에게 데이터를 제공할 때마다 아직 신선한지 검사하도록 강제한다. 9.6 클라 신선도 제약 웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼을 갖고 있다. 리프레시 버튼은 Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서,강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다. 클라는 Cache-control 요청 헤더를 사용하여 만료 제약을 엄격하게 하거나, 느슨하게 할 수 있다. 성능, 신뢰성, 비용 개선을 위한 절충안으로 신선도 요구 사항을 느슨하게 하고자 할 수 있다. Cache-Control: max-stale[=&lt;seconds&gt;]: 클라이언트가 캐시의 만료 시간을 초과한 응답을 받아들일지를 나타낸다. 초가 지정되면, 클라는 만료시간이 그 매개변수 값만큼 지난 문서도 받아들인다. Cache-Control: min-fresh=&lt;seconds&gt;: 클라는 지금으로부터 s초 후까지 신선한 문서만을 받아들인다. Cache-Control: max-age=&lt;seconds&gt;: s초보다 오랫동안 캐시 된 문서를 반환할 수 없다. Cache-control: no-cache: 캐시 된 리소스는 재검사하기 전에는 받아들이지 않을 것이다. Cache-control: no-store: 저장소에서 문서의 흔적을 빨리 삭제해야 한다. 문서에는 민감한 정보가 포함되어 있기 때문 Cache-control: only-if-cached: 클라는 캐시에 들어있는 사본만을 원한다. 10. 자세한 알고리즘나이와 신선도 수명 캐시 된 사본의 나이가 신선도 수명보다 작으면 사본은 제공해주기에 충분히 신선한 것이다.1$충분히_신선한가 = $나이 &lt; $신선도_수명 문서의 나이: 서버가 문서를 보낸 후(혹은 서버가 마지막으로 재검사한 후) 그 문서가 나이를 먹은 시간의 총합이다. 캐시는 문서 응답이 어떻게 왔는지 모르기 때문에, 문서가 완전히 새롭다고 가정하지 못한다. Age 헤더를 통해 명시적으로든서버가 생성한 Date 헤더를 통해 계산하든 간에문서의 나이를 판별해야 한다. 10.1 나이 계산 응답의 나이는 응답이 서버에서 생성되었을 때부터 지금까지의 총 시간이다. 응답이 인터넷상의 라우터들과 게이트웨이들 사이를 떠돌아다닌 시간과응답이 캐시에 머물렀던 시간을 포함한다. 12345678$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값) $보정된_겉보이_나이 = max($겉보기_나이, $Age_헤더값)$응답_지연_추정값 = $응답을_받은_시각 - $요청을_보낸_시각;$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;$사본이_우리의_캐시에_머무른_시간 = $현재_시각 - $응답을_받은_시각;$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간; 1. 겉보기 나이는 Date 헤더에 기반한다. 모든 컴퓨터가 똑같이 정확한 시계를 갖고 있다면,캐시 된 문서의 나이는 단순히현재 시간에서 서버가 문서를 보낸 시간(Date 헤더)을 뺀 겉보기 나이가 될 것이다.1$겉보기_나이 = $응답을_받은_시각 - $Date_헤더값 모든 컴퓨터는 똑같이 정확한 시계를 갖고 있지 않다. 클록 스큐 clock skew: 두 컴퓨터의 시계 설정 차이로 인한 문제클록 스큐 때문에 겉보기 나이는 종종 부정확하며 때로는 음수가 되기도 한다. 겉보기 나이가 음수가 될 경우 0으로 만들어야 한다.1$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값) 2. 점층적 나이 계산 (Age 헤더) 문서가 프락시나 캐시를 통과할 때마다그 장치들이 Age헤더에 상대적인 나이를 누적해서 더하도록 한다. 이 방법은 서버 같의 시간 비교나, 종단 간의 시간 비교를 필요로 하지 않는다. Age 헤더 값은 문서가 프락시들을 통과하면서 점점 늘어난다. HTTP&#x2F;1.1을 이해하는 어플리케이션은 문서가 각 어플리케이션에 머무른 시간과 네트워크 사이를 이동한 시간만큼 Age 헤더의 값을 늘려야 한다. 각 중간 어플리케이션은 자신의 내부 시계를 이용해서 쉽게 문서의 체류 시간을 계산할 수 있다. 비-HTTP&#x2F;1.1 장치는 Age 헤더를 인식하지 못한다. 상대 나이값은 가장 큰 것(보수적)이 선택된다. 다른 서버에서 넘어온 Date 값이나 나이계산값은 실제보다 작게 계산된 값일 수 있기 때문이다. 123$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값) $보정된_겉보이_나이 = max($겉보기_나이, $Age_헤더값)$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 3. 네트워크 지연에 대한 보상 느린 네트워크나 과부하가 걸린 서버에서 &#x3D;&gt; 문서가 네트워크나 서버의 교통 혼잡에 긴 시간 동안 갇혀있었던 경우 상대 나이 계산은 문서의 나이에 대한 상당히 모자란 추정이 될 수 있다. Date헤더는 문서가 캐시로 옮겨가는 도중에 얼마나 시간을 소비했는지 말해주지 않는다.1234$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값) $보정된_겉보이_나이 = max($겉보기_나이, $Age_헤더값)$응답_지연_추정값 = $응답을_받은_시각 - $요청을_보낸_시각;$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값; 4. 캐시에 저장되면, 나이를 더 먹는다. 문서에 대한 요청이 캐시에 도착했을 때,우리는 그 문서의 현재 나이를 계산하기 위해 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알 필요가 있다. 1$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간; 10.2 신선도 수명 계산 신선도 수명은 서버와 클라의 제약조건에 의존한다. 서버는 문서가 얼마나 자주 변경되어 발행되는지에 대한 정보를 갖고 있을 수도 있다. 클라는 속도가더 빠르다면 약간 신선하지 못한 콘텐츠도 받아들이려 할 수도 있고가능한 가장 최신의 콘텐츠를 요구할 수도 있다. 12345678910111213141516171819202122232425262728293031323334sub 서버_신선도_한계 &#123; local($휴리스틱, $서버_신선도_한계, $마지막으로_변경된_시각) $휴리스틱 = 0; if ($Max_Age_값이_설정되었나) &#123; $서버_신선도_한계 = $Max_Age_값 &#125; elsif ($Expires_값이설정되었나) &#123; $서버_신선도_한계 = $Expires_값 - $Date_값 &#125; elsif ($Last_Modified_값이_설정되었나) &#123; $마지막으로_변경된_시각 = max(0, $Date_값 - $Last_Modified_값) $서버_신선도_한계 = int($마지막으로_변경된_시각 * $lm_인자); $휴리스틱 = 1; &#125; else &#123; $서버_신선도_한계 = $캐시_최소_수명_기본값; $휴리스틱 = 1; &#125; if ($휴리스틱) &#123; if ($서버_신선도_한계 &gt; $캐시_최대_수명_기본값) $서버_신선도_한계 = $캐시_최대_수명_기본값 if ($서버_신선도_한계 &lt; $캐시_최소_수명_기본값) $서버_신선도_한계 = $캐시_최소_수명_기본값 &#125; return $서버_신선도_한계&#125;sub 클라이언트가_수정한_신선도_한계 &#123; $나이_한계 = 서버_신선도_한계() if ($Max_Stale_값이_설정되었나) &#123; if ($Max_Stale_값 == $INT_MAX) &#123; $나이_한계 = $INT_MAX &#125; else &#123; $나이_한계 = 서버_신선도_한계() + $Max_Stale_값 &#125; &#125; if ($Min_Fresh_값이_설정되었나) &#123; $나이_한계 = min($나이_한계, 서버_신선도_한계() - $Min_Fresh_값) &#125; if ($Max_Age_값이_설정되었나) &#123; $나이_한계 = min($나이_한계, $Max_Age_값) &#125;&#125; 전체 과정은 문서의 나이와 신선도 한계라는 두 가지 변수가 관련되어 있다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"cache","slug":"cache","permalink":"http://feel5ny.github.io/tags/cache/"}]},{"title":"캐시의 개념과 장점","slug":"HTTP_007-1","date":"2019-09-30T14:23:55.000Z","updated":"2024-11-23T12:12:24.904Z","comments":true,"path":"2019/09/30/HTTP_007-1/","permalink":"http://feel5ny.github.io/2019/09/30/HTTP_007-1/","excerpt":"","text":"캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다.웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면,그 문서는 원서버가 아니라 캐시로부터 제공된다. 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다. 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다. 캐시는 원서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다. 캐시는 거리로 인한 지연을 줄여준다. 페이지를 먼 곳에서 불러올수록 시간이 많이 거린다. 1. 불필요한 데이터 전송 캐시를 이용하면, 첫번째 서버 응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게된다. 2. 대역폭 병목 많은 네트워크가 원격 서버보다 로컬 네트워크 클라에 더 넓은 대역폭을 제공한다. 클라들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다. 만약 클라가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 성능을 개선할 수 있을 것이다. 3. 갑작스런 요청 쇄도 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다. 트래픽 급증은 네트워크와 웹서버의 심각한 장애를 야기시킨다. 음? 4. 거리로 인한 지연 대역폭이 문제가 되지 않더라도, 거리가 문제될 수 있다. 기계실 근처에 캐시를 설치하여 문서가 전송되느 거리를 수천 킬로미터에 수십미터로 줄일 수 있다. 보스턴과 샌프란시스코 사이의 거리는 약 4,400km이다. 어떤 웹페이자가 20개의 작은 이미지를 포함하고 있는데, 모두가 샌프란시스코에 있는 한 서버에 들어있다고 가정해보자.보스턴에 있는 클라가 서버로 동시에 4개의 커넥션을 열고, 그 커넥션을 유지한다면, 다운 받을 때의 빛의 속도로 인한 지연은 거의 1&#x2F;4초가 된다.(240밀리초) 만약 서버가 보스턴에서 더 멀리 10,800km 떨어진 도쿄라면 600밀리초로 커진다. 5. 적중과 부적중 캐시가 모든 문서의 사본을 저장하지는 않는다. 캐시 요청이 도착했을때,사본이 있다면: 요청이 처리될 수 있다. 캐시 적중 cache hit사본이 없다면: 원서버로 전달되기만 한다. 캐시 부적중 cache miss 5.1 재검사 Revalidation (신선도 검사) 원서버 콘텐츠는 변경될 수 있기 때문에,캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 점검해야한다.!! 이러한 신선도 검사를 HTTP 재검사라 부른다. HTTP는 서버로부터 전체 객체를 가져오지 않고도, 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했다. 대부분의 캐시는 클라가 사본을 요청하였으며,그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다. 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보낸다. 재검사 적중 (느린 적중) 사본이 유효함을 알게된 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤,사본을 클라에게 제공한다. 순수 캐시 적중보다 느리다. 원 서버와 검사를 할 필요가 있기 때문이다. 캐시 부적중보다는 빠르다. 서버로부터 객체 데이터를 받아올 필요가 없기 때문이다. If-Modified-Since 헤더 서버에게 보내는 GET 요청에 이 헤더를 추가하면,캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다. > 오늘은 9월 30일이다. 27일에 캐시되어있던 파일이며, 해당 시간 이후의 사본의 신선도를 확인한다. If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 3가지 상황 서버 콘텐츠가 변경되지 않을 경우 서버 콘텐츠가 변경된 경우 객체가 삭제된 경우 재검사 적중: 만약 서버객체가 변경되지 않았다면, 서버는 클라에게 작은 HTTP 304 Not Modified 응답을 보낸다. 재검사 부적중: 만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라에게 보낸다. 객체 삭제: 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제한다. 문서적중률과 바이트 단위 적중률은 둘다 캐시 성능에 대한 유용한 지표다. 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다. 트랜잭션은 고정된 소요 시간을 포함하게 되는데, 시간이 길 수도 있기 때문에,문서 적중률을 개선하면 전체 대기시간이 줄어든다. 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여준다. 바이트 단위 적중률의 개선은 대역폭 절약을 최적화한다. 5.2 적중률 (문서 적중률)캐시가 요청을 처리하는 비율을 캐시 적중률 혹은 문서 적중률이라고 부르기도 한다. 적중률은 0 ~ 1 값으로 되어 있다. 흔히 퍼센트로 표현된다. 캐시 부적중: 0%캐시 적중: 100% 캐시 관리자는 캐시 적중률이 100%에 근접하게 되는 것을 좋아할 것이다. 실제 적중률은 캐시가 얼마나 큰지캐시 사용자들의 관심사가 얼마나 비슷한지캐시된 데이터가 얼마나 자주 변경되거나 개인화되는지캐시가 어떻게 설정되어 있는지에 달려있다. 적중률은 예측하기 어려운 것으로, 악명이 높지만 오늘날 적중률 40%면 웹 캐시로 괜찮은 편이다. 5.3 바이트 적중률 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 몇몇 큰 객체는 덜 접근되지만, 그 크기 때문에 전체 트래픽에는 더 크게 기여한다. 어떤사람은 이러한 이유로 바이트 단위 적중률 측정값을 더 선호한다. 특히 트래픽의 모든 바이트에 요금을 매기려는 사람들 이 측정값은 트래픽이 절감된 정도를 포착해낸다. 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며,어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다. 5.4 적중과 부적중의 구별 HTTP는 클라에게 응답이 캐시적중이었는지, 원서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다 두가지 경우 모도 200 OK가 될 것이다. 어떤 상용 프락시 캐시는캐시에 무슨일이 일어났는지 설명하기 위해 Via 헤더에 추가 정보를 붙인다. 클라가 응답이 캐시에서 왔는지 알아내는 한가지 방법은 Date 헤더를 이용하는 것이다. 응답의 Date 헤더값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면, 클라는 응답이 캐시된 것임을 알아낼 수 있다. 클라가 캐시된 응답을 감지하는 또다른 방법은, 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용하는 것이다. 6. 캐시 토폴로지 캐시는 한명의 사용자에게만 할당 될 수도 있고수천명의 사용자들 간에 공유될 수도 있다. 토폴로지(영어: topology, 문화어: 망구성방식)는 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식을 말한다. 로컬 영역 네트워크(LAN)은 물리적 토폴로지와 논리적 토폴로지 둘 다 보여 줄 수 있는 네트워크의 한 예이다. 출처 토폴로지 종류 버스 토폴로지 스타 토폴로지 링 토폴로지 트리 토폴로지 6.1 개인 전용 캐시 개인 전용 캐시는 작고 저렴할 수 있다. 웹 브라우저는 개인 전용 캐시를 내장하고 있다. 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고사용자가 캐시 사이즈의 설정을 수정할 수 있도록 허용한다. 6.2 공용 프락시 캐시 공용 캐시는 캐시 프락시 서버 혹은 더 흔한 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다. 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자 입장에서 서버에 접근한다. 공용캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다. 각 개인 전용 캐시는 같은 문서를 네트워크를 거쳐 여러번 가져온다. 공용 캐시에서, 캐시는 자주 찾는 객체를 단 한번만 가져와모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다. 수동 프락시를 지정하거나, 프락시 자동설정 파일을 설정함으로써, 브라우저가 프락시 캐시를 사용하도록 설정할 수 있다. 인터셉트 프락시를 사용함으로써 브라우저의 설정 없이 HTTP 요청이 캐시를 통하도록 강제할 수 있다. 6.3 프락시 캐시 계층들 작은 캐시에서 캐시 부적중이 발생했을 때,더 큰 부모 캐시가 그 걸러 남겨진 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적이 경우가 많다. 클라 주위에는 작고 저렴한 캐시를 사용하고,계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하자는 것이다. 캐시 계층이 깊다면 프락시 연쇄가 길어지므로, 각 중간 프락시는 현저한 성능 저하가 발생할 것이다. 6.4 캐시망, 콘텐츠 라우팅, 피어링 잘 모르겠다. 캐시망캐시망의 프락시 캐시는어떤 부모 캐시와 대화할 것인지,아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한캐시 커뮤니케이션 결정을 동적으로 내린다. 콘텐츠 라우팅캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은다음에 나열된 일들을 모두 할 수 있을 것이다. URL에 근거하여, 부모 캐시와 원서버 중 하나를 동적으로 선택한다. URL에 근거하여, 특정 부모 캐시를 동적으로 선택한다. 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다. 다른 캐시들이 그들의 캐시된 콘텐츠에 부분으로 접근할 수 있도록 허용하되,그들의 캐시를 통한 Internet transit은 허용하지 않는다. 형제 캐시 선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다. HTTP는 형재 캐시를 지원하지 않기 때문에, 사람들은 인터넷 캐시 프로토콜(ICP)이나하이퍼텍스트 캐시 프로토콜 HTCP같은 프로토콜을 이용해 HTTP를 확장했다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 네트워크 토폴리지","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"cache","slug":"cache","permalink":"http://feel5ny.github.io/tags/cache/"}]},{"title":"웹에서 앱으로 이동하기 (feat.딥링크)","slug":"Communication_001","date":"2019-09-22T14:23:55.000Z","updated":"2024-11-23T12:12:24.851Z","comments":true,"path":"2019/09/22/Communication_001/","permalink":"http://feel5ny.github.io/2019/09/22/Communication_001/","excerpt":"","text":"하나의 서비스가 웹이나 앱, 두 가지 플랫폼에서 운영 중일 경우, 서로가 서로의 플랫폼으로 고객을 이동시킬 수 있다. 앱에서는 웹링크를 사용하여 웹으로 이동시키거나, 인앱브라우저로 웹화면을 띄우곤 하는데, 웹화면에서 앱으로의 이동은 어떨까.웹에서 앱의 특정 화면으로 이동시키기 위해선, 앱이 현재 디바이스에 인스톨이 되어있는지, 어떤 페이지로 이동하고 싶어하는지 등의 정보를 알아야한다. 이를 도와주는 개념이 딥링크다.마케터는 웹에서 앱 유입을 여러 측면으로써 효율 확인하길 원하며, 보통 앱 유입 성과측정을 위해서 branch, TUNE, Appsflyer같은 솔루선을 사용한다. 웹개발자는 웹서비스에 해당 솔류션에서 만들어주는 링크를 삽입하곤한다. ‘딥링크’의 개념딥링크는 단순한 개념이다.특정 콘텐츠에 직접 도달하는 모든 링크를 뜻하는데, 형태는 스킴(scheme)과 호스트(host)로 구성된 URL(Uniform Resource Locator)이며, 웹환경에서도 쉽게 적용할 수 있다. url의 자세한 설명은 여기 현재 url 또한 url하나로 블로그 글에 직접 도달할 수 있기 때문에 딥링크라고 말할 수 있다. (https://feel5ny.github.io/2019/09/22/Communication_001/) 앱에서도 특정 콘텐츠를 직접 도달할 수 있도록, 여러가지 딥링크 형태들을 활용한다. (url 스킴, 유니버설 링크..) 굿닥은 원링크 사용 제플린의 공유 url 앱의 특정 콘텐츠를 공유하고 싶을 경우에도 딥링크를 사용할 수 있다. 1. 딥링크딥링크를 사용할 경우, 앱이 설치된 유저는 앱 내 특정 페이지로 이동한다. 앱 미설치 유저는URL schemes방식의 딥링크 사용시에는 동작하지 않고Universal Link나 App Link 사용시 ios, and에 맞는 앱스토어로 이동한다. 1-1 딥링크의 종류URL schemes 딥링크의 가장 초기 형태\b이다. url 스킴을 앱에 정의하는 방식으로 사용한다. goodoc://단점 스킴을 제약없이 설정이 가능하기 때문에, 고유한 딥링크를 점유할 수 없다. 즉, **여러 앱에서 같은 이름의 스킴을 사용할 경우, 하이재킹(hijacking)**될 수도 있다. 이러한 이유로 몇몇 브라우저에서는 URL schemes에 대해 경고메세지를 띄우거나 동작을 막곤한다. URL schemes만으로 앱 설치 유무를 알 수 없다. 앱이 설치되어있지 않을 경우에 대해 공식적인 지원이 없기 때문에앱 미설치 유저는 딥링크가 동작하지 않는다. Universal Link (웹 링크 형태) URL schemes가 가진 문제점을 해결하기 위해 2015년 하반기에 iOS와 Android 플랫폼은 각각 새로운 딥링크를 개발하여 발표했다. iOS는 Universal LinkAndroid는 App Link 개념적으로는 비슷한 형태의 딥링크이다. 앱이 설치되어있을 경우이미지 출처: branch 앱이 미설치 일 경우 대체 url로 이동된다.이미지 출처: branch 표준 웹 링크 (http://mydomain.com) 이다. HTTPS가 적용된 도메인을 딥링크로 사용한다. 보안문제를 해결하였다. 특정 도메인이 딥링크로 사용되는 것이기 때문에, 고유성을 보장한다. 대체 url(fallback url)을 공식 지원하기 때문에, 앱 미설치자의 OS에서 해당 link를 대체url로 판단하여서 웹사이트로 떨어트린다. 웹서버에서 Universal link(ios) 처리하는 흐름 기본적으로 유니버셜 링크는 웹 URL 형식이므로, 해당 도메인에 연결되어있는 웹 서버에 1차적으로 요청이 들어간다. 해당 서비스가 1. 유니버셜 링크를 지원한다는 설정이 되어있고, 요청을 보낸 단말기에 2. 특정 앱이 설치되어 있다면 웹사이트 대신 앱을 실행하라는 응답을 보낼 수 있다. 단점 사용자의 트리거에 의해서만 작동한다. 스크립트로 클릭을 유발할 경우에는 앱이 설치되어있음에도 대체URL로 작동한다. 특정 앱에서는 동작하지 않도록 막고 있기도 하다. (핀터레스트, 페이스북 메신저, 텔레그램 ..) 단점들때문에 URL 스킴과 복합적으로 사용하기도 한다. 1-2 딥링크의 문제점 앱 미설치자의 경우, 앱스트어로 이동시 사용자를 추적할 수 없는 경우가 있다. 마켓을 이동하는 과정에서 딥링크가 유실되어 설치 후에 어떤 딥링크를 통해 앱을 설치했는지 알 수 없다. 이를 해결하기 위해 디퍼드 딥링크를 사용한다. 1-3 (방식) 디퍼드 딥링크 새로 앱을 설치한 사용자(NRU, Newly Registered User)를 집계할 수 있다. (마케터의 광고 효율성을 측정할 수 있다.) 사용자가 원하는 콘텐츠를 설치와 동시에 보여줄 수 있다. 앱 내 콘텐츠를 목적으로 설치한 사용자의 동선을 줄일 수 있다. 이런 장점을 지닌 디퍼드 딥링크는 각각의 OS 별로 구현하는 방식이 다르다.참고 2. 어트리뷰션 튤에서 만들어주는 링크모바일 앱 마케팅을 하는 곳이라면 어트리뷰션 툴 사용은 필수이다. 앱 설치 또는 구매와 같은 인앱이벤트에 대한 원인이 되는 광고 클릭을 찾는 것이 바로 어트리뷰션 툴의 목적이라고 할 수 있다. 어트리뷰션(Attribution): 어떤 행동에 대한 원인을 찾는 과정 파이어베이스에서는 dynamic LinkAppsflyer에서는 one Link라는 명칭으로 불린다. 하나의 URL로 각각의 OS에 맞게 자동으로 앱 내 특정페이지로 이동할 수 있게 해준다. 어트리뷰션 툴을 사용하면 어트리뷰션 툴에서 수집한 광고 클릭 데이터와 SDK를 통한 앱 설치 데이터가 연결되어 성과를 낸 광고를 특정할 수 있게 된다.즉, 광고의 성과를 분석할 수 있게 되는 것. 참고자료 branch의 딥링크 설명글 LINE-TRACKIT에서 딥링크를 사용하는 방법 다이렉트&#x2F;디퍼드&#x2F;다이나믹 딥링크 설명글 ab180의 딥링크 설명글 univasal link 어트리뷰션 툴 ab180","categories":[{"name":"04_AARRR","slug":"04-AARRR","permalink":"http://feel5ny.github.io/categories/04-AARRR/"},{"name":"Acquisition","slug":"04-AARRR/Acquisition","permalink":"http://feel5ny.github.io/categories/04-AARRR/Acquisition/"}],"tags":[{"name":"maketing","slug":"maketing","permalink":"http://feel5ny.github.io/tags/maketing/"},{"name":"app","slug":"app","permalink":"http://feel5ny.github.io/tags/app/"},{"name":"link","slug":"link","permalink":"http://feel5ny.github.io/tags/link/"},{"name":"url","slug":"url","permalink":"http://feel5ny.github.io/tags/url/"}]},{"title":"프록시","slug":"HTTP_006","date":"2019-09-22T07:23:55.000Z","updated":"2024-11-23T12:12:24.914Z","comments":true,"path":"2019/09/22/HTTP_006/","permalink":"http://feel5ny.github.io/2019/09/22/HTTP_006/","excerpt":"","text":"1. 프록시란? 웹 프록시 서버는 클라의 입장에서 트랜젝션을 수행하는 중개인이다. HTTP 프록시 서버는 웹 서버이기도 하고, 웹 클라이기도 하다. 1.1 개인 프록시와 공유 프록시개인 프록시 하나의 클라만을 위한 프록시 어떤 브라우저 보조 제품들은 몇몇 ISP 서비스와 마찬가지로 브라우저의 기능을 확장하거나 성능을 개선하거나, 무료 ISP 서비스를 위한 공고들을 운영하기 위해 작은 프록시를 사용자의 컴퓨터에서 직접 실행한다. ISP: Internet Service Provider (KT, SKT, LG+) 공유 프록시 여러 클라가 함께 사용하는 프록시 대부부의 프록시는 공유 프록시다. 1.2 Proxy vs Gateway 프록시: 같은 프로토콜을 사용하는 둘 이상의 앱을 연결 게이트웨이: 서로 다른 프로토콜을 사용하는 둘 이상을 연결프로토콜 변환기처럼 동작한다. ex) HTTP&#x2F;POP 게이트웨이: 이메일 서버와의 통신 2. 왜 사용할까? 보안을 개선하고 성능을 높여주며 비용을 절약한다. 부가적인 가치를 주는 여러 유용한 웹서비스를 구현하기 위해 트래픽을 감시하고 수정한다. 2.1 주 사용 케이스 어린이 필터: 성인 콘텐츠 차단용 필터링 프락시 문서 접근 제어자: 웹 리소스에 대한 단일한 접근 제어 전략을 구현하고 감사추적을 하기 위해. 보안 방화벽: 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제한다. 웹 캐시: 인기 있는 문서의 로컬 사본을 관리하고, 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄인다. 대리 프락시(Surrogate) 웹 서버인 것처럼 위장한다. 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용될 수 있다. 서버 가속기라고 불린다. 콘텐츠 라우팅 기능과 결합되어, 주문형 복제 콘텐츠의 분산 네트워크를 만들기 위해 사용될 수 있다. 콘텐츠 라우터 인터넷 트래픽 조건과 콘텐츠의 종류에 따라, 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작할 수 있다. 사용자들에게 제공할 여러 서비스를 구현하는데 사용할 수 있다. 사용자가 필터링 서비스에 가입했다면, HTTP 요청이 필터링 프락시를 통과하도록 할 수 있다. 트랜스 코드 콘텐츠를 클라에게 보내기 전에, 본문 포맷을 수정할 수 있다. 트랜스 코딩: 데이터의 표현방식을 변환하는 것 사례: gif 이미지 &#x3D;&gt; jpg &#x2F; 이미지의 크기 줄이기 &#x2F; 텍스트 파일 압축 &#x2F; 외국어 문서로 변환하기 &#x2F; … 익명화 프락시 Anonymizer HTTP 메세지에서 신원을 식별할 수 있는 특성들을 제거 &#x3D;&gt; 개인 정보보호와 익명성 보장에 기여한다. User-Agent 헤더에서 OS종류 &#x2F; From헤더 &#x2F; Referer헤더(출처) &#x2F; Cookie(프로필과 신원정보) 등을 제거한다. 3. 어디에 둘까? 어떻게 프락시가 네트워크에 배치되는가 어떻게 프락시의 연쇄가 계층을 이루는가 3.1 프락시 서버 배치 출구 프락시 Egress 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프락시를 로컬 네트워크의 출구에 박아 넣을 수 있다. 해킹 방지 방화벽 제공을 위해 &#x2F; 인터넷 트래픽 성능 개선 &#x2F; 필터링 출구 프락시 접근(입구) 프락시 고객으로부터의 모든 요청을 종합적으로 처리하기 위해 ISP 접근 지점에 위치 대리 프락시 (&#x3D;리버스 프락시) 네트워크의 가장 끝에 있는 웹서버들의 바로 앞에 위치, 웹 서버로 향하는 모든 요청을 처리하고, 필요할 때만 웹 서버에게 자원을 요청할 수 있다. 보안 기능을 추가 성능 개선용: 빠른 웹서버 캐시를 느린 웹 서버 앞에 놓는다. 네트워크 교환 프락시 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고, 트래픽 흐름을 감시하기 위해,충분한 처리 능력을 갖춘 프락시가 네트워크 사이의 인터넷 피어링 교환 지점들에 놓일 수 있다. 3.2 프락시 계층 부모관계: 인바운드 프락시 방향 쪽의 프락시를 부모, 아웃바운드 프록시 방향 쪽을 자식으로 본다. 3.2.1 프락시 계층 콘텐츠 라우팅 프록시 서버는 여러 가지 판단 근거에 의해 메세지를 다양하고 유동적인 프록시 서버와 원 서버들의 집합에게 보낼 수 있다. 동적 부모 선택의 몇 가지 사례 부하 균형: 자식 프록시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프록시를 고른다. 지리적 인접성에 근거한 라우팅: 자식 프록시는 원 서버의 지역을 담당하는 부모를 선택할 수 있다. 프로토콜&#x2F;타입 라우팅: URI에 근거하여 다른 부모나 원서버로 라우팅 할 수 있다. 유료 서비스 가입자를 위한 라우팅: 사용자가 빠른 서비스를 위해 추가금을 지불했다면, 성능 개선을 위한 압축 엔진으로 라우팅 될 수 있다. 3.2.2 어떻게 프록시가 트래픽을 처리하는가 어떻게 HTTP 트래픽이 프록시로 향하는 길을 찾아내는지 알아보자. 클라 트래픽이 프록시로 가도록 만드는 방법 4가지 클라이언트를 수정한다. 네트워크를 수정한다.: 클라가 컨트롤할 수 없다면, 네트워크 인프라를 가로채서 웹 트래픽을 프록시로 가도록 조장하는 방법. 인터셉트 프록시 (&#x3D; transparent proxy): HTTP 트래픽을 지켜보고 가로채어 클라 모르게 트래픽을 프록시로 보내는 스위칭 장치와, 라우팅 장치가 필요. DNS namespace를 수정한다. 대리 프록시는 웹 서버의 이름과 IP주소를 자신이 직접 허용한다. DNS 이른 테이블을 수동으로 편집하거나,사용할 적절한 프록시나 서버를 계산해주는 특별한 동적 DNS 서버를 이용해서 조정 가능하다. 웹 서버를 수정한다. HTTP 리다이렉션 명령을 클라에게 돌려줌으로써, 클라의 요청을 프록시로 리다이렉트 하도록 설정할 수 있다. 리다이렉트를 받는 즉시, 클라는 프록시와의 트랜잭션을 시작한다. 4. 클라에서 프록시 설정 방법4.1 수동 단 하나의 프록시 서버만 지정가능하다. 장애시 대체 작동에 대한 지원이 없다. 관리 문제를 야기한다. 4.2 클라 프록시 설정PAC 파일 프록시 자동 설정 파일은 프록시 설정에 대한 보다 동적인 해결책이다. 문서에 접근할 때마다, 자바스크립트 함수가 적절한 프록시 서버를 선택한다. 자바스크립트 PAC 파일의 URI를 브라우저에 설정해야 한다. 브라우저는 URI로부터 PAC파일을 가져와서 매 접근마다 적절한 프록시 서버를 계산하기 위해 실행한다. 확장자: .pac MIME타입: application/x-ns-proxy-autoconfig FindProxyForURL(url, host) 함수를 정의해야 한다.1FindProxyForURL(url, host): &quot;DIRECT&quot; | `PROXY $&#123;host&#125;:$&#123;port&#125;` | `SOCKS $&#123;host&#125;:$&#123;port&#125;` 12345function FindProxyForURL(url, host) &#123; if(url.substring(0,5) == &#x27;http:&#x27;) return &quot;PROXY http-proxy.mydomain.com:8080&quot; else if(url.substring(0,4) == &#x27;ftp:&#x27;) return &quot;PROXY ftp-proxy.mydomain.com:8080&quot; else return &quot;DIRECT&quot;&#125; MDN PAC 파일 참고자료 WPAD 파일웹 프록시 자동 발견 프로토콜 Web Proxy Auto-Discovery Protocol 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘이다. WPAD 프로토콜이 구현된 클라가 하게 될 일은 PAC URI를 찾기 위해 WPAD를 사용한다. 주어진 URI에서 PAC파일을 가져온다. 프록시 서버를 알아내기 위해 PAC파일을 실행한다. 알아낸 프록시 서버를 이용해서 요청을 처리한다. WPAD는 성공할 때까지 각 기법을 하나씩 시도해본다. (20장에서 자세히..) 동적 호스트 발견 규약 DHCP (Dynamic Host Configuration Protocol) 서비스 위치 규약 [SLP] DNS 잘 알려진 호스트 명 DNS SRV 레코드 DNS TXT 레코드 안의 서비스 URI 5. 프록시 요청의 특이사항 6가지 프록시 URI는 서버 URI와 다르다. 가상 호스팅에서 일어나는 같은 문제 인터셉트 프록시는 부분 URI를 받는다 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다. 전송 중 URI 변경 인터셉트 프록시를 이용한 URI 분석 5.1 프록시 URI는 서버 URI와 다르다. 웹 서버와 웹 프록시 메세지의 문법은 간다. 요청 URI가 달라진다.1234567클라 =&gt; 서버GET /index.html HTTP/1.0User-Agent: SuperBrowserv1.3클라 =&gt; 프록시GET http://www.mary.com/index.html HTTP/1.0User-Agent: SuperBrowserv1.3 애초에 단일 서버 기준으로 메세지 설계가 되었었다. 프록시가 부상하면서 부분 URI는 문제가 되었고, 프록시 기반 게이트웨이는 URI 스킴을 알 필요가 있었기 때문에 부분URI가 아닌 전체 URI를 보낸다. 5.2 가상 호스팅에서 일어나는 같은 문제 명시적인 프록시는 요청 메세지가 완전한 URI를 갖도록 함 가상 호스팅 웹 서버는 Host 헤더를 요구한다. 5.3 인터셉트 프록시는 부분 URI를 받는다 클라는 자신이 프록시와 대화하고 있음을 항상 알고 있지 않다. 몇몇 프록시는 클라에게는 보이지 않을 수 있다. (대리 프록시, 인터셉트 프록시) 때문에 보통 완전 URI를 보내지만, 위의 프록시들에게는 부분URI를 보내게된다. 5.4 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다. 다목적 프록시 서버는 요청 메세지에 완전URI와 부분URI를 모두 지원해야한다. 프록시&#x3D;&gt; 프록시로 요청시, 완전 URI&#x3D;&gt; 웹서버로 요청시, Host 헤더 5.5 전송 중 URI 변경프록시 서버는 요청 URI의 변경에 엄격해서는 안된다.사이드 이펙트를 일으킬 수 있다. 6. 메세지 추적 오늘날 웹 요청의 상당수가 프락시를 지나간다.&#x3D; 동시에 성능상의 이유로 세계 곳곳에 흩어져 있는 대리 캐시 저장고에 콘텐츠를 복제해두는 방식이 흔해지고있다. 프락시는 여러 벤더에 의해 개발된다. 프락시가 점점 흔해지면서, 프락시를 넘나드는 메세지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다. 6.1 Via 헤더 HTTP헤더 필드의 Via는 메세지가 지나는 각 중간 노드(Proxy or GateWay)의 정보를 나열한다. 노드를 지날때마다, 중간노드는 Via 목록의 끝에 반드시 추가되어야 한다. Via헤더 필드는 메세지의 전달을 추적하고, 메세지 루프를 진단하고, 요청을 보내고, 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메세지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용된다. 1Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com HTTP 1.1 프로토콜로 구현, proxy-62.irenes-isp.net로 불림 HTTP 1.0 프로토콜로 구현, cache.joes-hardware.com로 불림 네트워크 라우팅 루프를 탐지하기 위해 Via 헤더를 사용할 수 있다. Via 문법 쉽표로 구분되는 경유지waypoint 목록 각 경유지는 개별 프락시 서버나게이트웨이 홉을 나타낸다. 중간노드의 프로토콜과 주소에 대한 정보를 담고 있다. 1Via: ([ protocol-name &quot;/ ] protocol-version ( host [ &quot;:&quot; port] ) [ comment ]), (...) 123456Via: 1.1 62e18ccb7bd6.cloudfront.net (CloudFront)protocol-name: HTTPprotocol-version: 1.1host: 62e18ccb7bd6.cloudfront.netcomment: (CloudFront) 프로토콜 이름: 중개자가 받은 프로토콜 &#x2F; 프로토콜이 HTTP라면 이름이 없어도 된다. 프로토콜 버전: 수신한 메세지의 버전. 버전포맷은 프로토콜에 달려있다. 노드 이름: 중개자의 호스트와 포트번호(포트번호가 없으면 사용하는 프로토콜의 기본 포트라고 간주), 보안을위해 가명으로 대체 가능하다. 노드 코멘트: 중개자 노드를 서술하는 선택적인 코멘트. 벤더나 버전 정보를 포함한다. 프락시 서버에서 일어난 진단정보를 포함하기도 한다. Via 요청과 응답 경로 요청메세지가 프락시 A,B,C를 지나간다면,응답메세지는 프락시 C,B,A를 지나간다. 응답 Via 헤더는 거의 요청 Via 헤더와 반대다. Via와 게이트웨이 몇몇 프락시 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공한다. Via 헤더는 이러한 프로토콜 변환을 기록하므로 HTTP 어플리케이션은 프락시 연쇄에서 프로토콜 능력과 변환이 있었는지 알아챌 수 있다. Server헤더와 Via헤더 Server 응답 헤더 필드는 원서버에 의해 사용되는 소프트웨어를 알려준다. 응답 메세지가 프락시를 통과할 때, 프락시는 Server 헤더를 수정해서는 안된다. Server 헤더는 원 서버를 위해 존재한다.대신 프락시는 Via 항목을 추가해야 한다. 1Server: nginx/1.10.3 (Ubuntu) Via가 개인정보 보호와 보안에 미치는 영향 보안을 위한다면, Via 노드 이름을 가명으로 교체해야한다. 아주 강력한 보안을 위해 프락시는 정렬된 일련의 Via 경유지 항목들을 하나로 합칠 수 있다. 여러 경유지들이 모두 같은 조직의 통제하에 있고,호스트가 이미 가명으로 교체되지 ㅇ낳은 이상,그들에 대한 항목들을 합쳐서는 안된다. 수신된 프로토콜 값이 서로 다른 항목들도 합쳐서는 안된다. 12345Via 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com아래처럼 합칠 수 있다.Via: 1.0 foo, 1.1 concealed-stuff 6.2 TRACE 메서드 프락시가 점점 복잡해지고, 더 많은 벤더가 프락시 제품을 배치하면서, 상호운용성 문제가 증가한다. 프락시 네트워크를 진단하기 위해, HTTP&#x2F;1.1의 TRACE메서드는요청 메세지를 프락시의 연쇄를 따라가면서 관찰&#x2F;추적할 수 있도록 해준다. 프락시 흐름을 디버깅하는데 매우 유용하다. (널리 구현되지 않았다) TRACE 요청이 목적지 서버에 도착했을 때,서버는 전체 요청 메세지를 HTTP 응답 메세지의 본문에 포함시켜 송신자에게 그대로 돌려보낸다. Content-Type은 message&#x2F;http Max-Forwards 모든 프락시와 게이트웨이는 Max-Forwards를 지원해야 한다. TRACE와 OPTIONS 요청의 프락시 홉 갯수를 제한하기 위해 Max-Forwards를 사용한다. 전달되는 메세지가 무한루프에 빠지지 않는지프락시 연쇄를 테스트하거나, 연쇄 중간의 특정 프락시 서버들의 효과를 체크할 때 유용하다. Max-Forwards요청 헤더 필드는 이 요청 메세지가 몇번 더 다음 홉으로 전달될 수 있는지 말해주는 정수 하나를 담고 있다. 만약 0이라면, TRACE메서드를 더이상 전달하지 말고, 반드시 클라에게 돌려줘야한다. 0보다 크다면, 다음으로 전달될때 1을 감소하고 갱신해야한다. 7. 프락시 인증 접근 제어장치로써 제공될 수 있다. HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한,콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 매커니즘을 정의하고 있다. 제한된 콘텐츠에 대한 요청이 프락시 서버에 도착했을 때,407 Proxy Authorization Required 상태코드를 Proxy-Authenticate 헤더 필드와 함께 반환할 수 있다. 클라는 407 응답을 받게되면, 사용자에게 요구되는 자격을 수집한다. 자격을 획득하면: Proxy-Authenticate 헤더 필드에 자격을 담아서 다시 보낸다. 자격이 유효하면: 프락시는 원요청을 통과시킨다.자격이 유효하지 않으면: 407 응답을 보낸다. 프락시 인증은 인증해야하는 프락시가 연쇄상 있을 경우 잘 동작하지 않는다. 8. 프락시 상호운용성 클라, 서버, 프락시는 여러 벤더에 의해 만들어진다. 프락시 서버는 서로 다른 클라, 서버 사이를 중개해야한다. 8.1 지원하지 않는 헤더와 메서드 다루기 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야한다. 같은 이름의 헤더 필드가 여러개 있는 경우,그들의 상대적인 순서도 반드시 유지해야한다. 이해할 수 없는 메서드는 반드시 그대로 전달해야한다. 8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기 OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가어떤 기능을 지원하는지(메서드 등) 클라(혹은 프락시)가 알아볼 수 있게 해준다. 성공한다면, 200 OK 응답으로 반환한다.(서버에서 지원하거나, 지정한 리소스에 대한 가능한 선택적인 기능들을 서술하느 ㄴ여러 헤더를 포함하여) HTTP&#x2F;1.1이 명시한 헤더는, 서버에 의해 어떤 메서드가 지원되는지 서술하는 Allow 헤더 하나뿐이다. 8.3 Allow 헤더 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거한다.1Allow: GET, HEAD, PUT 서버는 클라가 원하는 모든 메서드를 지원해야할 의무는 없다. 요청에 대한 응답에는 실제로 지원하는 메서드들을 열거하는 Allow 헤더를 포함시켜야한다. 프락시는 Allow 필드를 수정할 수 없다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 MDN PAC 파일 참고자료 DHCP (Dynamic Host Configuration Protocol)","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"proxy","slug":"proxy","permalink":"http://feel5ny.github.io/tags/proxy/"}]},{"title":"한글은 노토산스, 영문/숫자는 다른 폰트로 해주세요...👀 (feat. unicode)","slug":"CSS_02","date":"2019-09-08T13:23:55.000Z","updated":"2024-11-23T12:12:54.695Z","comments":true,"path":"2019/09/08/CSS_02/","permalink":"http://feel5ny.github.io/2019/09/08/CSS_02/","excerpt":"","text":"노토 산스를 사용하다보면 영문과 숫자가 너무 날씬하다는 느낌을 받곤 했다.개인적인 취향으로 1 숫자 아랫부분에 있는 serif를 별로 좋아하지 않는다. 그밖에도 숫자에 볼륨감이 없어서 한글의 깔끔함에 비해서 영문과 숫자에 아쉬움들이 있곤했다. 글자간 커링도 작고, 카운터(속공간)도 작은 듯하고.. 그래도 점점 노토산스를 자주 애용하고 보다보니, 그냥 저냥 적응하고 있었는데, 회사 프로젝트에서 요 노토산스에 대해서 디자인 요청이 왔다. 한글은 노토산스로, 영문과 숫자, 특수문자는 오픈산스로 적용해주세요! (여기서 특수문자는 키보드서 shift와 함께 사용가능한 특수문자들) 듣던 중에 반가운 소리였다.(😘) 노토산스에 대해 개인적인 취향?을 해소해주는 디자인 요청이었기 때문에.그나저나 이걸 어떻게 적용할지는 고민이었다. 일일이 적용하는건 절대 말이 안된다고 생각했고, 다른 방법이 있을거라고 생각해보며 이리저리 서칭을 해보았다.이 포스팅에서는 어떤 원리로 font가 분리되어서 적용되는지에 대해서 설명하려고 한다. 글자 적용시 필요한 css의 @font-face에 대해서 알아보며, 크게는 @font-face를 포함하고 있는 at-rule의 개념과 css문의 개념을 가볍게 살펴본다. 바로 방법을 알고싶은 분들은 해당 단락은 넘어가도된다. @font-face에서 제공해주는 unicode range에 대해서 살펴본다. 실제 @font-face에서 적용하는 방법을 알아본다. 1. CSS문(CSS statement)과 @규칙 (At-rule), 그리고 @font-face우리가 보통 사용하는 규칙집합(선택자-선언 블록 쌍)은 큰 규칙집합 목록만으로 구성된 스타일 시트의 주요 구성 블록이다. 123p &#123; font-size: 10px&#125; 하지만 위 규칙집합들 이외에도 웹 개발자가 스타일 시트에서 전하고 싶은 다른 정보가 있을 수 있다. 문자 집합, import하려는 다른 외부 스타일 시트, font-face 또는 그밖의 다른 정보들과 같은. 위 정보들을 css에 담기 위해서는 특정 종류의 statement을 사용해야 한다. 1.1 CSS문 (CSS statement)statement(문)은 비공백 문자로 시작하여 첫 번째 닫는 중괄호 또는 세미콜론 (문자열 외에, 이스케이프되지 않고 다른 &#123;&#125;, () 및 [] 쌍에 포함되지 않는) 으로 끝나는 구성 블록이다. 다음과 같은 다른 종류의 문이 있다 1.1.1 규칙집합 Rulesets 위 그림 것처럼, CSS 선언의 컬렉션과 선택자에 의해 기술된 조건을 연결짓는 규칙집합 (또는 규칙). 우리가 흔히 사용하는. 1.1.2 At-Rule@ (U+0040 COMMERCIAL AT)로 시작한 다음statement의 마지막, 즉 블록 다음에는 세미콜론(;)이 오며,또는 다음 블록의 끝까지 계속 식별자가 뒤따른다. 식별자에 의해 정의된 각 유형의 at-rule은, 자체 내부 구문 및 의미(semantics)가 있을 수 있다. 메타 데이터 정보(@charset 또는 @import 같은), 조건부 정보(@media 또는 @document 같은) 또는 설명 정보(@font-face 같은)를 전달하는 데 사용된다. 중첩 문(nested statements) 이들은 at-rule, 조건부 그룹 규칙의 특정 부분집합에서 사용될 수 있는 문이다. 이러한 문은 오직 특정 조건이 일치되면 적용한다. at-rule의 @media는 브라우저가 돌아가는 장치가 표현된 조건과 일치하는 경우에만 적용된다. 미디어 쿼리에 정의된 조건과 연결합니다. at-rule의 @document는 현재 페이지가 일부 조건과 일치하는 경우에만 적용된다. (아직 실험)12345@document url(&quot;https://www.example.com/&quot;) &#123; h1 &#123; color: green; &#125;&#125; 1.2 @font-face at-rule의 @font-face CSS는 텍스트를 표시할 사용자 정의 글꼴을 지정한다. 이 글꼴은 원격 서버 또는 사용자 자신의 컴퓨터에 로컬로 설치된 글꼴에서 로드할 수 있다. 사용자의 컴퓨터에서 찾을 글꼴 이름을 지정하고사용자 에이전트가 일치 항목을 찾으면 로컬 글꼴이 사용된다. 그렇지 않으면 url() 함수를 사용하여 지정한 글꼴 리소스를 다운로드하여 사용한다. @font-face는 폰트 제작자들이 자신의 글꼴을 제공할 수 있게 함으로써 “웹 세이프” 글꼴 (즉, 보편적화된 흔한 웹 글꼴)에 국한되지 않고 콘텐츠를 디자인할 수 있게 한다. 찾고 사용할 로컬로 설치된 글꼴의 이름을 지정할 수 있기 때문에인터넷 연결에 의존하지 않고 글꼴을 기본 이상의 사용자 지정할 수 있다. url()과 local()을 함께 사용하는 것이 일반적이어서,사용자가 설치한 폰트의 사본이 사용 가능한 경우 사용되어,사용자의 기기에서 찾을 수 없는 경우 폰트의 사본을 다운로드하는 것으로 되돌아간다. 2. @font-face의 속성중 unicode-range 사용하기우리는 css에 정의된 글꼴정보가 글자에 적용될 시점에, 특정 문자는 필터하면서 적용되길 바라고 있다. 글자에 글꼴의 정의하는 부분은 css의 @font-face 블락 내부에서 선언되어야할 것이고, 특정 문자를 필터하기 위해서는 범위를 지정하는 부분이 필요하 것이다. 2.1 unicode-range 속성@font-face의 속성 중에는 unicode-range라는 속성이 존재한다.해당 속성은 글꼴에서 사용될 유니 코드 코드 포인트의 범위를 지정할 수 있다. 우리는 unicode-range를 사용하여 숫자와 영문, 특수문자의 범위를 알아내고, 해당 범위에 폰트를 지정할 것이다. 2.2 unicode와 범위유니코드 유니코드(Unicode)는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이며, 유니코드 협회(Unicode Consortium)가 제정한다. 유니코드의 목적은 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체하려는 것이다. 기존의 인코딩들은 그 규모나 범위 면에서 한정되어 있고, 다국어 환경에서는 서로 호환되지 않는 문제점이 있었다. 문자별 범위 유니코드에는 30가지 이상의 목차가 있다. 목차 우리는 숫자와 영문, 키보드로 입력가능한 특수문자에만 적용할 에정이므로, **Basic Latin**만 확인하면된다. 123451. 특수문자 범위: U+0020-002F, U+003A-0040, U+005B-0060, U+007B-007E2. 영문 범위: U+0041-005A(대문자), U+0061-007A(소문자)3. 숫자 범위: U+0030-0039전체 U+0020-007E 3. 실제 @font-face에서 적용하는 방법 실제 css의 font-family에 사용할 때에는 다르게 적용하고 싶은 문자마다 css를 적용하는 것이 아니다. 우리는 noto-sans를 전체 적용했지만, 특정 문자만 open-sans를 사용하고 싶은 상황이기 때문에, font-family에 따로 Open-sans 명시 없이 그대로 Noto-sans가 명시된 상태에서 내부적으로 적용시점에만 따로 적용되게 하면 된다. 이를 위해서는 같은 이름의 font-family를 갖는 두개의 @font-face가 필요하다. 하나의 @font-face에는 unicode-range없이 전체 적용할 noto-sans를 연결하고 다른 @font-face에는 unicode-range를 정의하고 해당 범위에만 적용할 open-sans를 연결한다. 12345678910111213@font-face &#123; font-family: &quot;NotoSansKR&quot;; src: url(&quot;../fonts/notoSansKR/NotoSans-Bold.woff&quot;) format(&quot;woff&quot;); font-style: normal;&#125;@font-face &#123; font-family: &quot;NotoSansKR&quot;; src: url(&quot;../fonts/openSans/OpenSans-SemiBold.woff&quot;) format(&quot;woff&quot;); unicode-range: U+0020-007E; font-style: normal;&#125; 참고자료 at-rule mdn font-face mdn css statement mdn 유니코드 목차","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. CSS","slug":"01-Web/03-CSS","permalink":"http://feel5ny.github.io/categories/01-Web/03-CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://feel5ny.github.io/tags/css/"},{"name":"unicode","slug":"unicode","permalink":"http://feel5ny.github.io/tags/unicode/"},{"name":"font","slug":"font","permalink":"http://feel5ny.github.io/tags/font/"}]},{"title":"웹 서버","slug":"HTTP_005","date":"2019-09-07T07:23:55.000Z","updated":"2024-11-23T12:12:24.877Z","comments":true,"path":"2019/09/07/HTTP_005/","permalink":"http://feel5ny.github.io/2019/09/07/HTTP_005/","excerpt":"","text":"HTTP 통신을 진단해주는 간단한 웹 서버를 node.js로 작성해본다. 어떻게 웹 서버가 HTTP 트랜젝션을 처리하는지 단계별로 설명해본다. 웹 서버가 하는 일 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다. 웹 서버는 자신이 제공하는 리소스를 관리하고, 웹 서버를 설정, 통제, 확장하기 위한 관리 기능을 제공한다. 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다. 운영체제는 컴퓨터 시스템의 하드웨어를 관리하고 TCP&#x2F;IP 네트워크 지원 웹 리소스를 유지하기 위한 파일 시스템 현재 연산 활동을 제어하기 위한 프로세스 관리를 제공한다. 웹 서버는 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치하고 실행할 수 있다. 몇몇 공유기들은 웹브라우저로 접근 가능한 관리 기능을 제공한다. node.js로 간단 웹서버를 구현해 보았다. loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-feel5ny-httpStudy-37558bf54d1222ef6413274b392c7318c0c60bd5\", \"feel5ny\", \"httpStudy\", \"37558bf54d1222ef6413274b392c7318c0c60bd5\", false); 공통적으로는 아래 그림에서 하는 일을 한다. 커넥션을 맺는다. 클라의 접속을 받아들이거나, 원치 않는 클라라면 닫는다. 요청을 받는다. HTTP 요청 메세지를 네트워크로부터 읽어 들인다. 요청을 처리한다. 요청 메세지를 해석하고 행동을 취한다. 리소스에 접근한다. 메세지에서 지정한 리소스에 접근한다. 응답을 만든다. 올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다. 응답을 보낸다. 응답을 클라에게 돌려준다. 트랜잭션을 로그로 남긴다. 로그파일에 트랜잭션 완료에 대한 기록을 남긴다. 1. 클라이언트 커넥션 수락 클라가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면, 해당 커넥션을 사용할 수 있다. 그렇지 않다면, 새로운 커넥션을 열 필요가 있다. 1.1 새 커넥션 다루기 클라가 웹 서버에 TCP 커넥션을 요청하면, 웹 서버는 그 커넥션을 맺고 TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라가 있는지 확인한다. 새 커넥션이 맺어지고 받아들여지면, 서버는 새 커넥션을 커넥션 목록에 추가하고, 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다. 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다. 어떤 웹서버들은 클라의 IP 주소나 호스트명이 인가되지 않았거나, 악의적이라고 알려진 것인 경우 커넥션을 닫는다. 1.2 클라이언트 호스트명 식별 **역방향 DNS(reverse DNS)**를 사용해서 클라의 IP 주소를 클라의 호스트 명으로 변환하도록 설정되어 있다. 웹서버는 클라이언트 호스트 명을 구체적인 접근 제어와 로깅을 위해 사용할 수 있다. 호스트명 룩업(hostname lookup)은 꽤 시간이 많이 걸릴 수 있어, 웹 트랜잭션을 느려지게 할 수 있다. 많은 대용량 웹 서버는 호스트명 분석(hostname resolution)을 꺼두거나, 특정 콘텐츠에 대해서만 켜놓는다. 1.3 ident를 통해 클라이언트 사용자 알아내기 몇몇 웹서버는 또한 IETF ident 프로토콜을 지원한다. IETF: 국제 인터넷 표준화 기구 Internet Engineering Task Force ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해준다. 이 정보는 특히 웹서버 로깅에서 유용하기 때문에, 널리 쓰이는 일반 로그포맷(Common Log Format)의 두 번째 필드는 각 HTTP 요청의 ident 사용자 이름을 담고 있다. ident protocol - wiki 아래는 어떻게 ident 프로토콜이 동작하는지 보여준다. 만약 클라가 ident 프로토콜을 지원한다면, 클라는 ident 결과를 위해 TCP port 113번을 listen한다. 공공 인터넷에서는 다음과 같은 이유로 잘 동작하지 않는다. 많은 클라 PC는 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않는다. ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연시킨다. 방화벽이 ident 트래픽이 들어오는 것을 막는 경우가 많다. ident 프로토콜은 안전하지 않고 조작하기 쉽다. ident 프로토콜은 가상 IP 주소를 잘 지원하지 않는다. 클라 사용자 이름의 노출로 인한 프라이버시 침해의 우려가 있다. 2. 요청 메세지 수신 커넥션 데이터가 도착하면,웹서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고,파싱하여 요청 메세지를 구성한다. 요청 메세지를 파싱할 때, 웹서버는 다음과 같은 일을 한다. 요청줄을 파싱하여 요청 메서드, 지정된 리소스의 식별자(URI), 버전 번호를 찾는다.각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 캐리지 리턴 줄바꿈(CRLF) 문자열로 끝난다. (참고) 메세지 헤더들을 읽는다. 각 메세지 헤더는 CRLF로 끝난다. 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다. 요청 본문이 있다면, 읽어 들인다. (길이는 Content-Length 헤더로 정의한다.) 2.1 메세지의 내부 표현 몇몇 웹서버는 요청 메세지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장한다. 자료구조는 요청 메세지의 각 조각에 대한 포인터와 길이를 담을 수 있을 것이고,헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근할 수 있을 것이다. 2.2 커넥션 입력&#x2F;출력 처리 아키텍처 고성능 웹서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다. 어떤 커넥션들로부터는 요청이 느리게, 혹은 드물게 흘러 들어오고,또 어떤 것들은 나중에 일어날 활동을 위해 대기하고 있는데 비해,일부 커넥션들은 웹 서버로 급속히 요청을 보내고 있을 것이다. 웹 서버들은 항상 새 요청을 주시하고 있다. 요청은 언제라도 도착할 수 있기 때문이다. 웹 서버는 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다. 2.2.1 단일 스레드 웹서버 단일 스레드 웹서버는 한 번에 하나씩 요청을 처리한다. 트랜젝션이 완료되면, 다음 커넥션이 처리된다. 처리 도중에 모든 다른 커넥션은 무시된다. 성능 문제를 만들어내므로, 로드가 적은 서버나 진단도구에서만 적당하다. 2.2.2 멀티스레드와 멀티스레드 웹서버 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 할당한다. 프로세스란 어떤 프로그램의 자신만의 변수 집합을 갖는 하나의 독립된 제어 흐름이다. 스레드는 프로세스의 더 빠르고 더 효율적인 버전이다. 스레드와 프로세스 모두 하나의 프로그램이 여러 작업을 동시에 할 수 있게 해준다. 몇몇 서버는 매 커넥션마다 스레드&#x2F;프로세스 하나를 할당하지만,서버가 수만 개의 동시 커넥션을 처리할 때 그로 인해 만들어진 수많은 프로세스나 스레드는 너무 많은 메모리나 시스템 리소스를 소비한다. 많은 멀티스레드 웹 서비스가 스레드&#x2F;프로세스의 최대 개수를 제한을 건다. 2.2.3 다중 I&#x2F;O 대량의 커넥션을 지원하기 위해, 많은 웹 서버는 다중 아키텍처를 채택했다. 다중 아키텍처에서는 모든 커넥션은 동시에 그 활동을 감시당한다. 커넥션의 상태가 바뀌면 (예: 데이터를 사용할 수 있게 되거나, 에러가 발생),그 커넥션에 대해 작은 양의 처리가 수행된다. 그 처리가 완료되면, 커넥션은 다음번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다. 스레드와 프로세스는 유휴 상태의 커넥션에 매여 기다리느라 리소스를 낭비하지 않는다. 2.2.4 다중 멀티스레드 웹서버 몇몇 시스템은 자신의 컴퓨터 플랫폼에 올라와 있는 CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 다중화(multiplexing)를 결합한다. 여러 개의 스레드(보통 하나의 물리적 프로세스)는 각각 열려있는 커넥션(혹은 열려있는 커넥션의 부분집합)을 감시하고, 각 커넥션에 대해 조금씩 작업을 수행한다. 3. 요청 처리 4. 리소스의 매핑과 접근 웹서버는 리소스 서버다. 그들은 HTML 페이지나 JPEG 이미지 같은 미리 만들어진 콘텐츠를 제공하며,서버 위에서 동작하는 리소스 생성 어플리케이션을 통해, 만들어진 동적 콘텐츠도 제공한다. 웹서버가 클라에 콘텐츠를 전달하려면, 그 전에 요청 메세지의 URI에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹서버에서 찾아서 그 콘텐츠의 원천을 식별해야 한다. 4.1 Docroot 가장 단순한 형태는 요청 URI를 웹서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것이다. 일반적으로 웹서버 파일시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해둔다. 이 폴더는 문서 루트 혹은 docroot로 불린다. 웹서버는 요청 메세지에서 URI를 가져와서 문서 루트 뒤에 붙인다. httpd.conf 설정 파일에 docroot 경로를 설정해두면 요청 헤더의 URI를 문서 루트 뒤에 붙인다. 12GET /specials/joy.gif HTTP/1.0HOST: feel5ny.github.io 1DocumentRoot /usr/local/httpd/files /usr/local/httpd/files + /specials/joy.gif 서버는 docroot 이외의 부분이 노출되는 일이 생기지 않도록 주의해야 한다.1https://feel5ny.github.io/.../ 4.1.1 가상 호스팅 된 docroot 가상 호스팅 웹서버는 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로, 한 웹서버에서 여러 개의 웹사이트를 호스팅한다. 가상 호스팅 웹서버는 URI나 Host 헤더에서 얻은 IP 주소나 호스트 명을 이용해 올바른 문서 루트를 식별한다. 4.1.2 사용자 홈 디렉터리 docroots 사용자들이 한대의 웹서버에서 각자의 개인 웹사이트를 만들 수 있도록 해주는 것이다. 보통 /과 물결표~ 다음에 사용자 이름이 오는 것으로 시작하는 URI는 그 사용자의 개인 문서 루트를 가리킨다. 개인 docroot는 주로 사용자 홈 디렉터리 안에 있는 public_html로 불리는 디렉터리지만, 설정에 따라 다르다. 4.2 디렉터리 목록 웹서버는 경로가 파일이 아닌, 디렉터리를 가리키는, 디렉터리 URL에 대한 요청을 받을 수 있다. 대부분의 웹서버는 클라가 디렉터리 URL을 요청했을 때,다음과 같이 몇가지 다른 행동을 취하도록 설정할 수 있다. 에러를 반환한다. 디렉터리 대신 특별한 ‘색인파일’을 반환한다. 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환한다. 대부분의 웹서버는 요청한 URL에 대응되는 디렉터리 안에서 index.html 혹은 index.htm으로 이름 붙은 파일을 찾아 반환한다. 사용자가 디렉터리 URI를 요청했을 때, 기본 색인 파일이 없고 디렉터리 색인 기능이 꺼져있지 않다면, 많은 웹서버는 자동으로 그 디렉터리의 파일들을 크기, 변경일 및 그 파일에 대한 링크와 함께 열거한 HTML 파일을 반환한다. 4.3 동적 콘텐츠 리소스 매핑 웹서버는 URI를 동적 리소스에 매핑할 수도 있다. 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑하는 것이다. 웹서버들 중에서 어플리케이션 서버라고 불리는 것들은 웹서버를 복잡한 백엔드 어플리케이션과 연결하는 일을 한다. 어플리케이션 서버는 그에 대한 동적 콘텐츠 생성 프로그램이 어디에 있는지, 그리고 어떻게 그 프로그램을 실행하는지 알려줄 수 있어야 한다. 대부분의 웹서버는 동적 리소스를 식별하고 매핑할 수 있는 기본적인 매커니즘을 갖고 있다. URI의 경로명이 실행 가능한 프로그램이 위치한 디렉터리로 매핑되도록 설정하는 기능을 제공하는 웹서버도 있다. 서버가 실행 가능한 경로명을 포함한 URI로 요청을 받으면, 그 경로에 대응하는 디렉터리에서 프로그램을 찾아 실행하려 시도한다. 4.4 서버사이드 인클루드 Server-Side Includes, SSI 만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 클라에게 보내기 전에 처리한다. 서버는 콘텐츠에 변수 이름이나 내장된 스크립트가 될 수 있는 어떤 특별한 패턴이 있는지 검사를 받는다. 특별한 패턴은 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환된다. 이것은 동적 콘텐츠를 만드는 쉬운 방법이다. 4.5 접근 제어 각각의 리소스에 접근제어를 할당할 수 있다. 웹서버는 클라의 IP 주소에 근거하여 접근을 제어할 수 있고, 접근하기 위한 비밀번호를 물어볼 수도 있다. HTTP 인증에서 자세히 다룬다. 5. 응답 만들기 응답메세지는 응답상태코드, 응답헤더, 응답본문을 포함한다. 5.1 응답 엔터티본문이 있다면, 응답 메세지는 주로 다음을 포함한다. 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더 응답 본문의 길이를 서술하는 Content-Length 헤더 실제 응답 본문의 내용 5.2 MIME 타입 결정하기웹 서버에게는 응답 본문의 MIME타입을 결정해야하는 책임이 있다.MIME타입과 리소스를 연결하는 여러 가지 방법이다. 5.2.1 mime.types 파일 이름의 확장자를 사용할 수 있다. 웹서버는 각 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME타입이 담겨있는 파일을 탐색한다. 확장자에 따라 mime타입을 결정한다.확장자별 mime타입 - mdn 5.2.2 매직 타이핑 Magic typing 아파치 웹 서버는 각 파일의 MIME타입을 알아내기 위해 파일의 내용을 검사해서 알려진 패턴에 대한 테이블 (매직 파일이라 불린다)에 해당하는 패턴이 있는지 찾아볼 수 있다. 느리긴 하지만, 파일이 표준 확장자 없이 이름 지어진 경우에는 편리하다. 매직 넘버. 다른 종류의 파일의 문법은 구조 상 보여지는 타입을 결정하는 데 도움을 줍니다. 예를 들어, 각 GIF 파일들은 47 49 46 38 16진수 값 [GIF89]로 시작되며 PNG 파일의 경우 89 50 4E 47 [.PNG]로 시작됩니다. 파일의 모든 타입들이 이런 매직 넘버를 가지고 있는 것은 아니므로 100% 신뢰할 만한 시스템은 아니기도 합니다.출처 5.2.3 유형 명시 Explicit typing 특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이어떤 MIME 타입을 갖도록 웹 서버를 설정할 수 있다. 5.2.4 유형 협상 Type negotiation 어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다. 이때 웹 서버가 사용자와의 협상 과정을 통해 사용하기 가장 좋은 형식(그리고 대응하는 MIME타입)을 판별할 것인지의 여부도 설정할 수 있다. 웹서버는 특정 파일이 특정 MIME타입을 갖게끔 설정할 수도 있다. 관련내용 5.3 리다이렉션 웹 서버는 종종 성공 메세지 대신 리다이렉션 응답을 반환한다. 웹 서버는 요청을 수행하기 위해, 브라우저가 다른 곳으로 가도록 리다이렉트할 수 있다. Location 응답헤더는 콘텐츠의 새로운 혹은 선호하는 위치에 대한 URI를 포함한다. 30x 상태코드 정리본 영구히 리소스가 옮겨진 경우 - 301 임시로 리소스가 옮겨진 경우 - 303, 307 URL 증강 - 303, 307 부하 균형 - 303, 307 친밀한 다른 서버가 있을 때 - 303, 307 디렉터리 이름 정규화 5.3.1 영구히 리소스가 옮겨진 경우 리소스는 새 URL이 부여되어 새로운 위치로 옮겨졌거나 이름이 바뀌었을 수 있다. 웹 서버는 클라에게 리소스의 이름이 바뀌었으므로, 클라는 북마크를 갱신하거나 할 수 있다고 말해줄 수 있다. 301 Moved Permanetly 상태코드는 이런 종류의 리다이렉트를 위해 사용된다. 5.3.2 임시로 리소스가 옮겨진 경우 리소스가 임시로 옮겨지거나, 이름이 변경된 경우, 서버는 클라를 새 위치로 리다이렉트 하길 원할 것이다. 이름 변경이 임시적이기 때문에, 서버는 클라가 나중에는 원래 URL로 찾아오고 북마크도 갱신하지 않기를 원한다. 303 See Other과 307 Temporary Redirect 상태코드는 이런 종류의 리다이렉트를 위해 사용된다. 5.3.3 URL 증강 서버는 종종 **문맥 정보(Context)**를 포함시키기 위해 재 작성된 URL로 리다이렉트한다. 요청이 도착했을 때, 서버는 상태 정보를 내포한 새 URL을 생성하고 사용자를 이 새 URL로 리다이렉트한다. 상태 정보가 추가된 URL은 흔히 뚱뚱한 URL이라고도 부른다. 클라는 리다이렉트를 따라가서, 상태 정보가 추가된 완전한 URL을 포함한 요청을 다시 보낸다. 303 See Other과 307 Temporary Redirect 상태코드를 사용한다. 5.3.4 부하 균형 과부하된 서버가 요청을 받으면,서버는 클라를 좀 덜 부하가 걸린 서버로 리다이렉트할 수 있다. 303 See Other과 307 Temporary Redirect 상태코드를 사용한다. 5.3.5 친밀한 다른 서버가 있을 때 웹 서버는 어떤 사용자에 대한 정보를 가질 수 있다. 서버는 클라를 그 클라에 대한 정보를 갖고 있는 다른 서버로 리다이렉트할 수 있다. 303 See Other과 307 Temporary Redirect 상태코드를 사용한다. 5.3.6 디렉터리 이름 정규화 클라가 디렉터리 이름에 대한 URI를 요청하는데 끝에 빗금(/)을 빠뜨렸다면,대부분의 웹 서버는 상대경로가 정상적으로 동작할 수 있도록클라를 슬래시를 추가한 URI로 리다이렉트한다. 6. 응답 보내기 서버는 여러 클라에 대한 많은 커넥션을 가질 수 있다. 그들 중 일부는 아무것도 안 하고 있는 상태이고, 일부는 서버로 데이터를 보내고 있으며, 또 다른 일부는 클라로 돌려줄 응답 데이터를 실어 나르고 있을 것이다. 서버는 커넥션 상태를 추적해야 하며,지속적인 커넥션은 특별히 주의해서 다룰 필요가 있다. 비지속 커넥션이라면, 서버는 모든 메세지를 전송했을 때 자신 쪽 커넥션을 닫을 것이다. 지속적인 커넥션이라면,서버가 Content-Length 헤더를 바르게 계산하기 위해 특별히 주의를 필요로 하는 경우,클라가 응답이 언제 끝나는지 알 수 없는 경우, 커넥션은 열린 상태를 유지할 것이다. 7. 로깅 트랜잭션이 완료되었을 때, 웹서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다. 대부분의 웹서버는 로깅에 대한 여러 가지 설정 양식을 제공한다. 자세한건 책의 21장.. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 컨텐츠 협상 ident protocol - wiki 확장자별 mime타입 - mdn 매직넘버 - mdn","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"웹서버","slug":"웹서버","permalink":"http://feel5ny.github.io/tags/%EC%9B%B9%EC%84%9C%EB%B2%84/"}]},{"title":"커넥션 관리 - TCP 커넥션의 종류","slug":"HTTP_004_02","date":"2019-09-04T07:23:55.000Z","updated":"2024-11-23T12:12:24.921Z","comments":true,"path":"2019/09/04/HTTP_004_02/","permalink":"http://feel5ny.github.io/2019/09/04/HTTP_004_02/","excerpt":"","text":"병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화 커넥션 관리를 위해 따라야 할 규칙들 1. 병렬 커넥션 parallel HTTP는 클라가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다. 1.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다. 하나의 커넥션으로 객체들을 로드할 때의 대역폭 제한과대기시간을 줄일 수 있다면더 빠르게 로드할 수 있을 것이다. 위 그림은 병렬 커넥션 방식을 개략적으로 보여준다. html을 머저 내려받고, 남은 3개의 트랜잭션이각각 별도의 커넥션에서 동시에 처리된다. 이미지들을 병렬로 내려받아 커넥션 지연이 겹쳐짐으로써 총 지연시간이 줄어든다. 1.2 병렬 커넥션이 항상 더 빠르지는 않다. 클라의 네트워크 대역폭이 좁을 때는 대부분 시간을 데이터 전송하는 데만 쓸 것이다. 다수의 커넥션은 메모리를 많이 소모하고, 자체적인 성능 문제를 발생시킨다. 브라우저는 실제로 병렬 커넥션을 사용하긴 하지만, 적은 수(대부분 4개, 최신 브라우저는 6~8개)의 병렬 커넥션만을 허용한다. 서버는 특정 클라로부터 과도한 수의 커넥션이 맺어졌을 경우, 그것을 임의로 끊어버릴 수 있다. 1.3 병렬 커넥션은 더 빠르게 느껴질 수 있다. 병렬 커넥션이 실제로 페이지를 더 빠르게 내려받는 것은 아니지만, 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있다. 사실 사람들은 페이지의 총 다운로드 시간이 더 걸린다 하더라도, 화면 전체에서 여러 작업이 일어나는 것으 ㄹ눈으로 확인할 수 있으면 그것을 더 빠르다고 여긴다. 2. 지속 커넥션 persistent웹 클라는 보통 같은 사이트에 여러 개의 커넥션을 맺는다. 즉 같은 서버에 계속 요청 사이트 지역성이라 부른다. site locality 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부른다. HTTP&#x2F;1.1을 지원하는 기기는 처리가 완료된 후에도TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용 할 수 있다. 커넥션을 맺기 위한 준비 작업에 따르는 시간을 절약할 수 있다. TCP의 느린 시작으로 인한 지연을 피할 수 있다. 2.1 지속 커넥션 vs 병렬 커넥션병렬 커넥션의 단점 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다. 새로운 커넥션은 TCP의 느린 시작 때문에 성능이 떨어진다. 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다. 지속 커넥션의 장점 커넥션을 맺기 이한 사전 작업 지연을 줄여줌 튜닝된 커넥션을 유지 커넥션의 수를 줄여준다. 지속 커넥션의 단점 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 될 것이다. 지속 커넥션 + 병렬 커넥션은 가장 효과적 HTTP&#x2F;1.0+ 에는 keep-alive 커넥션이 있고,HTTP&#x2F;1.1에는 지속 커넥션이 있다. 2.2 HTTP&#x2F;1.0+의 Keep-Alive 커넥션 초기의 지속 커넥션은 상호 운용과 관련된 설계에 문제가 있었지만,아직 많은 클라와 서버는 이 초기 keep-alive 커넥션을 사용하고 있다. 설계상의 문제는 HTTP&#x2F;1.1에서 수정되었다. 2.2.1 Keep-Alive 동작 HTTP&#x2F;1.1에서는 keep-alive는 사용하지 않기로 결정 아직 keep-alive 핸드셰이크가 널리 사용되고 있음. HTTP&#x2F;1.0 keep-alive 커넥션을 구현한 클라는 커넥션을 유지하기 위해서 요청에Connection: Keep-Alive 헤더를 포함시킨다. 이 요청을 받은 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메세지에 같은 헤더를 포함시켜 응답한다. 응답에 Connection: Keep-Alive가 없으면, 클라는 서버가 keep-alive를 지원하지 않으며,응답 메세지가 전송되고 나면 서버 커넥션을 끊을 것이라고 추정한다. 2.2.2 Keep-Alive 옵션 (헤더) keep-alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다. 클라나 서버가 keep-alive 요청을 받았다고 해서 무조건 그것을 따를 필요는 없다. Connection: Keep-Alive가 있을 때만 사용 가능하다. HTTP&#x2F;2에서는 무시된다. keep-alive의 동작은 Keep-Alive 헤더의 옵션들로 제어 가능하다 12Keep-Alive: timeout=5, max=10005초 동안 1000개의 커넥션을 유지하라는 내용 timeout 커넥션이 얼마간 유지될 것인지를 의미한다. 이대로 동작한다는 보장은 없다. max 커넥션이 몇 개의 HTTP 트렌젝션을 처리할 때까지 유지될 것인지를 의미한다. 이대로 동작한다는 보장은 없다. mdn 참고 2.2.3 Keep-Alive 커넥션 제한과 규칙 HTTP&#x2F;1.0과 HTTP&#x2F;2.0에서는 사용되지 않는다. Connection: Keep-Alive Connection: Keep-Alive가 있을 때만 사용 가능하다. Connection: Keep-Alive가 없을 경우 서버는 요청을 처리한 후 커넥션을 끊을 것이다. 클라는 Connection: Keep-Alive가 없을 경우 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있다. Content-Length과 커넥션 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다. 엔터티 본문이 정확한 Content-Length 값과 함께 멀티파트 미디어 형식을 가지거나, 청크 전송 인코딩 chunked transfer encoding으로 인코드 되어야 함을 뜻한다. keep-alive 커넥션에서 잘못된 Content-Length 값을 보내는 것은 좋지 않다. 트랜잭션이 끝나는 시점에 기존 메세지의 끝과 새로운 메세지의 시작점을 정확히 알 수 없기 때문이다. Connection 헤더 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다. (명시된 헤더는 다 제거되기 때문) keep-alive 커넥션은 connection 헤더를 인식하지 못하는 프락시 서버와 맺어지면 안 된다. HTTP&#x2F;1.0 을 따르는 기기로부터 받는 모든 Connection 헤더 필드는 무시해야 한다.오래된 프락시 서버로부터 실수로 전달될 수 있기 때문. 2.2.4 Keep-Alive와 dumb(멍충한) 프락시 Connection 헤더의 무조건 전달 웹 클라는 프락시에 Connection: Keep-Alive 헤더와 함께 메세지를 보내고, 커넥션을 유지하기를 요청한다. 클라는 커넥션을 유지하자는 요청이 받아들여졌는지 확인하기 위해 응답을 기다린다. 멍청한 프락시는 Connection 헤더를 이해하지 못해서 다음 서버에 메세지를 그대로 전달한다. Connection헤더는 홉별 헤더다.(hop-by-hop): 오직 한 개의 전송 링크에만 적용되며, 다음 서버로 전달되어서는 안 된다. Connection: Keep-Alive를 받은 웹 서버는 커넥션을 유지하자고 요청하는 것으로 잘못 판단하게 된다. 클라가 아닌 프락시와 커넥션을 유지하는 것에 동의하고 Connection: Keep-Alive 헤더를 포함하여 응답한다. 하지만 프락시는 Connection를 모른다. 프락시는 Connection: Keep-Alive 헤더를 포함하고 있는 응답메세지를 클라에게 전달한다. 클라는 이 헤더를 통해 프락시가 커넥션을 유지하는 것에 동의했다고 추정한다. 클라와 서버는 커넥션을 유지한다고 생각하지만, 정작 프락시는 모름. Connection를 모르는 프락시는 모든 데이터를 클라에게 전달하고 서버가 커넥션을 끊기를 기다린다. 하지만 서버는 커넥션을 유지하고, 프락시는 끊어지기 전까지 기다린다. 클라는 유지되고 있다고 생각되는 커넥션으로 다음 요청을 보내는데, 프락시는 예상치 못한 요청이 들어온 거라 프락시로부터 무시되고, 브라우저는 아무런 응답 없이 로드 중이라는 표시만 나온다. 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다린다. 프락시와 홉별 헤더위의 잘못된 통신을 피하려면 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안 된다. 프락시는 Connection 헤더, Keep-Alive 헤더도 전달하면 안 된다. 홉별 헤더들 역시 전달하거나 캐시하면 안 된다. Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 2.2.5 Proxy-Connection 살펴보기 Proxy-Connection은 비표준 헤더이다. 프록시가 종종 여러 계층으로 배치되어 있기 때문에 2.6와 같은 문제를 야기한다. 클라는 요청 시 Proxy-Connection 헤더 필드를 보내지 않도록 권장한다. Connection 헤더를 모르는 프락시에게 Connection 대신에 Proxy-Connection 확장 헤더를 프락시에게 전달한다. 웹 서버는 Proxy-Connection를 무시한다. 영리한 프락시라면, 의미 없는 Proxy-Connection헤더를 Connection 헤더로 바꿈으로써 원하던 효과를 얻게 된다. RFC 7230Proxy-Connection vs Connection header 2.3 HTTP&#x2F;1.1의 지속 커넥션 설계가 더 개선된 지속 커넥션을 지원한다. default로 활성화되어있다. HTTP&#x2F;1.1 어플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection:close 헤더를 명시해야 한다. HTTP&#x2F;1.1 클라는 응답에 Connection:close 헤더가 없으면 응답 후에도 커넥션을 계속 유지하는 것으로 추정한다. 클라와 서버는 언제든지 커넥션을 끊을 수 있다. Connection:close를 보내지 않는 것이 서버가 커넥션을 영원히 유지하겠다는 것은 아니다. 2.3.1 지속 커넥션의 제한과 규칙 클라가 요청에 Connection:close헤더를 포함해 보내면,클라는 그 커넥션으로 추가적인 요청을 보낼 수 없다. 클라가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection:close 헤더를 보내야 한다.. 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다. 엔터티 본문이 정확한 Content-Length 값을 가지거나, 청크 전송 인코딩 chunked transfer encoding으로 인코드 되어야 함을 뜻한다. Connection 헤더의 값과 상관없이 언제든지 커넥션을 끊을 수 있다. 3. 파이프라인 커넥션 pipelined HTTP&#x2F;1.1은 지속 커넥션을 통해서 요청을 파이프라이팅할 수 있다. keep-alive 커넥션의 성능을 더 높여준다. 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓인다. 대기 시간이 긴 네트워크 상황에서 네트워크 상의 왕복으로 인한 시간을 줄여서 성능을 높여준다. 3.1 파이프라인의 제약사항 HTTP 클라는 커넥션이 지속 커넥션인지 확인하기 전까지 파이프라인을 이어서는 안 된다. 응답은 요청 순서와 같게 와야 한다. 순서 없이 오면 순서에 맞게 정렬시킬 방법이 없다. HTTP 클라는 POST 요청같이(비멱등) 반복해서 보낼 경우, 문제가 생기는 요청은 파이프라인을 통해 보내면 안 된다. 에러가 발생하면 파이프라인을 통한 요청 중에 어떤 것들이 서버에서 처리되었는지 클라는 알 방법이 없다. 4. 커넥션 끊기에 대한 미스터리4.1 마음대로 커넥션 끊기 보통 커넥션은 메세지를 다 보낸 다음 끊지만,에러가 있는 상황에서는 헤더의 중간이나, 다른 엉뚱한 곳에서 끊길 수 있다. 4.2 Content-Length와 Truncation(끊기) 각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다. 클라나 프락시가 커넥션이 끊어졌다는 HTTP 응답을 받은 후,실제 전달된 엔터티의 길이와 Content-Length의 값이 일치하지 않거나Content-Length 자체가 존재하지 않으면, 수신자는 데이터의 정확한 길이를 서버에게 물어봐야 한다. 4.3 커넥션 끊기의 허용, 재시도 커넥션은 에러가 없더라도 언제든 끊을 수 있다. 클라가 트랜잭션을 수행 중에 전송 커넥션이 끊기게 되면, 클라는 그 트랜잭션을 재시도 하더라도, 문제가 없다면(멱등성) 커넥션을 다시 맺고 한 번 더 전송을 시도해야 한다. 이건 파이프라인 커넥션에서는 어렵다. 클라는 여러 요청을 큐에 쌓아 놓을 수 있지만,서버는 아직 처리되지 않고 스케줄이 조정되어야 하는 요청들을 남겨둔 채로 커넥션을 끊어버릴 수도 있다. 4.4 우아한 커넥션 끊기 TCP 커넥션은 그림처럼 양방향이다. TCP 커넥션의 양쪽에는 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 있다. 전체 끊기와 절반 끊기 전체 끊기: close()를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다. 절반 끊기: shutdonw()을 호출하면 입력 채널이나 출력 채널 중에 하나만을 개별적으로 끊는다. TCP 끊기와 리셋 에러 잘 모르겠다. 보통은 커넥션의 출력 채널을 끊는 것이 안전하다. 커넥션의 반대편에 있는 기기는 모든 데이터를 버퍼로부터 읽고 나서, 데이터 전송이 끝남과 동시에 당신이 커넥션을 끊었다는 것을 알게 될 것이다. 클라에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험하다. 서버의 운영체제는 TCP ‘connection reset by peer’ 메세지를 클라에게 보낼 것이다. 대부분의 운영체제는 이것을 심각한 에러로 취급하여 버퍼에 저장된, 아직 읽히지 않은 데이터를 모두 삭제한다. 파이프라인 커넥션에서는 이러한 상황은 더 악화된다. 우아하게 커넥션 끊기 우아하게 커넥션 끊기를 구현하는 것은 어플리케이션 자신의 출력 채널을 먼저 끊고, 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다. 양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면 커넥션은 리셋의 위험 없이 온전히 종료된다. 상대방이 절반 끊기를 구현했다는 보장도 없어서, 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검사를 주기적으로 해야 한다. HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 fetch 공식문서 fetch api XMLhttprequest 공식문서 keep alive관련 RFC문서","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://feel5ny.github.io/tags/TCP-IP/"},{"name":"connection","slug":"connection","permalink":"http://feel5ny.github.io/tags/connection/"}]},{"title":"커넥션 관리 - TCP 커넥션과 성능","slug":"HTTP_004_01","date":"2019-08-25T16:23:55.000Z","updated":"2024-11-23T12:12:24.908Z","comments":true,"path":"2019/08/26/HTTP_004_01/","permalink":"http://feel5ny.github.io/2019/08/26/HTTP_004_01/","excerpt":"","text":"HTTP는 어떻게 TCP 커넥션을 사용하는가 TCP 커넥션의 지연, 병목, 막힘 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화 커넥션 관리를 위해 따라야 할 규칙들 1. TCP 커넥션 전 세계 모든 HTTP 통신은, 지구상의 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는, 패킷 교환 네트워크 프로토콜들이 계층화된 집합인 TCP&#x2F;IP를 통해 이루어진다. 웹 브라우저가 TCP 커넥션을 통해서 웹 서버에 요청을 보낸다. 1https://feel5ny.github.io/index.html 브라우저가 feel5ny.github.io 라는 호스트 명을 추출한다. 브라우저가 이 호스트 명에 대한 IP 주소를 찾는다. 브라우저가 포트 번호 80을 얻는다. 브라우저가 185.199.111.153의 80포트로 TCP 커넥션을 생성한다. 브라우저가 바로 HTTP GET 요청 메세지를 보낸다. 브라우저가 서버에서 온 HTTP 응답 메세지를 읽는다. 브라우저가 커넥션을 끊는다. 1.1 신뢰할 수 있는 데이터 전송 통로인 TCP HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하다. TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다. 1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다. TCP는 IP 패킷 (IP 데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송한다 HTTP는 프로토콜 스택에서 최상위 계층이다. HTTPS에는 TLS 혹은 SSL이라 불리기도 하며 암호화 계층이 있다. HTTP 메세지를 전송하고자 할 경우,TCP 커넥션을 통해서 메세지 데이터의 내용을 순서대로 보낸다. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다. 이 모든 것은 TCP&#x2F;IP 소프트웨어에 의해 처리되며,그 과정은 HTTP 프로그래머에게 보이지 않는다. 각 TCP 세그먼트는하나의 IP 주소에서 다른 IP 주소로IP 패킷에 담겨 전달된다. IP 패킷이 포함하는 것. IP 패킷 헤더 (20byte) TCP 세그먼트 헤더 (20byte) TCP 데이터 조각 패킷 구조는 아래와 같다.그림출처 IP 헤더와 TCP 헤더는 아래와 같다.그림출처 1.3 TCP 커넥션 유지하기 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. TCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다. TCP 커넥션은 4가지 값으로 식별한다. 발신지 IP 주소 발신지 포트 수신지 IP 주소 수신지 포트 4가지 값으로 유일한 커넥션을 생성한다.4가지 커넥션 구성요소를 똑같이 가리키고 있는 커넥션은 있을 수 없다. 2. TCP의 성능에 대한 고려 HTTP는 TCP 바로 위에 있는 계층이기 때문에 TCP의 성능이 문제가 될 경우 HTTP 트렌젝션 성능에 영향이 있다. 때문에 TCP 프로토콜 내부를 알아본다. 2.1 HTTP 트랜잭션 지연 트랜잭션을 처리하는 시간은TCP 커넥션을 설정하고, 요청을 전송하고, 응답 메세지를 보내는 것에 비하면상당히 짧다는 것을 알 수 있다. 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.(클라나 서버가 많은 데이터를 내려받거나, 복잡하고 동적인 자원들을 실행하지 않는 한) 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야 한다. 만약 호스트에 방문한 적이 없으면 DNS 인프라를 사용하여 IP 주소로 변환하는데 수십 초의 시간이 걸릴 것이다. (DNS 캐시가 없을 경우) 클라는 TCP 커넥션 요청을 서버에게 보내고, 서버가 커넥션 허가 응답을 회신하기를 기다린다. 커넥션 설정 시간은 새로운 TCP 커넥션에서 항상 발생한다. 커넥션이 맺어지면 클라는 HTTP 요청을 새로 생성한 TCP 파이프를 통해 전송한다. 웹 서버는 데이터가 도착하는 대로 TCP 커넥션에서 요청 메세지를 읽고 처리한다. 2.2 성능 관련 중요 요소다음과 같은 요인과 그로 인한 성능상의 문제를 포함해 영향을 주는 일반적인 TCP 관련 지연들에 대해서 다른다. TCP 커넥션의 핸드셰이크 설정 TCP 편승(piggyback) 확인 응답(acknowledgment)을 위한 확인 응답 지연 알고리즘 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작 slow-start 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘 TIME_WAIT 지연과 포트 고갈 2.2.1 TCP 핸드셰이크 지연 (3 handshake)어떤 데이터를 전송하든, 새로운 TCP 커넥션을 열 때면,TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환한다.다음은 TCP 커넥션이 핸드셰이크를 하는 순서다. (예전에 정리한 글) 클라는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 서버에게 보낸다. 그 패킷은 SYN(synchronize sequence numbers)라는 특별한 flag를 가진다.(TCP flags의 종류) 커넥션 생성 요청이라는 뜻 서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 SYN + ACK(acknowledgment) flag를 포함한 TCP 패킷을 클라에게 보낸다. 마지막으로 클라는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인 응답 신호를 보낸다. (ACK) 오늘날 TCP는 클라가 이 확인 응답 패킷과 함께 + 데이터를 보낼 수 있다. 실제 개발자들은 이 패킷들을 보지 못한다. TCP 커넥션이 생성될 때 발생하는 지연이 전부다. 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다. TCP 구성으로 인한 지연을 제거하기 위해서 HTTP가 이미 존재하는 커넥션을 어떻게 재활용하는지 알아보자. 2.2.2 확인 응답 지연 알고리즘 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에, TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다. TCP 세그먼트는 순번과데이터 무결성 체크섬을 가진다. 송신자의 기준은 먼저 시작한 곳 수신자는 세그먼트를 온전히 받으면, 작은 확인 응답 패킷을 송신자에게 반환한다. (ACK) 송신자가 특정 시간 안에 확인 응답 메세지를 받지 못하면, 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송한다. 데이터 보낼 때 같이 보내면 되겠다! 확인 응답은 그 크기가 작기 때문에 TCP는같은 방향으로 송출되는 데이터 패킷에 확인 응답을 편승시킨다. (piggyback) TCP는 송출 데이터 패킷과 확인 응답을 하나로 묶음으로써네트워크를 좀 더 효율적으로 사용한다. 확인 응답 지연은 송출할 확인 응답을 특정 시간 동안(0.1초 ~ 0.2초) 버퍼에 저장해 두고,확인 응답을 편승시키기 위한 송출 데이터 패킷을 찾는다. 막상 HTTP에서는 HTTP 동작 방식은 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킨다. 편승할 패킷을 찾으려고 하면, 해당 방향으로 송출될 패킷이 많지 않기 때문에,확인 응답 지연으로 인한 지연이 자주 발생한다. 2.2.3 TCP 느린 시작 slow startTCP 느린 시작 TCP 커넥션은 시간이 지나면서 자체적으로 튜닝되어서,처음에는 커넥션의 최대 속도를 제한하고,데이터가 성공적으로 전송됨에 따라서, 속도 제한을 높여나간다. 인터넷의 갑작스러운 부하와 혼잡을 방지하는 데 쓰인다. 혼잡 윈도를 연다. opening the congestion window TCP 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷의 수를 제한한다. 패킷이 성공적으로 전달되는 각 시점에 송신자는 추가로 2개의 패킷을 더 전송할 수 있는 권한을 얻는다. HTTP 트랜잭션에서 전송할 데이터의 양이 많으면 모든 패킷을 한 번에 전송할 수 없다.한 개의 패킷만 전송하고 확인 응답을 기다렸다 받으면, 2개의 패킷을 보낼 수 있고, 그 패킷 각각에 대한 확인 응답을 받으면 총 4개의 패킷을 보낼 수 있게 된다. 혼잡제어 기능 때문에 새로운 커넥션은 튜닝된 커넥션보다 느리다. (지속커넥션과 연관) 2.2.4 네이글 알고리즘과 TCP_NODELAY “가능하면 조금씩 여러 번 보내지 말고 한 번에 많이 보내라(Effective TCP)” 라는 원칙을 기반으로 만들어진 알고리즘이다. John Nagle의 이름을 따서 만들어졌다. 네이글 알고리즘은 HTTP 성능 관련 여러 문제를 발생시킨다. 크기가 작은 HTTP 메세지는 패킷을 채우지 못해, 앞으로 생길지 생기지 않을지 모르는 추가적인 데이터를 기다리며 지연될 것이다. 확인 응답 지연과 함께 쓰일 경우 비효율적이다. HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다. 그림 출처 TCP_NODELAY 참고글 2.2.5 TIME_WAIT의 누적과 포트 고갈 TCP 커넥션의 endpoint에서 TCP 커넥션을 끊으면,endpoint에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓는다. 이 정보는 같은 주소와 포트 번호를 사용하는새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것이다. 이전 커넥션과 관련된 패킷이그 커넥션과 같은 주소와 포트 번호를 가진 새로운 커넥션에 삽입되는 문제를 방지한다. 보통 세그먼트의 최대 생명주기에 두 배 정도 2MSL이라고 불리며 보통 2분 정도 오래전, 라우터가 매우 느렸던 때에는 중복되는 패킷의 복제본이 삭제되기 전까지 인터넷에 있는 큐에 1분이 넘게 보관되어 있었기 때문에 최대 생명주기를 1분으로 정했다. 현대의 빠른 라우터들 덕분에 커넥션이 닫힌 후에 중복되는 패킷이 생기는 경우는 거의 없어졌다. Time wait에 대한 글카카오 블로그toast 블로그 3. HTTP 커넥션 관리커넥션을 생성하고 최적화하는 HTTP 기술을 설명할 것이다. 3.1 흔히 잘못 이해하는 Connection 헤더 HTTP는 클라와 서버 사이에 중개 서버가 놓이는 것을 허락한다. (프락시, 중개) 어떤 경우에는 두 개의 인접한 HTTP 앱이현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있다. 이때 HTTP Connection 헤더를 사용하면 맺고 있는 커넥션에만 값이 적용 가능하다. Connection 헤더에는 3가지 종류의 토큰이 전달될 수 있다. HTTP&#x2F;2에서는 무시된다. HTTP header field name 헤더 보호하기 이 커넥션에만 해당되는 헤더들을 나열 해당 필드들은 현재 커넥션만을 위한 정보이므로,다음 커넥션에 해당 헤더를 전달하면 안된다. Connection 헤더에는 hop-by-hop 헤더 명을 기술한다. hop은 각 서버를 의미하며 hop-by-hop은 특정 두 서버 간에만 영향을 미치고, 다른 서버 간에는 영향을 미치지 않음을 뜻한다. Connection 헤더에 있는 헤더 필드의 이름에 해당되는 헤더들은 모두 삭제되어야 한다. 임시적인 토큰값: 커넥션에 대한 비표준 옵션을 의미 close: 커넥션이 작업이 완료되면 종료되어야 함을 의미. keep-alive mdn 3.2 순차적인 트랜젝션 처리에 의한 지연 커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안 좋아질 수 있다. 만약 3개의 이미지가 있는 웹페이지에 접근한다면? 4개의 HTTP 트랜젝션을 만들어야 함. (html+이미지) 만약 각 트랜젝션이 새로운 커넥션을 필요로 한다면? 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생할 것이다. 순차처리로 인한 지연에는 물리적인 지연뿐 아니라,하나의 이미지를 내려받고 있는 중에는 웹페이지의 나머지 공간에 아무런 변화가 없어서 느껴지는 심리적인 지연도 있다. HTTP 커넥션의 성능을 향상시킬 수 있는 여러 최신 기술이 있다. 병렬 커넥션 parallel 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청 지속 커넥션 persistent 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용 파이프라인 커넥션 pipelined 공유 TCP 커넥션을 통한 병렬 HTTP 요청 다중 커넥션 multiplexed 요청과 응답들에 대한 중재 (실험적인 기술이다..) HTTP 완벽가이드 책을 보고 이해한 내용을 정리 한 글입니다. 참고자료 패킷 그림 nagle 알고리즘 time wait time wait-카카오 time wait-toast밋업","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://feel5ny.github.io/tags/TCP-IP/"},{"name":"connection","slug":"connection","permalink":"http://feel5ny.github.io/tags/connection/"}]},{"title":"HTTP 메세지 - 헤더","slug":"HTTP_003_04","date":"2019-08-18T12:23:55.000Z","updated":"2024-11-23T12:12:24.913Z","comments":true,"path":"2019/08/18/HTTP_003_04/","permalink":"http://feel5ny.github.io/2019/08/18/HTTP_003_04/","excerpt":"","text":"해당 링크를 기준으로 standard 중 일부만 정리하였다. 책에서 더 이상 쓰지 않는 헤더는 취소선 처리하였다. 메세지 헤더헤더에는👆 특정 종류의 메세지에만 사용할 수 있는 헤더와,🤚 더 일반 목적으로 사용할 수 있는 헤더,👐 그리고 응답과 요청 메세지 양쪽 모두에서 정보를 제공하는 헤더가 있다. 일반 헤더 일반 정보 헤더 일반 캐시 헤더 요청 헤더 요청 정보 헤더 Accept 관련 헤더 조건부 요청 헤더 요청 보안 헤더 프락시 요청 헤더 응답 헤더 협상 헤더 응답 보안 헤더 엔터티 헤더 엔터티 정보 헤더 콘텐츠 헤더 엔터티 캐싱 헤더 Header (HTTP&#x2F;1.1 기준) 1. 일반 헤더 General headers 클라와 서버 양쪽 모두가 사용한다. 아주 기본적인 정보를 제공한다. 일반 정보헤더1234Connection: keep-aliveDate: Wed, 21 Oct 2015 07:28:00 GMTTransfer-Encoding: gzip, chunkedVia: HTTP/1.1 GWA Connection: 클라와 서버가 요청&#x2F;응답 연결에 대한 옵션을 정할 수 있게 해준다. 전송된 값이 keep-alive일 경우, 연결은 지속적이며 닫히지 않으므로 동일한 서버에 대한 후속 요청이 수행될 수 있다. close, keep-alive Date: 메세지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다. MIME-Version: 발송자가 사용한 MIME의 버전을 알려준다. Trailer chunked transfer: 인코딩된 메세지의 끝 부분에 위치한 헤더들의 목록을 나열한다. Transfer-Encoding: 수신자에게 안전한 전송을 위해 메세지에 어떤 인코딩이 적용되었는지 말해준다. chunked, compress, deflate, gzip, identity Upgrade: 발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 알려준다. Via: 이 메세지가 어떤 중개자를 거쳐 왔는지 보여준다. 관련) TRACE 메서드 일반 캐시 헤더12Cache-Control: public, max-age=31536000Pragma: no-cache 최신 버전의 HTTP는 매우 풍부한 캐시 매개변수의 집합을 가지고 있다. Cache-Control: 메세지와 함께 캐시 지시자를 전달하기 위해 사용한다. max-age&#x3D;{seconds}, max-stale[&#x3D;{seconds}], min-fresh&#x3D;{seconds}, no-cache, no-store, no-transform, only-if-cached, must-revalidate, no-cache, no-store, no-transform, public, private, proxy-revalidate, s-maxage&#x3D;{seconds}, immutable, stale-while-revalidate&#x3D;{seconds}, stale-if-error&#x3D;{seconds}, Pragma: 메세지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않는다. (HTTP&#x2F;1.0) no-cache 2. 요청 헤더요청 메세지에서만 의미를 갖는 헤더다. 요청 정보 헤더1234From: webmaster@example.orgHost: developer.cdn.mozilla.netReferer: https://developer.mozilla.org/en-US/docs/Web/JavaScriptUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:42.0) Gecko/20100101 Firefox/42.0 Client-IP: 클라가 실행된 컴퓨터의 IP를 제공한다. From: 클라 사용자의 메일주소를 제공한다. {email} Host: 요청의 대상이 되는 서버의 호스트 명과 포트를 준다. {host}:{port} Referer: 현재의 요청 URI가 들어있었던 문서의 URL을 제공한다. {url} User-Agent: 요청을 보낸 어플리케이션의 이름을 서버에게 말해준다. {product} &#x2F; {product-version} {comment} UA-Color: 클라 기기 디스플레이의 색상 능력에 대한 정보를 제공한다. UA-CPU: 클라 CPU의 종류와 제조사를 알려준다. UA-Disp: 클라 디스플레이 능력에 대한 정보를 제공한다. UA-OS: 클라 기기에서 동작 중인 운영체제의 이름과 버전을 알려준다. UA-Pixels: 클라 기기 디스플레이에 대한 픽셀 정보를 제공한다. Accept 관련 헤더12345Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1Accept-Encoding: gzip, compress, brAccept-Language: de-CHTE: gzip 클라는 Accept 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있다.서버는 클라가 사용할 수도 없는 것을 전송하는데 시간과 대역폭을 낭비하지 않을 수 있다. Accept: 서버에게 서버가 보내도 되는 콘텐츠 타입을 MIME 타입를 말해준다. Accept-Charset: 서버에게 서버가 보내도 되는 문자집합을 말해준다. Accept-Encoding: 서버에게 서버가 보내도 되는 인코딩을 말해준다. gzip, compress, deflate, br, identity Accept-Language: 서버에게 서버가 보내도 되는 언어를 말해준다. TE: 서버에게 서버가 보내도 되는 확장전송 코딩을 말해준다. (Transfer-Encoding) compress, deflate, gzip, trailers 조건부 요청 헤더1234567Expect: 100-continueIf-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMTIf-None-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;If-Range: Wed, 21 Oct 2015 07:28:00 GMTIf-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMTRange: bytes=0-499, -500 클라는 요청에 몇몇 제약을 넣기도 한다.클라는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다. Expect: 클라가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다. If-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져온다. {etag_value} If-Modified-Since: 주어진 날짜 이후에 리소스가 변경되지 않는다면 요청을 제한한다. If-None-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져온다. If-Range: 문서의 특정 범위에 대한 요청을 할 수 있게 해준다. {date}, {etag} If-Unmodified-Since: 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다. Range: 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청한다. {unit}&#x3D;{range-start}-{range-end}, {range-start}-{range-end} ex. bytes=200-1000 요청 보안 헤더123Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1lCookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1; HTTP는 자체적으로 요청을 위한 간단한 인증요구&#x2F;응답 체계를 갖고 있다.요청하는 클라가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써, 트랜잭션을 약간 더 안전하게 만들고자 한다. Authorization: 클라가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다. {type} {credentials} 예시) Basic YWxhZGRpbjpvcGVuc2VzYW1l Cookie: 클라가 서버에게 토큰을 전달할 때 사용한다. 진짜 보안헤더는 아니지만, 보안에 영향을 줄 수 있다는 것은 확실하다. {name}&#x3D;{value}; {name2}&#x3D;{value2}; Cookie2: 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용한다. 프락시 요청 헤더1Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l Max-Forwards: 요청이 원서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. 관련) TRACE 메서드와 함께 사용된다. Proxy-Authorization: Authorization과 같으나 프락시에서 인증을 할 때 쓰인다. {type} {credentials} Proxy-Connection: Connection과 같으나 프락시에서 연결을 맺을 때 쓰인다. 3. 응답 헤더응답 메세지는 그들만의 응답 헤더를 갖는다.응답 헤더는 클라에게 부가 정보를 제공한다. 응답 정보 헤더1234Age: 24Retry-After: Wed, 21 Oct 2015 07:28:00 GMTServer: Apache/2.4.1 (Unix)Warning: 112 - &quot;cache down&quot; &quot;Wed, 21 Oct 2015 07:28:00 GMT&quot; Age: 응답이 얼마나 오래되었는지 {delta-seconds} Public: 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록 Retry-After: 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시간 {http-date}, {delay-seconds} Server: 서버 어플리케이션의 이름과 버전 {product} Title: HTML 문서에서 주어진 것과 같은 제목 Warning: 사유 구절에 있는 것보다 더 자세한 경고 메세지 {warn-code} {warn-agent} {warn-text} [{warn-date}] 예시) Warning: 110 anderson&#x2F;1.3.37 “Response is stale” 협상 헤더12Accept-Ranges: bytesVary: User-Agent 서버에 프랑스어나 독일어로 번역된 HTML 문서가 있는 경우와 같이 여러 가지 표현이 가능한 상황이라면,HTTP&#x2F;1.1은 서버와 클라가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있도록 지원한다. Accept-Ranges: 서버에게 서버가 보내도 되는 언어를 말해준다. Vary: 서버가 확인해 보아야 하고, 그렇기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록 응답 보안 헤더123Proxy-Authenticate: Basic realm=&quot;Access to the internal site&quot;Set-Cookie: sessionid=38afes7a8; HttpOnly; Path=/WWW-Authenticate: Basic 기본적인 인증 요구 헤더들이다. Proxy-Authenticate: 프락시에서 클라로 보낸 인증요구의 목록 Set-Cookie: 진짜 보안 헤더는 아니지만, 보안에 영향은 줄 수 있다. 서버가 클라를 인증할 수 있도록 클라 측에 토큰을 설정하기 위해 사용한다. {cookie-name}&#x3D;{cookie-value} {cookie-name}&#x3D;{cookie-value}; Expires&#x3D;{date} {cookie-name}&#x3D;{cookie-value}; Max-Age&#x3D;{non-zero-digit} {cookie-name}&#x3D;{cookie-value}; Domain&#x3D;{domain-value} {cookie-name}&#x3D;{cookie-value}; Path&#x3D;{path-value} {cookie-name}&#x3D;{cookie-value}; Secure {cookie-name}&#x3D;{cookie-value}; HttpOnly {cookie-name}&#x3D;{cookie-value}; SameSite&#x3D;Strict {cookie-name}&#x3D;{cookie-value}; SameSite&#x3D;Lax {cookie-name}&#x3D;{cookie-value}; SameSite&#x3D;None Set-Cookie2: Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키. WWW-Authenticate: 서버에서 클라로 보낸 인증요구의 목록 {type} realm&#x3D;{realm} 예시) Basic realm&#x3D;”Access to the staging site” 4. 엔터티 헤더엔터티에 대해 설명하는 헤더들은 많다.요청과 응답 양쪽 모두 엔터티를 포함할 수 있기 때문에,이 헤더들은 양 타입의 메세지에 모두 나타날 수 있다. 엔터티 정보헤더12Allow: GET, POST, HEADLocation: /index.html Allow: 이 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열한다. 예시) Allow: GET, POST, HEAD Location: 클라에게 엔터티가 실제로 어디에 위치하고 있는지 말해준다. 수신자에게 리소스에 대한 (아마도 새로운) 위치 URL을 알려줄 때 사용한다. 관련) 리다이렉션 상태코드 (300번대) Location과 Content-Location는 다릅니다:Location가 리다이렉션의 대상(혹은 새롭게 만들어진 문서의 URL)을 가르키는데 반해,Content-Location은 더 이상의 컨텐츠 협상없이, 리소스 접근에 필요한 직접적인 URL을 가르킵니다.Location은 응답과 연관된 헤더인데 반해, Content-Location 은 반환된 개체와 연관이 있습니다.출처 mdn 콘텐츠 헤더123456Content-Encoding: gzipContent-Language: de-DEContent-Location: /my-first-blog-postContent-Range: bytes 200-1000/67589Content-Type: text/html; charset=utf-8Content-Disposition: form-data; name=&quot;myFile&quot;; filename=&quot;foo.txt&quot; 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들이다.웹브라우저는 내용 유형을 기술한 Content-Type 헤더를 보고 그 객체를 어떻게 보여줄지 결정할 수 있다. Content-Base: 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL Content-Encoding: 본문에 적용된 어떤 인코딩 gzip, compress, deflate, identity, br Content-Language: 본문을 이해하는데 가장 적절한 자연어 예시) de-DE, en-CA Content-Length: 본문의 길이나 크기 Content-Location: 리소스가 실제로 어디에 위치하는지 Content-MD5: 본문의 MD5 체크섬 Content-Range: 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현 {unit} {range-start}-{range-end}&#x2F;{size} 예시) bytes 200-1000&#x2F;67589 Content-Type: 이 본문이 어떤 종류의 객체인지 {media-type};charset&#x3D;{value}; boundary&#x3D;{something} 예시) text&#x2F;html; charset&#x3D;utf-8 예시) multipart&#x2F;form-data; boundary&#x3D;something Content-Disposition: 콘텐츠가 브라우저에 인라인으로 표시될 것으로 예상되는지, 즉 웹 페이지 또는 웹 페이지의 일부로서 또는 첨부 파일로 로컬로 다운로드 및 저장될 것으로 예상되는지를 나타내는 헤더다. Content-Disposition: inline Content-Disposition: attachment Content-Disposition: form-data **; name&#x3D;”fieldName”**이 덧붙여서 올 수 있다. 엔터티 캐싱 헤더1234ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;Expires: Wed, 21 Oct 2015 07:28:00 GMTLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT 일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공한다.엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공한다. ETag: 이 엔터티에 대한 엔터티 태그 Expires: 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 Last-Modified: 가장 최근 이 엔터티가 변경된 일시 책뽀개기 모임 중 http 완벽가이드 1장 뽀개기 진행중입니다. (~8월말) (다음 모임은 2장)(모임 참여를 원하신다면 댓글로 문의 바랍니다.) HTTP 완벽가이드 책을 보고 이해한 내용을 저만의 순서로 정리 한 글입니다. 참고자료 IANA registry MDN","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"message","slug":"message","permalink":"http://feel5ny.github.io/tags/message/"},{"name":"header","slug":"header","permalink":"http://feel5ny.github.io/tags/header/"}]},{"title":"HTTP 메세지 - 상태코드","slug":"HTTP_003_03","date":"2019-08-17T12:23:55.000Z","updated":"2024-11-23T12:12:30.102Z","comments":true,"path":"2019/08/17/HTTP_003_03/","permalink":"http://feel5ny.github.io/2019/08/17/HTTP_003_03/","excerpt":"","text":"출처: http-decision-diagram HTTP 응답에, 어떤 상황에 해당 상태코드가 반환되는지를 보여주는 시각화 다이어그램 자료이다. 상태코드와 사유구절 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.&#x3D;&gt; 상태코드, 사유구절 HTTP&#x2F;1.1 기준이다. 상태코드 (HTTP&#x2F;1.1 기준) 정보성 상태 코드 (100 - 199) HTTP&#x2F;1.1에 도입되었다. 복잡함을 감수할만한 가치가 있는지에 대한 논란이 되고 있다. 100 - Continue 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미한다. 이것을 보낸 후 서버는 반드시 요청을 받아 응답해야 한다. 클라가 서버에 엔터티 본문을 전송하기 전에그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때,그 확인 작업을 최적화하기 위한 의도로 도입된 것이다. 클라이언트와 100 Continue 클라이언트가 엔터티를 서버에게 보내려고 하고, 100 continue 응답을 기다리겠다면, 클라는 Expect 요청 헤더를 보낼 필요가 있다. 1Expect: 100-continue Expect 최적화를 위한 것이다. 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다. 100 Continue 값이 담긴 Expect 헤더를 보낸 클라 서버가 100 Continue 응답을 보내주기를 막연히 기다리면 안 된다. 약간의 타임아웃 후에 클라는 그냥 엔터티를 보내야 한다. 프론트 개발자는 예상치 못한 100 Continue 응답에도 대비해야한다.. 서버와 100 Continue서버가 100 Continue 값이 담긴 expect 헤더가 포함된 요청을 받는다면 100 Continue 응답 혹은 에러코드로 답해야한다. 417 Expectation Failed 에러 받은 엔터티에 대한 최종 응답코드는 보내줘야 한다. 클라: 서버에게 expect 헤더 보냄 서버: 음! 받을 수 있으니, 100을 보내야겠군 클라: 왜 안 오지 그냥 entity 보내자. 서버: 음? 100 아직 안보냈는데 entity가 왔네. 걍 받자 서버: 잘 받았어 ~ 응답 보내줘야 함 엔터티 읽다가 에러가 나와도, 연결을 닫아서는 안된다. 클라가 응답을 받을 수 없게 되기 때문이다. (?) 아직 잘 모르겠다. 프락시와 100 Continue 클라: 서버에게 expect 헤더 보냄 프락시: 서버에게 expect 헤더 고대로 보냄 만약 다음 홉서버가(next-hope) HTTP&#x2F;1.1 이전 버전이라는 걸 알게 되면 417 Expectation Failed를 클라에게 응답한다. 101 - switching protocols 클라이언트가 upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다. 웹 소켓과 함께 사용될 수 있다. 아래는 upgrade 헤더의 웹소켓으로 서버가 프로토콜을 바꿨다는 의미이다. 123HTTP/1.1 101 Switching ProtocolsUpgrade: websocket Connection: Upgrade 성공 상태 코드 (200 - 299)200 - OK 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다. GET: 리소스를 가져왔고 메시지 바디에 전송되었다. HEAD: 개체 헤더가 메시지 바디에 있다. POST: 리소스가 명시하는 행동의 결과가 메시지 바디에 전송되었다. TRACE: 서버가 요청받은 메시지가 메시지 바디에 포함되어있다. PUT 또는 DELETE의 성공 결과는 종종 200 OK가 아니라 204 No Content (또는 201 Created 리소스가 처음으로 업로드되었을 때)이다 200응답은 캐쉬될 수 있다. 201 - Created 서버 개체를 생성하라는 요청을 위한 것 (PUT) 서버는 반드시 객체를 생성하고 해당코드로 응답해야 한다. 응답에는 location 헤더: 생성된 리소스에 대한 최대한 구체적인 참조 엔터티 본문: 그 리소스를 참조할 수 있는 여러 URL 202 - Accepted 요청은 받아들여졌으나, 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 어떤 보장도 없다.요청을 받아들이기에 적법해 보인다는 의미이다. 응답 엔터티 본문: 요청에 대한 상태와, 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지)을 포함해야 한다. 203 - Non-Authoritative Information 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다.(?) 프록시가 리소스의 사본을 갖고 있었지만리소스에 대한 메타 정보(헤더)를 검증하지 못한(혹은 안 한) 경우 이런 일이 발생할 수 있다. 요청이 성공했지만 페이로드가 원본 서버의 200(OK) 응답의 변환 프록시에 의해 수정되었음을 나타낸다. 204 - No Content 응답메세지에서 헤더와 상태줄은 있지만, 엔터티 본문은 없다. 204 응답은 기본적으로 캐시할 수 있다. 그러한 반응에는 ETag 헤더가 포함된다. 일반적인 사용 사례는 사용자에게 표시되는 페이지의 현재 내용을 변경하지 않고PUT 요청의 결과로 204를 반환하고 리소스를 업데이트하는 것이다. PUT 요청의 결과로 리소스가 생성되면 201이 대신 반환된다. 페이지를 새로 업데이트된 페이지로 변경해야 하는 경우 200을 대신 사용해야 한다. 205 - Reset Content 브라우저를 위해 사용되는 코드 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우거나,캔버스 상태를 재설정하거나,UI를 새로 고치도록 지시한다. 206 - Partial Content 부분 혹은 범위 요청이 성공했다. 나중에 우리는 클라가 특별한 헤더를 사용해서 문서의 부분 혹은 특정 범위를 요청할 수 있다는 것을 보게 될 것이다. 이 상태 코드는 범위 요청이 성공했음을 의미한다. Content-Range헤더와 관련 있다. 206 응답은 Content-Range와 Date 헤더를 반드시 포함해야 하며, Etag와 Content-Location중 하나의 헤더도 반드시 포함해야 한다. 리다이렉션 상태 코드 (300 - 399) 클라이언트가 관심 있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나, 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 웹서버에서 리다이렉션 코드가 쓰이는 경우에 대한 글은 여기(#5.3)를 확인해보면된다. 300 - Multiple Choices 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환된다. 요청에 둘 이상의 가능한 응답이 있음을 나타낸다. 사용자 에이전트 또는 사용자는 이 중 하나를 선택해야 한다. 응답 중 하나를 선택하는 표준화된 방법이 없기 때문에, 이 응답 코드는 거의 사용되지 않는다. 서버는 Location 헤더에 선호하는 URL을 포함시킬 수 있다. 일반적인 사용 사례는 어떤 서버가 하나의 HTML 문서를 영어와 프랑스어 모두로 제공하는 경우 등에 사용할 수 있다. 클라이언트 주도협상 301 - Moved Permanently 요청된 리소스가 Location 헤더가 지정한 URL로 확실하게 이동되었음을 나타낸다. 브라우저는 이 페이지로 리디렉션 되고 검색 엔진은 그들의 자원 링크를 업데이트한다 따라서 301 코드는 GET 또는 HEAD 방법에 대한 응답으로만 사용하고,대신 POST 방법에 대한 308 영구 리디렉션을 사용하는 것이 좋다. 이 상태에서는 메서드 변경이 명시적으로 금지되기 때문이다. 302 - Found 요청된 리소스가 Location 헤더가 지정한 URL로 일시적으로 이동되었음을 나타낸다. 브라우저는 이 페이지로 리디렉션 되지만 검색 엔진은 리소스에 대한 링크를 업데이트하지 않는다. 따라서 302 코드는 GET 또는 HEAD 방법에 대한 응답으로만 설정하고,메서드 변경이 명시적으로 금지되므로 대신 307 임시 리디렉션을 사용하는 것이 좋다. 사용된 메서드를 GET로 변경하려는 경우 대신 **303 “기타”**를 사용해야 한다. 303 - See Other 클라에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 쓰인다. 새 URL은 응답메세지의 Location 헤더에 들어있다. 이 코드의 목적은 POST 요청에 대한 응답으로 클라에게 리소스의 위치를 알려주는 것. 이 응답 코드는 보통 PUT 또는 POST의 결과로 반송된다. 304 - Not Modified 클라는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라가 GET과 같은 조건부 요청을 보냈고,그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 리소스가 여전히 최신인지 수정되었는지 검사할 수 있다. If-Modified-Since 헤더를 전송한다. (If-None-Match, If-Modified-From) 캐시된 자원으로의 암묵적 리디렉션이다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안된다. 200 OK 응답에는Cache-Control, Content-Location, Date, ETag, Expires, Vary가 포함되었을 것이다. 305 - Use Proxy306 - 사용되지 않음307 - Temporary Redirect Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 308 - Permanent Redirect 클라이언트 에러 상태 코드 (400 - 499) 클라이언트는 서버가 다룰 수 없는 무엇인가를 보낸다. 잘못 구성된 요청 메세지 같은 것이 있을 수 있으며, 존재하지 않은 URL 요청도 있을 수 있다. 400 - Bad Request 클라이언트가 잘못된 요청을 보냈다고 말해준다. 401 - Unauthorized 리소스를 얻기 전에 클라에게 스스로 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다. 402 - Payment Required 이 상태 코드는 쓰이지 않지만, 미래에 사용될 수도 있어서 미리 준비해둔 비표준 응답 코드 403 - Forbidden 요청이 서버에 의해 거부되었음을 알려주기 위해 사용된다. 왜 요청이 거부되었는지 서버가 알려주고자 한다면,그 이유를 설명하는 엔터니 본문을 포함시킬 수 있다. 이 코드는 보통 서버가 거절의 이유를 숨기고 싶을 때 사용한다. 이 상태는 401과 비슷하지만, 로그인 로직(틀린 비밀번호로 로그인 행위)처럼 반응하여 재인증(re-authenticating)을 하더라도 지속적으로 접속을 거절 합니다. 404 - Not Found 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다. 404 페이지를 띄우는 링크는 대체로 브로큰 링크(broken link) 또는 **데드 링크(dead link)**라고 부르며, link rot 대상일 수도 있습니다. 404 상태 코드는 리소스가 일시적, 또는 영구적으로 사라졌다는 것을 의미하지는 않다. 리소스가 영구적 삭제되었다면 404 상태 코드 대신 410 (Gone) 상태 코드가 쓰여야 합니다. 405 - Method Not Allowed 요청 URL에 대해, 지원하지 않은 메서드로 요청받았을 때 사용한다. 요청한 리소스에 대해 어떤 메서드가 사용 가능한지 클라에게 알려주기 위해,요청에 Allow 헤더가 포함되어야 한다. 두 가지 필수 메소드인 GET와 HEAD는 사용 불가능해서는 안 되며,이러한 오류 타입을 반환해서는 안 됩니다. 406 - Not Acceptable 클라는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. Accept Accept-Charset Accept-Encoding Accept-Language 주어진 URL에 대한 리소스 중 클라가 받아들일 수 있는 것이 없는 겨우 사용한다. 종종 서버는 클라에게 왜 요청이 만족될 수 없었는지 알려주는 헤더를 포함시킨다. 실제로 이 오류는 거의 사용되지 않는다. 서버는 최종 사용자가 암호화되고 수정하기 어려운 이 오류 코드를 사용하여 응답하는 대신 관련 헤더를 무시하고 사용자에게 실제 페이지를 제공한다. 사용자가 완전히 만족하지 않더라도 오류 코드보다 이를 선호할 것으로 추정된다. 407 - Proxy Authentication Required 401 상태코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다. 408 - Request Timeout 클라의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다. 이 타임아웃의 길이는 서버마다 다르지만,대개 어떠한 적법한 요청도 받아들일 수 있을 정도로 충분히 길다. 408은 서버가 계속 대기하지 않고 연결을 닫기로 결정했음을 의미하므로서버는 응답에 있는 “닫기” 연결 헤더 필드를 전송해야 한다. 이 응답은 Chrome, Firefox 27+, IE9와 같은 일부 브라우저들이서핑 속도를 높이기 위해 HTTP 사전 연결 메커니즘을 사용하기 때문에 훨씬 더 많이 사용된다. 409 - Conflict 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용한다. 서버는 요청이 충돌을 일으킬 염려가 있다고 생각될 때 이 요청을 보낼 수 있다. 응답은 충돌에 대해 설명하는 본문을 포함해야 한다. 충돌은 PUT 요청에 대응하여 발생할 가능성이 가장 높다.예를 들어 서버에 이미 있는 파일보다 오래된 파일을 업로드할 때 409의 응답이 발생하여 버전 제어 충돌이 발생할 수 있다. 410 - Gone 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다르다. 주로 웹사이트를 유지보수 하면서, 서버 관리자가 클라에게 리소스가 제거된 경우 이를 알려주기 위해 사용한다. 캐시 가능하다. 411 - Length Required 서버 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용한다. 클라가 서버에 청크 데이터를 보낼때, 서버가 청크 인코딩을 받아들여주지 않을 경우에도 411 Length Required가 내려온다. 412 - Precondition Failed 클라가 조건부 요청을 했는데, 그중 하나가 실패했을 때 사용한다. 조건부 요청은 클라가 Expect 헤더를 포함했을 때 발생한다. 대상 리소스에 대한 액세스가 거부되었음을 나타낸다. 이는 If-Unmodified-from 또는 If-None-Match 헤더에 의해 정의된 조건이 충족되지 않을 때 GET 또는 HEAD 이외의 방법에 대한 조건부 요청에서 발생한다. 413 - Payload Too Large (Request Entity Too Large) 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라가 보냈을 때 사용한다. 서버가 연결을 닫거나 헤더 필드(Retry-After)를 반환할 수 있다. 2. 414 - URI Too Long (Request URI Too Long) 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라가 보냈을 때 사용한다. 415 - Unsupported Media Type 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라가 보냈을 때 사용한다. 416 - Range Not Satisfiable 요청 메세지가 리소스의 특정 범위를 요청했는데,그 범위가 잘못되었거나 맞지 않을 때 사용한다. 417 - Expectation Failed 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용한다. 418 - I’m a teapot 서버가 찻주전자이기 때문에 커피 내리기를 거절했다는 것을 의미합니다. 이 오류는 1998년 만우절 농담이었던 하이퍼 텍스트 커피 포트 제어 규약(Hyper Text Coffee Pot Control Protocol)의 레퍼런스입니다. 422 - Unprocessable Entity 이 응답은 서버가 요청을 이해하고 요청 문법도 올바르지만 요청된 지시를 따를 수 없음을 나타냅니다. 클라이언트는 요청을 수정하지 않고 동일한 형태로 다시 보내서는 안된다. 425 - Too Early 서버가 재생될 수 있는 요청을 처리하는 것을 원치 않음을 나타내며, 이는 재생 공격의 가능성을 만든다. 426 - Upgrade Required 서버가 현재 프로토콜을 사용하여 요청을 수행하기를 거부하지만클라이언트가 다른 프로토콜로 업그레이드한 후 요청을 수행할 의향이 있음을 나타낸다. 서버는 필요한 프로토콜을 나타내기 위해 이 응답과 함께 업그레이드 헤더를 보낸다. 428 - Precondition Required 서버가 요청을 조건부로 해야 함을 나타낸다. 일반적으로 이는 If-Match와 같은 필수 전제 조건 헤더가 누락됨을 의미한다. 전제 조건 헤더가 서버 측 상태와 일치하지 않을 경우 응답은 412 Prefixed가 되어야 한다. 429 - Too Many Requests 사용자가 지정된 시간 동안 너무 많은 요청을 보냈음을 나타낸다. 재시도 후 헤더가 이 응답에 포함될 수 있으며, 이는 새 요청을 하기 전에 대기할 시간을 나타낼 수 있다. 3. 431 - Request Header Fields Too Large 서버가 헤더 필드가 너무 커서 요청을 처리하지 않음을 나타낸다.요청 헤더 필드의 크기를 줄인 후 요청을 다시 제출할 수 있다. 총 요청 헤더 필드 수가 너무 많은 경우 또는 단일 헤더 필드가 너무 큰 경우 사용할 수 있다. 이 오류는 잘 테스트된 프로덕션 시스템에서 발생해서는 안 되지만,새로운 시스템을 테스트하는 동안 더 자주 발견될 수 있다. 451 - Unavailable For Legal Reasons 법적 이유로 사용할 수 없는 클라이언트 오류 응답 코드는 사용자가 법적 조치가 발행된 웹 페이지와 같이법적 이유로 사용할 수 없는 리소스를 요청했음을 나타낸다. 서버 에러 상태 코드 (500 - 599) 클라가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다. 클라가 서버의 제한에 걸린 것일 수도 있고,혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다. 프락시는 클라의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다. 500 - Internal Server Error 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다. 501 - Not Implemented 클라가 서버의 능력을 넘은 요청을 했을 때 사용한다. 예서버가 지원하지 않는 메서드를 사용 502 - Bad Gateway 프락시나 게이트웨이처럼 행동하는 서버가그 요청 응답 연쇄에 있는 다음 링크로부터가짜 응답에 맞닥뜨렸을 때 사용한다. 1. 503 - Service Unavailable 서버가 요청을 처리해 줄 수 없지만, 나중에 가능함을 의미하고자 할대 사용한다. 서버가 언제 그 리소스를 사용할 수 있게 될지 알고 있다면, 서버는 Retry-After 헤더를 응답에 포함시킬 수 있다. 504 - Gateway Timeout 408과 비슷하지만,다른 서버에게 요청을 보내고 응답을 기다리다타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다. 505 - 02. HTTP Version Not Supported 서버가 지원할 수 없거나, 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용한다 몇몇 서버 어플리케이션들은 오래된 버전의 프로토콜을 지원하지 않는 것을 택한다. 511 - 02. Network Authentication Required 클라이언트가 네트워크 액세스를 얻으려면 인증이 필요하다는 것을 나타낸다. 이 상태는 원 서버에서 생성되는 것이 아니라네트워크에 대한 액세스를 제어하는 프록시를 가로채서 생성된다. 네트워크 운영자들은 때때로 접근을 허가하기 전에약간의 인증, 용어의 수락 또는 다른 사용자 상호 작용을 요구한다(예: 인터넷 카페나 공항에서). 그들은 종종 자신의 MAC(Media Access Control) 주소를 사용하여 그렇게 하지 않은 클라이언트를 식별한다. 책뽀개기 모임 중 http 완벽가이드 1장 뽀개기 진행중입니다. (~8월말) (다음 모임은 2장)(모임 참여를 원하신다면 댓글로 문의 바랍니다.) HTTP 완벽가이드 책을 보고 이해한 내용을 저만의 순서로 정리 한 글입니다. 참고자료 MDN","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"message","slug":"message","permalink":"http://feel5ny.github.io/tags/message/"},{"name":"status code","slug":"status-code","permalink":"http://feel5ny.github.io/tags/status-code/"}]},{"title":"HTTP 메세지 - 메서드","slug":"HTTP_003_02","date":"2019-08-16T12:23:55.000Z","updated":"2024-11-23T12:12:24.877Z","comments":true,"path":"2019/08/16/HTTP_003_02/","permalink":"http://feel5ny.github.io/2019/08/16/HTTP_003_02/","excerpt":"","text":"HTTP 메세지 중 요청 줄에 존재하는 메서드에 대해서 알아본다. 요청 메서드에 따라서 서버에서 처리되는 과정, 반환되는 메세지의 형태가 달라진다. HTTP&#x2F;1.1에서 정의한 메서드에는 총 9가지가 존재하며, 서비스에 따라 커스텀한 확장 메서드를 만들 수 있다. 모든 서버가 모든 메서드를 구현하지 않는다. 모든 메서드를 구현하지 않았다 하더라도 메서드는 대부분 제한적으로 사용될 것이다. 일반적으로 서버 설정에 의해 메서드의 제한이 정해지며, 따라서 사이트마다 또 서버마다 다를 수 있다. 안전성 Safe HTTP는 안전한 메서드라 불리는 메서드의 집합이다. 안전한 메서드의 목적은,서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때사용자들에게 그 사실을 알려줄 수 있도록 하는 것에 있다. 읽기 전용인 경우 안전한 메서드로 간주한다. GET, HEAD, OPTIONS 메서드는 안전한 메서드로 정의되어있다. 디버깅용 메서드 TRACE로 클라이언트 쪽에 공격을 시도하여 credentials을 훔칠 수도 있기 때문에 안전한 메서드에 속하지 않는다. RFC 7231 설명 번역에 오역이 있을 수 있습니다.. 정의된 의미들이 본질적으로 읽기 전용인 경우, 요청 메소드는 “안전한” 것으로 간주됩니다. 즉, 클라이언트는 해당 리소스에 안전성있는 메서드를 적용한 결과로, origin 서버에 상태변화를 요청하지도 않고, 상태변화를 예상하지도 않는다. 마찬가지로, 안전성 있는 메서드를 합리적으로 사용한다면 origin 서버에서는 어떤 해를 야기하거나 리소스 손실 또는 비정상적인 부담을 예상하지 않는다. 안전한 메소드의 정의로 잠재적으로 유해하거나, 완전히 읽기 전용이 아니거나, 안전한 메소드를 호출하는 동안 사이드 이팩트를 일으키는 행동 을\u001d 포함시키지 않았다. 중요한 것은 client가 추가젹인 \u001d행동을 요구하지 않았고, 그것에 대해 책임을 질 수 없다는 것이다. 예를 들어 대부분의 서버는 메소드에 관계없이 모든 응답이 완료될 때 로그 파일에 액세스하기 위해 요청 정보를 추가하며, 로그 저장소가 가득 차서 서버가 손상될 수 있음에도 불구하고 안전한 것으로 간주된다. 마찬가지로, 웹 상에서 광고를 선택함으로써 시작된 안전한 요청은 종종 광고 계정을 청구하는 부작용을 낳을 것이다. 이 사양에서 정의한 요청 메서드 중 GET, HEAD, OPTIONS 및 TRACE 메서드는 안전하도록 정의되어 있습니다. 안전한 메서드과 안전하지 않은 메서드을 구분하는 목적은 자동 검색 프로세스(스파이더)와 캐시 성능 최적화(프리페치)가 해를 일으킬 염려 없이 작동할 수 있도록 하는 것이다. 또한, 사용자 에이전트는 신뢰할 수 없는 콘텐츠를 처리할 때 안전하지 않은 메서드의 자동 사용에 적절한 제약을 가할 수 있다. 사용자 에이전트는 사용자에게 잠재적 조치를 제시할 때 안전과 안전하지 않은 메서드을 구분하여 사용자가 요청하기 전에 안전하지 않은 조치를 인지할 수 있도록 해야 한다. 효과적인 요청 URI 내의 매개 변수가 action을 선택하는 효과를 가지도록 리소스를 구성하는 경우 action이 요청 메서드의 의미와 일치하는지 확인하는 것은 리소스 소유자의 책임이다. 예를 들어 웹 기반 콘텐츠 편집 소프트웨어는 “page?do&#x3D;delete”와 같은 쿼리 매개 변수 내의 action을 사용하는 것이 일반적이다. 이러한 리소스의 목적이 안전하지 않은 action을 수행하는 것이라면(GET, HEAD, OPTIONS가 아닌) 리소스 소유자는 안전한 요청 방법을 사용하여 액세스할 때 해당 action을 실행 중지하거나 허용하지 않아야 한다. 그렇게 하지 않으면 자동화된 프로세스가 링크 유지보수, 프리 페치(사전 검색), 검색 색인 구축 등을 위해 모든 URI 참조에 GET를 수행할 때 사이드 이팩트가 발생할 수 있다. 원문 Request methods are considered \"safe\" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server. This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account. Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe. The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content. A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested. When a resource is constructed such that parameters within the effective request URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as \"page?do=delete\". If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc. 멱등성 Idempotent 특정 메서드의 요청을 여러 번 했을 경우, 한번 요청했을 때와 결과가 같다면 멱등으로 간주한다. PUT, DELETE, TRACE 및 안전한 요청 방법(GET, HEAD, OPTIONS)이 멱등성을 갖는다. RFC 7231 설명 번역에 오역이 있을 수 있습니다.. 요청 메서드로 해당 방법으로 동일한 요청을 여러번 했을 때, 한 번했을 때와 결과가 같다면 “멱등”으로 간주한다. 이 사양에서 정의한 요청 방법 중에서 PUT, DELETE 및 안전성 있는 메서드가 멱등성을 갖는다. 안전성과 마찬가지로 멱등성은 사용자가 요청한 내용에만 적용됩니다. 서버는 각 요청을 별도로 기록하거나, 수정 관리 기록을 유지하거나 \u001d혹은 멱등성을 갖는 요청마다 다른 비멱등성 사이드이팩트들를 \b구현할 수도 있다. 클라이언트가 서버의 응답을 읽기 전에 통신 장애가 발생할 경우 요청이 자동으로 반복될 수 있기 때문에 멱등성 메서드가 구별된다. 예를 들어 클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 연결이 닫힌 경우 클라이언트는 새로운 연결을 설정하고 멱등(?) 요청을 다시 시도할 수 있다. 원래 요청이 성공하더라도, 응답은 다를 수 있지만, 요청을 반복하는 것은 의도된 것과 동일한 효과를 낼 것이라는 것을 알고 있다. 원문 A request method is considered \"idempotent\" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent. Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request. Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ. 캐시 가능성 Cachable 향후 재사용을 위해 이에 대한 응답을 저장할 수 있음을 나타낼 수 있다. 일반적으로 현재 시점의 응답이나 권한 있는 응답에 의존하지 않는 안전한 메서드는 캐시 가능한 것으로 정의한다. GET, HEAD, POST RFC 7231 설명 요청 method는 \"cacheable\"로 정의되어 향후의 재사용을 위해 이에 대한 응답을 저장할 수 있음을 나타낼 수 있다. 구체적인 요건은 [RFC7234](https://tools.ietf.org/html/rfc7234)를 참조한다. 일반적으로 현재 또는 권한 있는 응답에 의존하지 않는 안전한 메서드를 캐시 가능한 것으로 정의된다. 이 규격은 압도적으로 많은 캐시 구현이 GET와 HEAD만 지원하지만 GET, HEAD 및 POST는 캐시 가능한 것으로 정의한다. Request methods can be defined as “cacheable” to indicate that responses to them are allowed to be stored for future reuse; for specific requirements see RFC7234. In general, safe methods that do not depend on a current or authoritative response are defined as cacheable; this specification defines GET, HEAD, and POST as cacheable, although the overwhelming majority of cache implementations only support GET and HEAD. 메서드 종류 (HTTP&#x2F;1.1 기준) 1. GET서버에게 리소스를 달라고 요청하기 위해 쓰인다. 요청메세지에 바디 존재 X 성공 응답메세지에 바디 존재 O 안전성 \u001d O 멱등성 \u001d O 캐시 가능? \u001d O HTML form에서 사용 가능? O 요청 123GET /index.html HTTP/1.1Host: feel5ny.github.ioAccept: * 응답 12345HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 617&lt;html&gt;...&lt;/html&gt; cf__1 왜 안전성과 멱등이 중요할까?안전성과 멱등은 신뢰할 수 없는 네트워크 상의 HTTP를 신뢰할 수 있게 만들어 준다. 만일 GET 요청을 보내고 응답을 못 받았을 경우 그냥 한 번 더 보내면 된다. 이 동작은 안전하다. 먼저 보낸 요청이 벌써 처리되었다 하더라도 서버에 다른 영향은 없다. 마찬가지로 PUT 요청을 보내고 응답을 못 받았다면 단지 한 번 더 동일한 요청을 보내면 된다.그러나 POST는 안전하지도 않고 멱등도 아니다. 따라서 POST 메소드는 주의해서 사용해야 한다. 출처(행복한 아빠) 2. HEADGET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.엔터티 본문은 반환되지 않는다. 이럴 때 사용한다. 리소스를 가져오지 않고도, 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있다. 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다. 헤더만을 확인하여 리소스가 변경되었는지 검사할 수 있다. 큰 용량의 리소스를 다운로드 받을지 말지 결정하기 위해서 사전 요청하는 용도로 사용할 수 있다. 요청메세지에 바디 존재 X 성공 응답메세지에 바디 존재 X 안전성 \u001d O 멱등성 \u001d O 캐시 가능? \u001d O HTML form에서 사용 가능? X 요청 123HEAD /index.html HTTP/1.1Host: feel5ny.github.ioAccept: * 응답 123HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 617 3. PUT서버에 문서를 쓴다….(?) 예시 어떤 발행 시스템은 사용자가 PUT을 이용해 웹페이지를 만들고, 웹서버에 직접 게시할 수 있도록 해준다. PUT 메서드의 의미는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 자료를 만들거나, 이미 URL이 존재한다면, 본문을 사용해서 교체하는 것이다. 데이터를 변경할 수 있는 메서드이기 때문에 서버 입장에서는 위험할 수 있다. PUT은 콘텐츠를 변경할 수 있게 해주기 때문에,많은 웹 서버가 PUT을 수행하기 전에 사용자에게비밀번호를 입력해서 로그인을 하도록 요구할 것이다. 요청메세지에 바디 존재 O 성공 응답메세지에 바디 존재 X 안전성 \u001d X 멱등성 \u001d O 캐시 가능? \u001d X HTML form에서 사용 가능? X 요청 1234PUT /joy.txt HTTP/1.1Host: feel5ny.github.ioContent-Type: text/plainContent-Length: 34 응답 12345HTTP/1.1 201 CreatedContent-Type: text/htmlContent-Length: 47http://feel5ny.github.io/joy.txt 새로운 생성 시에는 성공 응답코드로 201 Created을 내려줘야 한다. 수정 작업 시에는 성공 응답코드로 200을 내려줘야 한다. PUT과 POST의 차이점은 PUT은 멱등하다. PUT은 한번 혹은 연속적으로 여러 번 하더라도 동일하지만 영향(부작용이 아님)을 미치지만, POST는 연속적인 요청이 그대로 전달되어, 요청이 연속적으로 들어가는 것으로 인지하여 추가적인 영향이 있을 수 있습니다. PUT으로 새 리소스를 생성하고또 동일한 내용으로 PUT을 리소스에 요청해도두 번째는 이미 존재하고 동일한 내용이므로 결과는 같다. 이미 존재하는 리소스에 PUT을 보낼 경우동일한 내용으로 몇 번을 보내더라도동일한 내용으로 상태가 저장되므로리소스 상태는 변하지 않는다. 4. POST 서버에 입력 데이터를 전송하기 위해 설계되었다. request의 body 타입은 Content-Type 헤더(header)에 따라 결정된다. POST는 비멱등성을 갖는다. 같은 POST를 연속적으로 보낸다면 명령을 여러 번 내린 것처럼 부가적인 효과를 가져올 것입니다. 요청메세지에 바디 존재 O 성공 응답메세지에 바디 존재 O 안전성 \u001d X 멱등성 \u001d X 캐시 가능? \u001d 새 정보가 포함되었을 때만 HTML form에서 사용 가능? X 요청 123456POST /inventory-check.cgi HTTP/1.1Host: feel5ny.github.ioContent-Type: text/plainContent-Length: 18item=bandsaw 2647 응답 12345HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 37The bandsaw model 2647 is in stock! 5. TRACE자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다. 클라이언트가 어떤 요청을 할 때,그 요청은 방화벽, 프락시, 게이트웨이 등의 어플리케이션을 통과할 수 있다. 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다. TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다. TRACE 요청은 목적지 서버에서 루프백 loopback 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는자신이 받은 요청 메세지를 본문에 넣어서TRACE 응답을 돌려준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 어플리케이션의 요청&#x2F;응답 연쇄를 따라가면서자신이 보낸 메세지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다. TRACE는 주로 진단을 위해 사용된다. (디버깅용) 요청이 의도한 요청&#x2F;응답 연쇄를 거쳐가는지 검사할 수 있다. 중간 어플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있다. 프락시는POST 요청을 바로 서버로 통과시키는 반면,GET 요청은 웹 캐시와 같은 다른 HTTP 어플리케이션으로 전송한다. TRACE는 메서드를 구별하는 메커니즘을 제공하지 않는다. TRACE 요청을 어떻게 처리할 것인지에 대해서는 일반적으로 중간 어플리케이션이 결정을 내린다. TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다.TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다. 요청메세지에 바디 존재 X 성공 응답메세지에 바디 존재 X 안전성 \u001d X 멱등성 \u001d O 캐시 가능? \u001d X HTML form에서 사용 가능? X 클라 요청 123TRACE /product-list.txt HTTP/1.1Accept: *Host: feel5ny.github.io 프록시 요청 1234TRACE /product-list.txt HTTP/1.1Accept: *Host: feel5ny.github.ioVia: 1.1 proxy3.company.com 👈 서버 응답 12345678HTTP/1.1 200 OKContent-Type: text/plainContent-Length: 96TRACE /product-list.txt HTTP/1.1Accept: *Host: feel5ny.github.ioVia: 1.1 proxy3.company.com 👈 프록시 응답 123456789HTTP/1.1 200 OKContent-Type: text/plainContent-Length: 96Via: 1.1 proxy3.company.com 👈TRACE /product-list.txt HTTP/1.1Accept: *Host: feel5ny.github.ioVia: 1.1 proxy3.company.com 👈 6. OPTIONS options 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다. 응답메세지 헤더에 Allow 필드를 포함해서 돌려준다. preflight 요청용으로 OPTIONS 메서드를 사용한다. cf__2 Preflight Preflight Request는 actual 요청 전에 인증 헤더를 전송하여 서버의 허용 여부를 미리 체크하는 테스트 요청이다. CORS Preflight Request는 CORS 프로토콜이 이해하는지 확인하는 요청이다. 메서드는 OPTIONS를 사용하며, 헤더를 함게 보낸다. Access-Control-Request-Method Access-Control-Request-Headers Origin Preflight Request 필요시 브라우저에서 자동으로 전송되므로, 일반적인 경우 프론트 개발자는 이러한 요청을 직접 만들 필요가 없다.참고 요청메세지에 바디 존재 X 성공 응답메세지에 바디 존재 O 안전성 \u001d O 멱등성 \u001d O 캐시 가능? \u001d X HTML form에서 사용 가능? X 요청 123OPTIONS * HTTP/1.1Host: feel5ny.github.ioAccept: * 응답 123HTTP/1.1 200 OKAllow: GET, POST, PUT, OPTIONSContent-Length: 0 7. DELETE 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다. 요청메세지에 바디 존재 ▲ 성공 응답메세지에 바디 존재 ▲ 안전성 \u001d X 멱등성 \u001d O 캐시 가능? \u001d X HTML form에서 사용 가능? X 요청 12DELETE /joy.txt HTTP/1.1Host: feel5ny.github.io 응답 12345HTTP/1.1 201 CreatedContent-Type: text/htmlContent-Length: 47I have your delete request, will take time to process. 200 OK 202 Accepted 204 No content 8. PATCH 리소스의 부분 수정 시 사용된다. PUT과 달리 비멱등성을 가진다. PATCH의 사용 여부는 Accept-Patch로도 가능하다. PUT과의 차이점 PUT은 문서 자체의 교체만을 허용한다. PUT으로 수정할 JSON 일부분을 보낼 때, 보낸 필드 이외의 필드는 null 혹은 초기화 처리가 된다. PATCH로 수정할 JSON 일부분을 보낼 때, 해당 필드만 수정된다. 요청메세지에 바디 존재 O 성공 응답메세지에 바디 존재 O 안전성 \u001d X 멱등성 \u001d X 캐시 가능? \u001d X HTML form에서 사용 가능? X 요청전 데이터 1234&#123; &quot;name&quot;: &quot;joy&quot;, &quot;company&quot;: &quot;goodoc&quot;&#125; PATCH 요청 12345PATCH /api/user/123 HTTP/1.1 Host: www.example.comContent-Type: application/json&#123;&quot;company&quot;: &quot;protopie&quot;&#125; PATCH 결과 1234&#123; &quot;name&quot;: &quot;joy&quot;, &quot;company&quot;: &quot;protopie&quot;&#125; PUT 요청 12345PUT /api/user/123 HTTP/1.1 Host: www.example.comContent-Type: application/json&#123;&quot;company&quot;: &quot;JOYI&quot;&#125; PUT 결과 1234&#123; &quot;name&quot;: null, &quot;company&quot;: &quot;JOYI&quot;&#125; 9. CONNECT 잘 모르겠다. HTTP CONNECT 메소드는 요청된 리소스와 양방향 통신을 시작한다. 터널을 여는 데 사용할 수 있다. 예를 들어 CONNECT 메소드를 사용하여 SSL(HTTPS)을 사용하는 웹 사이트에 액세스 할 수 있다. 클라이언트는 HTTP 프록시 서버에 TCP 연결을 원하는 대상으로 터널링하도록 요청한다. 그런 다음 서버는 클라이언트 대신 연결을 진행한다. 서버가 연결을 설정하면 프록시 서버는 클라이언트와의 TCP 스트림을 계속 프록시한다. 요청메세지에 바디 존재 X 성공 응답메세지에 바디 존재 O 안전성 \u001d X 멱등성 \u001d X 캐시 가능? \u001d X HTML form에서 사용 가능? X 요청 123CONNECT server.example.com:80 HTTP/1.1 Host: server.example.com:80 Proxy-Authorization: basic aGVsbG86d29ybGQ= 10. 확장 메서드 HTTP 명세에 정의되지 않은 메서드다. HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다. 아래는 웹 배포 확장메서드의 예시 LOCK - 사용자가 리소스를 잠글 수 있게 해준다. MKCOL - 사용자가 문서를 생성할 수 있게 해준다. COPY - 서버에 있는 리소스를 복사한다. MOVE - 서버에 있는 리소스를 옮긴다. 확장메서드를 다룰 때는 ‘엄격하게 보내고 관대하게 받아들여라’라는 오랜 규칙에 다르는 것이 가장 좋다. 책뽀개기 모임 중 http 완벽가이드 1장 뽀개기 진행중입니다. (~8월말) (다음 모임은 2장) HTTP 완벽가이드 책을 보고 이해한 내용을 저만의 순서로 정리 한 글입니다. 참고자료 http 멱등성참고 1 http 멱등성참고 2 http method 참고 preflight 참고 1 preflight 참고 2 http 응답 다이어그램 도움이 많이 된 시각화 자료 PUT과 PATCH의 차이 1 PUT과 PATCH의 차이 2 rfc7231","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"message","slug":"message","permalink":"http://feel5ny.github.io/tags/message/"},{"name":"method","slug":"method","permalink":"http://feel5ny.github.io/tags/method/"}]},{"title":"HTTP 메세지 - 개요","slug":"HTTP_003_01","date":"2019-08-15T12:23:55.000Z","updated":"2024-11-23T12:12:24.914Z","comments":true,"path":"2019/08/15/HTTP_003_01/","permalink":"http://feel5ny.github.io/2019/08/15/HTTP_003_01/","excerpt":"","text":"HTTP 메서지에 대해서 알아본다. 메세지는 세 덩어리로 나눌 수 있다 시작줄, 헤더, 본문. 시작줄은 요청과 응답에 따라 다르다. 요청의 시작줄에는 서버에 요구할 동작을 명시하는 메서드, 리소스의 위치를 알려줄 URL, 프로토콜 버전을 명시한다. 응답의 시작줄에는 버전과 처리 결과에 대한 상태코드, 사유구절이 명시되어있다. 다음 줄에는 헤더가 존재한다. 헤더는 일반헤더, 요청헤더, 응답헤더, 확장헤더, entity헤더로 구분할 수 있다. RFC 7231에서는 요청 헤더와 응답 헤더로 나눠서 설명한다. 헤더와 본문 사이에는 꼭 한 줄을 비워두어야한다.(CRLF) 본문은 옵셔널하다. 있을 때도 있고 없을 때도 있다. 메세지의 흐름을 설명하는 용어가 존재하는데, 상대적으로 표현된다. 서버를 기준으로 외부 클라에서 서버로(안으로) 흐르는 메세지를 인바운드, 서버에서 클라로(밖으로) 나가는 메세지를 아웃바운드라고 하며, 발신자를 기준으로 발신자에서 수신자의 방향을 다운스트림, 그 반대를 업스트림이라고 한다. 1. 메세지의 흐름HTTP 메세지는 HTTP 메세지 간에 주고받은 데이터의 블록들이다 데이터의 블록 텍스트 메타 정보: 메세지의 내용과 의미를 설명 클라이언트 서버, 프락시 사이를 흐름 메세지의 방향을 의미하는 용어인바운드 &#x2F; 아웃바인드 &#x2F; 업스트림 &#x2F; 다운스트림 1.1 인바운드 - 아웃바운드 HTTP는 인바운드와 아웃바인드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. 흐름 표현은 상대적인 표현방식으로, 인바운드와 아웃바인드는 서버를 기준으로클라에서 ⇒ 서버로의 안 쪽 흐름을 인바운드서버에서 ⇒ 클라 방향으로의 흐름을 아웃바운드 라고 한다. 인바운드로 이동 &#x2F; 아웃바운드로 이동 1.2 업스트림 - 다운스트림 요청&#x2F;응답 이라는 성격과 상관없이발신자와 수신자의 개념에서 발신자를 기준으로발신자에서 ⇒ 수신자 방향을 다운스트림수신자에서 ⇒ 발신자 방향을 업스트림 이라고 한다. 2. 메세지의 문법 HTTP메세지는 요청이나 응답으로 분류된다. 요청 메세지는 웹서버에 어떤 동작을 요구한다. - 메서드 응답 메세지는 요청의 결과를 클라이언트에게 돌려준다. 요청 버전은 프로토콜 버전 1234&lt;메서드&gt; &lt;요청 URL&gt; &lt;버전&gt;&lt;헤더&gt;&lt;엔터티 본문&gt; 응답 1234&lt;버전&gt; &lt;상태 코드&gt; &lt;사유 구절&gt;&lt;헤더&gt;&lt;엔터티 본문&gt; 3. 메세지의 각 부분 HTTP 메세지는 단순한, 데이터의 구조화된 블록이다. 시작줄 &#x2F; 헤더블록 &#x2F; 본문 3.1 시작줄과 헤더 줄 단위로 분리된 아스키 문자열 각 줄은 **캐리지 리턴(13)**과 **개행문자(10)**로 구성된 두 글자의 줄바꿈 문자열로 끝난다. CRLF라고 쓴다. HTTP 명세에 따르면줄바꿈 문자열은 CRLF이지만견고한 어플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 한다는 점을언급할 필요가 있을 듯하다. 그니까 모든 어플리케이션이 CRLF를 받아들일 수 있다는 전제가 깔려야한다. 오래되거나 잘못 만들어진 HTTP 어플리케이션들 중에서는 캐리지 리턴과 개행 문자 모두를 항상 전송하지 않는 것들도 있다. 아스키 문자열 ? 미국정보교환표준부호(영어: American Standard Code for Information Interchange), 또는 줄여서 ASCII( &#x2F;ˈæski&#x2F;, 아스키)는 영문 알파벳을 사용하는 대표적인 문자 인코딩이다. 아스키는 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며, 대부분의 문자 인코딩이 아스키에 기초를 두고 있다. 아스키코드 10 LF ( Line Feed &#x3D;&gt; 다음 줄로) 13 CR ( Cariage Return &#x3D;&gt; 제일 처음 칸으로) 3.1 시작줄 요청 메세지의 시작줄은 무엇을 해야하는지 말해준다. 응답 메세지의 시작줄은 무슨 일이 일어났는지 말해준다. 3.1.1 요청줄 요청 메세지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다.요청 메세지는 메서드 : 서버에서 어떤 동작이 일어나야 하는지 설명해주는 URL : 동작에 대한 대상을 지칭 HTTP 버전 : 클라가 어떤 HTTP버전으로 말하고 있는지 HTTP&#x2F;1.0 이전에는 요청줄에 HTTP버전이 미포함이었다. 모든 필드는 공백으로 구분된다. 3.1.1.1 메서드 요청의 시작줄은 메서드로 시작한다. 서버에게 무엇을 해야 하는지 말해준다. HTTP 명세에서 공통 요청 메서드의 집합을 정의한다. GET - 서버에서 어떤 문서를 가져온다. HEAD - 서버에서 어떤 문서에 대한 헤더만 가져온다. POST - 서버가 처리해야 할 데이터를 보낸다. PUT - 서버에 요청 메세지의 본문을 저장한다. TRACE - 메세지가 프락시를 거처 서버에 도달하는 과정을 추적한다. OPTIONS - 서버가 어떤 메서드를 수행할 수 있는지 확인한다. DELETE - 서버에서 문서를 제거한다. 모든 서버가 위 메서드를 모두 구현한 것은 아니다. 확장메서드 - 하지만 쉽게 확장할 수 (커스텀) 있도록 HTTP가 설계했기 때문에그들만의 메서드를 추가로 구현했을 수도 있다. 3.1.1.2 버전버전 번호는 HTTP로 대화하는 어플리케이션들에게대화 상대의 능력과 메세지의 형식에 대한 단서를 제공하기 위한 것이다. 요청과 응답의 버전이 다를 경우 혼란을 야기할수 있다. HTTP&#x2F;2.22는 HTTP&#x2F;2.3 보다 큰 버전이다.22와 3의 비교라고 보면 된다. 3.1.2 응답줄 응답 메세지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메세지의 시작줄, 즉 응답줄은 HTTP버전 숫자로된 상태코드 텍스트로 된 사유구절 HTTP&#x2F;1.0 이전에는 응답에 응답줄이 들어있을 필요가 없었다. 모든 필드는 공백으로 구분된다. 3.1.2.1 상태코드 클라이언트에게 무엇이 일어났는지 말해준다. 응답의 시작줄에 위치한다. 숫자로 된 코드와 문자열(사유구절)로 되어 있어서 사람이 이해하기 쉬운 메세지 두 형태 모두로 반환된다. 사유구절이 사람에게 쉽게 읽히고, 숫자로 된 코드는 프로그램이 에러를 처리하기 쉽다. 프로토콜이 진화하면서, 더 많은 상태 코드가 HTTP 명세에 공식적으로 정의될 것이다. 만약 인식할 수 없는 상태 코드라면 확장코드이다. 3.1.2.2 사유구절 응답 시작줄의 마지막 구성요소. 사유구절은 상태 코드와 1:1로 대응된다. 상태코드의 사람이 이해하기 쉬운 버전이다. 엄격한 규칙은 제공하지 않는다. 3.2 헤더 0개에서 1개 혹은 여러 개의 HTTP헤더가 온다. 긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수도 있다.스페이스 혹은 탭 문자가 와야 한다. 3.2.1 헤더 분류 헤더필드를 정의하다. 자유롭게 자신만의 헤더를 만들어낼 수 있다. 아래 분류 기준은 헤더를 이해하기 쉽게 카테고리화 한 것이며,RFC7231 기준으로는 Controls, Conditionals, Content Negotiation, Authentication Credentials, Request Context 로만 분류되어있다. Controls: 요청의 특정 처리를 지시하는 헤더들 Conditionals: 조건부 헤더 Content Negotiation: 협상 헤더 Authentication Credentials: 권한 헤더 Request Context: 요청 정보 헤더 3.2.1.2 일반 헤더 요청과 응답 양쪽에 모두 나타날 수 있음 예) Date, Connection, Cache-control … 3.2.1.3 요청 헤더 요청에 대한 부가정보를 제공 예) Host, User-Agent, From, Cookie, Referer, If-Modified-Since, Authorization, Origin, Accept 3.2.1.4 응답 헤더 응답에 대한 부가정보를 제공 예) Server, Accept-Range, Set-Cookie, Expires, Age, ETag, Proxy-authenticate, Allow, Access-Control-Allow-Origin 3.2.1.5 Entity 헤더 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술 예) Content-Type, Content-language, Content-Encoding, Content-Length, Content-Location, Content-Disposition, Content-Security-Policy, Location, Last-Modified, Transfer-Encoding 3.2.1.6 확장 헤더 명세에 정의되지 않은 새로운 헤더 3.2 본문 단순히 선택적인 데이터 덩어리이다. 옵셔너얼 ~ 시작줄과 헤더와 달리 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다 이진데이터: binary 데이터 이미지 파일 3. 엔터티 본문 optional인 엔터티 본문 메세지의 화물이라고 할 수 있다. 이미지,비디오,HTML문서,소프트웨어 어플리케이션,신용카드 트랜젝션,전자우편 등여러 종류의 디지털 데이터를 실어 나를 수 있다. 책뽀개기 모임 중 http 완벽가이드 1장 뽀개기 진행 중입니다. (~8월말) (다음 모임은 2장)(모임 참여를 원하신다면 댓글로 문의 바랍니다.) HTTP 완벽가이드 책을 보고 이해한 내용을 저만의 순서로 정리 한 글입니다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"message","slug":"message","permalink":"http://feel5ny.github.io/tags/message/"}]},{"title":"URL과 리소스","slug":"HTTP_002","date":"2019-08-09T12:23:55.000Z","updated":"2024-11-23T12:12:24.921Z","comments":true,"path":"2019/08/09/HTTP_002/","permalink":"http://feel5ny.github.io/2019/08/09/HTTP_002/","excerpt":"","text":"책뽀개기 모임 중 http 완벽가이드 1장 뽀개기 진행중입니다. (~8월말) (다음 모임은 2장)(모임 참여를 원하신다면 댓글로 문의 바랍니다.) HTTP 완벽가이드 책을 보고 이해한 내용을 저만의 순서로 정리 한 글입니다. URL의 개념URL(Uniform Resource Locator)은 인터넷 리소스를 가리키는 표준이름이다. URL은 전자정보 일부를 가리키고, 그것이어디에 있고어떻게 접근할 수 있는지 알려준다. URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며, URL을 이용해 사람과 어플리케이션이 인터넷 상의 수십억 개의 리소스를 찾고 사용하며 공유할 수 있다. URL을 통해 사람이 HTTP 및 다른 프로토콜을 통해 접근할 수 있다. URL을 사용하면 리소스를 일관된 방식으로 지칭할 수 있다.대부분의 URL은 동일하게 스킴://서버위치/경로 구조로 이루어져있다. 인터넷상의 모든 리소스를 가리키고 가져오기 위해,모든 사람이 같은 방식으로 이름을 써서 리소스를 찾을 수 있도록,단일 방식의 작명 규칙을 가진 것이다.&#x3D;&#x3D;&#x3D; 통합 자원 위치값 URL은 URI의 일부URL은 통합 자원식별자 혹은 URI라고 불리는 더 일반화된 부류의 부분집합이다.URI는 URL과 URN으로 구성된 종합적인 개념이다. URL은 리소스가 어디 있는지 설명해서 리소스를 식별한다. URN은 현재 그 리소스가 어디에 존재하든 상관없이 그 이름만으로 리소스를 식별한다. 안전한 통합 자원 위치(URL)값을 위해서 1. URL의 구성 모든 리소스들은 다른 스킴을 통해 접근할 수 있으며, URL 문법은 스킴에 따라서 달라진다. 대부분의 URL은 일반 URL문법을 따른다. 의미있는 URL이라는 개념도 있다. (Clean URLs) 당신이 URL을 조작하기 쉽게 한다. 어디에 있고, 무엇을 하고, 무엇을 읽거나 웹에서 상호작용하는 지에 대해 유저들에게 분명히 알려준다. 몇몇의 검색엔진은 관련 페이지들을 잘 분류하기 위해 이런 의미론을 사용할 수 있다. URL은 9개의 컴포넌트로 구성되어있다. 1&lt;스킴&gt;://&lt;사용자이름&gt;:&lt;비밀번호&gt;@&lt;호스트&gt;:&lt;포트&gt;/&lt;경로&gt;;&lt;파라미터&gt;?&lt;질의&gt;#&lt;플래그먼트&gt; - 1.1 스킴 스킴은 주어진 리소스에 어떻게 접근하는지 알려주는 중요한 정보다. URL을 해석하는 어플리케이션이어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려준다. 첫번째 구분자로 :를 사용한다. 스킴명은 대소문자를 가리지 않는다. 1.2 사용자 정보기본값 사용자 이름 : anonymous 비밀번호 : IEUser(익스플로러), chrome@example.com(크롬) 많은 서버가 자신이 가지고 있는 데이터에 접근을 허용하기 전에사용자 이름과 비밀번호를 요구한다. FTP서버가 주로 그러하다.1ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu 1.3 호스트 어플리케이션이 인터넷에 있는 리소스를 찾으려면리소스를 호스팅하고 있는 장비와장비 내에서 리소스에 접근할 수 있는 서버가 어디에 있는지 알아야 한다. Host 접근하려고 하는 리소스를 가지고 있는 인터넷상의 호스트장비(?)를 가리킨다. 호스트명이나 IP주소로 제공한다. Port 서버가 열어놓은 네트워크 포트를 가리킨다. TCP 프로토콜을 사용하는 HTTP는 기본 포트가 80이다. (https는 443) 1.4 경로 리소스가 서버의 어디에 있는지 알려준다. 계층적 파일 시스템 경로와 유사한 구조이다. 유닉스 파일 시스템의 파일 경로와 유사하다. /를 기준으로 경로조각으로 나누니다. 각 경로조각은 자체만으로 파라미터 컴포넌트를 가질 수 있다. 1.5 파라미터 Matrix parameter 많은 스킴이 객체에 대한 호스트 및 경로 정보만으로는 리소스를 찾지 못한다. URL이 사용하는 어플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요하다. URL의 파라미터 컴포넌트는어플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는데 사용한다. 이 컴포넌트는 이름&#x2F;값 쌍의 리스트로 URL 나머지 부분들로부터 ; 문자로 구분하여 URL에 기술한다. 쿼리스트링과 차이점개인적으로 지금까지 이런 형식의 URL을 본적이 없어서, 검색해보니이런 형식을 Matrix parameter라고 불리며, 쿼리스트링과의 차이점은 아래와 같다고 나왔다.( 관련링크 Query vs. Matrix Params ) urls with query params won’t have their response cached by intermediaries&#x2F;proxies (at present)쿼리 파라미터가있는 URL은 현재 중개자&#x2F;프록시에 의한 응답이 캐시되지 않습니다. matrix parameters may appear anywhere in path매트릭스 파라미터는는 path의 어느 곳이든 표현될 수 있다. calculating the relative uri is different상대 URI를 계산하는 것이 다르다. query params are generally abused to add new verbs instead of using existing methods on resources쿼리 파라미터는 일반적으로 리소스에 기존 방법을 사용하는 대신 새 동사를 추가하는데에 남용된다. matrix parameters are not resources, they are aspects that help reference a resource in an information space that is difficult to represent within a hierarchy매트릭스 파라미터는 자원이 아니며, 정보 공간에서 계층 구조 내에서 표현하기 어려운 자원을 참조하는 데 도움이되는 측면입니다. 아직 proposal state에 존재하며, 웹 표준이 아니라고 한다. (관련 링크 w3-MatrixURIs ) 1.6 쿼리파라미터 (질의 문자열).. 데이터베이스 같은 서비스들은 요청을 받을 리소스 형식의 범위를 좁히기 위해질문이나 질의를 받을 수 있다. URL의 쿼리스트링 컴포넌트는게이트웨이를 가리키는 정보를 URL의 경로 컴포넌트와 함께 전달하고 있다. 보통 게이트웨이는 다른 어플리케이션에 접근하려고 할 때 거치는 통로라고 할 수 있다. 쿼리스트링은 포맷에 제약사항은 없다. (URL에 금지된 문자제외하고) 편의상 많은 게이트웨이가 &amp;로 나뉜 이름=값 쌍 형식의 쿼리스트링을 원한다 1.7 플래그먼트 fragment HTML과 같은 리소스 형식들은 본래의 수준보다 더 작게 나뉠 수 있다. 문단으로 나뉠 수 있는 경우 리소스 안에 있는 특정 문단을 가리킬 수 있다. 리소스의 특정 부분을 가리킬 수 있도록 리소스 내 조각을 가리킬 수 있는 fragment 컴포넌트를 제공한다. 보통은 서버에는 fragment를 전달하진 않고, 프론트에서 특정 문단을 보여주고 싶을 때 사용한다. 2. 안전한 URL을 위해 고민한 설계자들URL 설계자들은 이런 고민을 했다. 모든 인터넷 프로토콜로 URL이 안전하게 전송될 수 있기를 바랬고 안전한 전송이란,정보가 유실될 위험 없이 URL을 전송할 수 있다는 것을 의미한다.문자가 제거되는 일을 피하고자 URL은 상대적으로 작고 일반적으로 안전한 알파벳 문자만 포함하도록 허락한다. 가독성도 있기를 바랬다. URL 설계자들은 이런 결론을 내렸다. 특정 문자 사용 금지. 따라서 출력이 되지 않거나 보이지 않는 문자를이메일 프로그램에서 사용할 수 있다고 해서,그리고 그 문자들이 변환될 수 있다 하더라도,URL에서 그런 문자들을 사용하는 것은 금지되었다. 알파벳 이외의 문자도 포함될 수 있도록 이스케이프 기능 추가 사람들이 알파벳 이외의 문자도 포함하려고 할 때가 있다는 것을 알게 되어이스케이프라는 기능을 추가하여안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게 하였다. 2.1 URL문자 집합 역사적으로 많은 컴포터 어플리케이션이 US-ASCII 문자 집합을 사용해 왔다. US-ASCII는 문자를 서식화하고 하드웨어상에서 신호를 주고받기 위해, 7비트를 사용하여 영문 자판에 있는 키 대부분과 몇몇 출력되지 않는 제어 문자를 표현한다. 미국인들에게는 편리하지만, 유럽언어나 수백가지 비 라틴계 언어들에 존재한는 변형된 문자들까지 US-ASCII가 지원하지 않는다. URL이 특정 이진데이터를 포함해야하는 경우도 있다. 이런 경우를 지원하기 위해서 이스케이프 문자열을 쓸 수 있게 설계하였다. 이스케이프 문자열은 URL에서 사용이 금지된 문자들로, 특정 문자나 데이터를 인코딩할 수 있게 함으로써 이동성과 완성도를 높였다. 2.2 인코딩 체계URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안되었다.인코딩은 이스케이프 문자로 바꿔준다. 이스케이프 문자 (퍼센트 문자): %로 시작해 ASCII 코드로 표현되는 두개의 16진수 숫자로 이루어져있다. 예시 ~ → 126 (0x7E) → %7E → 32 (0x20) → %20 % → 37 (0x25) → %25 2.3 문자 제한 몇몇 문자는 URL에서 특별한 의미로 예약되어있다. 어떤 문자는 US-ASCII의 출력 가능한 문자 집합에 포함되어있지 않다. 몇몇 인터넷 게이트웨이와 프로토콜에서 혼동되는 것으로 알려져 있어 사용을 지양하고 있다. URL 예약어 % : 인코딩 이스케이프 토큰 / : 경로 컴포넌트 세그먼트를 나누는 용도 . : 경로 컴포넌트에서 사용 .. : 경로 컴포넌트에서 사용 # : fragment 컴포넌트에서 사용 ? : 쿼리파라미터 컴포넌트에서 사용 ; : 매트릭스 파라미터 컴포넌트에서 사용 : : 스킴, 사용자 이름&#x2F;비밀번호, 호스트&#x2F;포트의 구획문자로 사용 $ : 미리 선점되었다. + : 미리 선점되었다. 게이트웨이에서 불안하게 다루기 때문에 제한 &#123; &#125; | \\ ~ [ ] ・ 게이트웨이와 같은 여러 전송 에이전트에서 불안하게 다루기 때문에 제한됨 &lt; &gt; &quot; 안전하지 않음. 웹 문서에서 URL을 구분지어 표시s하듯이 URL 범위 밖에서 역할이 있는 문자이기 때문에 반드시 인코딩해야한다. US-ASCII 관련 0x00-0x1F 0x7F 제한됨. 이 16진수 범위에 속하는 문자들은 인쇄되지 않는 US-ASCII 문자다. &gt; 0x7F 제한됨. 이 16진수 범위에 속하는 문자들은 7비트 US-ASCII 문자가 아니다. 3. 편리한 URL 사용을 위한 상황별 단축 URL웹 클라이언트는 몇몇 단축 URL을 인식하고 사용한다. 상대URL은 리소스 안에 있는 리소스를 간결하게 기술하는데 사용 URL확장은 사용자가 기억하고 있는 URL 일부를 입력하면 나머지 부분을 자동으로 입력해준다. 3.1 상대 URLURL은 2가지로 나뉜다. 상대 URL : 모든 정보를 담고 있지 않다. 기저(base)URL을 사용해야한다. 절대 URL : 리소스에 접근하는데 필요한 모든 정보를 가지고 있다. 문서의 URL을 기준으로 상대경로로 해석될 수 있다. 상대URL은 fragment이거나 URL 일부다. 브라우저 같은 어플리케이션은 상대URL과 절대URL 간에 상호 변환을 할 수 있어야 한다. 기저 URL기저 URL 찾는 방법 리소스에서 명시적으로 제공 &lt;base&gt; HTML 태그를 기술할 수 있다. (base) 리소스를 포함하고 있는 기저 URL 해당 리소스의 URL을 기저 URL로 쓸 수 있다. 기저URL이 없는 경우 불안전하거나 깨진 URL일 수도 있다. 상대 참조 해석하기상대 URL과 기저을 각각의 컴포넌트 조각으로 나누는 것이다.URL분해하기 &#x3D; URL 파싱하기변환을 위해서 특정 알고리즘을 사용한다.이 알고리즘은 상대URL을 절대URL 형태로 변환한다. 3.2 URL 확장 호스트명 확장 yahoo.com ⇒ www.yahoo.com 을 만든다. 사용자의 시간을 절약하고 혼란을 막아준다. 호스트명에 대한 확장 기능은 프락시와 다른 HTTP 어플리케이션에 문제를 발생시킬 수도 있다. 히스토리 확장 과거에 사용자가 방문했던 URL의 기록을 저장해놓는다. 4. 접근하는 방법의 종류(스킴의 종류) 스킴 설명 예 http HTTP스킴이다. 포트값이 생략되어 있으면 기본값은 80이다. http://feel5ny.github.io https 암호화하기 위해 넷스케이프에서 개발한 보안 소켓 계층(SSL)을 사용한다. 기본포트는 443 https://feel5ny.github.io mailto 이메일 주소를 가리킨다. RFC 822 mailto:joe@joes-hardware.com ftp 파일 전송 프로토콜. FTP는 웹과 URL이 출현하기 전부터 있었다. ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/ rtsp, rtspu 실시간 스트리밍 프로토콜(Real Time Streaming Protocol), rtspu에서 u는 리소스를 읽기 위해서 UDP 프로토콜이 사용됨을 뜻한다. rtsp://www.joes-hardware.com:554/interview/cto_video file 주어진 호스트 기기에서 바로 접근할 수 있는 파일들을 나타낸다. file//OFFICE-FS/policies/casual-fridays.doc news RFC 1036에 정의된 바와 같이 특정 문서나 뉴스 그룹에 접근하는데 사용한다. news:rec.arts.startrek telnet 대화형 서비스에 접근하는데 사용한다. telnet://slurp:webhound@joes-hardware.com:23/ 참고자료 HTTPs://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_domain_name HTTPs://developer.mozilla.org/ko/docs/Learn/Common_questions/What_is_a_URL","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"URL","slug":"URL","permalink":"http://feel5ny.github.io/tags/URL/"}]},{"title":"HTTP 개관","slug":"HTTP_001","date":"2019-08-03T12:23:55.000Z","updated":"2024-11-23T12:12:24.872Z","comments":true,"path":"2019/08/03/HTTP_001/","permalink":"http://feel5ny.github.io/2019/08/03/HTTP_001/","excerpt":"","text":"책뽀개기 모임 중 http 완벽가이드 1장 뽀개기 진행중입니다. (~8월말) (다음 모임은 2장)(모임 참여를 원하신다면 댓글로 문의 바랍니다.) HTTP 완벽가이드 책을 보고 이해한 내용을 저만의 순서로 정리 한 글입니다. 개요 &#x2F; 클라이언트와 서버의 전체 흐름 보기웹 어플리케이션은 사용자에게 어플리케이션을 보여주기 위해,사용자가 어플리케이션에 입장할 시점에서버에서 데이터(소스)를 받아와야한다. 어플리케이션은 서버에게 어떻게 데이터를 받아오는지 http를 모른다고 생각하고 상상해보자. 우선 데이터가 존재하는 서버의 위치부터 파악 해야한다. 데이터는 보통 다른 서버에서 받아오게 되는데,수많은 서버 중 특정 서버를 가리키기 위해서는 해당 서버의 주소를 알아야한다. Host2. 위치를 파악했다면 클라이언트와 서버의 연결이 필요하다. TCP&#x2F;IP 커넥션, port3. 연결이 이루어졌다면, 서버에게 원하는 바를 요청해야한다. 서버와 클라이언트가 둘다 이해할 수 있는 공용 언어가 필요하다. 공용 언어에서 어떤 대화방식이 이루어지는지,어떤 약속된 규칙으로 메세지를 주고받는지를 파악하고,이 규칙을 지킨 요청사항을 보내야한다. HTTP: HTTP 프로토콜을 통해 요청&#x2F;응답메세지를 보낸다.4. 요청이나 응답에서 어떤 데이터를 보내고, 받았는지 데이터의 위치, 종류를 알아야, 클라이언트에서 해석할 수 있다. 데이터는 종류가 많다. 일반 text부터 이미지, pdf파일, 음악파일, 영상파일 등등 어떤 종류의 데이터가 오가고 있고 어떻게 해석해줘야하는지에 대해 알려줘야한다. Content-Type, URI5. 특정상황에선 통신을 원할하게 해주는 다른 요소들이 필요하다. 서버의 데이터를 필터하는 과정이 필요하거나,받은 데이터를 저장해서 서버요청을 줄이는 등특정상황에서의 처리를 위한 요소가 필요하다. HTTP의 기반 시스템의 구성요소 이 모든 과정에 필요한 HTTP에 대해서 알아보고, 과정 순서대로 톺아보려고한다. HTTP의 개념HTTP (HyperTest Transfer Protocaol)HTTP는 WWW 상에서 정보를 주고받을 수 있는 프로토콜이다.주로 HTML 문서를 주고받는 데에 쓰인다.TCP와 UDP를 사용하며, 80번 포트를 사용한다. 인터넷의 멀티미디어 배달부 웹브라우저, 서버, 웹 어플리케이션 모두 HTTP (HyperTest Transfer Protocaol)을 통해 서로 대화한다. HTTP는 현대 인터넷의 공용어이다. HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에, 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장한다. 웹 서버는 HTTP프로토콜로 의사소통하기 때문에 보통 HTTP서버라고 불린다. 프로토콜이란?사람과 사람이 통신할 때 서로 이해할 수 있는 언어, 공용된 언어를 사용해 전세계 모든 사람과 대화 할수 있다라고 하면,컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것인데 이것이 바로 프로토콜(Protocol) 입니다. HTTP클라이언트와 HTTP서버는 월드 와이드 웹의 기본 요소이다. HTTP클라이언트는 HTTP를 사용할 수 있는 에이전트를 뜻한다. 클라이언트 입장에서 생각해보기 원하는 데이터가 있는 서버의 위치를 알아야한다. 위치를 파악했다면 연결이 필요하다. 연결이 이루어졌다면, 서버에게 원하는 바를 요청해야한다. 어디에있는 어떤 데이터인지를 알려줘야한다. 1. 원하는 데이터가 있는 서버의 위치를 알아야한다.데이터를 갖고 있는 서버의 위치를 알기 위해서 해당 서버의 주소, 즉 ip주소와 포트번호를 알아야한다. 1.1 접속, IP 주소 그리고 포트번호뒤에 나올 TCP&#x2F;IP 커넥션에 필요한 IP주소와 포트번호에 대한 내용이다. HTTP 클라이언트가 서버에 메세지를 전송할 수 있게 되기 전에,인터넷 프로토콜 주소와 포트번호를 사용해클라이언트와 서버 사이에 TCP&#x2F;IP 커넥션을 맺어야 한다. TCP에서는서버 컴퓨터에 대한 IP주소와그 서버에서 실행 중인 프로그램이 사용중인 포트번호가 필요하다.( 전화기로 치면, IP주소는 전화번호, 포트번호는 전화 걸고자 하는 상대방이 쓰는 번호 ) IP주소와 포트번호는 어떻게 알 수 있을까? ⇒ URL을 이용하면된다. 123http://207.200.83.29:80http://www.netscape.com:80/index.htmlhttp://www.netscape.com/index.html 호스트 명은 도메인 이름 서비스 (Domain Name Service, DNS)라 불리는 장치를 통해 쉽게 IP로 변환될 수 있다. 포트번호가 없는 경우 기본은 80이다. 1.2 단순한 HTML리소스를 사용자에게 보여주는 순서12345671. 웹 브라우저는 서버의 URL에서 호스트 명을 추출한다.2. 웹 브라우저는 서버의 호스트 명을 IP로 변환한다.3. 웹 브라우저는 URL에서 포트번호 (있다면) 을 추출한다.4. 웹 브라우저는 웹 서버와 TCP 커넥션을 맺는다.5. 웹 브라우저는 서버에 http 요청을 보낸다.6. 서버는 웹브라우저에 http 응답을 돌려준다.7. 커넥션이 닫히면, 웹 브라우저는 문서를 보여준다. 1번부터 4번까지 알아보았다. 2. 위치를 파악했다면 연결이 필요하다.TCP 커넥션을 통해서 어떻게 데이터가 넘어가는지 알아보자. TCP&#x2F;IP (Transmission Control Protocol &#x2F; Internet Protocol) 인터넷 전송 프로토콜 인터넷 자체가 TCP&#x2F;IP에 기초하고 있다. TTCP&#x2F;IP는 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합이다. TCP&#x2F;IP는 각 네트워크와 하드웨어의 특성을 숨기고,어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해 준다. 네트워크 개념상, HTTP프로토콜은 TCP위의 계층이다. HTTP는 자신의 메세지 데이터를 전송하기 위해 TCP를 사용한다. 이와 유사하게 TCP는 IP위의 계층이다. HTTP는 어플리케이션 계층 프로토콜이다. HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경쓰지 않는다. TCP가 제공하는 것 오류 없는 데이터 전송 순서에 맞는 전달 조각나지 않는 데이터 스트림 텔넷을 이용한 예시 텔넷 유틸리티는당신의 키보드를 목적지의 TCP 포트로 연결해주고출력 TCP 포트를 당신의 화면으로 연결해준다. 텔넷은 직접 컴퓨터의 포트로 TCP 커넥션을 연결해서 그 포트로 글자를 타이핑해 넣을 수 있게 해준다.1234567891011121314151617181920212223242526272829303132333435telnet feel5ny.github.io 80 👈👩‍💻Trying 185.199.108.153...Connected to feel5ny.github.io.Escape character is &#x27;^]&#x27;.GET /index.html HTTP/1.1 👈👩‍💻Host: feel5ny.github.io 👈👩‍💻HTTP/1.1 301 Moved PermanentlyServer: GitHub.comContent-Type: text/htmlLocation: https://feel5ny.github.io/index.htmlX-GitHub-Request-Id: D618:10D7:EA3B81:F6E706:5D445B26Content-Length: 178Accept-Ranges: bytesDate: Fri, 02 Aug 2019 15:47:51 GMTVia: 1.1 varnishAge: 0Connection: keep-aliveX-Served-By: cache-itm18822-ITMX-Cache: MISSX-Cache-Hits: 0X-Timer: S1564760871.463728,VS0,VE108Vary: Accept-EncodingX-Fastly-Request-ID: 092f039231a1abe8f0a17ae484a57d8d54cf5810&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 3. 연결이 이루어졌다면, 서버에게 원하는 바를 요청해야한다. ( 트랜젝션, 메세지 )서버와 대화하는 방식을 알아야한다. 클라이언트와 서버의 대화는주로 사람이 대화하듯이 말을 전달하고,응답받는 모양으로 구성되어있다. 즉, HTTP 트랜잭션은 요청 명령과 응답 결과로 구성되어있다. 서로가 이해하는 언어로 사용해야하기때문에 HTTP 메세지라고 불리는 정형화된 데이터 덩어리를 이용해 이루어진다. 3.1 트랜젝션 3.1.1 메서드클라이언트는 사용자의 요청에 따라 데이터를 처리하기위해 서버에게 특정 액션을 설명해줘야한다. 이를 위해서 HTTP는 HTTP 메서드라고 불리는 여러 가지 종류의 요청 명령을 지원한다. 메서드는 서버에게 어떤 동작이 취해져야하는지 말해준다. HTTP 에서 흔히 쓰이는 5가지 메서드 GET (서버 ⇒ 클) 보내라. 서버에서 클라이언트로 지정한 소스를 PUT 저장하라. 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 DELETE 삭제하라. 지정한 리소스를 서버에서 POST (클 ⇒ 서버) 보내라. 클라이언트 데이터를 서버 게이트웨이 어플리케이션으로 HEAD 보내라 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라. 3.1.2 상태코드 상태 코드는클라이언트에게 요청이 성공했는지아니면 추가 조치가 필요한지 알려주는 세자리 숫자다. 흔히 쓰이는 상태 코드 몇가지. 200 문서가 바르게 반환되었다. 사유구절 http는 각 숫자 상태 코드에 텍스트로 된 사유구절 (reason phrase)도 함께 보낸다. 200 OK 200 Document attached 200 Success 200 All’s cool, dude 302 다시 보내라. 다른 곳에 가서 리소스를 가져가라. 404 리소스를 찾을 수 없다. 3.2 메세지 서로가 이해하는 언어로 사용해야하기때문에 HTTP 메세지라고 불리는 정형화된 데이터 덩어리를 이용해 이루어진다. HTTP 메세지는 단순한 줄 단위이 문자열이다. 이진 형식이 아닌 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽다. HTTP 메세지 웹 클라이언트 ⇒ 웹 서버 : 요청 메세지 웹 서버 ⇒ 웹 클라이언트 : 응답 메세지 이 외의 다른 종류이 http 메세지는 없다. HTTP 요청과 응답 메세지의 형식은 굉장히 비슷하다. 출처 시작줄 요청이라면 무엇을 해야 하는지 응답이라면 무슨 일이 일어 났는지 나타낸다. 요청헤더 헤더 필드는 : 구분되어 있는 하나의 이름과 하나의 값으로 구성된다. 빈 줄로 끝난다. 본문 본문은 필요에 따라 올 수 있다. 문자열이며, 임의의 이진 데이터를 포함할 수 있다. (이미지, 비디오, 오디오 트랙, 응용소프트웨어) 4. 어디에있는 어떤 데이터인지를 알려줘야한다. ( 리소스 )이제 서버와 어떻게 대화하는지를 알게 되었다.특정 데이터를 특정 액션(메서드)을 해달라는 요청을 하는 방법을 알게되었는데,특정 데이터라는 건 어떻게 서버가 알게 해야할까.우선 데이터가 어디에 있는 어떤 컨텐츠인지. 해당 컨텐츠가 어떤 타입인지를 알야아한다. 어디에 있는 어떤 컨텐츠인지를 어떻게 알까. URI개념을 이용하면 된다. 4.1 URIUniform Resource Identifier &#x3D; 통합 자원 식별자 웹 서버 리소스는 각자 이름을 갖고 있다. 아래 URI를 분석해보면,https://feel5ny.github.io/2019/07/07/Joylog_003/ 1231. https:// http 프로토콜을 사용하라2. feel5ny.github.io 으로 이동하라3. /2019/07/07/Joylog_003 라고 불리는 리소스를 가져와라. URI에는 2가지가 있다. URL (locator) URN (name) 4.1.1 URL (locator)Uniform Resource locator &#x3D; 통합 자원 지시자 리소스 식별자의 가장 흔한 형태다. URL 은 특정 서버의한 리소스에 대한구체적인 위치를 서술한다. 오늘날 대부분의 URI는 URL이다. URL은 리소스가 정확히 어디에 있고, 어떻게 접근할 수 있는지 분명히 알려준다. 대부분의 URL은 세 부분으로 이루어지고, 표준 포맷을 따른다.( https://feel5ny.github.io/2019/07/07/Joylog_003/ ) https:// URL의 첫번째 부분은 스킴이라고 불린다. 리소스에 접근하기 위해 사용되는 프로토콜을 서술한다. 보통은 http 프로토콜 http:// 스킴과 스키마의 차이점스키마(schema)는 계획이나 도식을 가리키는 영어 낱말로, 다음을 가리킨다. 참고로 스킴(scheme)은 스키마와 거의 같은 의미로 쓰이나, 보통 스키마가 대략적인 계획이나 도식을 뜻하는 데 비해 스킴은 구체적이고 확정된 것을 말한다. feel5ny.github.io 두번째 부분은 서버의 인터넷 주소를 제공 /2019/07/07/Joylog_003/ 마지막은 웹 서버의 리소스를 가리킨다. 4.1.2 URN (name) 잘 모르겠다. Uniform Resource name &#x3D; 통합 자원 이름 URN은 콘텐츠를 이루는 한 리소스에 대해,그 리소스의 위치에 영향받지 않는 유일무이한 이름 역할을 한다. (?) 이 위치 독립적인 URN은 리소스를 여기저기로 옮기더라도 문제없이 동작한다. 리소스가 그 이름을 변하지 않게 유지한 한,여러 종류의 네트워크 접속 프로토콜로 접근해도 문제없다. 예시) 인터넷 표준문서 RFC 2141이 어디에 잇거나 상관없이 그것을 지칭하기 위해 URN을 사용할 수 있다. URN은 여전히 실험 중인 상태이고,아직 널리 채택되지 않았다. 효율적인 동작을 위해 URN은 리소스 위치를 분석하기 위한 인프라 지원이 필요한데,그러한 인프라가 부지하기에 URN 채택이 더 늦춰지고 있다. 어디에 있고, 어떤 이름을 갖는 파일인지를 알아보는 방법을 알아봤으니,해당 컨텐츠가 어떤 종류의 타입인지를 알야아한다. 4.2 미디어 타입인터넷은 수천 가지 데이터 타입을 다루기 때문에HTTP는 웹에서 전송되는 객체 각각에신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙인다. 4.2.1 MIMEMIME &#x3D; multipurpose Internet Mail Extensions &#x3D; 다목적 인터넷 메일 확장 왜 MIME? MIME은 원래 각기 다른 전자메일 시스템 사이에서메세지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었다. MIME은 이메일에서 잘 동작하기 때문에http에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해 채택되었다. HTTP에서 MIME 타입은?웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다. 웹브라우저는 서버로부터 객체를 돌려받을 때,다룰 수 있는 객체인지, MIME타입을 통해 확인한다. 대부분의 웹브라우저는 잘 알려진 객체 타입 수백가지를 다룰 수 있다. 이미지 파일을 보여주고html 파일을 분석하거나 포매팅하고,오디오 파일을 컴퓨터의 스피커를 통해 재생하고특별한 포맷의 파일을 다루기 위해 외부 플러그인 소프트웨어를 실행한다. MIME은 어떻게 표시되나?MIME 타입은 사선 &#x2F;으로 구분된 주 타입과 부타입으로 이루어진 문자열 라벨이다. 1주타입/부타입 (primary object type / specific subtype) 종류 html로 작성된 텍스트 문서 text/html plain ASCII 텍스트 문서 text/plain jpeg image/jpeg gif image/gif quicktime video/quicktime microsoft ppt application/vnd.ms-powerpoint HTTP의 종류HTTP&#x2F;0.91991년 HTTP 프로토타입 HTTP&#x2F;0.9 문제점 심각한 디자인 결함 연동: 구식 클라이언트하고만 같이 사용 가능. 메서드: GET 메서드만 지원 미지원: MIME타입, HTTP헤더, 버전 번호는 지원하지 않는다. 상황 원래 간단한 HTML 객체를 받아오기 위해 만들어진 것이다. 바로 1.0으로 대체됨 HTTP&#x2F;1.0처음으로 널리 쓰이기 시작한 HTTP 버전 버전번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가가했다. HTTP가 상업적, 학술적으로 급성장하던 시기에 만들어진, 잘 동작하는 용례들의 모음에 가깝다. HTTP&#x2F;1.0+상황 월드와이드 웹이 급격히 성공하면서클라이언트와 서버들은 그에 다른 요구를 만족시키기 위해HTTP에 기능을 추가해갔다. 지원 오래 지속되는 keep-alive 커넥션, 가상 호스팅 지원, 프락시 연결 지원, 공식은 아니지만 표준으로 추가됨. HTTP&#x2F;1.1HTTP 설계의 구조적 결함 교정,두드러진 성능 최적화,잘못된 기능제거에 집중했다. HTTP&#x2F;2.01.1 성능 문제를 개선하기 위해구글의 SPDY 프로토콜을 기반으로 설계가 진행중인 프로토콜이다. SPDY SPDY는 ‘speedy’라는 단어를 기반으로 Google이 만든 조어로,Google이 자신들의 ‘Make the Web Faster’ 노력의 하나로 제안한 새로운 프로토콜입니다.이는 초창기 인터넷 환경에서 고안된 HTTP의 단점들을 보완하여,지금과 앞으로의 인터넷 환경을 보다 효율적으로 이용할 수 있는 프로토콜로 제안된 것입니다. 참고자료: NAVER D2 @2021-02-12 추가 HTTP2에 대한 문서 https://http2-explained.haxx.se/ko HTTP3에 대한 문서 https://http3-explained.haxx.se/ko HTTP 기반 시스템의 구성요소 ( 인터넷 곳곳에 설치된 )특정상황에 효율적인 처리를 위해 만들어진 HTTP 구성 요소 개념 프락시 캐시 게이트웨이 터널 에이전트 1. 프락시클라이언트와 서버 사이에 위치한 HTTP 중개자 서버와 클라이언트 사이에 중계자로서대리로 통신을 수행하는 것을 가리켜 ‘프록시’,그 중계 기능을 하는 것을 ‘프록시 서버’라고 부른다. 클라이언트와 서버 사이에 위치한다. 클라이언트의 모든 HTTP 요청을 받아 서버에 전달한다. 요청을 수정한 뒤에이 어플리케이션은 사용자를 위한 프락시로 동작하며사용자를 대신해서 서버에 접근한다. 프락시는 주로 보안을 위해 사용된다. 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 한다. 프락시는 요청과 응답을 필터링한다. 예시 어플리케이션 바이러스를 검출하거나 초등학교 학생들에게 성인 콘텐츠를 차단한다. 2. 캐시많이 찾는 웹페이지를클라이언트 가까이에 보관하는 HTTP 창고 웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중자주 찾는 것의 사본을 저장해두는,특별한 종류의 HTTP 프락시 서버이다. 더 빠르게 문서를 다운받을 수 있다. HTTP는 캐시를 효율적으로 동작하게 하고,캐시된 콘텐츠를 최신 버전으로 유지하면서동시에 프라이버시도 보호하기 위한 많은 기능을 정의한다. 3. 게이트웨이다른 어플리케이션과 연결된 특별한 웹 서버 다른 서버들의 중개자로 동작하는 특별한 서버다. 주로, HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용된다. 게이트웨이는 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다. 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못할 것이다.( 변환의 개념이기때문에 A에서 B의 변환이라면 A, B의 정보를 모두 알기 때문에 ) 예시 HTTP&#x2F;FTP 게이트웨이는 FTP URI에 대한 HTTP요청을 받아들인뒤FTP 프로토콜을 이용해 문서를 가져온다. 받아온 문서는 HTTP 메세지에 담겨 클라이언트에게 보내다. 4. 터널HTTP 통신을 전달하기만 하는 특별한 프락시 터널은 두 커넥션 사이에서날raw 데이터를 열어보지 않고그대로 전달해주는 HTTP 어플리케이션이다. HTTP 터널은비 HTTP 데이터를하나 이상의 HTTP 연결을 통해그대로 전송해주기 위해 사용된다. 예시 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써, 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있다. 5. 에이전트자동화된 HTTP 요청을 만드는 준지능적 semi-intelligent 웹클라이언트 사용자 에이전트는사용자를 위해 HTTP 요청을 만들어주는클라이언트 프로그램이다. 웹 요청을 만드는 어플리케이션은 무엇이든 HTTP 에이전트다. 예시 자동화된 에이전트: 스파이더, 웹로봇 참고링크 https://bignet.tistory.com/73","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"}]},{"title":"2019 상반기 회고 + 하반기 다짐 (feat. 글또)","slug":"Joylog_003","date":"2019-07-07T12:23:55.000Z","updated":"2024-11-23T12:12:24.869Z","comments":true,"path":"2019/07/07/Joylog_003/","permalink":"http://feel5ny.github.io/2019/07/07/Joylog_003/","excerpt":"","text":"2019년 상반기가 지났다.그동안 잘 지냈는지, 어떻게 지내고 있는지 스스로 회고해보고,앞으로 2019년을 어떻게 잘 마무리할 것인지 정리해보려고 한다. 1. 2019 다짐한 것, 잘 이루고 있을까?2019 다짐 글 ( 안녕 2018, 안녕 2019 ) ➔ 1.1 기본 실력 키우기 (10%)2019년 다짐 글을 쓸 당시 기본 실력을 키우자 라는 글을 쓸 때의 느낌은.. 참 가벼웠던 거 같다.두루뭉술했고, 구체적이지 않아서, 어쨌든 자바스크립트 공부겠지., 특정 책 하나 더 공부하지라는 정도로만 느꼈었다. 때문에 목표가 구체적이지 않아서, 동기도 강하지 않았다. 그런 와중에 회사에서의 상반기 경험으로 기본 실력의 범위를 다시 한번 정의할 수 있었다.상반기 때는 기본 실력이 왜 중요한지, 구체적으로 느낄 수 있는 여러 가지 사건이 있었다. 프론트엔드 개발자로서의 언어의 기본 지식도 포함되지만, 서비스(어플리케이션)을 만들고 배포하고 유지 보수하는 상황에서 필요한 지식도 기본 실력에 포함시켜야 한다고 생각했고, 그 지식의 더 원론적인 레벨에 있는 내용도 더 많이 공부해야겠다고 생각이 들었다. 상반기를 가볍게 본다면 자바스크립트의 es6 문법에 대해서 좀 더 공부했고, 실무에서도 활용해보려고 노력했다. 리액트 등의 프레임워크 의존도도 벗어나보려고 스터디도 참여해 보았고, 알고리즘 공부도 조금씩 진행했다. 이 글의 하반기 다짐 글에는 기본 실력 키우기의 소제목을 구체적으로 정의해서 실천해야겠다. 1.2 디자인 시스템 이해도 높이기 (30%)디자인 시스템의 이해도를 높이기 위해서개인적으로는 코드 레벨에서 구조화정도까지만 작업이 되었고,외부적으로는 디자인 시스템에 대해서 사내발표를 진행했다. 디자이너와 함께하는 프로젝트에서 효과가 발휘되는 시스템인데, 현재 나의 상황에서는 사내의 프로젝트 정도가 디자인 시스템을 적용할 수 있었다. 이 시스템의 구축은 디자이너와의 협업도 필요한 부분이지만, 사전에 이 시스템이 개발자들에게 어떤 생산성을 가져다주는지에 대해서 팀원들에게 먼저 알려줄 필요가 있다고 생각이 들었다. 1.3 포트폴리오 작업하기 (0%)개인적인 포트폴리오 작업을 이루지 못했다. 너무 무겁게 생각해서 시작을 못한 것도 큰 이유인 것 같다.그래서 이번엔 진짜 가볍게! 어플리케이션 수준 말고, 우선 게츠비 혹은 hexo 블로그 테마를 만드는 것을 1차 목표로 다시 잡았다.또 다른 목표는 회사일과 내 생활의 균형을 맞춰가면서 작은 것 하나라도 만들어보는 것. 2. 2019 상반기 뭘 했을까 2.1 👥 외부 활동2.1.1 글또 2기 (글쓰기 활동) 작년 11월부터 글또 2기에 참여하고 있었다. 4월에 마무리를 지으면서, 총 17개의 글을 작성하였다. 개수는 큰 의미가 없지만.. 1기에 비해서는 글의 퀄리티나, 글감의 종류는 많이 아쉬운 편이다.나름 그래도 반강제적으로 공부할 수 있도록 만들어준 것에 감사하다. 2주일마다 주말에 컴퓨터 앞에 앉을 수 있도록 도와주는 고마운 모임이다.2기 마무리 때는 케어랩스 본사로 초대 드렸다. 타이밍이 좋지 않아 엘리베이터 공사 중에 모임 날짜가 잡혀서 반강제로 10층까지 계단 운동을 할 수 있도록 만들어드렸다 😂 2.1.2 코드 스피츠 수업 참여 (원론 수업)좋아하는 코드 스피츠 강의를 2개 참여했다. OOP Design with Game (2월) 코드골프 알고리즘 (4월) 1번 수업이 진짜 재밌었다. 그 당시 어플리케이션에서 역할별로 레이어를 쪼개는 아키텍처에 대해서 적용해 보려고 고민을 많이 하고 있었는데, 고민만큼 의문도 컸었다. 사실 레이어를 쪼개지 않을수록 그 순간의 작업량은 쪼갰을 때보다는 확실히 적고, 단순하기 때문이다. 그런 의문이 들 때 이 수업을 들었는데, 레이어링이 후에 어플리케이션의 복잡도를 낮출 수 있도록 도와준다는 내용을 듣고, 확신을 얻고 작업할 수 있게 되었다. 물론 자바스크립트로 게임을 만드는 것에도 엄청 재밌었다. 코드 스피츠 수업은 수업 자체가 너무 알차기 때문에 정리하는 데만\u001d 해도 시간이 많이 걸리는 수업이다. 단점이라면, 정리만으로도 마치 공부를 다했다는 착각이 들기 때문에 반드시 배운 내용을 덮어두고 의식적으로 실습을 해봐야지 배운 내용을 리마인드 시키면서 체화시킬 수 있는데, 정리 이후의 시간에 투자를 많이 못 했던 것 같다. 물론 작년까지만 해도 코드 스피츠 수업 내용 자체를 이해하기위해 많은 노력을 했었어야 했는데,이제는 조금? 작년보다는 받아들이는데 시간이 조금 줄어든 것 같다… 의식적 실습에 더 투자해보자. 코드골프 수업 때는 사실 이 영역은 배워야 할 부분이 너무 많다는 것이 느껴져서 중도 포기를 하게 되었다. 지식부터 접근할 때의 생각 방법까지.. 이 수업 시간에는 매 순간이 놀라움이었다. (정말 매번 수업 때마다 헐?을 난무)아직까지는 따라가기 버겁다고 생각이 들어서 keep 해 놓았고, 티끌 모아 태산 전략으로 아주 조금씩 공부해 보려고 한다. 2.1.3 바닐라 JS 온라인 스터디 (코드 리뷰, JS) 프로그래머스에서 진행하는 바닐라 자바스크립트 스터디에 참여\b했다. 평소 사내에서는 리액트 위주로 작업을 하기 때문에 따로 사이드 프로젝트를 하지 않는 이상,(사실 사이드 프로젝트에서도 바닐라는 잘 안 쓰게 될 거 같다..) 혹은 코드 스피츠 같은 바닐라 자바스크립트 기반의 수업에 참여하지 않는 이상 바닐라로 실습하는 환경을 만들기 힘들었기 때문에 감을 잃지 않게 수강하게 되었다. 수업방식은 과제의 명세를 다 구현하고, pr을 올리면 서로가 코드 리뷰를 해주는 방식이다. 근데 생각보다 코드 리뷰에 대해서 너무 좋은 인상을 얻게 되었다. 사실 솔직하게는 제대로 된 코드 리뷰를 처음 받아본 것 같았다. 이렇게 서로 다른 스타일을 갖고 있는 많은 인원의 코드 리뷰를 받을 수 있다는 것과, 서로 간의 커뮤니케이션 방법에 대해서도 다양하게 접할 수 있어서 협업 시 지녀야 할 스킬에 대해서 배울 수 있었다. 2.1.4 AWS 워크샵 (aws 서비스들 맛보기)사실 이 워크샵 때 진행했던 모든 aws 서비스를 전부 이해하진 못했다. 하루 만에 8가지 서비스 맛보기니 ㅎㅎ 뭔가 aws에는 이렇게나 많은 서비스가 있고, 이 기능을 너희가 써주면 좋을 거 같아! 느낌의 수업이었다. 수업도 아니고.. 거의 튜토리얼 형 수업이었다. 집에서 몇 번 하면서 아 이런 게 있구나 하는 정도로 복습해 보려고 한다. 간단한 토이 프로젝트에 써보면 재밌을 거 같긴 하다. 2.1.5 이상한 모임 번역 (실패인가 아닌가) 이모에서 번역팀을 모집해서 참여했다. 나름 테스트 번역도 통과해서 비개발 번역팀에 속하게 되었고, 첫 번째 번역은 이모지 글에 대한 번역이었다. 하나의 글을 함께 번역하는데, 데드라인을 딱히 정하지 않고 있어서 다른 분들은 아직도 .. 진행 중이다… (뭔가 이 모임은 마무리 지어야겠다..) 2.2 🗣 발표2.2.1 사내 발표굿닥은 매주 사내 테크톡을 진행한다. 개발자들이 매주 돌아가면서 자유롭게 발표를 하는 형식으로 진행하는데, 상반기 때는 3번의 발표를 진행했다. 대부분이 팀 내에 공유가 되면 좋을 주제들 위주로 진행했다. [함께자라기] 책 리뷰 난 어떻게 야생해서 성장해야하는가 우린 어떻게 함께 성장해 할 수 있는가 디자인 시스템과 웹 프론트엔드 디자인 시스템은 무엇인가? 웹 프론트엔드는 디자인시스템을 프로젝트에 어떻게 녹일 수 있는가 버저닝과 문서화 (feat.Web) 버저닝은 전체 프로세스에서 어떤 장점을 줄까 docs as code 개념으로 문서를 관리하자 + + 2.2.2 외부 발표\u001f1. 실수하며 성장하기올해 초, 패캠 수료생들의 모임에서 발표를 진행했다. 1년 동안 무엇을 실수했고, 그로 인해서 무엇을 배웠냐에 초점을 맞춰서 발표를 진행했다. 개인적으로 1년을 회고할 수 있어서 좋았다. 2. 기록하며 성장하기이제 막 커리어를 시작할 분들을 위한 세미나에서 발표 제안이 왔다.제일 도움이 많이 되었던 기록하기에 대해서 발표해보려고 한다. ➔ + 2.3 ✍️ 어떤 글을 썼을까? (17)2.3.1 글감 회고 📚 공부 정리글 13 개인 글 1 💡 튜토리얼 글 3 2기 때 글또를 하면서 작성했던 글의 종류이다. 2기 때 글의 카테고리를 이렇게 정리했었다. 📚: 공부하자! 내 스타일로 메모 💡: 작업하다가 삽질해서 내 것이 된 지식을 정리하자. 🙆: 내가 알고 있는 부분을 정리해보자. 🏃: 세미나 다녀왔습니다. 그때 당시에는 “1번 &gt; 2번, 3번 비율로 쓸 예정이다.” 라고 했었는데, 확실히 예상대로 ㅎㅎ 1번을 많이 작성하₩긴 했다. 3번 4번은 아예 작성하지를 못했다. 4번은 상반기에는 딱히.. 세미나가 없었다. 사실 표만 예매하고 가지 않아서 쓸 후기가 없었다. 3번은 약간 여유가 있을 때 쓰게 되곤하는데, 상반기에는 여유가 없었다. 사내에 큰 배포도 있었고, 야근도 종종 하고 이것저것 일을 벌\b여놔서 그런 게 아닌가 싶다. 2.3.2 2기 때 생각했던 글의 방향? 확실히 글 쓰는데 스트레스는 받지 않았다. 책 요약은 2개 작성 3번은 거의 쓰지 못했다. 🧐 2.4 👤 개인 공부2.4.1 자바스크립트사실 상반기에는 자바스크립트 자체 공부는 많이 못 한 거 같다. 물론 수업을 이것저것 듣긴 했지만.. 개인적으로는 이것저것 삽질을 통해 알게 된 깨달음 정도..만 있었던 거 같다. (반성반성) 2.4.2 아키텍처클린 아케텍처에 한때 꽂혔었다. 레거시 코드를 양성하고 싶지 않은 강한 마음으로, 복잡도를 낮출 수 있는 여러 가지 설계 방법에 대해서 고민했었고, 클린 아키텍처에 관심을 갖게 되었다. 기존 알고 있던 아키텍처보다 조금 더 비즈니스 로직을 이상적으로 분리할 수 있었지만, 레이어가 많이 쪼개짐에 따라 관리해야 할 레이어도 많이 생겨난다는 상황은 또 다른 고민을 만들긴 했다. 2.4.2 삽질하면서 공부 젠킨스 젠킨스를 이것저것 만져보면서 공부하게 되었다. 사실 툴 공부이기 때문에 큰 의미는 없지만 이것저것 재밌게 커스터마이징하면서 배울 수 있었는데, 특히 shell script 배운 게 너무 재밌고 신기했다. git hook에서 precommit시 이것저것 조건문을 걸어서 git의 특정 명령어를 막는다던가, 특정 상황은 제외를 거는 스크립트를 작성하는 부분이 신기했고 재밌었다. 웹 캐시 웹의 캐시구조에 대해서 여러 가지 버그를 통해서 배울 수 있었다. 특정 버그 픽스를 위해서 캐시의 일부분만을 이해했기 때문에 전체 공부를 위해서 네트워크 책을 톺아보려고 한다. \u001f 2.5 💁‍ 김나영 활동2.5.1 유튜브..?남자친구와 유튜브 컨텐츠를 제작해보려고 했다. 계정도 만들고 촬영도 했는데 편집을 아직 못했다. 유투브 콘텐츠는 확실히 자극적인 콘텐츠로 만들어야 하는데, 자극적인 카피를 뽑는 것부터, 생소한 주제라든지, 재밌게 편집해야 하는 부분이라든지, 지금까지 만들었던 콘텐츠들과는 다르게 생각해야 하는 면이 있어서 만들 때부터 고민이다. 2.5.2 필라테스매년 한 해의 다짐 리스트에 있던 운동을 시작해보았다. 체력이 너무 떨어진 것 같아서 시작한 것도 있다.사실 다른 핑계들 때문에 시작하지 못할 수 있었는데, 회사에서 필라테스 하시는 분들의 이야기도 듣고, 주변 지인들의 적극적인 권유로 시작하게 되었다. 2달 반 정도 진행되고 있는데, 선생님이 자세가 괜찮다고 엊그제 말씀해주셔서 기분이 좋은 상태다!필라테스도 알아야 할 용어가 너무 많아서, 선생님은 단어만 말하면 내가 딱딱 그 자세를 하길 원하시는데, 바로바로 기억해내지 못했다. 몇 번을 그렇게 되니 안되겠다 싶어 한번 정리나 해보자 해서, 요약 그림을 만들었는데, 한두 번하다가 그만뒀다. 3. 2019 하반기 뭘 해볼까 (목표 설정)상반기를 회고해보니 공부 비율보다는 딴짓 비율이 높은 것 같다.좀 더 기본 지식 딥한 공부 + 체화하는 실습시간을 갖는 걸 목표로 잡고 계획해봐야겠다. 3.1 👤 개인 공부3.1.1 기본 실력 키우기 (10%) 웹 네트워크 장기전으로 가야 하기 때문에 스터디로 진행하려고 한다. HTTP 완벽가이드 책을 끝까지 톺아보기 기본 톺아보기 구글 웹문서- 목표: 어플리케이션 개념에서 알아야 할 웹 지식을 배우자- 구글에서 정리한 웹 문서를 톺아보기 mdn- 목표: 기본적으로 내가 편하게 쓰고 있는 api나 method에 대해서 제대로 알자.- mdn의 기본설명을 확인하면서 쉽게 설명할 수 있는 수준으로 이해하고 공부하려고 한다. 3.1.2 디자인 시스템 이해도 높이기 (30%) 프로젝트 컴포넌트 정리하기 프로젝트 컴포넌트의 속성을 좀 더 디자인 속성의 개념으로 카테고리화한다. docs as code 개념으로 컴포넌트 문서화를 진행한다. (스토리북) 디자이너와 싱크 맞추기 1번이 완료된다는 전제가 필요하다. 3.1.3 포트폴리오 작업하기 (0%)맨 처음에 말했던 것처럼 블로그 테마 하나 내보기!지금까지 블로그 하면서 불편했던 부분을 개선해서 올리려고 한다. 3.2 ✍ 어떤 글을 쓸까? (글감 방향) 📚: 공부하자! 내 스타일로 메모 💡: 작업하다가 삽질해서 내 것이 된 지식을 정리하자. 🙆: 내가 알고 있는 부분을 정리해보자. 🏃: 세미나 다녀왔습니다. 아무래도 1번 &gt; 2번 &gt; 3번, 4번 순으로 작성할 것 같다. 특히 이번 삽질하면서 작성하고 싶은 글이 너무 많아서 2번의 비율이 예전보다 높지 않을까 생각된다. 우선 이번 기수 때 12개의 글을 기본 작성해야 하니 1번: 5개 2번: 3개 3번: 2개 4번: 2개 이렇게 개수는 필수로 두고 작성해보자! 3.3 💁‍ 김나영 활동 유튜브 영상 12월 전에 1개 이상 올리기. 필라테스 복근 운동 시 마지막 버티기 힘들 때 하나 더 해보려고 하기. 나만의 제대로 쉬는 방법 생각해보기 사실 개인의 스트레스는 나 자신뿐만 아니라 주변에도 안 좋은 영향을 끼치는 것 같다. 이번 상반기 때 그런 부분을 많이 느끼면서, 하반기 때는 스트레스를 잘 관리하고, 단기간 동안 최고의 휴식은 어떻게 취할 수 있는지에 대해서 생각해 보기로 했다. 요가든 명상이든 책에서 얻을 수 있는 부분이던, 술로 스트레스를 푸는 방법 말고 나만의 휴식 방법에 대해서 고민해보고 정립하고 싶다.","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"Joy","slug":"Joy","permalink":"http://feel5ny.github.io/tags/Joy/"},{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/tags/blog/"}]},{"title":"코드스피츠80_OOP design with game (2)- 2. 모델 (베이스 레이어)","slug":"OOP_09_2","date":"2019-03-17T04:32:40.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2019/03/17/OOP_09_2/","permalink":"http://feel5ny.github.io/2019/03/17/OOP_09_2/","excerpt":"","text":"코드스피츠 강의 정리록 생소한 도메인으로 배우는게 좋다.익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.때문에 80기는 게임을 통해서 진행할 예정. 1. 저번시간의 코드에서 잘못된 점을 찾아보자. 1.1 베이스 클래스에 네이티브 지식이 포함되어있다.12345678const Block = class &#123; static GET(type = parseInt(Math.random() * 5))&#123; return new Block(type);&#125; constructor(type) &#123; this._type = type; &#125; get image()&#123; return 👉 `url(&#x27;img/block$&#123;this._type&#125;.png&#x27;`;&#125; get type()&#123; return this._type&#125;&#125; 블럭 모델에 네이티브 지식이 들어가있다. (css 지식) 베이스 레이어에 들어오면 안되는 지식이다. 아키텍처는 코드에 가질 수 있는 역할과 가질 수 없는 역할, 기질 수 있는 책임과 가질수 없는 책임을 명시할 수 있고, 그것으로 코드가 바른지 안바른지 판단하는 기준표가 된다. 기존 모델에서 지금 아키텍처와 안 맞는 부분을 지목할 수 있다. 1.2 통제권을 가진 제왕이 존재한다. (1) - 블럭 위치값의 지식123456789101112131415👉 const data = [];...return tid =&gt; &#123; table = document.querySelector(tid); 👉 for (let i = 0; i &lt; row; i++)&#123; const r = []; data.push(r); 👉 for(let j = 0; j &lt; column; j++) r[j] = Block.GET(); &#125; table.addEventListener(&#x27;mousedown&#x27;, down); table.addEventListener(&#x27;mouseup&#x27;, up); table.addEventListener(&#x27;mouseleave&#x27;, up); table.addEventListener(&#x27;mousemove&#x27;, move); render();&#125;; cf__1. 프로시저적인 생각을 한다? 를 어디서 알 수 있냐면,&#x3D; 모든 연산을 data를 갖고 하려고 한다. data가 왕이다. 통제의 왕 일반적으로 프로시저로 짜면 메모리를 적게 사용하게 된다. 메모리의 효율성이 높아지고, 연산의 횟수가 줄어든다. 하지만 모든 복잡성을 본인이 감당해야한다. 예를들어 현재는 2차원배열로 작업했지만,요건이 만약 3차원의 개념으로 바뀐다면?3차원배열로 바꿔야하는데 그럼.. 로직을 아예 바꿔야함 블럭의 위치값2차원 배열에 들어가는데, 블럭에 X값 Y값이 들어가있나? 안들어가있음. 실제 객체는(Block) 모르고 있다. 블럭은 x, y값을 모르는데 자기 스스로 move나 판정을 할 수 있을까?row와 column값은(i와 j) Block의 지식일까? data의 지식일까? 현재는 data가 통제의 왕이기 때문에 data가 블럭의 판정통제권을 들고 있다.(i, j) 객체지향은 내 할일이 아니면 위임하는 것이다. 자기일이 아닌거는 계속 미룬다. 미룰사람이 누군지만 알고 있으면 된다. 말로만 객체지향이나 역할을 거의 수행할 수 없는 상태.현재 블럭은 x,y에 대한 역할을 수행할 수 없다. 1.3 통제권을 가진 제왕이 존재한다. (2) - 선택된 블럭의 지식1234567891011121314151617181920212223const selected = [], getBlock = (x, y) =&gt; &#123;...&#125;const down = (&#123;pageX: x, pageY: y&#125;) =&gt; &#123; if(isDown) return; const curr = getBlock(x,y); if(!curr) return; isDown = true; 👉 selected.length = 0; 👉 selected[0] = startBlock = currBlock = curr; render();&#125;;const move = (&#123; pageX: x, pageY: y &#125;) =&gt; &#123; if (!isDown) return; const curr = getBlock(x, y); if (!crr || curr.type !== startBlock.type || !isNext(curr)) return; 👉 if (selected.indexOf(curr) == -1) selected.push(curr); 👉 else if (selected[selected.length - 1] == curr) selected.pop(); currBlock = curr; render();&#125;;const up = () =&gt; (👉 selected.length &gt; 2 ? remove() : reset()); selected를 사방에서 직접 컨트롤하고 있다. 만약 선택의 조건이 현재 요건과 달라진다면?down, move, up 모두 바꿔야 한다. selected도 블럭이 선택되어있는지 아닌지에 대한 지식이기 때문에 Block의 지식이다. 선택된 그룹도 블럭이 알고 있는 것이고, 블럭이 블럭 인스턴스끼리 협력하는 코드는 블럭내의 지식이다. 블럭은 내 형제가 누군지에 대해서 블럭이라는 클래스 지식내에서 해결할 수 있다. 우리는 완전히 독립되어있는 어떤 데이터를 바라보고 있는 프로시저를 짜서 해결하려고 한다. 때문에 데이터 구조가 달라지면 다 바꿔야한다. 끊임없는 상태에 대한 변화의 책임을 블럭이 갖고 있어야한다. 가장 중요한 권한은 블럭의 type이 아니라끊임없는 상태에 대한 변화의 책임을 블럭이 갖고 있어야한다. 상태를 갖고 있으면 관리가 어렵기 때문에 해당 책임을 갖고 있는 객체가 알아서 하게끔 권한을 주는 것. 현재 코드에서 블럭의 상태는거의 상태가 없는 객체나 마찬가지이다. 2. 프로시저를 객체지향으로 바꿔보자. 2.1 모델 (feat. 유틸) 2.1.1 심플한 책임12345678const Block = class &#123; static GET(type = parseInt(Math.random() * 5))&#123; return new Block(type);&#125; constructor(type) &#123; this._type = type; &#125; get image()&#123; return `url(&#x27;img/block$&#123;this._type&#125;.png&#x27;`;&#125; get type()&#123; return this._type&#125;&#125; 👇👇👇 1234const UTIL = &#123; el: (v: string) =&gt; document.querySelector(v), prop: (...arg) =&gt; Object.assign(...arg)&#125; 123456789101112131415161718192021222324252627282930313233interface IItem &#123; pos: (x: number, y: number) =&gt; void; select: (item: Item) =&gt; void; unselect: () =&gt; void;&#125;const Item = class &#123; static GET(type: number, x: number, y: number)&#123; return new Item(type, x, y); &#125; constructor(_type: number, _x: number, _y: number) &#123; prop(this, &#123;_type, _x, _y, _selected: false, _prev: null&#125;) &#125; get type()&#123; return this._type; &#125; get x()&#123; return this._x; &#125; get y()&#123; return this._y; &#125; get selected()&#123; return this.selected; &#125; get prev()&#123; return this._prev; &#125; pos(x: number, y: number)&#123; // 어디로 움직일지 this._x = x; this._y = y; &#125; select(item: Item)&#123; // 어떤 아이템에 선택할지? this._selected = true; this._prev = item; &#125; unselect()&#123; this._selected = false; this._prev = null; &#125;&#125; 싱글 노드 링크드 리스트가 완성되었다. 이전에는 배열로(data) 관리했었는데, 이제는 링크드 리스트로 관리한다.나의 지식은 나와 이전(prev) 정도까지밖에 모르기 때문에 item 객체가 이 이상을 알게 되면, 권한 위반이 된다. **권한 책임을 축소하면 연산이 많이 일어난다. **(연산이 늘어난 부분은 걱정하지 말자.) 밖에는 캡슐화 된 메소드로 대화한다. 블럭 상태는 밖에서 관리하지 않고, 밖에서는 pos, select, unselect만 알게하자. 2.1.2 어려운 책임좀 더 어려운 책임을 바라보게 하자. 12345678910111213const Item = class &#123; ... isSelectedList(item: Item)&#123; if(!this._prev) return false; if(this._prev === item) return true; else return this._prev.isSelectedList(item) &#125; isBorder(item: Item) &#123; return (Math.abs(this.x - item.x) &lt; 2) &amp;&amp; (Math.abs(this.y - item.y) &lt; 2) &#125;&#125; 1. isSelectedListselectedList에 포함되어있냐 아니냐를 판단하는 메소드 모든 상황이 안되면, 바로 이전의 item에게 물어본다. 책임 권한을 _prev로 제약하여 메모리와 연산을 교환하였다. (링크드 리스트) 이 모든 건 자료구조의 일부이다. cf__2. 객체지향에서 책임의 범위와 자료구조 책임 범위를 축소하면 연산을 많이하게 된다.- 타클래스의 메서드를 호출할 경우도 있고, 본인의 연결되어있는 클래스를 호출하는 경우가 더 많다. 객체지향에서는 기본적으로 배열같은 어그리게이션(집합)을 쓰는 경우가 거의 없다.- 어그리게이션을 쓰면 어그리게이터에 대한 로직을 따로 짜야한다.- 코디네이터를 더 만들기 싫으면 본인 안에 링크드 리스트로 연결하는 수밖에 없다.- 컬렉터를 만드냐 안만드냐는 아키텍처상 중요한 요소이다.- 컬렉터를 추상화하는 것은 굉장히 어려운 것이다.- 통합된 자료구조를 안쓰게 되니까 다 연산으로 되어있는 자료구조를 쓰게 된다. 배열을 링크드 리스트로 치환한 것이다. 같은 자료구조임에도 불구하고, 연산으로 메모리로 치환하거나 메모리를 연산으로 치환할 수 있다. 연산을 메모리로 치환하면 속도가 빨라진다. 메모리를 연산으로 치환하면 좋은 점이하나는 메모리가 절감되는 경우가 생기고,권한을 축소할 수 있는 권한이 생긴다. (프로시저) 자바스크립트의 프로토타입체인은 대표적으로 연산을 통해서 메모리를 줄이는 시스템이다.연산을 통해서 프로토타입 체인에 가져오는 것이다.예전 메모리가 없던(넷스케이프)시절 개발된 자바스크립트. 하지만 현대의 크롬브라우저는 속도가 더 중요하기 때문에 모든 프로토타입 체이닝에 잇는 것을 다 copy해서 캐시테이블을 만들어서 거기서 읽는다. 더이상 프로토타입 체인 타고 가서 가져오지 않는다. 때문에 크롬에서 자바사크립트가 빠른 이유이다. 체인을 매번 타고 가는 연산은 귀찮기 때문에 알고리즘의 태반은 자료구조로 되어있고,자료구조의 태반은 다시 또 알고리즘으로 돌아가게 되어있다.항상 메모리와 연산은 교환할 수 있다. 2. isBorder나의 인접 셀을 파악하는 것도 나의 권한이다. 특정 아이템의 x,y가 나의 지식이기 때문에. 나의 x,y와 아이템의 x,y의 차이를 이용해서 나의 인접 셀인지 아닌지를 알 수 있다. cf__3. 권한 + 책임 &#x3D; 역할 우리가 책임을 부여하고 싶으면, 권한을 부여해야한다. 두개가 어긋나면 둘중 하나가 깨진다. 객체지향에서 권한은 은닉화 되어서 내부 상태로 숨고,책임은 표면화되서 외부 메소드를 드러나게 되어있다.메소드는 캡슐화해서 표현된다.ex_ATM기기 객체지향에서 메소드는 this라는 내부상태의 은닉되어있는 상태를 사용하고 있느냐,추상화가 되어있는, 캡슐화 되어있는 메소드냐가 충족되어야객체지향에서 메소드라고 부른다. 얼만큼 캡슐화되어야하는지는 대상에 따라 다르다. 어느 정도로 캡슐화되어있느냐는 공개 범위에 달려있다. 현재 Item의 기준은 게임이다. 게임이 이해할 수 있고, 몰라도 되는 기준으로 캡슐화 그게 내부 인터널에서 사용하는것? 자기들끼리 쓰는것? 부모자식간에 쓰는 것? 내가 만약 프로그램을 짜서 공개되는 코드도 마지막에 은닉과 캡슐화를 처리하는 단계는 항상 머리속에 짱구를 그려야한다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"코드스피츠80_OOP design with game (2)- 1. 개요","slug":"OOP_09_1","date":"2019-03-11T01:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/03/11/OOP_09_1/","permalink":"http://feel5ny.github.io/2019/03/11/OOP_09_1/","excerpt":"","text":"코드스피츠 강의 정리록 생소한 도메인으로 배우는게 좋다.익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.때문에 80기는 게임을 통해서 진행할 예정. 0. 프로시저 프로그래밍 저번시간의 프로시저 프로그래밍 복습 프로시저 프로그래밍의 특징 함수와 함수가 처리해야 할 데이터가 분리되어있고, 데이터와 함수가 같이 연동되어야 하지만 프로시저가 작동된다. . 프로시저 작동에서는 행위에만 집착하게 된다. (데이터 배열에 무엇을 채웠어 무엇을 비웠어) 데이터를 처리했다는 행위에 집중한다. . 함수형과는 다르게 프로시저들은 가리키고 있는 데이터가 있다. 프로시저는 상태를 지향하며, (유틸리티처럼) 특정 상태를 변화시키는 것에 관심을 둔다. (함수형은 인자로 받거나 지역변수만 사용하는 식으로 데이터를 처리하고 있다.) 프로시저 프로그래밍의 단점 데이터의 변화와 데이터를 처리하는 함수의 변화가 동시에 이루어지지 않는다. . 데이터를 조금만 바꾸던지, 처리를 바꾸면 데이터가 어긋나게 되고 프로그램 전체가 깨지게 된다. 데이터 항목 구성을 변화하거나데이터 자체에 추가적인 내용이나 연결되어있는 데이터를 만드는 일은 흔하다.&#x3D;&gt; 이런 상황이 생기면 기존의 프로시저가 깨진다. 우리는 프로시저 프로그래밍에 익숙해져 있다.ex_TDDTDD를 사용하면 무조건 프로시저로 짜게 된다.테스트 메소드 전체는 다 프로시져이다. 테스트 메소드가 알 수 없는 외부상태의 것을 테스트하는 함수 : 프로시저 : 객체를 바꾸면 테스트함수가 다 깨짐. 다 바꿔야함. 테스트 주도 개발을 하려면, 설계를 잘하면 할 수 있다. 프로시저로 만들면 어떤 일이 생긴냐면..ex_만약에 폭발형 아이템을 만든다면?&#x3D;&gt; 프로시저 전체를 다 수정하는 수밖에 없다.&#x3D;&gt; if를 넣어서 분기하면서 수정하는 수밖에 없다.(모든 함수에 다 들어간다.)&#x3D;&gt; if가 추가되는 것이 문제가 아니라 기존의 모든 레거시와의 관계를 재검토해서 들어가야하는데..복잡성을 감당할 수 없다. 복잡성이 폭발하면 ? &#x3D;&gt; 버려야합니다. 프로그래밍의 수명은 복잡성 컨트롤 제어에 실패하면더이상 유지보수할 수 없기 때문에나머지의 모든 프로그래밍 기법들은 복잡성이 더 복잡해지지 않게 하기 위해. 엔트로피 증가법칙 😎😎많은 사람들의 요건추가와 변화로 엔트로피가 꾸준히 증가한다.엔트로피를 증가시키는 것을 최대한 둔화시켜야한다.프로그래밍 세계에서 엔트로피가 언제 증가하는지 알아가는 것이 우리 스터디에서 배워야할 것.많은 장치로 엔트로피의 증가를 막을 수있다.아무리 막아도 내년되면 다시 짜야한다.잘못짠 프로그램은 엔트로피가 급격하게 증가해서 빨리 버리게 된다.잘짠 프로그램도 버려야한다. 엔트로피 증가방향을 컨트롤해서 완화시키고복잡한 환경이나 여러가지 변화상황을 잘 받아들일 수 있는 구조를 짜는것을디자인이라고 하고아키텍처라고 한다. 엔트로피 증가를 막으려고. 엔트로피 증가를 막자.객체지향에서는 어떻게 앤트로피 증가를 막느냐.역할이라는 것으로 분리해서 막는다. 가장 중요한 변화율변화율을 기준으로 역할을 분리해서 역할별로 객체들을 만들고 싶은데,그렇게 하기에는 우리가 해결해야 하는 문제가 너무 큰 덩어리로 되어있는 문제라는 것이다. 사람은 한꺼번에 복잡성 제어를 못 하기 때문에 복잡성 폭발한 프로그램은 버리게 된다.너무 복잡한 것은 분석할 수 없다.복잡한 문제는 나눠서 분석해야지만 분석할 수 있다. 복잡한 문제를 나눠서 분석하기 위한 도구를 추상화 도구라고 한다.(다른 글) 1. Categorizing분류를 통해서 계속 나눠가면상쇄 적인 부분만 하나씩 정복해나가면 전체를 이해할 수 있다는 개념 단점: 카테고리가 여러 곳에 소속되어있을 때 처리하기가 많다. 2. Modeling기억해야만 할 것을 정리하면 모델링이 된다. 없어야 할 데이터는 없어야 한다. 없어야 할 데이터가 있는 것도 오류다..현재의 모델링이 미래에 유용한 것도 아니고미래\b를 위해서 현재의 모델링을 함부로 확장하는 것도 아니다. 모델링의 단점: 유지보수가 힘들다. 현실 세계에서는 모델이 자주 바뀐다ex_학생. &#x3D;&gt; 학번, 이름, 데이터에 의존하고 있는 프로시저가 데이터의 변화를 따라갈 수 없기 때문에 \b프로시저 프로그램들이 에러가 나는 것이다. 현실 세계에서 모델링을 해야 하고모델링을 다루는 함수들을 강력하게 바인딩시키지 않으면모델의 변화가 프로시저에 충분히 반영되지 않거나프로시저의 변화가 모델에 반영되지 않아 둘이 어긋나서 프로그램이 깨지는 것. 3. Grouping우리가 필요해서 묶어주는 것 enum을 사용하면 단일집합을 사용할 수있다. class도 집합.클리스의 인스턴스를 만드는 것도 어떤 그룹인지 마킹을 해주는 의미도 있다.단지 그룹핑만을 위해서 마커를 사용할 경우에 클래스나 인터페이스를 마커 클래스나 마커 인터페이스라고 한다.ex_ 페이스북에 해시태그에 ‘맛집’도 집합 1. 레이어 분리 (Layering)(feat. 마틴 파울러의 앤터 프라이즈 디자인 패턴 책)레이어라는 방법을 사용한다.레이어는 일종에 카테고라이즈에 가깝다. 먼저 크게 분리한다.client ←→ serverpresentation ←→ doman ←→ data source domain: 도메인 로직 data source: 저장하는 로직 presentation: 도메인을 표현하는 로직 (앱, 웹,..) 1. 레이어는 계층적이다. 레이어들간에는 호환되지 않는다! 층을 정확하게 나눠야한다. 2. 기저레이어는 추상레이어를 모른다. **추상레이어** - 기저레이어를 사용하는 레이어 - 기저레이어에 대한 지식을 알고 있는 레이어 - OOP에 대입하면 **기저레이어: 부모클래스 추상레이어: 자식클래스** - 자식이 부모를 알고 있다. 부모는 자식을 모른다. 3. 레이어안에 다수의 역할이 소속된다. 레이어안에는 다수의 역할이나 다수의 역할을 수행하는 인스턴스들이 소속된다. 레이어안에는 레이어의 전체적인 레이어 가이드들을 지키고 있는 수많은 레이어들이 존제한다. 인메모리에서 레이어를 나누어보자.레이어를 나누는 눈이 필요하다. (함수형) 유틸리티 함수와 메소드의 차이는 this를 쓰냐안쓰냐. OOP에는 기저 인터페이스나 기저 클래스도 유틸리티로 분류하기도 한다. 베이스 클래스 구상 클래스 호스트코드 게임의 실체는 어디일까?실체는 호스트 코드. 구상 클래스, 베이스 클래스에 로직이 있고, 호스트코드는 사용하는 입장이다. 진짜로 일하는 애는 호스트코드 호스트코드부터 짜는 것이 좋다. 반대로 짜게 되면 사용하지 않을 것들도 만들게 됨. 수업 시간에는 아키텍처를 공부하기 위해 반대로 짜볼 것이다. 0. 유틸리티함수 호출 하는 방식으로 다른 레이어와 소통한다. 모든 레이어와 소통. 1. 베이스 클래스베이스 클래스와 구상 클래스의 관계는 상속되거나 소유된다. 1.1 기반이 되는 3가지 클래스 모델 모델링 한 것, 게임 자체를 모델링한 데이터가 존재함. (entity) 뷰 모델을 그림 그릴 수 있는 로직 컨트롤러 뷰와 대화하거나 해당 모델을 처리할 수 있는 로직이 한꺼번에 들어있음 컨트롤러가 여러 개의 모델을 소유하게 될 것이다. 뷰가 인터렉션을 할 때 컨트롤러에게 위임하는데컨트롤러에게 뷰의 책임을 위임하지 않을 것이다.뷰가 컨트롤러에 그냥 위임하게 되면 컨트롤러에 뷰의 사정이 들어가게 된다.(네이티브 분리가 안 된다. ex_ dom을 컨트롤하는 로직 등등..) mvc패턴을 날로쓰면 컨트롤러가 반드시 특정 뷰와 강력한 바인딩이 되어서 뷰를 교체할 수 없다. 강력한 바인딩을 해제하기 위해서는컨트롤러에게는 순수한 데이터 관련된 요청만 시켜야하고나머지 인터렉션은 뷰가 가져갸아한다. mvp나, mvvm을 쓰면된다. view에서는 인터렉션 1차 처리를 한다. event listener같은 로직을 넣고, 컨트롤러에는 순수한 데이터만 보낼 것 1.2 뷰와 컨트롤러 사이의 버퍼 &#x3D; 메세지 뷰가 컨트롤러와 직접 대화하게 되면 뷰의 네이티브 지식을 알아야한다.이것을 방지하기 위해 버퍼를 하나 둔다. (메세지) 컨트롤러는 메세지만 바라보고 있고,뷰도 메세지만 바라보면서메세지로만 통신한다. why? 네이티브 요소를 완전히 제거해서컨트롤러도 인메모리 객체를,뷰도 인메모리 객체를 바라보게 하기 위해서 중간에 메세지라는 매개체를 둔다. 메세지는 중립적인 역할 메세지는 중립적인 역할이자, 인메모리 객체이다.네이티브 지식이 전혀 없다. 컨트롤러는 이 메세지를 받아들여서 모델과 매핑을 시켜야하고,뷰는 메세지를 받아들여서 네이트브 객체와 매핑을 시켜야한다. 1.3 서브 뷰뷰도 혼자서 전부 처리하기에 힘들기때문에서브뷰를 만들어서 그림그리는 체계를 나눠준다. 최종적으로 만들 것은 구상서브뷰와 구상모델을 만들게 된다. 서브뷰의 구상서브뷰와 뷰의 구상뷰를 만들 것이다. 구상서브뷰는 div가 될 것이고 구상뷰는 section뷰가 될 것이다. 모델은 아직 서브 모델이 필요없다.( 블럭의 다른 종류를 만들지 않음._ 추후 폭탄만들때는 필요 )\u001d 베이스 클래스 까지는 인메모리 객체이다.네이티브 지식이 하나도 나오지 않는다. 구상 클래스만 네이티브 지식을 갖게 된다. 네이티브 지식은 횡으로도 분리하지만 종으로도 분리하게 되는데 이를 레이어링이라고 했다. 우리가 레이어링을 한 이유는 베이스 클래스에는 순수한 인메모리 객체만 두고, 구상클래스에 네이티브 지식을 두게 하기 위함이다. 2. 구상클래스 호스트 클래스는 구상클래스를 인스턴스화 하여 사용한다. 구상모델 구상컨트롤러- Game\u001c이 바로 컨트롤러 역할을 수행하고 있음- 게임에 있는 하나하나의 블럭이 모델.- 게임이라는 컨트롤러 하나만 있으면 되기 때문에 굳이 없어도됨. 구상뷰 3. 호스트코드 구상컨트롤러 생성 및 초기화","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"코드스피츠80_OOP design with game (1)- 2. OOAD & 프로시저 P","slug":"OOP_08_2","date":"2019-02-23T01:20:19.000Z","updated":"2024-11-23T12:10:17.001Z","comments":true,"path":"2019/02/23/OOP_08_2/","permalink":"http://feel5ny.github.io/2019/02/23/OOP_08_2/","excerpt":"","text":"코드스피츠 강의 정리록 생소한 도메인으로 배우는게 좋다.익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.때문에 80기는 게임을 통해서 진행할 예정. 객체지향 프로그래밍을 배우기 전,프로시저 프로그래밍 형태의 코드를 알아본다. 2. 게임 개요 및 규칙 2.1 앤티티 파악아키텍트나 디자인패턴을 만드는 설계자들은현상을 보고, 현상으로부터 프로그램 엔티티를 도출해서 설계를 들어간다. 블럭에는 타입이 있구나. 블럭 connect의 최저 갯수 제한이 있겠구나. 스테이지의 가로 세로 갯수 선택했던 블럭들을 돌아갈 수 있다. 새로운 블록이 떨어진다. 인지과학 가상세계임에도 불구하고 물리력가 중력을 기대한다 ㅋ 2.2 규칙 Entity 블럭타입: 5가지 (0,1,2,3,4) cell size: 8*8 Core Action 한번에 3개 이상 같은 색으로 인접한 블록이 선택되면 삭제됨 삭제되면 위의 블록이 내려옴. 내려온 뒤 공간의 블록이 생성되어 채워짐 cf__1 게임이야기 ~모바일시대에서는 복잡한 core action이 많이 들어간 게임은 상품성이 없다. (안좋은 예: 와우)core action이 단순한 게임이 상품성이 좋다. 최근 rpg게임들은 단순하게 변했다. 한붓그리기도 이미 오래전에 누가 찾아낸 코어액션중에 하나이다. 재밌는 반복거리를 찾아내면 벗어나려고 하지 않는다. 3. 어디서부터 시작할까?프로그램의 핵심은 데이터사람은 표면적인 것만 파악하려고 한다. 표면적인 것\u001e과 시각적인 것 경험에 의존에 의해서 파악하기 때문에 경험한 것만 보인다. 프로그램의 핵심은 데이터이다. 거의 대부분의 프로그램들은 다 예쁜 데이터 view. 개발자의 눈으로 보면 프로그램의 핵심은 데이터이다. entity의 종류를 미리 파악하자. 👀12345678column = 8;row = 8;blockTypes = [0, 1, 2, 3, 4];Block = class &#123; constructor()&#123;&#125;; isNext()&#123;&#125;; isValid()&#123;&#125;;&#125; 현실세계 entity에는 이 3가지 이외에는 발견하기 힘들다. 스칼라 값 설정에 따라 자유롭게 크기를 변경할 수 있음. 단일 값 가변적 (한번에 하나의 값만 보유할 수 있는 원자량 from wiki) 정의값 미리 정해진 타입이 존재한다. bolckTypes는 콜렉션 개념이 아니다.집합을 정의한 개념이다. 하나의 값인것처럼. 객체값 생성되거나 삭제되고, 연결되거나 조건을 파악한다. 블록을 객체로 보는 이유는 블록이 자신만의 책임을 위임할 수 있기 때문이다. 다음번에 올 수 있는 블록이니? 올바른 위치인 상태이니? 자신의 상태를 은닉\u001c하고 캡슐화 블록에는 자신만의 책임을 가질 수 있기 때문에 객체로 평가하게 된다. UML을 깊이 공부하면 5가지 종류의 여러가지 entity과 관계가 나온다. cf__2. 클래스이냐? 싱글톤 객체이냐?를 항상 고민한다. 싱글톤 객체 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴. 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다. 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이다. 객체는 하나만 있거나 여러개 있다.하나만 있는 것인지 여러개 있는 것인지 파악해야한다. 하나만 있는데 클래스로 정의하거나여러개 있는 것인데 객체로 만들면 반드시 고우투헬.. 여러개 있는 것을 개별적으로 만들면,여러개 있는 애들은 보통 변화를 한꺼번에 일으켜야하는데개별적으로 만\b들었기 때문에 한꺼번에 수정할 수 없게 된다. 하나만 있어야 하는데 클래스로 만들면인스턴스가 여러개 생길 수 있다. 3.1 [객체] Block 클래스? 혹은 싱글톤 객체? 블록은 여러개 생성되므로 클래스 책임 12345678const Block = class &#123; constructor(type)&#123; this._type = type; &#125; get image()&#123;return `url(&#x27;img/$&#123;this._type&#125;.png&#x27;)`;&#125; get type()&#123;return this._type;&#125;&#125;Block.GET = (type = parseInt(Math.random()*5)) =&gt; new Block(type); 자신만의 타입을 갖는다. parseInt(Math.random()*5): 0 ~ 4 사이의 타입을 얻게됨 인자에 초기화 코드를 명시해주면선언과 코드의 내용을 분리할 수 있어서 가독성이 좋아진다. 타입에 따른 이미지 경로를 반환한다. (타입에 따른 블록 이미지가 다르니까.. ) 왜 factory 함수로? (Block.GET) Block 클래스는 받아온 type을 자기 타입으로 기억하는데만 관심 있다. 타입을 전달하지 않았을 때 어떻게 만드는지는엄밀하게 따지면 블럭의 지식은 아니다. 블럭을 만드는 쪽이 관심 있다. 만드는 쪽이 관심있는 것과만들어 지는 쪽이 관심있는 것이 다르다. 랜덤함수는 팩토리 함수가 가져야할 지식이다. 팩토리 함수는 클래스 내부로 가면 안된다. 변화율때문에! 타입은 stage마다 바뀔꺼고, 아이템 추가되면 더 바뀔 것이다. 타입은 변화율이 높은 개념이므로 클래스와 분리하여 명확한 의도를 작성하게 한다. 변화율을 평가하는 가장 쉬운 방법 변화율을 잘 디자인 했으면 책임이 없다고 생각됬던 객체는 수정되지 않아야한다. 우리의 목표는 보다 더 많은 파일을 안건드리고 일부파일만 건드려야한다. cf__3. Factory 함수객체지향\b할 때 클래스를 사용하는 경우 생성자를 봉인하자.factory함수로 클래스를 얻어가게 하자. static 키워드 써서 불러오게 해도됨. factory 함수의 명칭은 일관되게 모든 클래스에 생성자를 대신하는 스태틱 함수를 만들자.(예제에서는 GET) 팩토리 함수 : 객체를 반환하는 함수 cf__4. 단일 책임원칙 훈련하기단일 책임원칙은 엄밀하게 지키려면 굉장히 어렵고,섬세하게 바라보는 눈으로언제나 의심해서 관리하지 않으면 실력..키워지지 않는다.(빠르면 3년 늦으면 5년..ㅎ) 3.2 [객체] Game게임이라는 객체는 블록들을 소유하는 마스터 객체 클래스이냐? 싱글톤 객체이냐? 게임은 하나의 객체만 있으면 된다. (바둑판 하나.) 구지 클래스로 선언하지 않고, 싱글톤 객체로 만든다. &#x3D;&gt; 싱글톤 객체 책임 2번과 3번은 내부에서만 알면된다. 초기화필요한 정보를 바탕으로 게임 본체를 생성 렌더링그림 갱신 이벤트 걸기각 블록에서 이벤트를 처리 외부에서 게임의 어떤 상태만 알면 될까? 게임 초기화함수만 하나 노출하면 됨 123456// 게임은 초기화된 게임이 바로 생성되어야 하므로, 즉시실행함수로.const Game = (_ =&gt; &#123; const init = ... ... return init;&#125;)() 4. Game 시나리오 테이블 형태 정의 테이블 생성 테이블 내에 블록 데이터 채우기 (data)2차원배열을 만들어야하기때문에row와 column을 돌면서 생성한다. 렌더링 data는 inMemory 객체 render를 따로 호출하는 것은 네이티브 객체이기때문에(dom의 세상..) 렌더링 전 table에 이벤트 걸기. 1. + 2. + 3. [객체, 스칼라값, 정의값] 테이블 데이터 정의 테이블 형태 정의 테이블 생성 테이블 내에 블록 데이터 채우기 (data) 1234567891011121314151617const Game = (_ =&gt; &#123; const column = 8, row = 8, blockSize = 80; const data = []; let table; const init = tid =&gt; &#123; table = document.querySelector(tid); for (let i = 0; i &lt; row; i++)&#123; const r = []; data.push(r); for(let j = 0; j &lt; column; j++) r[j] = Block.GET(); &#125; render(); &#125;; const render = _ =&gt; &#123;...&#125;&#125;) 4. 렌더링데이터를 소비해서표를 다시 그려주는 로직. 1234567891011121314151617181920212223242526const Game = (_ =&gt; &#123; const column = 8, row = 8, blockSize = 80; const data = []; let table; const init = tid =&gt; &#123; ... render(); &#125;; /// 👇👇👇 const el = tag =&gt; document.createElement(tag); const render = _ =&gt; &#123; table.innerHTML = &#x27;&#x27;; data.forEach(row =&gt; table.appendChild( row.reduce((tr, block) =&gt; &#123; tr.appendChild(el(&#x27;td&#x27;)).style.cssText = ` $&#123;block? `background: $&#123;block.image&#125;;` : &#x27;&#x27;&#125; width: $&#123;blockSize&#125;px; height: $&#123;blockSize&#125;px cursor: pointer`; return tr; &#125;, el(&#x27;tr&#x27;)) )); &#125;; 👆👆👆&#125;) 배열을 루프돌아서각각의 줄을 td를 갖는 tr로 바꿔서table에 넣고 싶음. td를 갖는 tr로 각각의 줄을 (td를 갖는) tr로 바꿔서 cf__5. 배열의 고차함수배열의 고차함수를 쓰는 원리는 간단하다.- 루프돌고 싶으면 forEach- 배열의 원소를 바꾼 배열을 얻고 싶으면 map- 하나의 값으로 뭉치고 싶으면 reduce &gt; 여러개의 집합을 하나의 스칼라값으로 바꾸는 것 5. table에 이벤트 걸기.1234567891011121314151617181920212223const Game = (_ =&gt; &#123; const column = 8, row = 8, blockSize = 80; const data = []; let table; const init = tid =&gt; &#123; table = document.querySelector(tid); for (let i = 0; i &lt; row; i++)&#123; const r = []; data.push(r); for(let j = 0; j &lt; column; j++) r[j] = Block.GET(); &#125; 👇👇👇 table.addEventListener(&#x27;mousedown&#x27;, down); table.addEventListener(&#x27;mouseup&#x27;, up); table.addEventListener(&#x27;mouseleave&#x27;, up); table.addEventListener(&#x27;mousemove&#x27;, move); 👆👆👆 render(); &#125;; const el = tag =&gt; document.createElement(tag); const render = _ =&gt; &#123;...&#125;&#125;) mousedown 마우스를 누르는 그 순간. (click과 다르게 press하는 순간) mouseup 손가락을 떼는 그 순간. mouseleave 바인딩된 요소에만 이벤트가 발생하며, 해당 엘리먼트의 영역에서 마우스가 벗어날 때 발생한다. mousemove 마우스가 엘리먼트에서 움직일 때 5.1 이벤트 &gt; 블럭을 누르는 순간: down move는 mousedown인 상태여야 의미가 있다. down의 상태값 필요 현재 눌러진 블록의 위치값 알아야함. event로부터 x,y값 전\b체좌표를 받아와서 x, y좌표를 이용해서 테이블 내에서 몇번째 블록인지, 데이터로 치환하게 된다. 현재 눌러진 블록이 첫 시작? 아니면 중간? 1. 시작 블록 - 지금 선택이 시작되는 블록 - 라이언타입이면 계속 라이언 타입 - 시작값은 왜 알아야하지? - 돌아가기도 해야함. 2. 현재 블록 - move할때마다 변함 (cursor와 같은) 12345const down = e =&gt; &#123; // down된 상태를 활성 // x, y로부터 block 데이터를 얻음 // 위에서 얻은 블록을 시작블록 및 현재 블록으로 설정하고 선택목록에 포함시킴.&#125; down의 상태값 down이 아닐때만 down. 어떤 블록이 선택되어있는지. x,y값을 넣으면 몇번째인지 알아낼 수 있는 함수 1234567891011121314151617const column = 8, row = 8, blockSize = 80;const data = [];let table;👇👇👇let startBlock, currBlock, isDown;const selected = [], getBlock = (x, y) =&gt; &#123;...&#125;const down = (&#123;pageX: x, pageY: y&#125;) =&gt; &#123; if(isDown) return; const curr = getBlock(x,y); if(!curr) return; isDown = true; selected.length = 0; selected[0] = startBlock = currBlock = curr; render();&#125;👆👆👆 getBlock이외의 밑에나오는 로직은 전부 인메모리 로직.네이티브 레이어를 다루는 방법은 즉시 인메모리 객체로 변환한다. cf__6. 네이티브 객체를 다룰때 가장 중요한 요령 네이티브 레이어를 최대한 줄이는 것. 네이티브의 정보 중에 필요한 핵심정보만 이용해서 즉시 인메모리 객체로 바꿈. 네이티브의 코드가 많이 퍼져있으면 퍼져있을수록더욱더 다루기 어렵고더욱더 컨버팅하기 어렵게 된다. 네이티브 코드중에 필요한 부분만 추출해서 &#x3D;&gt; 즉시 인메모리 객체로 바꾸고 나머지 로직은 인메모리에서 수용하도록 함. 좋은 개발자말하면 코드로 옮기는 것이 리얼타임이 될때까지.. 훈련하자.좋은 개발자는 제어문을 잘쓰거나, 코드를 한국어로 번역하거나 한국어를 코드로 번역하는 능력에 달려있다.숙련을 많이 해서 실시간으로. 5.cf 네이티브 코드 &#x3D;&gt; 인메모리 객체로 변환123456789// 네이티브 객체의 값을 =&gt; 인메모리 객체로 변환해주는 변환기 !// 많이 나옴.const getBlock = (x: number, y: number): Block =&gt; &#123; const &#123; top: T, left: L &#125; = table.getBoundingClientRect(); if (x &lt; L || x &gt; L + blockSize * row || y &lt; T || y &gt; T + blockSize * column) return null; // 바둑판 범위를 넘는 경우 제외(왼쪽넘어, 오른쪽넘어, 위쪽넘어, 아래쪽 넘어) return data[parseInt(y - T) / blockSize][parseInt(x - L) / blockSize];&#125;; getBoundingClientRectElement.getBoundingClientRect() 메서드는요소의 크기와 요소의 viewport에서의 상대적인 위치를 반환합니다.12345678910DOMRect &#123; x: 0, y: 0, width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0&#125; 5.2 이벤트 &gt; 블럭을 떼는 순간: up코어액션이 여기서 다 일어난다. down을 해제 선택목록이 3이상이면 삭제 실시 2이하면 리셋 12345const up = e =&gt; &#123; // down을 해제 // 선택목록이 3이상이면 삭제 실시 // 2이하면 리셋&#125; 5.2.0 reset선택항목이 2이하면 모두 초기화시킨다.12345678const up = _ =&gt; selected.length &gt; 2 ? remove() : reset();const reset = _ =&gt; &#123; startBlock = currBlock = null; selected.length = 0; isDown = false; render();&#125;cf__7. 쉬운것부터 짜자!쉬운 것은 의존성이 없다. 고칠 일이 적다.복잡한 것부터 짜면 의존성이 많은 것부터 짜게 되고,나중에 깨달은게 많을수록 더 많이 고치게 된다. 선택된 블록들을 지워주고 &#x3D;&gt; remove 떨어뜨린 다음에 &#x3D;&gt; drop 새로 생성하고 &#x3D;&gt; readyToFill 다시 내려와주면서, 합쳐줘야함. &#x3D;&gt; fill 5.2.1 remove 😫😫12345678910111213const remove = () =&gt; &#123; /* 데이터 내부의 row를 돌면서 해당 row에 선택된 요소가 존재하면 null로 만드는 함수. */ data.forEach(r =&gt; &#123; selected.forEach(v =&gt; &#123; let i; if ((i = r.indexOf(v)) !== -1) r[i] = null; &#125;); &#125;); render(); setTimeout(drop, 300);&#125;; forEach는 for문보다 대화가됨. column을 돌면서 row를 계산해서 떨어뜨리는 일을 한다.한턴에는 한칸씩 떨어진다.중력에 의해 떨어지는 방향은column기준이기때문에 column을 먼저 loop돌린다.row는 맨 아랫줄부터 떨어지는 작업을 해야하므로.. (전체row -1) 부터 시작 isNext: 윗줄에도 block이 있는 상황이라 다음 row도 검사해야하는지. isEmpty: 떨어질 블럭이 하나의 column row들에 있는지 없는지. 123456789101112131415161718192021222324252627282930const drop = _ =&gt; &#123; let isNext = false; // drop을 더 해야하는지 말아야하는지. for (let j = 0; j &lt; column; j++) &#123; for (let i = row - 1; i &gt; -1; i--) &#123; if (!data[i][j] &amp;&amp; i) &#123; // 해당 구멍에 블럭이 없고, row의 인덱스가 0이 아닌(꼭대기가 아닌) let k = i, // 해당 줄의 index를 복사한다. isEmpty = true; // data[i][j] 위에 떨어질 블럭이 비었는지 아닌지. while (k--) // index를 하나씩 확인하면서 if (data[k][j]) &#123; // 위에 블럭이 있으면 isEmpty = false; // 위에 떨어질 블럭이 하나라도 있다는 뜻 break; // 반복분을 끝낸다. &#125; if (isEmpty) break; // 위에 떨어질 블럭이 하나도 없으면 row loop 종료 다음 column loop 시작 // 위에 블럭이 하나라도 있는 상황이고, // 다음 row도 검새햐아함을 flag isNext = true; // 떨어뜨리기. while (i--) &#123; // 해당 줄 위에 data[i + 1][j] = data[i][j]; // 현재 검사한 블럭에 위의 블럭을 넣어주고, data[i][j] = null; // 위의 블럭은 null로 초기화 &#125; break; // row loop를 종료 다음 column loop 시작 &#125; &#125; &#125; render(); isNext ? setTmeout(drop, 300) : readyToFill();&#125;; ㅋㅋㅋ ㅠㅠ 대댜냐댜..머리가 좋아지는수밖에 없다.잘짜고, 쉽게 짤때까지 머리로 훈련하는 수밖에 없다.알고리즘, 코딩인터뷰, 자료구조, 트리구조 보다 도메인 해석 능력을 키우자.어떠한 도메인에 \b대해서 알고리즘을 짜는 능력은 훈련밖에 없다.복잡한 일이 일어나는 것을 눈으로 관찰해서 어떤 일인지 파악한 다음에코드로 차근차근 푸는건 훈련밖에 없다.이거 안되면 아키텍처고 디자인패턴이고 필요없다.. 채울준비를 하는 것은 밖에부터 채워야하는 애들이 예쁘게 내려오게 하기 위해서. 지워진 모양 그대로의 형태가 위에 형성되고 &#x3D;&gt; readyToFill 해당 형태가 떨어지는 상황 &#x3D;&gt; fill 1234567891011121314151617181920212223242526272829303132333435363738394041const fills = [];// fill 배열 초기화// column은 똑같고, row만 계산해서 생성하면 됨.// 실제 fills의 길이와 채워진 카운팅이 같게되면 다 채워졌다고 볼 예정 let fillCnt = 0;const readyToFill = _ =&gt; &#123; fills.length = 0; // data를 돌면서 구멍난 부분을 찾는다. data.some(row =&gt; &#123; if (row.indexOf(null) === -1) return ture; // 구멍없는 row면 끝냄. const r = [...row].fill(null); // 새로운 row를 만들어서 우선 null로 채움 fills.push(r); row.forEach((v, i) =&gt; !v &amp;&amp; (r[i] = Block.GET())); // v가 없으면 해당 구멍에 block으로 채움 &#125;); fillCnt = 0; // ? setTimeout(fill, 300);&#125;;const fill = _ =&gt; &#123; if (fillCnt &gt; fills.length) &#123; // fillCnt가 증가하다가 fills의 length와 일치하면 그만둘 때 isDown = false; return; &#125; for (let i = 0; i &lt; fillCnt; i++) &#123; // 채워야하는 fill 배열의 row에서 해당 요소가 null이 아니라 채워져있으면(v), // data의 해당 요소에 v를 넣는다. // fills에 있는 마지막줄부터 윗줄을 채워가면 된다.. fills[fills.length - i - 1].forEach((v, j) =&gt; &#123; if (v) data[fillCnt - i - 1][j] = v; &#125;); &#125; fillCnt++; render(); setTimeout(fill, 300);&#125;; 5.3 이벤트 &gt; 블럭을 down하면서 움직이는 상태: move누른상태에서 다음(혹은 이전) 블럭으로 움직이는 상태 1234567const move = e =&gt; &#123; // down이 아니라면 이탈 // x,y 위치의 블록을 얻음 // 위에서 얻은 블록이 이전 블록의 타입이 같고 인접되어있는지 검사 // 위에서 얻은 블록이 선택목록에 없으면 추가 // 위에서 얻은 블록이 선택목록에 있다면 전전 블록일 경우 하나 삭제&#125; 123456789const move = (&#123; pageX: x, pageY: y &#125;) =&gt; &#123; if (!isDown) return; const curr = getBlock(x, y); if (!crr || curr.type !== startBlock.type || !isNext(curr)) return; if (selected.indexOf(curr) == -1) selected.push(curr); else if (selected[selected.length - 1] == curr) selected.pop(); currBlock = curr; render();&#125;; 12345678910111213141516171819202122232425// 받아오는 curr 블럭과 cache해놓은 curr 블럭을 비교하여 인접해있는지 검사.// 나와 위치가 한개 차이 난다는 것. x로 하나 차이 혹은 y로 하나 차이const isNext = curr =&gt; &#123; let r0, c0, r1, c1, cnt = 0; /* data에서 들어온 curr의 x인덱스, y인덱스와 currBlock의 x인덱스와 y인덱스를 구하는 방법. */ data.some((row, i) =&gt; &#123; let j; if ((j = row.indexOf(currBlock)) !== -1) (r0 = i), (c0 = j), cnt++; if ((j = row.indexOf(curr)) !== -1) (r1 = i), (c1 = j), cnt++; return cnt === 2; &#125;); return ( curr !== currBlock &amp;&amp; (Math.abs(r0 - r1) === 1 || Math.abs(c0 - c1) === 1) );&#125;; 자바스크립트에서 배열의 고차함수로 여러 제어문을 제거할 수 있다. 최종 코드 및 정리프로시저 함수: 반환값이 없는 함수sideEffect가 엄청 많다.현재 로직들은 모두 프로시저 함수.앞으로 객체지향으로 리팩토링 예정. 최종코드 (TS ver.) 123456789101112131415161718192021222324252627282930313233343536// Game에서 사용한 interfaceinterface IGame &#123; // 게임판 정보 column: number; row: number; blockSize: number; data: (Block | null)[][]; // 네이티브 객체 정보 table: HTMLElement; // 상태 정보 startBlock: Block; currBlock: Block; isDown: boolean; selected: Block[]; isNext: (curr: Block) =&gt; boolean; getBlock: (x: number, y: number) =&gt; Block; // 이벤트 관련 down: (&#123; pageX: x, pageY: y &#125;: &#123; pageX: number; pageY: number &#125;) =&gt; void; move: (&#123; pageX: x, pageY: y &#125;: &#123; pageX: number; pageY: number &#125;) =&gt; void; up: () =&gt; void; reset: () =&gt; void; remove: () =&gt; void; drop: () =&gt; void; fills: (Block | null)[][]; fillCnt: number; readyToFill: () =&gt; void; fill: () =&gt; void; // util el: (tag: HTMLElementTagNameMap) =&gt; HTMLElement; render: () =&gt; void;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180// 도저히 머리가 따라가기 힘들어서 TS로 우선 변환..const Game = (() =&gt; &#123; class Block &#123; static GET(type = Math.random() * 5) &#123; return new Block(type); &#125; _type: number; constructor(type) &#123; this._type = type; &#125; get image() &#123; return `url(&#x27;img/block$&#123;this._type&#125;.png&#x27;)`; &#125; get type() &#123; return this._type; &#125; &#125; const column = 8, row = 8, blockSize = 80; const data: (Block | null)[][] = []; let table: HTMLElement; let startBlock: Block, currBlock: Block, isDown: boolean; const selected: Block[] = []; const getBlock = (x: number, y: number): Block =&gt; &#123; const &#123; top: T, left: L &#125; = table.getBoundingClientRect(); if (x &lt; L || x &gt; L + blockSize * row || y &lt; T || y &gt; T + blockSize * column) return null; return data[(y - T) / blockSize][(x - L) / blockSize]; &#125;; const isNext = (curr: Block): boolean =&gt; &#123; let r0: number, c0: number, r1: number, c1: number, cnt = 0; data.some((row: (Block | null)[], i: number) =&gt; &#123; let j: number; if ((j = row.indexOf(currBlock)) != -1) (r0 = i), (c0 = j), cnt++; if ((j = row.indexOf(curr)) != -1) (r1 = i), (c1 = j), cnt++; return cnt == 2; &#125;); return ( (curr != currBlock &amp;&amp; Math.abs(r0 - r1) == 1) || Math.abs(c0 - c1) == 1 ); &#125;; const reset = () =&gt; &#123; startBlock = currBlock = null; selected.length = 0; isDown = false; render(); &#125;; const remove = () =&gt; &#123; data.forEach((r: (Block | null)[]) =&gt; &#123; //데이터삭제 selected.forEach((v: Block) =&gt; &#123; let i: number; if ((i = r.indexOf(v)) != -1) r[i] = null; &#125;); &#125;); render(); setTimeout(drop, 300); &#125;; const drop = () =&gt; &#123; let isNext = false; for (let j = 0; j &lt; column; j++) &#123; for (let i = row - 1; i &gt; -1; i--) &#123; if (!data[i][j] &amp;&amp; i) &#123; let k = i, isEmpty = true; while (k--) if (data[k][j]) &#123; isEmpty = false; break; &#125; if (isEmpty) break; isNext = true; while (i--) &#123; data[i + 1][j] = data[i][j]; data[i][j] = null; &#125; break; &#125; &#125; &#125; render(); isNext ? setTimeout(drop, 300) : readyToFill(); &#125;; const fills: (Block | null)[][] = []; let fillCnt = 0; const readyToFill = () =&gt; &#123; fills.length = 0; data.some((row: (Block | null)[]) =&gt; &#123; if (row.indexOf(null) == -1) return true; const r: (Block | null)[] = [...row].fill(null); fills.push(r); row.forEach((v: Block | null, i) =&gt; !v &amp;&amp; (r[i] = Block.GET())); &#125;); fillCnt = 0; setTimeout(fill, 300); &#125;; const fill = () =&gt; &#123; if (fillCnt &gt; fills.length) &#123; isDown = false; return; &#125; for (let i = 0; i &lt; fillCnt; i++) &#123; fills[fills.length - i - 1].forEach((v, j) =&gt; &#123; if (v) data[fillCnt - i - 1][j] = v; &#125;); &#125; fillCnt++; render(); setTimeout(fill, 300); &#125;; const down = (&#123; pageX: x, pageY: y &#125;: &#123; pageX: number; pageY: number &#125;) =&gt; &#123; if (isDown) return; const curr = getBlock(x, y); if (!curr) return; isDown = true; selected.length = 0; selected[0] = startBlock = currBlock = curr; render(); &#125;; const move = (&#123; pageX: x, pageY: y &#125;) =&gt; &#123; if (!isDown) return; const curr = getBlock(x, y); if (!curr || curr.type != startBlock.type || !isNext(curr)) return; if (selected.indexOf(curr) == -1) selected.push(curr); else if (selected[selected.length - 2] == curr) selected.pop(); currBlock = curr; render(); &#125;; const up = () =&gt; (selected.length &gt; 2 ? remove() : reset()); const el = (tag: keyof HTMLElementTagNameMap) =&gt; document.createElement(tag); const render = () =&gt; &#123; table.innerHTML = &quot;&quot;; data.forEach(row =&gt; table.appendChild( row.reduce((tr, block) =&gt; &#123; tr.appendChild(el(&quot;td&quot;)).style.cssText = ` $&#123;block ? `background:$&#123;block.image&#125;;` : &quot;&quot;&#125; width:$&#123;blockSize&#125;px; height:$&#123;blockSize&#125;px; cursor:pointer`; return tr; &#125;, el(&quot;tr&quot;)) ) ); &#125;; return (tid: string) =&gt; &#123; table = document.querySelector(tid); for (let i = 0; i &lt; row; i++) &#123; const r = []; data.push(r); for (let j = 0; j &lt; column; j++) r[j] = Block.GET(); &#125; table.addEventListener(&quot;mousedown&quot;, down); table.addEventListener(&quot;mouseup&quot;, up); table.addEventListener(&quot;mouseleave&quot;, up); table.addEventListener(&quot;mousemove&quot;, move); render(); &#125;;&#125;)();Game(&quot;#stage&quot;);","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"코드스피츠80_OOP design with game (1)- 1. 객체지향과 값지향","slug":"OOP_08_1","date":"2019-02-17T01:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/02/17/OOP_08_1/","permalink":"http://feel5ny.github.io/2019/02/17/OOP_08_1/","excerpt":"","text":"코드스피츠 강의 정리록 생소한 도메인으로 배우는게 좋다.익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.때문에 80기는 게임을 통해서 진행할 예정. 1. 객체지향 준비운동객체지향 ←→ 값지향객체지향의 반대말은 값지향이다.객체지향과 값지향을 비교해보면서 기본개념을 잡고 넘어가자. 1.1 객체지향 1) 참조값을 사용함.객체지향에서는함수의 인자를 보내던,변수에 대입을 하던,연산을 하던참조를 사용한다. cf__1 언어마다 어떠한 타입에 대해서 값으로 처리, 참조로 처리할지 결정한다.그렇다고 오브젝트는 값이 아닐 것이다 라고 생각하면 안된돠.오브젝트도 값으로 생각하는 언어들이 있다. 자바스크립트에서는 스트링을 값으로 보고 있다. 자바에서는 스트링을 객체로 보고 있다. 언어마다 어떠한 타입에 대해서 직접적으로 값으로 처리할지참조로 처리할지 결정하는 것이다. 원래 값이고 원래 참조다 라는 개념은 없다. * 한번 만든 객체가 전파됨.참조는 순식간에 전파된다.객체 컨텍스트에서는 참조를 쓴다고 했다.참조가 되면 원본은 힙메모리에 만들어지고모든 객체는 힙메모리의 주소만 참조하고 다니는 것이다. 주소값만 복사되고 있는 것.⇒ 한번 만들어진 객체는 통제권을 쉽게 벗어나서 주소의 복사가 왕창 일어난다는 것이다. 객체지향의 큰 어려움은 객체를 일단 만들고 나면주소값을 보호할 수 있을 것 같지만 실제로는 순식간에 퍼져나간다.⇒ 문제는 그 주소값을 참조하는 변수에 새로운 객체를 할당할 수 있다. A라는 변수가 원래는 old 객체를 참조하고 있었는데,A라는 변수에 new객체를 할당하면 새로운 주소가 A변수에 들어간다.⇒ A는 아무 문제가 없지만, B &#x3D; A, C &#x3D; B의 B,C변수들이 다 바보가 된다.즉, A의 참조부분을 잡았던 애들이 다 바보가 된다.B와 C는 old를 가리키고 있지만, A는 이제 new가 되었다.. 객체지향에서는 객체 참조키를 함부로 노출하지 않고 쥐고 있지 않으면순식간에 오염이 전파되서 A객체도 new객체를 받아들일 수 없다. 겁나니까. 객체지향은 이러한 단점이 있다. 참조가 쉽게 전파된다.참조 전파를 막는 장치가 있거나,섬세하게 관리하지않으면 참조가 순식간에 전파되어서참조를 전파시킨 본인조차도 새 객체를 받아들일 수 없다. 그럼.. 전체가 썪어서 망가진다.. **이 부분을 관리하는 것이 객체지향에서 어려운 점이다. ** 그에 비해서 값지향은 매번 복사가된다. 전파되지 않는다는 것이다.끊임없는 클론이 양산된다.⇒ 메모리가 엄청나게 많이 사용된다.⇒ GC에 의존할 수밖에 없다. 값으로 계속 복사가 되기때문에값에 대한 컨텍스트를 이어갈 수 없고컨텍스트를 포함한 새로운 값을 만드는데 성공해야한다. 값지향에서는 히스토리를 볼 수 없고 상태의 흐름을 볼 수 없다.중간중간에 흔적을 따로따로 상태를 보관해줘야한다. 결과물이 복잡할수록 함수의 복잡성은 올라간다.⇒ 수정은 더욱더 올라간다.ex) 함수형, rx 객체지향은 싱글톤 객체나 메모리상의 유일한 객체를 참조로 전파시키고 있으니까,메모리상의 유리한 점이나 객체의 생성에 대한 안정성을 확보해 줄 수 있다.다만, 주소의 전파가 일어나면 썩어들어간다. * 데이터를 처리하는 메소드를 내장함.본인의 상태를 본인이 책임질 수 있다.class 내에 메소드들이 this가 안나오면 메소드가 아니다. this가 없고, 인지와 지역변수만 쓰는 것은 유틸리티 함수이다. 우리는 \b기계적으로 class코드를 살펴보고 메\b소드에 this가 나오는지 안나오는지 살펴보고 안나오면 전부 유틸리티로 보내야한다. 다른 함수에서 유틸리티를 사용할지도 모르고,나중에 유틸리티 함수로 분리하지 않고, 리팩토링이나 수정시비슷한 함수를 사용하는 위치가 어디있는지 모르게 되며, 중복코드가 생길 가능성이 있다. * 모든 메소드는 현재 객체 컨텍스트 사용리팩토링할 때 알 수 있는 것은우리가 짠 클래스에 this를 사용하지 않는 메소드가 나온다는 점으로부터, 이건 객체협력으로 문제를 풀고 잇지 않구나를 알 수 있다.값 컨텍스트를 섞어서 문제를 풀었다는 것을 알 수 있다. 리팩토링이 끝나고 나면, this만 사용하는 클래스의 협력으로 문제가 풀리게 된다.그것이 우리의 궁극적인 목표이기도 하다. 2) 각 객체는 단일한 책임을 갖음 SOLID (마틴 파울러)우리가 알파고가 아니다. 이세돌이다.사람의 한계로 인해서 한번에 하나밖에 안된다.인간의 한계때문에 SOLID원칙이 있는 것이다. ⇒ 그래서 컨벤션이 존재. 자신이 처리할 수 없는 책임은 타 객체와 협력 객체망에 참여하여 자신의 역할 수행g하도록 한다. 3) 객체지향 사고 객체망으로 문제를 해결한다. 혼자할 수 있는 일이 단일책임밖에 없기 때문에객체망으로 해결한다. 단일책임을 준수한다. 객체를 이용하여 문제를 해결한다. 값으로 문제를 해결하지 않는다. 모든 처리를 객체로한다. 값을 도입하면 도입할수록 객체지향이 아니게된다. 은닉과 캡슐화를 활용하여 상태를 처리한다. 순식간에 전파되기 때문에. 은닉왜 안보여 줄까? ⇒ 지식 (knowledge)은닉을 하는 이유는 사람때문이다. 사람을 못믿기 때문에..객체지향은 사람 중심의 사고로 사람을 무지하다고 생각하는..ㅋㅋ 패러다임이다. 캡슐화은닉과 전혀 다른 이야기이다. 나의 행동을 구체적으로 부여주지 않으려고 하는건 아니다.추상화된 수준으로 설명하고 싶은 것.(ex_ATM기기: 돈세는 소리로 사용자의 목적을 인지시키지만, 실제 내부에서는 많은 일이 벌어진다.) 캡슐화를 common sense로 제공한다.**가장 설계능력이 많이 필요한 부부은 캡슐화이다. **좋은 아키텍쳐는 캡슐화를 잘한다.캡슐화를 하는 이유 중 하나는 객체망을 숨기기 위한 것도 있다.아키텍쳐들이 하는 일들이다. 기계 친화적인 코드는 없다. 기계친화적인 포맷은 없다.사람에게 이해가 쉬운 코드. 사람이 잘 사용할 수 있는 캡슐화. ⇒ 객체지향이 지원하는 것이다. 1.2 값지향 1) 값의 복사를 사용함.* 값의 평가 방법값이라는 것은 어떻게 구분할까?객체 간의 식별은 메모리의 주소로 한다. 값에서는 메모리의 주소는 틀리지만,타입에서 인정한 동과평과방법에 의해서값의 동과를 판별하는 전용식이 따로 있다. 메모리의 주소로 평가하는 것이 아니라값에 따라서 평가하는 방법이 다 다르다. * 값을 처리하는 유틸리티 함수가 존재값에서는 값을 평가하는 기준이 따로 있고,그것으로 동과를 평가한다. (메모리의 주소로 평가하지 않는다.)값이 있으면 값의 동과\b를 평가하는 식은 값 밖에 있다.메소드도 아니다.메소드로 처리하지 않고 값을 처리하는 유틸리티 함수로 값을 처리하게 된다. 타입 그룹별로 존재하게 된다. * 함수가 값을 처리하는 경우 컨텍스트는 없음메모리에 있는 값 그 자체를 사용한다. cf__2. 객체도 값처럼 사용하면 값 컨텍스트로 넘어간다.자바같은 언어에서 객체는 생성할때 무조건 고유한 해시코드를 갖고 태어난다.객체는 원래 메모리 주소로 구분해야하는데, 해시코드를 어딘가에 캐시잡아놓고, 해시코드와 해시코드를 비교해서 객체의 동과를 비교하려고 한다. 이런 경우 객체지만 값 컨택스트로 넘어간다.메모리의 주소로 비교해야하는데, 특별한 값의 비교방법으로 동과를 평가하면 그 비교식들은 순식간의 값 컨텍스트로 바뀐다. 2) 값은 순수한 데이터로 책임의 개념이 없음* 각 역할에 맞는 적절한 값의 타입이 존재함값 지향에서는 값과 독립적인 함수일가?인티저를 더하는 함수는 값에 독립적일까? 독립적이다.단지 타입에 종속되어있다. 어떤 함수는 인티저 타입만 건드릴 수 있고,어떤 함수는 더블 타입만 건드릴 수 있다.이때 말한 \b타입은 객체타입이 \b아님. 타입에 따라서 값타입이냐객체타입이냐는 굉장히 큰 구분점을 갖게 된다.값타입에서는 그 타입이 함수를 그룹짓는 기준이 되어버린다. 값에서는 하나하나 값을 구분하는 것이 아니라값의 타입만 구분\b할 수 있기 때문이다.그 다음에는 이 값과 값의 크기만 갖는것이다. 객체는 그렇게 구분되지 않는다.메모리만 있으면 독립성이 확보이다.값은 복잡한 녀석들이다 의외로 * 값을 처리하는 함수의 조합으로 문제를 해결함값은 계속 복사되고, 계속 역할이 없는 상태로 존재하기 때문에\b값지향을 이용해서 문제를 처리하기 위해서는값을 처리하는 함수의 조합으로 문제를 처리하는 수밖에 없다. HOC 끊임없이 그 함수가 값을 만들거나 값을 받아들이면서최종적으로 도메인을 해결하기 때문에결국에 값을 통한 문제들은 대부분 파이프라인으로 결론을 내게된다. ex__도자기 공정도자기를 예로 들자.도자기를 만드는 방법을흙을 반죽하고 ⇒ 반죽한 흙을 빚어서 도자기를 만드는 과정이라고 치면.과정을 유틸리티 함수로 만들어보자. 함수는 흙을 받고, 반죽을 return하게끔 만들 수 있다.이런 함수는 고정상태와 고\u001e정출력이 있다.어떤 과정을 순수하게 고정상태와 고정출력이 있는 상태로 구분지어서 나눌 수 있냐가 중요하다. 값지향을 하기 위해서는 상태를 구분지을 수 있냐 없냐 즉,내가 처리하려는 공정을 딱딱 잘라낼 수 있는지 없는지가 굉장히 중요하다. 하지만 우리 비즈니스의 요건들은 딱딱 잘라낼 수 있는 상황이 아니다.무조건 아닌 것은 아니고, 우리가 속해있는 도메인에 달려있다.\b값지향으로는 가역성을 만들기 어려워서 리셋을 한다. 3) 값 지향 사고 연산을 통해 문제를 해결한다. 연산에 적합한 값을 정의한다(함수포함) 값을 통해 문제를 해결한다. 순수함수를 활용하여 상태를 제거한다. 값과immutable과rx와함수형으로 풀 수 있는 문제는그렇게 많지 않다. 주요 도메인은 객체지향을 쓰는 이유는 사람의 마음은 기계가 아니기 때문에..개발 잘 하고싶으면 인지과학, 인지심리, 뇌과학 배우면 좋다.사람들이 좋아하는 것을 하면 좋은 아키텍처가 될수있다 .. :) 1.3 객체지향에서 단일 책임의 도출 기준객체 디자인 또는 설계객체의 책임을 도출하고 객체망을 구성하는 것 책임 (or 역할)을 도출하는 기준으로 사용할 수 있는 후보군3가지 요령이 있다. (3번으로 갈수록 뒤로갈수록 중요성이 높다.) 1) 도메인 - 의존성객체디자인을 할 때 도메인에서 뽑는 것이 좋다. 의존성 관리가 훨씬 쉬워진다. 객체망을 구성할때 독립적인 단위로 구성할 수 있다. * 첫번째로 역할을 인식할때는 도메\u001c인 경계를 나누고 시작하자.DDD 개발: 의존성때문에! 의존성의 범위를 정의할 수 있기 때문에 가역성이 좋아진다. 2) 네이티브 영역 - 가변성개발은 크게 2가지 영역을 다룬다고 생각해도된다. 인메모리 객체 로직이 메모리안에서 도는 로직들이 있다. I&#x2F;O (네이티브 영역) 통제권 밖에 잇는 것. ex. DOM, 쿠키, ajax * 인메모리와 인메모리 바깥 생태계가 주고받는 행위가 존재한다. 쿠키를 읽어온다. : 하드에서 읽어옴 네트워크 통신 : 소켓으로 읽어옴 돔하고 대화.. I&#x2F;O를 사용하면 드득거린다.쿠키를 읽을때 드득거리는 것을 볼 수 있다.때문에 일부러 웹워커같은 것을 사용한다. ajax 비동기인데 왜 워커에서 띄어서 하지? ajax가 I&#x2F;O라서 ajax가 발동하는 순간을 보면 드득거린다. 백그라운드 thread를 띄어서(웹워커) 여기서 I&#x2F;O를 띄어야,메인 thread에 영향을 안주게 된다. * 네이티브 영역: I&#x2F;O영역인메모리 영역과 네이티브 영역을 분리해서 객체를 구성해라. 믹스한 경우 ex__인메모리 객체와 돔을 믹스해서 사이트를 만들엇을 경우돔말고 캔버스로 바꾸면? &#x3D;&gt; 고우투 헬 이 두개를 분리한 사례 React 리액트의 인메모리 구조체가네이티브와 완전히 분리되어있기 때문에.리액트로 짠 코드를리액트 네이티브로 바꿀 수 있고리액트 캔버스로 바꿀 수 있다..리액트 본체가 완전히 인메모리로 되어있기 때문에 가능한 상황. 도메인보다 더 중요하다.네이티브 도메인을 분리해주자. 정리 **네이티브 영역을 분리해서 프로그램을 구축하지 않으면새로운 네이티브 영역과 바인딩하거나 환경이 바뀔때 비용을 든다..네이티브 영역에 의존하면 안된다.의존하지 않기 위해서는 인메모리, I&#x2F;O 따로 만들어야한다. 도메인 패턴도메인 패턴을 따르지 않는 패턴을enterprise pattern에서 transaction script pattern 3) 변화율 - 유지보수변화율의 기준으로 나누어야한다. 예를 들어고객의 비즈니스 요구사항이 바뀔때 바뀌는 부분이고고객의 시장반응이 바뀔때 바뀌는 부분이라면해당 변화율 기준으로 나눠놔야한다. 구간을 나눠서, 책임을 나눌 때어떠한 일때문에 바뀌는지에 따라서 나눠 놓으라는 것. 모든 프로그램은 변하니까.변하는 이유에 따라서 나눠놔라.좋은 아키텍트가 되는 중요한 자질이다. 변화율을 꽤뚫어봐라!변화율에 대한 센스가 아키텍트의 중요한 자질. 도메인을 기준으로 책임을 도출해보자.네이티브 영역을 분리해서 책임을 도출해보자.변화율을 인식해서 책임을 도출해보자.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"ES6 Symbol 오브젝트","slug":"JS_23","date":"2019-02-03T14:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2019/02/03/JS_23/","permalink":"http://feel5ny.github.io/2019/02/03/JS_23/","excerpt":"","text":"CommentSymbol에 대해서 이해가 안갔는데 C언어의 enum과 비슷한 개념이라고 설명한 부분에서 살짝 감이 왔다. ECMAScript6 책 (두고두고 보는 자바스크립트 표준 레퍼런스)인프런 JavaScript ES6+ 제대로 알아보기 – 중급 :: symbol 심볼은 3가지 형태로 사용할 수 있다. Symbol(): Symbol 값을 생성하며 스코프 안에서 사용한다. Symbol.for(): 글로벌 Symbol registry에 저장되며 전체 프로그램에서 사용한다. Well-Known Symbol: 빌트인 Symbol 프로퍼티로 오버라이드하여 기능을 추가, 변경할 수 있다. 1. primitivestring, number, boolean은 레퍼(Wrapper) 오브젝트가 있다. string은 String number는 Number boolean은 Boolean es6에서 symbol의 Symbol 오브젝트가 추가되었다. wrapper 오브젝트는 vlaueOf()로 프리미티브 값을 구할 수 있지만, symbol은 값을 반환하지 않는다. 2. Symbol()Symbol([description]) description: 설명, 주석 반환값: 유니크한 Symbol 값 1let sym = Symbol(); new 연산자를 사용하지 않는다. Symbol()로 생성된 값은 프로그램 전체를 통해 유일하고, 값을 변경할 수 없다.(immutable) C언어의 enum과 비슷한 개념이다. 생성한 Symobol에 프로퍼티를 설정할 수 없다. 반환자가 오브젝트가 아니므로, 오브젝트를 생성한다고 할 수 없다. symbol값을 생성한다는 표현이 적절하다. String의 &#39;&#39;, Array의 [] 처럼 Symbol을 생성하는 리터럴이 없다. undefined와 null 처럼 그 자체가 값이 되는 것도 아니다. 함수로 호출해야 값을 생성하여 반환한다. Symbol() Symbol()로 값을 생성하고 출력하면, Symbol()로 생성한 값을 반환하지 않고, Symbol 값을 생성했던 형태를 반환한다. 이는 symbol의 특징이다. Symbol값을 외부에 노출시키지 않는 것이 Symbol의 특징이다. Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성한다. Symbol값을 외부에 제공하지 않으므로 디버깅할 때 유용하다. 파라미터를 작성하지 않으면 undefined로 인식한다. 12345feature1: const sym = Symbol();feature6: sym // Symbol()feature_: typeof sym // symbolfeature8: Symbol(&quot;주석&quot;) // Symbole(주석)feature2: sym == Symbole() // false 3. Symbol 값 변경 Symbol()로 생성한 Symbol값은 변경할 수 없다. Symbol값에 문자열을 추가하고 싶을 경우 Symbol을 toString()이나 String()으로 변환한 후 연결해야한다. 4. Symbol 오브젝트 생성Object(123)처럼 Object()의 파라미터에 123을 지정하면 Number 오브젝트를 반환한다. Object() 파라미터에 Symbol 값을 지정하면 Symbol 오브젝트를 반환한다. Symbol 오브젝트에 Symbol메서드, Symbol.prototype, protototype에 연결된 프로퍼티가 설정된다. 5. 오브젝트에서 Symbol 사용유일한 값을 갖는 Symbol 특성을 활용하여Symbol 값을 오브젝트의 프로퍼티 키로 사용하면 프로퍼티키가 중복되지 않습니다. symbol-keyed property[Symbol()]형태와 같이 대괄호 안에 Symbol()을 작성 1&#123;[Symbol()]: 123&#125; 이렇게 프로퍼티 키에 작성한 Symbol()을 **symbol-keyed property**라고 한다. &#123; ABC: 123 &#125;에서 ABC에 Symbol값을 넣은 것이다.\u001f여기서 Symbol값은 문자열이 아니라 그냥 Symbol값이라고 생각하면된다. 123456let sym = Symbol(&quot;123&quot;);let obj = &#123;[sym]: &quot;456&quot;&#125;;console.log(obj); // &#123;Symbol(123): &quot;456&quot;&#125;console.log(obj[sym]); // 456console.log(obj.sym); // undefined 대괄호를 사용하지 않고 obj.sym 형태로 작성하면 에러는 안나지만 undefined가 반환된다. Symbol을 키로 갖는 프로퍼티를 &lt;&lt;&gt;&gt;형태로 표기하고 있다. 6. Symbol 사용형태for-in 문에서 symbol-keyed property는 열거되지 않는다. Symbol이 [[Enumerable]]: false이기 때문.(객체의 데이터 프로퍼티에서 [[Enumerable]]은 기본적으로 true이다.) 6.1 for-in 문에서 Symbol 사용 (외부스코프에서 의미없는 키값 &#x3D;&gt; symbol화)12345678910let obj = &#123;nine: 999&#125;;obj[Symbol(&quot;one&quot;)] = 111;obj[Symbol(&quot;two&quot;)] = &quot;222&quot;;console.log(obj);for (const key in obj)&#123; console.log(key)&#125;// &#123;nine: 999, Symbol(one): 111, Symbol(two): &quot;222&quot;&#125;// nine 일반적으로 for-in문으로 객체를 순회하면서 symbol-keyd property는 접근할 수 없다.때문에 객체의 고유한 식별자로써, 상수개념으로 사용한다.외부 스코프에서 의미가 있지 않는 값들만 symbol화 시킨다.은닉화의 목적이 있기때문에 외부 스코프에서는 접근가능하지 않아야하지만 내부에서는 가능하도록 만들어야한다. Object.getOwnPropertySymbols()를 사용하여 symbol-keyed property 키값들을 열거할 수 있다. Reflect.ownKeys를 사용하면 symbol-keyed property 키와 값까지 알 수 있다. 6.2 클래스 메서드 이름으로 Symbol 사용12345678910111213141516const symbolOne = Symbol(&quot;symbol one&quot;);const symbolTwo = Symbol(&quot;symbol two&quot;);class Sports &#123; static [symbolOne]()&#123; return &quot;Symbol-1&quot;; &#125; [symbolTwo]() &#123; return &quot;Symbol-2&quot;; &#125;&#125;console.log(Sports[symbolOne]());const obj = new Sports();console.log(obj[symbolTwo]()); 6.3 JSON.stringify()에서 Symbol 사용123let sym = Symbol(&quot;key&quot;);let result = JSON.stringify(&#123;[sym]: &quot;값&quot;&#125;);console.log(result); // &#123;&#125; 빈 오브젝트가 반환된다.이는 Symbol 값을 외부에 노출되지 않도록 하기 위한 조치이다. 6.4 프로퍼티 은닉화 symbol로 정의된 키값에는 바로 접근이 불가능하다. 키값이 들어있는 프로퍼티를 객체 내부에 적용해놓으면 심볼 키에 접근가능하다. 1234567const x = () =&gt; &#123; const a = Symbol(&#x27;a&#x27;); return &#123; [a]: 10, a: a, &#125;&#125; 7. Symbol.forpublic member 전역공간에서 공유되는 심볼.여기저기서 많이 사용되는 공용상수를 사용할때 사용 12345678const a = Symbol.for(&#x27;abc&#x27;) // 새로 생성해서 넣음.console.log(a) // &quot;Symbol(abc)&quot;const b = Symbol.for(&#x27;abc&#x27;) // 기존에 &#x27;abc&#x27; 식별자로 되어있는 symbol을 찾아서 있으면 넣어준다.console.log(b) // &quot;Symbol(abc)&quot;a === b // true ?!a와 b가 값과 타입이 같다고 나온다.Symbol.for는 for의 인자를 식별자로 사용한다. 12345678const obj1 = (() =&gt; &#123; const COMMON1 = Symbol.for(&#x27;공유심볼&#x27;) return &#123; [COMMON1]: &#x27;공유할 프로퍼티 키값. 어디서든 접근 가능&#x27; &#125;&#125;)();obj1[Symbol.for(&#x27;공유심볼&#x27;)]// &quot;공유할 프로퍼티 키값. 어디서든 접근 가능&quot;","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"symbol","slug":"symbol","permalink":"http://feel5ny.github.io/tags/symbol/"}]},{"title":"코드스피츠77 ES6_4회차_Abstract loop & lazy execution","slug":"JS_20","date":"2019-02-03T11:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/02/03/JS_20/","permalink":"http://feel5ny.github.io/2019/02/03/JS_20/","excerpt":"","text":"🌕🌑🌑 TL;DR복습할때나 이 문제가 까먹었을 즈음에 풀어보기 iterable객체 완성하기??? 구해보기(2가지 방법으로)1234567&#123; [Symbol.iterator]()&#123;return this;&#125; data: [&#123;a:[1,2,3,4], b:&#x27;-&#x27;&#125;, [5,6,7], 8, 9], next()&#123; return ??? &#125;&#125; 코드스피츠 강의 정리록입니다. 4강 키워드: Generator의 지연실행 측면과 이를 위한 추상루프화 1. abstract loop: 루프의 추상화 1.1 complex recursion 복잡한 반복단순한 배열 루프인 경우 간단히 이터레이션을 작성할 수 있다. 12345678910&#123; [Symbol.iterator]()&#123;return this;&#125;, data:[1,2,3,4], next()&#123; return &#123; done:this.data.length == 0, value:this.data.shift() &#125;; &#125;&#125; 복잡한 다층형 그래프는 어떻게 이터레이션 할 것인가?es6와 es6이전의 객체 리터럴의 큰 차이점이 무엇인가 es6이전 기존의 객체 리터럴에서는 객체 리터럴의 순서가 없다. 자바로 따지면 hash memory로 되어있다. es6 es6의 객체 리터럴은에서는 객체 리터럴의 순서가 있다. linked hash memory로 되어있다. 반드시 순서대로 해석된다. 문제1234567&#123; [Symbol.iterator]()&#123;return this;&#125; data: [&#123;a:[1,2,3,4], b:&#x27;-&#x27;&#125;, [5,6,7], 8, 9], next()&#123; return ??? &#125;&#125; 생각해보기 (글쓴이 생각..) iterable 프로토콜 유지하기 배열 요소들의 타입 검사 객체일 경우객체 내부 키값의 요소들의 타입 검사 객체일 경우 배열일 경우 일반 값인 경우 &#x3D;&gt; 처음 타입 검사와 같은 흐름이므로 해당 flow를 recursive 되도록 한다. 어떻게 같은 루프를 다시 태우지.. 배열일 경우배열 요소의 타입 검사 객체일 경우 배열일 경우 일반 값인 경우 &#x3D;&gt; 처음 타입 검사와 같은 흐름이므로 해당 flow를 recursive 되도록 한다. 어떻게 같은 루프를 다시 태우지.. 일반 값인 경우값 반환 cf__1. 루프를 어떻게하면 잘 짤 수 있을까.루프를 잘 짜고보다 어려운 로직을 짜는 방법은내 머리가 선언한 변수만큼을 추적할 수 있어야 한다… 기본적인 알고리즘 전략은 최대한 상태를 덜쓰는것. 내 머리가 추적할 정도로.. 정답각각이 컨테이너 형이라면그 컨테이너를 다시 해체해서 다시 배열에 붙여준다.더 이상 컨테이너 형이 아닐 때까지 123456789101112131415161718192021222324252627// 프로토콜만 맞춰주면 된다.// &#123;// done: boolean,// value: 출력값..// &#125;&#123; [Symbol.iterator]()&#123;return this;&#125; data: [&#123;a:[1,2,3,4], b:&#x27;-&#x27;&#125;, [5,6,7], 8, 9], next()&#123; let v; while(v = this.data.shift()) &#123; // shift가 더이상 안되면 undefined switch(true)&#123; case Array.isArray(v): // 2번째 케이스문의 객체 타입가드 조건문이 array 타입도 포함되므로, array만을 위한 조거문을 먼저 작성한다. this.data.unshift(...v); break; case v &amp;&amp; typeof v === &#x27;object&#x27;: for(var k in v) this.data.unshift(...x); break; default: return &#123;value:v, done: false&#125; &#125; return &#123;done: true&#125; &#125; &#125;&#125; 정답 내의 오류for(var k in v) for…in문은 prototype의 key까지 다 나오기 때문에 hasOwnProperty를 조건에 추가해야한다. hasOwnProperty는 자신의 고유 속성, 즉 상속받은 프로퍼티가 아닌 순수 자신의 속성인 경우에만 true라는 값을 반환하는 특징이 있습니다. 123for(var k in v)&#123; if(v.hasOwnProperty(k)) this.data.unshift(...x);&#125; 현재 상태에서는 순서 보장이 안된다. 123let x = [];for(var k in v) x.push(v[k])this.data.unshift(...x); 한번더 리팩토링값인 타입을 v instanceof Object로 판단할 수 있다! 12345678910111213&#123; [Symbol.iterator]()&#123;return this;&#125; data: [&#123;a:[1,2,3,4], b:&#x27;-&#x27;&#125;, [5,6,7], 8, 9], next()&#123; let v; while(v = this.data.shift()) &#123; if(!(v instanceof Object)) return &#123;value: v&#125;; if(!Array.isArray(v)) v = Object.values(v); this.data.unshift(...v); &#125; return &#123;done: true&#125; &#125;&#125; 정리자바스크립트 언어는 2가지로 되어있다. 언어자체의 문법적인 내용, 클래스 라이브러리자바스크립트의 클래스 라이브러리는 코어객체 (Built-in)Math, Date, RegEx…&#x3D;&gt; 표준으로 제공되고 있는 언어 표준의 일부&#x3D;&gt; 언어 스팩의 일부 코어객체에 있는 메서드들을 사용하는 것이기본 언어자체의 문법을 사용하는 것보다 더 안전하다.ex. for..in보다 Object.values 재사용성 올리기unshift나 shift로 인해서 data의 배열이 빈배열이 되는 상황이 된다.클래스로 묶어서 매번 부를때마다 인스턴스를 반환하는 형태로 만들자. cf__2. 함수를 변수에 할당하자.함수를 정의할때 3가지 스타일 함수 표현식 함수 선언문 Function… 함수는 값이기 때문에 변수에 할당하는 형식이 맞다. 더 정확하게 호이스팅에 의존하지 않고 어느 시점에 함수를 만들었다를 명확하게 코드로 인지할 수 있기 때문에 function으로 시작하는 함수 정의방법은 아예 금지시키고 못쓰게 하는 경우가 많다. lint에도 함수선언문 금지룰이 있다. 클래스도 하나의 값이다. 변수에 할당이 된다. 변수의 할당 없이 class..로 시작하는 선언방법은 이 클래스가 언제 만들어졌는지 모호하게 만드는 관점이 있다. 12345678910111213141516171819202122const Compx = class &#123; constructor(data) &#123;this.data = data;&#125; [Symbol.iterator]()&#123; const data = JSON.parse(JSON.stringify(this.data)); // 완전한 복사. 가장빨리 복사하는 방법.. return &#123; next()&#123; let v; while(v = data.shift())&#123; if(!(v instanceof Object)) return &#123;value:v&#125;; if(!Array.isArray(v)) v = Object.values(v); data.unshift(...v); &#125; return &#123;done:true&#125;; &#125; &#125; &#125;&#125;const a = new Compx([&#123;a:[1,2,3,4], b:&#x27;-&#x27;&#125;, [5,6,7], 8, 9]);console.log([...a]);console.log([...a]); shift를 사용하는 것은 data가 배열이 와야하는 조건이 있기 때문에data의 사본을 만들때 아예 배열화시킨다.const data = [JSON.parse(JSON.stringify(this.data));] if절을 보면 mandatory가 아닌 optional. 1234567891011121314151617const Compx = class &#123; constructor(data) &#123;this.data = data;&#125; *gene()&#123; const data = [JSON.parse(JSON.stringify(this.data))]; let v; while(v = data.shift())&#123; if(!(v instanceof Object)) yield v; else &#123; if(!Array.isArray(v)) v = Object.values(v); data.unshift(...v); &#125; &#125; &#125;&#125;;const a = new Compx([&#123;a:[1,2,3,4], b:&#x27;-&#x27;&#125;, [5,6,7], 8, 9]);console.log([...a]);console.log([...a]); 1.2 abstract loop위의 루프는 목적이 있는 루프이다.목적이 있는 루프를 만들고 목적을 바꾸면 루프를 다시 짜야한다. 다양한 구조의 루프와 무관하게 해당 값이나 상황의 개입만 하고 싶은 경우12345678910111213(data, f) =&gt; &#123; let v; while(v = data.shift())&#123; if(!(v instanceof Object))&#123; // v로 뭔가 하는 부분 f(v); &#125; else &#123; if(!Array.isArray(v)) v = Object.values(v); data.unshift(...v); &#125; &#125;&#125; 이 상황에서 f(v)를 호출하는 body에 본래 목적과 다른 로직이 추가 될 경우,같은 로직을 복사하고 원하는 로직을 추가해야하는 상황이 발생한다.문으로 로직을 작성할 때는 별다른 방법이 없다.&#x3D;&gt; 제어문을 재활용할 수 없으므로 중복정의할 수 밖에 없다.&#x3D;&gt; 문은 사용하고 나면 재활용할 수 없는데 이걸 어떻게 객체화하지? 결국 제어문을 직접 사용할 수 없고 구조객체를 이용해 루프 실행기를 별도로 구현구조를 추상화해보자. 루프 공통 골격 개별구조객체 cf__3. if문을 제거하는 방법우리가 배우는 거의 모든 priority 기법은 if를 어떻게하면 제거할까에 대한 연구일 수도 있다. 사람은 if가 많아지면 감당이 안된다. 조건이 많아져서..if를 어떻게하면 제거할 수 있을까? 정단한 이유라면 바로 제거할 수 없다. 필요에 의해서 태어났기 때문에 if로 나눠지는 경우의 수만큼의 값을 미리 만들어 놓고, 바깥쪽에서 그 값을 선택해서 들어오게 하는 수밖에 없다. 아래는 if가 3개이다. array일때 object일때 primitive일때3개만큼의 객체를 만들어놓고 바깥쪽에서 객체를 결정하게 끔 만들어 주면 값으로 분리할 수 있게 된다. &#x3D;&gt; 이렇게 if문이 하나씩 제거된다.1234567891011(data, f) =&gt; &#123; let v; while(v = data.shift())&#123; if(!(v instanceof Object))&#123; f(v) &#125; else &#123; if(!Array.isArray(v)) v = Object.values(v); data.unshift(...v); &#125; &#125;&#125; 팩토리 + 컴포지트 선택기는 팩토리 패턴으로 각각의 조건문을 컴포지트 패턴으로 cf__4. 팩토리 패턴 참고 비슷한 객체를 공장에서 찍어내듯이 반복적으로 생성할 수 있게 하는 패턴 컴파일 시점에 구체적인 타입(클래스)을 몰라도 객체 생성이 가능하다 팩토리 패턴의 가장 흔한 사례는 Object() 를 이용한 객체 생성시, 주어지는 값의 타입에 따라 String, Boolean, Number 등으로 객체가 생성되는 것이다. cf__5. composite 패턴1234567891011121314151617181920212223242526// 😵😵😵const Operator = class &#123; static factory(v)&#123; if(v instanceof Object)&#123; if(!Array.isArray(v)) v = Object.values(v); // --- object도 배열로 환원시켰기 때문에 현재 v는 배열임. return new ArrayOp(v.map(v =&gt; Operator.factory(v))) &#125; else return new PrimaOp(v); &#125; constructor(v)&#123;this.v = v&#125; operation(f)&#123;throw &#x27;override&#x27;&#125;&#125;// primitive 타입 처리하는 클래스const PrimaOp = class extends Operator &#123; constructor(v)&#123;super(v)&#125; operation(f)&#123;f(this.v);&#125;&#125;// 배열 타입을 처리하는 클래스const ArrayOp = class extends Operator &#123; constructor(v)&#123;super(v);&#125; operation(f)&#123;for(const v of this.v) v.operation(f);&#125;&#125;Operator.factory([1,2,3,&#123;a:4, b:5&#125;,6,7]).operation(console.log) 케이스를 더 많이 늘리는 것도 가능하다.. 2. lazy execution yield yield*","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"generator","slug":"generator","permalink":"http://feel5ny.github.io/tags/generator/"},{"name":"yield","slug":"yield","permalink":"http://feel5ny.github.io/tags/yield/"},{"name":"loop","slug":"loop","permalink":"http://feel5ny.github.io/tags/loop/"}]},{"title":"코드스피츠77 ES6_3회차_Iteration & generator","slug":"JS_19","date":"2019-02-03T09:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/02/03/JS_19/","permalink":"http://feel5ny.github.io/2019/02/03/JS_19/","excerpt":"","text":"🌕🌑🌑자바스크립트에서도 일반명사처럼 생긴 고유명사가 많이 나오고, 그중에 하나가 interface. 자바에서의 interface는 따로 있지만, 자바스크립트에서의 interface는 무슨 의미인지, 뭐에 쓰는 용어인지 알아보자.자바스크립트 스펙에 정의되어있는 interface 규격에 맞춰 자바스크립트의 루프가 구현되어있기 때문에 중요하며, loop를 배우기 전에 알아보자. 1. Interface in JS1.1 InterfaceECMAScript 공식문서에서는 interface에 대한 정의를 명확하게 내리고 있다. 인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트 어떤 Object라도 인터페이스의 정의를 충족시킬 수 있다. 하나의 Object는 여러 개의 인터페이스를 충족시킬 수 있다. 반환값의 타입까지 정할 수 있다. interface 예제 test라는 키를 갖고 값으로 문자열인지를 1개 받아 boolean 결과를 반환하는 함수가 온다. 123&#123; test(str)&#123; return true; &#125;&#125; cf__1. es6 객체리터럴test옆에 바로 괄호? es6에서 객체 리터럴에 새로 도입된 문법. key에 function을 집어넣는 경우가 생기면, function과 :을 생략하고 바로 괄호를 쓸 수 있는 문법이 추가되었다.123&#123; test: function (str)&#123; return true; &#125;&#125; 자바스크립트 엔진 레벨에서 여러가지 interface를 정의하고 있다. 1.2 Iterator interface next라는 키를 갖고 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 함수가 온다. IteratorResultObject는 interface이다.(아래의 IteratorResult interface를 확인) IteratorResultObject는 value와 done이라는 키를 갖고 있다. 이 중 done은 계속 반복할 수 있을지 없을지에 따라 불린값을 반환한다. done이 true일때는 value는 undefined 라는것도 정의되어있음 위 조건만 만족하면 Iterator 객체로 본다.아래는 타입스크립트에서 자바스크립트 내장 객체들을 정의해놓은 type definition 파일의 일부를 가져왔다. 1234567891011// lib.es2015.iterable.d.tsinterface IteratorResult&lt;T&gt; &#123; done: boolean; value: T;&#125;interface Iterator&lt;T&gt; &#123; next(value?: any): IteratorResult&lt;T&gt;; return?(value?: any): IteratorResult&lt;T&gt;; throw?(e?: any): IteratorResult&lt;T&gt;;&#125; 12345&#123; next()&#123; return &#123;value: 1, done: false&#125;; &#125;&#125; 그니까 iterator란이터레이터 프로토콜(: 데이터 컬렉션을 순회하기 위한 프로토콜(미리약속된 규칙))은 next메소드를 호출하면 iterable을 순회하며 value, done 프로퍼티를 갖는 iteratorResultObject를 반환한다.123456789&#123; data: [1,2,3,4], next()&#123; return &#123; value: this.data.pop(), done: this.data.length == 0 &#125; &#125;&#125;1.3 Iterable interface Symbol.iterator라는 키를 갖고 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다. Iterator Object 인터페이스는 위 1.2의 interface 12345678// lib.es2015.iterable.d.tsinterface Iterable&lt;T&gt; &#123; [Symbol.iterator](): Iterator&lt;T&gt;;&#125;interface IterableIterator&lt;T&gt; extends Iterator&lt;T&gt; &#123; [Symbol.iterator](): IterableIterator&lt;T&gt;;&#125; 123456789&#123; [Symbole.iterator]()&#123; return &#123; next()&#123; return &#123;value: 1, done: false&#125; &#125; &#125; &#125;&#125; 그니까 iterable란?iterable은 Symbol.iterator 메소드를 구현하거나, 프로토타입 체인에 의해 상속한 객체를 말한다.Symbol.iterator 메소드는 이터레이터를 반환한다. Symbol? ES6 추가된 새로운 primitive type 객체가 아닌 값으로 인식된다는 말. typeof로 보면 Symbole 타입이 나온다. primitive이지만 객체의 키로 사용할 수 있는 특징이 있다. Symbol.iterator는 이터레이터 오브젝트를 생성하면서 반환한다. 오브젝트의 [Symbol.iterator]를 호출하면 이터레이터 오브젝트를 생성하여 반환한다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. iterator만 있으면 되지 않을까? 왜 iterable이 필요하지?- loop를 돌 수 있는 reset 타이밍을 위해서- 즉, loop를 돌리는 객체의 사본을 만들기 위해서 iterable형태가 필요한 것이다. - 위에서 iterable 형태를 보면, Symbole.iterator를 키로 갖는걸 볼 수 있는데, 루프 돌 때마다 루프를 위한 변수와 원본데이터 변수를 구분하면서 iterator를 잘 \u001e구축하라고 iterable이 한번 개입하는 것이다. - iterator 패턴에서 온 개념\u001f 2. Loop to Iterator왜 for, while, do..while을 쓰지 않게 하고 이런걸 제공할까 문이기 때문에 한번 실행하고 나면 사라진다.(노이만 머신의 구조) 메모리에 남지않고, 실행된 후 사라진다. 두번다시 반복시킬 수 없다. 다시 호출을 위해서는 함수로 빼던지, 2번사용하던지 해야한다. 여러번 다시 사용하는것은 안전하지 않다.. 어딘가 저장해놓고 재사용해야한다. loop를 식으로 바꾸고 싶다는 마음이 생김!! 2.1 While문으로 살펴보는 Iterator현대언어의 기본적인 패러다임은문을 제거하고 전부 식(값)으로 바꾸버리는 것. 모든 문을 함수에 집어 넣어버리면함수에서는 값이 반환되는 형태이고, 그 함수를 호출하면 문을 원하는 시점에 실행할 수 있게된다. 여러번 문을 반복해서 실행할 수 있다. 문을 메모리에(함수) 담아두면 flow를 타지 않고 원하는 시점에 마음대로 실행할 수 있다. commend 패턴: 우리가 원하는 문들을 죄다 값으로 바꿔서 invoke에 저장하고, invoke를 호출할때마다 마음대로 문을 실행했다, 멈췄다, 되돌렸다 를 할 수 있게 만들어주는 패턴 \u001efor문이나 while문을 값으로 바꾸고 싶다.반복 전용에 해당되는 객체로 바꿔주면 된다. while vs iterator while1234let arr = [1,2,3,4];while(arr.length &gt; 0)&#123; console.log(arr.pop());&#125; 조건문: 계속 반복할지 판단. body: 반복시마다 처리할 것. iterator1234567891011&#123; arr: [1,2,3,4], next()&#123; return &#123; done: this.arr.length == 0, // while의 조건문에 해당 (계속 반복할지 판단.) value: console.log(this.arr.pop()) // while의 body에 해당 (반복시 처리할 것.) &#125; &#125;&#125; 더 반복할지 말지에 대한 조건문을 while에서는 while문 자체가 들고 있었지만,iterator에서는 iterator의 next 반환값 자체가 갖고 있다. 즉, next에 의존적이 된다. 정리1. 반복자체를 하지는 않지만 (: iterator 객체와 next객체가 반복하진 않지만.) 2. 외부에서 반복을 하려고 할 때 3. 반복에 필요한 조건과 실행을 4. 미리 준비해 둔 객체 (self description: 나 자신에 대해서 내부에 설명) 즉, 반복행위와 반복을 위한 준비를 분리 미리 반복에 대한 준비를 해두고 필요할 때 필요한 만큼 반복 3. 반복을 재현할 수 있음 반복 자체를 하지 않지만,외부에서 iterator를 이용해서 반복하려고 하는 상황을 위해서,반복에 필요한 조건과 실행을 미리 준비해둔 객체를 갖고 있는 것이다. (iteratorResult객체) next만 부르면, 몇번이고 반복할 수 있다.이제는 더이상 복잡한 loop의 상태조건이나 문의 실행을 다 빼버리고,외부에서는 반복이라는 행위만 하면된다.&#x3D;&gt; 반복기와 반복조건을 분리 3. ES6+ Loop3.1 사용자 반복 처리기직접 Iterator 반복처리기를 구현해보자. 커스텀 12345678910111213141516171819202122232425262728293031// 1. 반복기const loop = (iter: IterableIterator&lt;number[]&gt;, f: Function) =&gt; &#123; // iterable 가드 if (typeof iter[Symbol.iterator] == &#x27;function&#x27;) &#123; iter = iter[Symbol.iterator](); // next확인하는 가드도 있어야함. &#125; else return; // iterator 가드 if (typeof iter.next != &#x27;function&#x27;) return; do &#123; const v = iter.next(); if (v.done) return; // undefined면 종료처리 f(v.value); // 아니면 f에 value 전달 &#125; while (true); // 반복기일뿐!! 재귀함수로 짜도 상관없다.&#125;// 2. 반복되야할 조건이 있는 iterableconst iter = &#123; arr: [1, 2, 3, 4], [Symbol.iterator]() &#123; return this; &#125;, next() &#123; return &#123; done: this.arr.length == 0, value: this.arr.pop() &#125; &#125;&#125;loop(iter,console.log) 반복되야되는 조건에 해당되는 값들과반복기를 분리했더니반복기쪽에서는 그냥 돌리기만 하면되는 책임으로 확 줄고 (loop함수),나머지 상태관리나 루프에 대한 모든 책임은 다 iterator객체가 가져갔다. iterator객체가 굉장히 안전적으로 몇번이라도 이 loop를 성공할 것이다. 개발자스스로 나름대로의 구조와 이름으로 짤수도 있다.단지 이제는 자바스크립트 표준이 있다. 이터레이터 패턴을 구현하는데에 있어서 자바스크립트 표준 스펙이 나왔고, 이걸 구현하는 공식적인 방법이 스펙으로 정의되어있다.만약 스스로 나름대로의 이터레이터를 구현해 왔다면, 이제는 자바스크립트 표준 인터페이스에 맞춰서 iterator를 구현하시는 쪽으로 바꿔야한다.언어의 혜택이 많기 때문 3.2 내장 반복 처리기언어의 지원을 받는다는 것은 무슨뜻일가.언어가 iterator 인터페이스에 대해서 처리해주는 내장 기능이 있다.우리가 만든 모든 객체가 iterator 인터페이스를 충족\b해주면, 언어가 제공하는 문법적인 요소를 다 사용할 수 있다.iterable객체가 아닌데 아래의 처리기들을 사용하면 스크립트가 죽는다. 어떤 객체가 Iterable이라면, 그 객체에 대해서 자바스크립트에서는 아래의 기능들을 사용할 수 있다. 분해대입(destructuring assignment) spread 연산자 (…) for…of 루프 기타 iterable을 인수로 받는 함수 Array\u001f destructuring 배열해체 1234567891011121314// iter는 iterable 객체.const iter = &#123; [Symbol.iterator]()&#123;return this&#125;, arr: [1,2,3,4], next()&#123; return &#123; done: this.arr.length == 0, value: this.arr.pop() &#125; &#125;&#125;;const [a, ...b] = iter;console.log(a,b); // 4, [3,2,1] 해체구분은 보통 변수를 선언하는 쪽에 쓰인다. 배열은 =의 왼쪽에 오면 변수이름이 된다. 해당 index에 있는 값을 변수에 담음. Spread 펼치기 12345678910111213const iter = &#123; [Symbol.iterator]()&#123;return this&#125;, arr: [1,2,3,4], next()&#123; return &#123; done: this.arr.length == 0, value: this.arr.pop() &#125; &#125;&#125;;const a = [...iter];console.log(a); // [4,3,2,1] Rest Parameter (나머지 인자)\u001d 12345678910111213const iter = &#123; [Symbol.iterator]()&#123;return this;&#125;, arr:[1,2,3,4], next()&#123; return &#123; done: this.arr.length == 0, value: this.arr.pop() &#125; &#125;&#125;const test = (...arg) =&gt; console.log(arg);test(...iter); for ...ofwhile, for처럼 권한이 있지않고 권한이 전혀 없는 for. 1234567891011121314const iter = &#123; [Symbol.iterator]()&#123;return this;&#125;, arr:[1,2,3,4], next()&#123; return &#123; done: this.arr.length == 0, value: this.arr.pop() &#125; &#125;&#125;for (const v of iter)&#123; console.log(v);&#125; for...of iterator에서 value만 받아서 내려준다. 배열이나 object를 써야지 이 혜택을 받는 것이 아니라, iterator만 만들면 이 혜택을 받을 수 있다.객체 만들때는 괴로울지 몰라도, \b사용할때는 예쁘게 작업 가능. 신규로 출시되는 많은 API가 iterable을 \b포함하고 태어나기때문에iterable interface는 es6세계에서 반드시 이해하고 외우고 있어야 하는 내용이다. 정리자바스크립트 es6이후에는 반복을 위해서 iterable을 만든다. 3.3 연습제곱을 요소로 갖는 가상컬렉션 😵😵😵 12345678910111213141516171819202122232425const N2 = class &#123; constructor(max)&#123; this.max = max; // 무한배열을 막기위해 &#125; [Symbol.iterator]()&#123; let cursor = 0, max = this.max; return &#123; done: false, next()&#123; // 반복기일 뿐 if (cursor &gt; max) &#123; this.done = true; &#125; else &#123; this.value = cursor * cursor; cursor++; &#125; return this; &#125; &#125; &#125;&#125;console.log([...new N2(5)]);for (const v of new N2(5))&#123; consoel.log(v )&#125; 하나의 Object는 여러 개의 인터페이스를 충족시킬 수 있다.이 객체는 Iterator객체임과 동시에 iteratorResultObject이기도 하다. 우리가 만든 loop에는 안전장치가 있어야한다. loop조건을 걸때 무조건 max값을 넣는 습관을 들이자. symbol iterator를 호출할 때 마다 제각각 다른 지역변수가 만들어질테고,그때마다 태어난 함수도 제각각 다른 지역변수를 자유변수로 캡쳐해둘 것이다. 함수호출할때마다 instance가 자기만의 field를 갖고 태어난것과 비슷하네? 함수형 패러다임에서는 instance를 new 연산자로 생성하는 대신에,함수를 생성함으로써 그때에 있는 자유변수를 instance의 field처럼 쓰게 된다.자바스크립트에서는 instance를 만들면서 field지정할것인지.함수를 생성하면서 자유변수를 지정할 것인지 선택할 수 있다.혹은 섞어 쓰거나. 이게 자바스크립트가 혼란스러운 이유… 비단 자바스크립트만 그렇진 않다.. cf__2. 함수, 함수 스코프, 클로저함수는 함수가 만들어지는 시점에 바깥쪽에 있는 변수들을 캡쳐해서 마치 지역변수로 쓸 수 있는 권한이 있다. 함수 입장에서는 지역변수, 인자도 아닌데 참조할 수 있는 변수 &#x3D;&gt; 자유변수 자유변수가 생성되는 원리는 언어마다 다르다. 자유변수를 함수는 사용할 수 있다. 자바스크립트 매커니즘에서는 next라는 함수가 탄생할 때, 바깥쪽 함수 둘레에 있는 변수들을 사용할 수 있다. 자유변수가 잡혀서 사용되는 닫혀진 공간을 클로저라고 한다.함수는 곧 클로저라고 할 수 있다. 자유변수를 가둬둘 수 있기 때문에 cf__3. 자바스크립트를 특정버전으로 열심히 공부해도..계속 바뀐다. 자바스크립트 엔진의 구조는 계속 바뀌기 때문에 컴퓨터 사이언스 원론을 이해하는게 훨씬 낫다. 스코프 체이닝.. 변수를 캡쳐해오고.. 이건 자바스크립트 3.1 engine 원리임.. 지금 얼마전 크롬 67에서는 새로운 함수 호출 실행 시스\u001c템을 만들었기 때문에 함수 호출이 급격하게 빨라졌다. 요즘 책은 … 모두 자바스크립트 3.1 엔진이야기다….(헐) ‘현재에 이르러 배우게되는 자바스크립트는 대부분 ECMAScript 3 버전에 대한 공부이며, 최근에 출시된 ECMAScript 6 버전이 새로운 기능으로 무장되어 있어 이와 관련된 공부가 필요할 것이다.출처 지금 엔진은 그렇게 움직이지 않는다. 그냥 컴퓨터 사이언스 원론을 이해하는게 낫다. 자료구조를 iterable로 구축하는 훈련이 되있어야하지만, 문법적인 혜택을 누릴 수 있다.하지만 생각보다 iterable 객체를 만드는 것이 리소스가 많이 든다.generator함수로 해결할 수 있다. 4. GeneratorIterator의 구현을 돕는 Generator (IteratorGenerator)function*() generator 함수를 생성하는 리터럴. generator함수를 호출할 때마다 iterator가 만들어진다. generator는 iterator이며, 동시에 iterable이기도 하다. 😵😵😵 반복기와 반복조건부분이 분리되어있지만 함께 갖고 있다. 123456789101112const generator = function*(max)&#123; let cursor = 0;\u001e while(cursor &lt; max)&#123; // iterator에서 next()와 같은 역할 yield cursor * cursor; cursor++; &#125;&#125;console.log([...generator(5)]);for(const v of generator(5))&#123; console.log(v);&#125; yield라는 키워드 suspense라는 기능: while문이 돌다가 잠깐 멈춘다! 문은 멈출 수 없지만 yield에서 중지된다. iteratorResultObject를 반환한다. 루틴이 아니다. co-routine 함수는 루틴generator는 코루틴이라고 부른다. 참고자료https://helloworldjavascript.net/pages/260-iteration.htmlhttps://poiemaweb.com/es6-iteration-for-ofhttps://jusungpark.tistory.com/25","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"iterator","slug":"iterator","permalink":"http://feel5ny.github.io/tags/iterator/"},{"name":"generator","slug":"generator","permalink":"http://feel5ny.github.io/tags/generator/"}]},{"title":"CodeSpitz77 2회_Flow control statement (2)","slug":"JS_18_2","date":"2019-02-03T07:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2019/02/03/JS_18_2/","permalink":"http://feel5ny.github.io/2019/02/03/JS_18_2/","excerpt":"","text":"🌕🌑🌑 TL;DRoptional flow control에서는 if문에 대해서 다룬다. if문에서 가장 중요한 것은 모든 상황에 대한 예외처리이며, 특히 if..else을 사용할 경우 else문 뒤에는 mandatory 상태의 문이 와야한다. 후방결합이라는 특징때문에 else if 사용을 조심해야한다. 병행조건일때는 switch문을 쓰고 부분집합에서의 조건문이 필요할 경우에는 if..else를 사용한다.if문의 여러 중첩을 else if문으로 쓰곤했는데, 많은 상황을 예외처리 한것인가에 대해 항상 의문이 들곤했었다. 이번 시간을 통해서 else if문은 지양하기로 하고, else문 뒤에 조건문을 추가하고 싶을 경우 중괄호 이후에 if else문을 써서, else뒤에는 mandatory한 상황을 만들게끔 습관을 들이기로 했다.Iterate Flow Control에서는 For문과 While, do..while문을 다룬다. For문은 3가지 식을 넣을 수 있는데 첫번째는 식과 문 중에는 선언문만 올 수 있고, 두번째는 boolean을 반환하는 조건식이 오며, 빈값일 경우 무조건 truthy라는 특징이 있으므로 무한루프에 빠지지 않게 조심해야한다. 세번째는 식이 오는데, statement의 마지막에 처리되므로 statement 마지막에 두어도된다. while문은 조건식이 필수이며, 조건식과 관련된 코드가 body에 안나올 경우 무한루프에 빠지게된다. do..while문은 while 조건문 뒤에 ;을 붙여야한다. 코드스피츠 강의 정리록77 동영상 음원문제로 77교안을 토대로 73강의를 들으며 작성 2. Optional flow controlconditional Statement: 조건문 2.1 if, if elseif (condition) statement1 [else statement2] 12345if (c &gt; 5) &#123;&#125; else switch (c) &#123;&#125; 123if (c &gt; 5) &#123;&#125; else for (;;) &#123;&#125; 2.1.1 Truthy, Falsymdn falsy는 0, false, null, undefined,&quot;&quot;, NaN이 있다. 나머지는 truthy이다. 2.1.2 Optional, Mandatory특정 상황에 따라 optional한지 mandatoy한지 다르다. if절은 optional, if else절은 mandatory하다. if else절은 모든 구문이 mandatory여야한다. optional 상태의 경우는 예외처리가 안되어있다고 생각하면 된다. 12if (expression) //optionalif (expression) statement1 else statement2 // Mandatory 암묵적인 오류(context error)예1) 123if (a) // mandatoryelse if (b &amp;&amp; a) else 위의 코든에서 첫번째 else뒤에는 mandatory되어야하지만, optional하다. a와 b의 상태에 따라 b &amp;&amp; a의 값이 다르기 때문 12345678910111213if (a)else &#123; if (b &amp;&amp; a) else &#123; if (!b &amp;&amp; a) else &#123; if(b &amp;&amp; !a) else &#123; if(!b &amp;&amp;!a) &#125; &#125; &#125;&#125; 에2) 12345if(c === 1)&#123; &#125; else &#123; if (c === 2)&#123;&#125;&#125; else 다음에 옵셔널한 if만 놓여있다.else 안에는 mandatory해야한다. 12345678if(c === 1)&#123; &#125; else &#123; if (c === 2)&#123; &#125; else &#123; &#125;&#125; if..else문에서 else if문을 사용할 경우 육안으로는 많은 경우를 대비하는 처리하기 헷갈린다. 이는 후방 결합때문이다. 2.1.3 RL Parsing arrow function과 if else 구문만 오른쪽에서 왼쪽으로 후방 결합한다. 대부분의 버그는 후방 결합에서 일어난다. else if문 쓰는 습관을 버리자. else 다음에 조건문이 필요할 경우, 중괄호 이후에 if-else문 사용하기 후방결합의 실수를 피하기 위해 중괄호와 괄호를 붙여주는 것이 좋다. 123456789if (c===1)&#123;&#125; else &#123; if (c===2)&#123; &#125; else &#123; &#125;&#125; 병렬조건을 선택할 때 절대로 else if를 쓰면 안되는 이유이다. else if는 원래부터 위험한 코드고, 남들이 해석할때 난감해 지는 코드일 뿐만아니라, else 후방조건이 제대로 붙어있는지 검사하기 굉장히 까다롭다. 컴파일 에러도 안나고 런타임 다 통과하기 때문.. 런타임때 다 통과하지만 로직이 잘못된 경우가 너무 많다. 2.1.4 Nested, Parallel이렇게 if else를 봤더니.. 1차 조건이 분기한 이후에 부분집합에서만 쓰인다. 병행조건일 때 쓰는 것이 아니라 부분집합을 다시 분기할때.. nested되어있는 sub집합에 대한 조건일때 사용한다. else if는 병행조건일 때 쓰면 원래 안되는 것. 병행조건(Parallel)일때는 무조건! &#x3D;&gt; switch switch를 쓴다. 내가 평가해야할 식들이 동등할 경우 !!! switch문으로 간다. 내가 평가해야할 식이 nested되어야 할 경우 if중첩. 병행조건에는 반드시 예외가 생길 수 있는 가능성이 있기 때문에switch에는 default가 필수이다!! if else 안에 switch문은 괜찮을까? else 에는 mandatory가 되어야 하는데 switch문에서 default 문을 썼다면 mandatory가 보장되기 때문에 사용해도된다. 병행조건으로 빠졌지만, dafault가 붙어있는 이상 빠져 나올 구멍이 없다. 조건문을 중첩해서 사용할 때는 mandatory로 빠지는 건지 optional로 빠지는지 확인하면 된다. mandatory로 시작했으면 mandatory로 끝내야하고optional로 시작했으면 optional로 끝내야하고optional과 mandatory를 섞어 써야한다면 로직분리를 잘하던지 완전히 분리해서 함수로 빼던지(격리). 자기 코드의 의도를 명확하게 해서 변화가 일어날 때 어디까지만 수정하고 나머지는 여파가 없게끔 하는 방법에 대해서 익힐 필요가 있다.코드를 짤때 어떻게 섬세하게 짤 것인가. 3. Iterate Flow Control반복문 for while, do..while for ( of ); &#x3D;&gt; for iteration for ( in ); &#x3D;&gt; forEach와 유사 3.1 Forfor문의 3개의 선택식에 어떤 코드를 넣어야할지 반드시 이해해야한다. for ([initialization]; [condition]; [final-expression]) Initialization Limited Statement 원래 식만 와야하는데 선언문 한정으로 문이 올 수 있다.(문중에 선언문만 올 수 있다.) 선언문 또는 식이 올 수 있다. 혹은 공문도 올 수 있다. 식 또는 변수 선언. 주로 카운터 변수를 초기화할 때 사용한다.2. condition (:조건) 매 반복마다 평가할 식. 평가 결과가 참이라면 statement를 실행한다. 이 식을 넣지 않을 때(공문) 결과는 언제나 참이다. (Empty Truthy) - 무한루프 결과가 거짓이라면 for문의 바로 다음 식으로 건너 뛴다.3. final-expression 매 반복 후 평가할 식. 다음번 condition 평가 이전에 발생한다. statement 끝에 있는것과 같는 상황이다. 즉, statement 마지막에 실행된다. (Last Execution) 반복해서 쓰지 않기 위해서 3번째 항목에 넣는것. 1234var a = 3; // declare statement. 문이다.for (var i = 0; turthy; ex)&#123; &#125; 3.2 While, do whilewhile (condition) statement condition이 공문일 경우 syntax error를 반환한다. while문은 중문이 오는 것이 정상.2줄이 오는 것이 정상이다. 123456789while(truthy)&#123;&#125;// while문 보다 1번은 먼저 더 실행하는 꼴do &#123; &#125; while (truthy); do statement while (condition); do while문은 마지막에 ; 붙이는게 공식문서에 명시되어있는 규칙 do 다음의 statement가 단문일 경우 ;붙이면 됨do a++; while(a); 3.2.1 Infinite Loopwhile문과 do..while문은 평가식에 관여되어있는상태값을 바꾸지 않으면 무한루프에 빠질 위험이 높다. 식별자와 관련된 코드가 안나온다면 무한루프 1234var a = -1;while(a &gt; 2)&#123; a++;&#125; 조건식(condition)에 나오는 상태가 body에 나오는지 안나오는지부터 봐야한다. 현실코드 123while(act.method().c)&#123; author.action();&#125; ??? 뭔지 모름. 이런 코드는 무조건 배재해야한다..123456var a = act.method().cwhile(a)&#123; author.action(); a = act.method().c;&#125; 적어도 body안에 조건식에 나오는 상태가 되었다.. 참고자료https://mkki.github.io/code-spitz/2018/07/12/code-spitz-2.html","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"flow control","slug":"flow-control","permalink":"http://feel5ny.github.io/tags/flow-control/"}]},{"title":"CodeSpitz77 2회_Flow control statement (1)","slug":"JS_18_1","date":"2019-02-03T05:20:19.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2019/02/03/JS_18_1/","permalink":"http://feel5ny.github.io/2019/02/03/JS_18_1/","excerpt":"","text":"🌕🌑🌑 코드스피츠 강의 정리록 복습Flow란?우리가 짠 파일이메모리에 적재되고,적재된 순간, 명령과 데이터로 나눠져서 적재된 다음에명령이 쭉 한꺼번에 실행되는데,명령이 차근차근 실행되는 과정. 0. Record, Completion Record자바스크립트 언어의 기본적인 문처리 기법을 알아보자. 0.1 Record자바스크립트는 문을 처리할때 식과 다르게 처리한다.식은 하나의 값으로 처리될 뿐이지만,문은 실행단위로 처리된다.문을 10개 쓰면, 10개의 실행단위가 생각난다.(식은 10개 써도, 값 하나로 수렴될 뿐이다.)문의 갯수를 늘리면, 자바스크립트 엔진은 갯수만큼을 처리해야할 과제로 알고 있다.한줄한줄의 문이 생길때 마다 과제로 등록해 놓는다.&#x3D;&gt; Record 우리가 일반적으로 문을 짜면 Record 하나하나로 번역이 된다.자바스크립트 엔진은 우리가 짠 코드를 파싱할때 문들을 Record단위로 파싱한다.Record가 하나하나 생성이되면 flow를 타고 쭉 움직인다. Record를 만들고Record를 실행하는 과정이자바스크립트 엔진의 주 작동원리이다. 요즘 현대 브라우저들은 자바스크립트 3.1엔진에서 돌지 않는다.(인사이드 자바스크립트나 자바스크립트를 말하다와 같은 책들은 좋지만, 작동원리는 현대 브라우저와 다르다. (3.1버전 엔진기준으로 설명된 책))모든 항목에 있어서 브라우저들이 해석하는 방식이 달라졌다. 스펙문서도 달라짐.자바스크립트 엔진의 작동원리를 지금 버전에서 배워도, 매년 스펙이 갱신되기 때문에 내가 알고 있던 지식이 다음해에는 무의미해질 수 있다.기저층의 작동원리보다는무엇을 의미하고 추상적인 의미는 무엇인지 체계를 배우는 것이 더 의미있다..&#x3D; 작동원리보다는 근본적인 부분을 배우자. 자바스크립트 엔진에서 Record를 부르는 말은 굉장히 많다. 언어의 버전마다 다르다 정리 우리가 문을 작성하면 문을 하나의 Record로 바꿔준다는 것. 자바스크립트는 이런 Record를 모아서 Record를 처리해가면서 작동한다는 사실만 알면 된다. 0.2 Flow Control Statement, Completion recordif문이라서 분기를 할 수 있다던지, loop구분이라서 계속 flow를 돌릴 수 있는flow 제어를 하면 레코드를 선택하거나 레코드를 순환시킬 수 있는 권한을 갖게 된다. flow 제어를 할 수 있는 문을 record로 바꿀때는Completion record로 바뀐다.completion record은 record를 뭘 선택할 수 있는지 flow에 관여할 수 있다. 자바스크립트 엔진은 우리가 작성한 문을Record와 Completion record로 나누고,Completion record들이 어떤 레코드를 선택할지 결정하는데 사용한다. 문은 컴파일러에게 주는 힌트일 뿐이라고 했었다. if나 for문을 쓰면 값으로 환원되지 않고Completion record가 어떻게 작동할지를 자바스크립트에게 알려주는 힌트가 될 뿐. 자바스크립트는 그 힌트를 받아서 내부적으로 이런 flow 흐름도를 만드는completion record를 생성하게 된다. 정리 우리가 짜는 문 하나하나가 flow를 구성한다. flow control하는 문들은 별도로 구성한다. 1. Direct flow control직접 flow control하는 명령어를 배워보자. 1.1 label자바스크립트에서 사용할 수 있는 직접 flow control에는 label이 있다. 다중 for문을 사용했을 때 바깥쪽 for문으로 빠져나오고 싶으면, break를 사용하면 된다. 1.1.1 Identifier (&#x3D; 식별자) 자바스크립트 변수 identifierA JavaScript identifier must start witha letter, underscore (_), or dollar sign ($);subsequent characters can also be digits (0-9). Because JavaScript is case sensitive, letters include the characters “A” through “Z” (uppercase) and the characters “a” through “z” (lowercase). (참고) $를 시작할수도, 포함할 수도없다. 나머지는 변수 식별자 규칙과 같다. 뒤에 :를 붙여주는 순간 label이 된다. 1.1.2 Scope label의 이름은 같은 범위(scope)내에서 2개가 나올 수 없다. 런타임에 오류가 잡히지 않고파싱하는 타임에 오류가 난다. 에러를 사전에 잡을 수 있는 장점이 있다. Label의 scope? label의 scope는 함수로 결정된다. label scope라는 개념이 있다. label scope도 shadowing이 일어난다. 1234567&lt;script&gt; abc: &#123; console.log(&quot;start&quot;); if (true) break; console.log(&quot;end&quot;); &#125;&lt;/script&gt; Uncaught SyntaxError: Illegal break statement 12345678&lt;script&gt; abc: &#123; console.log(&quot;start&quot;); if (true) break abc; console.log(&quot;end&quot;); &#125; console.log(&quot;test&quot;);&lt;/script&gt; starttest break뒤에 명시된 label 스코프의 마지막으로 jump할 수 있다는 의미이다.&#x3D;&gt; flow 수동 제어에 성공 label 스코프를 생성하게 되면label 스코프 내에서는 label을 빠져나올 수 있는 권리가 주어진다. loop가 아니라서 continue는 사용하지 못하지만 break는 사용할 수 있다. 가장 원초적인 flow control 이 방법을 통해서 label 섹션을 만들면 label 섹션에서 flow control이 가능하다. label 영역이 아닌곳도 될까?label 영역이 아는곳에서 되게 하려면 label 영역을 나눠줘야한다. 1.1.3 Label range label range를 인식하려면 label set을 인식할 수 있어야한다. 어떻게 해서 label이 label영\u001c역을 확보하는지 알아야 한다. 이 label에서 다음 label까지가 하나의 label range를 이룬다. label다음에 iteration이 오거나, switch가 오면 이것들이 다시 label 범위를 한정짓게 된다. 123456&lt;script&gt; console.log(&quot;0&quot;); abc: if (true) break abc; console.log(&quot;1&quot;); bbb: console.log(&quot;2&quot;);&lt;/script&gt; 012 label range로 확정했지만, jump하지 못했다. goto처럼 건너뛰려면label 스코프를 선언하던지,iteration label이 되던지,switch label이 되던지 해야지 jump할 수 있다. 자바스크립트에는 goto 구문이 없다는 것에 주의.break나 continue에서만 레이블을 사용할 수 있다. 직접 레이블을 선택해서 goto는 안되고break, continue로 아래로 내려가는 것만 가능하다. 왔다갔다 할 수 없다. label만 갖고 loop문을 만들 수 없다. 반복적인 실행만 할 수 없을 뿐 jump시킬 수 있다. if문에서는 break 문 뒤에 label을 작성해야하는데,while이나 for문에서는 label을 명시적으로 쓰지않고 break문만 쓸 수 있는 이유는 무엇일\u001c까 123456&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; if (i === 5) break; &#125; console.log(&quot;end&quot;);&lt;/script&gt; 왜 error가 아닐까? 1.1.4 Auto label1234567&lt;script&gt;temp38: for (var i = 0; i &lt; 10; i++) &#123; if (i === 5) break temp38; &#125; console.log(&quot;end&quot;);&lt;/script&gt; 자바스크립트 엔진이 우리 대신에 label을 삽입해준 셈. &#x3D; auto label iteration(for문)이나 switch문 앞에서 발동된다. auto label이 만들어낸 이름 undefined named label(위 예시의 temp38같은) cf__1 주석을 깨끗하게 쓰고 싶다면? 앞주석을 쓰기 위해서 앞에 쓰기도 한다. 오픈소스에 이렇게 쓰여있는 경우가 많다. 123ab: console.log(&#x27;123&#x27;)cd: console.log(&#x27;123&#x27;)dc: console.log(&#x27;123&#x27;) 1.1.5 label은 호출됐을 때 처음으로가나요?jump구문은 jump가 시작하는 문장 블럭의 가장 처음으로 가게 되어있다. for문이 루프돌면, 가장 처음으로 간다. 함수 호출하면 가장 처음으로 간다.하지만 break의 label를 본다면.. 처음으로 가야하는 거 아닌가?? break의 label은 블럭의 마지막으로 보낸다. 자바스크립트의 label 스펙은 자바의 label 스펙과 동일히다레이블은 자바스크립트의 3.1버전때부터 있었던 스펙 1.2 Switchswitch의 문법적 요소를 확인해보자. switch라는 키워드가 나오고 괄호가 나오고 괄호 안에 식이들어갈 수 있고, 중괄호가 나온다. for문 다음에 괄호는 단문이 나올 수 있고 중문이 나올 수 있는데, 중문때문에 중괄호를 쓴다. switch문은 그럴 수 없다. 무조건 중괄호가 나와야한다. 문법적인 토큰이라는 뜻이다. switch의 몸체를 나타내는 전용 토큰. 언어 파서가 해석하기 위한 토큰으로서의 중괄호이다. 왜 중괄호를 쓸까.switch는 중괄호의 영역을 특별한 영역으로 만든다.special label block으로 만든다. case 식 콜론 : 1.2.1 Special label Blockswitch는 특별한 레이블 영역을 사용할 수 있는 공간을 만들어주는 문법이라고 생각해도 된다. label과 완전히 일치하다.\u001e 컴파일타임에 해석되는 정적인 레이블을 만드는 것이 아니라case 안의 식을 동\u001c적으로 해석할 수 있는 특수한 레이블로 만들었을 뿐이다. switch는 case와 default label만 사용하도록 한다. 우리는 switch 괄호안에 있는 값의 평가된 것을런타임에 평가해서case에 있는 값과 일치하는 label로 보낼 수 있는특수한 레이블 구문을 만들 수 있\u001c는 switch문이라는 것을 알 수 있다. 그 안에 있는 label은 우리가 알고 있는 label과 동일하게 작동한다. 1.2.2 Fall Throughcase문 안에서 break를 \u001c안쓰면 그 다음 case문이 실행되는 현상 break를 걸면, undefined name label로 빠져나오게 된다. switch문 앞에 auto label을 만든다. 1.2.3 Auto Label12345678910&lt;script&gt; switch (true) &#123; default: console.log(&quot;c&quot;); case true: console.log(&quot;0&quot;); case false: console.log(&quot;1&quot;); &#125;&lt;/script&gt; 언어마다 스페셜 label block 해석 방식이 다르다. 자바스크립트에서는 switch의 스페셜 label block을 위에서 아래로 처리한다. 자바나 c같은 언어는 switch를 쓸때 해석하는 방식이 자바스크립트와 다르다. 12345678910111213&lt;script&gt; temp17: switch (true) &#123; default: console.log(&quot;c&quot;); case true: console.log(&quot;0&quot;); break temp17; case false: console.log(&quot;1&quot;); &#125; console.log(&quot;end&quot;);&lt;/script&gt; 자바스크립트 엔진이 break문 뒤에 auto label을 붙여준다고 생각하면 된다. auto label이 발생되는 지점은iteration(for문)이나 switch문 앞에서 발동된다. 1.2.4 Runtime switch자바스크립트에 case문은 runtime에 해석을 한다. runtime에 해석하는 기능때문에 자바스크립트를 2가지 방식으로 switch문을 쓸 수 있게 만든다. 값에 대한 routing으로 (mini router) 특정 값에 대한 routing table 조건 평가에 대한 분기 값에 대한 routing이 정적인 경우 값에 대한 routing에 더 우선순위가 높다. 123456789101112131415161718192021222324&lt;script&gt; // 1. mini router var a = true; switch (a) &#123; default: console.log(&quot;c&quot;); case true: console.log(&quot;0&quot;); break; case false: console.log(&quot;1&quot;); &#125; console.log(&quot;end&quot;); // 2. 조건 평가에 대한 분기 // 디자인패턴 chianable responsibility 패턴 switch (true)&#123; case network() === &#x27;online&#x27;: case network() === &#x27;wifi&#x27;: case network() === &#x27;offline&#x27;: case localcache(): default: // 안내문.. &#125;&lt;/script&gt; 1.2.5 Reverse caseswitch구문이 runtime에 해석된다는 것은 뭐냐?한줄씩 순차적으로 실행된다. switch문을 라우터로 사용하지 않거나, 라우터로 사용하더라도 함수가 개입되거나, 증감현상처럼 상태를 바꾸는 코드가 들어가면 항상 주의해서 써야한다. runtime에서 switch를 해석하는 모든 언어에서 발생한다. python, ruby, javaScript 유의깊에 사용하지 않으면 문제를 일으킨다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"flow control","slug":"flow-control","permalink":"http://feel5ny.github.io/tags/flow-control/"}]},{"title":"Git Submodule로 공용로직 공유하기","slug":"Git_01","date":"2019-01-27T12:23:55.000Z","updated":"2024-11-23T12:26:28.996Z","comments":true,"path":"2019/01/27/Git_01/","permalink":"http://feel5ny.github.io/2019/01/27/Git_01/","excerpt":"","text":"잘못된 점이 있으면 댓글 부탁드립니다 :) 서론한 언어로 여러 프로젝트를 만들다 보면, 공용으로 사용되는 모듈들이 자연스럽게 생성된다. 비즈니스 코어를 모듈화할 수 있고, 또는 언어도 같고, api를 공유하는 프로젝트가 2벌 이상일 경우 http client만 모아있는 모듈을 따로 분리해서 공용화할 수도 있을 것이다. 이렇게 같은 공용 컴포넌트, 공용 모듈을 만들어서 공유할 수 있는 시스템이 구축된다면 공용으로 사용하고 있는 모듈에서 이슈가 생길 경우 작업은 한 번만 이루어 질 수 있기 때문에 생산성이 높아지고, 관리가 용이해진다.git의 submodule을 사용하면 프로젝트 간 공용 모듈을 공유할 수 있다.이 포스트에서는 submodule에 대해서 간단하게 다룰 것이다. 예시는 react + typeScript 기반이다. 부모 프로젝트에서 자식프로젝트의validation class를 사용해 볼 것이다. ## 1. 부모 프로젝트 셋팅하기 submodule_parent라는 이름의 react+TS 프로젝트를 셋팅한다. 1npx create-react-app submodule_parent --scripts-version=react-scripts-ts App.tsx파일에서 form을 생성하여, input의 글자가Email 형식이 아니라면 fail, Email 형식이면 pass 워딩을 보여주는 UI를 만들 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243// App.tsximport * as React from &quot;react&quot;;namespace App &#123; export interface IState &#123; isEmail: boolean; text: string; &#125;&#125;class App extends React.Component&lt;&#123;&#125;, App.IState&gt; &#123; constructor(prop: React.Component) &#123; super(prop); this.state = &#123; isEmail: false, text: &quot;&quot; &#125;; &#125; // validation check onCheckEmail = () =&gt; false 👈👈 ? this.setState(&#123; isEmail: true &#125;) : this.setState(&#123; isEmail: false &#125;); handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; this.setState(&#123; text: e.target.value &#125;); render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.onCheckEmail&#125;&gt;isEamil?&lt;/button&gt; &#123;this.state.isEmail ? ( &lt;h1 style=&#123;&#123; color: &quot;green&quot; &#125;&#125;&gt;Pass&lt;/h1&gt; ) : ( &lt;h1 style=&#123;&#123; color: &quot;red&quot; &#125;&#125;&gt;Fail&lt;/h1&gt; )&#125; &lt;/div&gt; ); &#125;&#125;export default App; email validation 로직은 공용 모듈로 분리해보자. ## 2. 자식 프로젝트 셋팅하기 부모 프로젝트에서 submodule로 추가하기 위해서는 자식 프로젝트를 remote repository에 올려야한다. > 예시를 위해 submodule_child라는 이름을 사용했지만, 실제 프로젝트에 넣어질 이름으로 짓는게 좋다. > ex. validation 12345mkdir submodule_childcd submodule_child# 자식 프로젝트git remote add origin &lt;repository 주소&gt; 해당 폴더에 validation class를 만들었다.현재 예시로 든 부모 프로젝트는 src 아래의 ts파일을 컴파일하도록 설정해놓았다. (src 밖의 ts파일은 컴파일하지 못함.) 만약 js파일로 공용 모듈을 만든다면 상관없지만, ts로 만든다면, src 하위에 submodule을 관리하는 폴더를 두도록 해야 한다. (혹은 경로에 상관없이 tsconfig파일에서 inlcude에 포함하면됨) 1234567891011// validation.tsexport class Validation &#123; email = (email: string): boolean =&gt; &#123; const regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]&#123;2,3&#125;$/; return regexr.test(email); &#125;; phone = (phone: string): boolean =&gt; &#123; const regexr = /^\\d&#123;3&#125;-\\d&#123;3,4&#125;-\\d&#123;4&#125;$/; return regexr.test(phone); &#125;;&#125; 공용으로 사용할 class을 만들었고, push 한다. 현재는 자식브랜치의 master 브랜치에서 작업 후 올렸지만, 부모프로젝트에서 자식프로젝트의 여러 브랜치에 접근할 수 있으므로, 전략적으로 사용해도 된다. 개인적으로는 꼬일 수 있기 때문에 공용모듈은 master만 받는 식으로..하는게 좋지 않을까.. 12git commit -am &quot;first init&quot;git push origin master ## 3. 부모 프로젝트에 자식 프로젝트 submodule로 추가하기 부모 프로젝트의 경로로 가서 아래의 명령어로 submodule을 추가할 수 있다. - 추가시 따로 submodule을 관리하는 폴더가 있다면 해당 경로로 이동 후 add하면된다. 1git submodule add &lt;자식 프로젝트 repository&gt; 추가가 되면 자동으로 .gitmodules파일이 생성되고, 해당 경로에 submodule파일이 fetch된다. 예시의 경우 src 하위에 submodule_child라는 서브모듈을 추가하였다. .gitmodules 파일에는 프로젝트에서 관리하고 있는 서브모듈 목록에 대한 정보가 들어있다. 이 파일도 .gitignore 파일처럼 버전 관리된다. 이 프로젝트를 Clone하는 사람은 .gitmodules 파일을 보고 어떤 서브모듈 프로젝트가 있는지 알 수 있다. 123[submodule &quot;src/submodule_child&quot;]path = src/submodule_childurl = git@github.com:feel5ny/submodule_child.git 깃 크라켄이라는 git client app을 사용하고 있는데, 해당 옵션에도 추가된 것을 확인할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import * as React from &quot;react&quot;;import &#123; Validation &#125; from &quot;./submodule_child/validation&quot;;/********* 👆👆👆 *********/namespace App &#123; export interface IState &#123; isEmail: boolean; text: string; &#125;&#125;class App extends React.Component&lt;&#123;&#125;, App.IState&gt; &#123; validation: Validation; constructor(prop: React.Component) &#123; super(prop); this.validation = new Validation(); this.state = &#123; isEmail: false, text: &quot;&quot; &#125;; &#125; onCheckEmail = () =&gt; this.validation.email(this.state.text) 👈👈 ? this.setState(&#123; isEmail: true &#125;) : this.setState(&#123; isEmail: false &#125;); handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; this.setState(&#123; text: e.target.value &#125;); render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.onCheckEmail&#125;&gt;isEamil?&lt;/button&gt; &#123;this.state.isEmail ? ( &lt;h1 style=&#123;&#123; color: &quot;green&quot; &#125;&#125;&gt;Pass&lt;/h1&gt; ) : ( &lt;h1 style=&#123;&#123; color: &quot;red&quot; &#125;&#125;&gt;Fail&lt;/h1&gt; )&#125; &lt;/div&gt; ); &#125;&#125;export default App; ## 4. 자식 프로젝트 수정 후 부모 프로젝트에서 update하기 공용 컴포넌트는 자주 바뀔 일을 없겠지만, 한번 add 된 이후 update가 있을면 기존 프로젝트에서 pull하는 방식과 마찬가지로 update하면된다. 대신 pull을 이용해 최신 코드를 받길 원한다면 해당 경로로 이동하여 pull을 받아야 한다. - 공식 문서에는 서브 모듈사용 시 수정할 경우 (부모 프로젝트에서 자식 프로젝트 수정할 경우) 주의사항에 대해 자세히 작성되어있으니 읽어보길 권한다. [서브 모듈 사용할 때 주의할 점들](https://git-scm.com/book/ko/v1/Git-%EB%8F%84%EA%B5%AC-%EC%84%9C%EB%B8%8C%EB%AA%A8%EB%93%88#%EC%84%9C%EB%B8%8C%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90%EB%93%A4) 참고.6 Git 도구 - 서브모듈","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"02. Code","slug":"03-DevOps/02-Code","permalink":"http://feel5ny.github.io/categories/03-DevOps/02-Code/"}],"tags":[{"name":"git","slug":"git","permalink":"http://feel5ny.github.io/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://feel5ny.github.io/tags/submodule/"}]},{"title":"CodeSpitz77 1회_Programming & JS elementry","slug":"JS_17","date":"2019-01-22T13:20:19.000Z","updated":"2024-11-23T12:10:16.962Z","comments":true,"path":"2019/01/22/JS_17/","permalink":"http://feel5ny.github.io/2019/01/22/JS_17/","excerpt":"","text":"🌕🌑🌑 코드스피츠 강의 정리록 1. 왜 이렇게 짰니. - 개발 기본을 알아보자.철학&#x2F;가치&#x2F;동기 철학 상대주의적으로 바라보자. 기준 (: 왜 이렇게 짰니?.. 이것만 지켜도 비용절감.) 가치 : 이러이러한 가치를 추구했기 때문에 이렇게 작성하였다. 의사소통 A가 짠 코드를 아무도 못알아보면 비용낭비 단순함 A가 짠 코드가 복잡하여 요건 추가시 더 많은 시간낭비 유연함 A가 짠 코드에 요건추가시 다 뜯어고쳐야하면 비용낭비 원칙 (by Kent Beck) 지역화 A가 짠 코드를 고쳤더니 전체가 영향이 가면 &gt; 비용낭비 중복제거 A가 짠 코드를 고쳤더니 다른 곳은 그대로..&gt; 또 시간투자, 비용낭비 대칭성 예시_Get&#x2F;Set A가 짠 코드에 get은 있는데 set은 없다. 시간낭비 추상적인 원칙도 있고, 컨벤션과같은 구체적인 원칙도 있다. 패턴 (선배들의 경험기반..경험도 반복되면 진리에 가까워짐.) 개발론 설계론 각종 적용 패턴 동기 비용 시간 2. program과 timing 컴퓨터가 뭘까?프로그램이 뭘까? 2-1-1. program language code lint time 컴파일 전에 많은 에러를 잡을 수 있다. lint 타임에서 에러를 잡는게 제일 좋다! 당근 machine language(기계어) compile time file load: file이 메모리에 올라가는 과정 여기서부터 프로그램으로 불린다. load까지 프로그래머의 역할. run: 실행 run time run time에서도 잡지 못하는 에러&#x3D;&gt; context error 개발자들끼리의 의사소통 문제 기획서의 오류 terminate: 종료 2-1-2. script program 😎 일반 프로그램과 다른점은, machine language가 4단계에 있다는 점. 자바스크립트도 이에 해당됨 language code: 코드작성 후 file: js파일을 load: 브라우저에 로드하면 machine language(기계어): 기계어로 바꿔서 run: 실행 (매번 기계어를 바꿀 수 없으니, 캐시를 태워놓기도) terminate: 종료 2-2-1. program runtime컴파일 타임이 없어서 런타임이 중요런타임은 메모리에 적재하여 실행하는 것 loading instruction fetch &amp; decoding(외부버스에서 명령을 가져와 해석) execution (실행) 명령 하나당, 2번과 3번의 반복 메모리에 적재된 프로그램을 cpu가 소개한다. (노이만 머신의 구조) 컴파일 타임에는 실제 메모리를 갖고 있지 않는다.메모리는 런타임때 올려짐. 때문에 가짜 메모리 상에서 시뮬레이션 하며 만든다. 컴파일 타임에 만들어진 파일 속의 코드들은 다 가짜 메모리에 올라가져있음. 로드 시 **가짜메모리 A와 진짜 메모리 A와 매핑해줘야한다. **(virtual memory mapping table &#x3D;&#x3D; VTable) 컴파일러 언어들은 다 갖고있는 순서라고 생각하면된다. essential definition loading: 가장 중요한 것 부터 프로그램에 적재한다. VTable에 매핑한다. run runtime definition loading 자바스크립트에서 런타임 중에 클릭 후 함수를 만들어 낼 수 있다. 실행 후에도 정의물이 나오는 상황 컴파일시점에 확정시키는 것이 아니라 runtime때 2-2-2. script program runtime 여러 레이어로 구성되어있다고 생각해도 된다. 스크립트 프로그램은 컴파일 단계가 없다보니, 런타임을 레이어로 나눠서 관리한다. 3. Memory, Address, Pointer, Variables, Dispatch프로그램 안에서 무슨일이 일어나는지 생각해보자.데이터 부분의 메모리가 어떻게 움직이는지.참조의 참조를 왜 쓰는지를 배우는게 핵심 (linked list, decorator, …) 직접 알지 않고 다른 아이를 통해서 알려고 하지? 3-1. Memory고유한 번호를 주소로 갖는 블럭체계로 되어있다.블럭을 나타내는 주소는 몇자리일까? &#x3D;&gt; 64bit인지 32bit인지 3-2. 메모리 모델(포인터 개념) A = &quot;TEST&quot; &amp;A = 11 (C언어에서 주소값의 변수 앞에 &amp;를 사용한다.) B = &amp;A *B = &quot;TEST&quot; 직접참조의 위험성 어떤 변수를 외부에 공개할 때 사용처를 확정지을 수 없다. 누가 어떻게 쓸지 모른다. 통제권을 벗어난다. C = B, D = B, ... : C와 D는 B를 바라보고있다. B의 배신.. B = &amp;K : 주소값이 바꾸었다. B가 변경되었기 때문에 당연히 C,D도 바뀔거라 생각하지만, 아니다. 직접참조를 피하는 이유이다. 참조를 복사했을 때 꼭 이렇다. 함수형 패러다임에서는 참조를 피하려고한다. double dispatch를 통해 해결할 수 있다. 12B = &#123; value: &amp;A, V: 3 &#125;C = B, D = B, ... B가 직접참조하지않고, 간접적으로 참조하게 만들었다.Dispatch: 주소로부터 값을 얻는 행위 Double Dispatch 자료구조에서 linked list의 원리 객체지향에서는 인터페이스와 클래스의 관계 B가 배신을 때려도 대응할 수 있다. 3-3. Lexical Grammar (어휘적인 측면의 문법) Control Character 제어문자 White Space 공백문자 Line Terminators 개행문자 Comments 주석 Keyword 예약어 Literals 리터럴: 더이상 나눌 수 없는 객체나 값의 표현 3-4. Language Element자바스크립트는 아래의 큰 3가지 카테고리로 나눌 수 있다. 3-4-1. Statements: 문 컴파일러 혹은 실행기에게 주는 힌트이다. 메모리에 남는 개념이 아니다. 처리하고 끝낸다. Control Statement ex. If, For, While … ex. ruby는 문이라는 개념이 없다. 문을 나누는 기준에는 2가지가 있다. 공문, 식문, 제어문, 선언문 공문: 아무것도 없는 문 for(var i=0; i&lt;5; i++); &#x3D;&gt; 에러가 없다. 공문의 기준은 ; 식문: 제어문: 선언문: 메모리 상의 변수를 할당하는 일 단문, 중문 if(true); if(true) a = 3; else b = 5 에러가 나지 않는 이유if 절의 정의 : if(condition1) statement1 else statementN if (true) a=3; else if (a &gt; 2) b = 3; else b =5; if (true) a=3; else &#123;if (a &gt; 2) b = 3; else b =5;&#125; 암묵적으로 위처럼 줄괄호가 있다고 생각하는 것. else if절이 있는 것이 아니라,앞부분의 if else절의 else가 갖고 있는 if else절이라고 생각하자. 중괄호는 중문에서 많이 쓰인다. 3-4-2. Expresssion: 식 식의 결과는 언제나 하나의 값으로 수렴되다. 값식, 연산식, 호출식 3;5;6; 하나의 값식을 식문으로 인지하기 때문에 에러나지 않는다. 3-4-3. Identifier 식별자 변수를 의미한다. 기본형, 참조형 4. 흐름프로그래밍: 메모리에 적재되어있는 명령어의 연쇄(flow)Sync Flow &#x2F; Flow Control &#x2F; Sub Flow 4-1. Sync Flow 메모리에 적대되어있는 명령어를 실행하는 동안 우리는** 간섭을 못한다.** 동기화 흐름, 동기화 로직 이라고 한다. 4-2. 흐름제어 (flow control) 일자로 흐르는 sync flow를 제어할 수 있기 때문에 흐름제어라고 부른다. 4-3. sub flow 어떤 흐름은 반복적으로 쓰이기도 한다. 함수나 클래스를 이용한다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"programming","slug":"programming","permalink":"http://feel5ny.github.io/tags/programming/"}]},{"title":"안녕 2018, 안녕 2019","slug":"Joylog_002","date":"2019-01-13T12:23:55.000Z","updated":"2024-11-23T11:39:30.473Z","comments":true,"path":"2019/01/13/Joylog_002/","permalink":"http://feel5ny.github.io/2019/01/13/Joylog_002/","excerpt":"","text":"1. 전쟁같던 2018년 2018년 1월 개발자로서 처음 실무에서 일하기 시작하였다. **업무 적응, 비즈니스 로직을 이해, 부족한 실력을 올리기 위해** 정신없는 하루하루를 보냈다. 얼마나 달렸냐면 전환일 기준으로 사용할 수 있는 연차가 9개였는데, 12월에 확인해보니 8개나 남아있었다..(좀 쉬엄쉬엄할걸!) 그래도 이런 전쟁 같은 상황에서 달릴 수 있었던 이유는, 전쟁 속에서도 **배움**이 있었기 때문이다. 그밖에도 외부활동도 최소 1가지는 하였다. 사내분들 이외의 분들도 만나고 싶었고, 커뮤니티도 참여하고 싶었기 때문이다. 예전만큼은 아니지만, 종종 외주작업도 들어오곤 했는데, 이젠 점점 줄이는 추세로 갔다. 아무래도 지금은 선택과 집중을 해야 했기 때문에.. 1.1 업무를 통해 배우다.업무는 다양하게 요청 들어왔다.내가 잘 구현할 수 있는 부분도 있었고, 생소한 기술을 사용해야 하는 부분도 있었다. 생각지 못한 버그들을 맞닥드릴 때도 있었다. 혼자서 하고 싶은 작업만 했다면 이런 이슈들은 만나보지 못했을 것이다.경험해보지 못했던 버그들을 고치거나, 기능을 구현해야 할 때, 그것을 공부하고 블로그에 정리하는 일은 뿌듯함과 성취감을 가져다 주곤 했다. 또한 아직 부족한 부분에 대해서도 인지할 수 있게 되는 계기가 되었다. 1.2 외부활동을 통해 나를 되돌아보다. 일주일 중 70프로를 회사 동료들과 함께 보낸다.부정적인 시선으로 본다면, 우물 안 개구리가 될 수도 있고, 커뮤니티의 영역이 좁아질 수 있었기 때문에 부담 없는 외부활동을 하고 싶었다. 꼭 오프라인 활동을 하지 않아도 말이다. 체력이 약해진 터라 외부활동은 최대한 자제하고 ㅎㅎ 시간을 많이 뺏을 것 같은 활동도 우선은 고려하지 않았다. 아직 공부에 투자를 많이 해야 할 시기이기 때문.. 온라인으로 활동할 수 있는 커뮤니티를 찾다가 우연히 개발자 글쓰기 모임을 알게 되어 지금까지 꾸준히 참여 중이다. 외부활동의 장점은 나를 되돌아볼 수 있다는 점이다. 회사에서 잠시 한발자국 물러나 나를 바라볼 수 있는 잠깐의 시간을 가질 수 있도록 도와주기 때문에, 일정 기간마다 자기 객관화를 할 수 있도록 도와준다. 그리고 글쓰기 습관이 붙은 덕분에 2018년에는 45개의 글을 작성할 수 있게 되었다. ( 글또 1기 회고글 ) 1.3 취미활동 취미활동 취미활동.. 예전에는 기타치는걸 좋아했다! 예전이라 함은 디자인으로 수입이 있을때의 시기. 지금은 개발자가 되었기에 오히려 디자인작업이 리프레쉬할 수 있는 활동이 되었다. 아무래도 꾸준히 해왔던 커리어 중 하나였기 때문에 작업할 때 편안하고, 쉽게 놓지 못하는 부분도 있다. 올해는 캐릭터 작업 외주, 간단한 인포그래픽 영상, 웹 디자인 작업이 들어왔다. 웹디자인 작업건이 제일 덩어리가 컸었는데, 시간을 너무 많이 들여야 해서 그 이후에는 정말 간단하게 작업할 수 있는 외주만 받았다. 작업물이 아까워서 드리블에 올렸는데 얼마 지나지 않아 바로 드리블에 초대되기도 했다. (예전엔 드리블 초대장 받으려고 그렇게 노력했건만!) 2. 어떤 개발자가 되고 싶은건가?2018년도는 여러 면에서의 적응을 위해 내면을 깊게 들여다보지 못했다. 때문에 힘들 때 자주 흔들리곤 했는데, 그때마다 why를 외쳤다. 초심을 되돌아보고, 앞으로 어떤 방향으로 나아갈지 간략하게라도 정리를 하곤 했다. 자, 그래서 난 어떤 개발자가 되고 싶은가. 사실 제일 core는 내가 만든 기능으로 타인에게 도움 주기다. 한 번에 이룰 수 없다는 걸 알기 때문에 롱런을 위해서 재미있게 나아가려고 한다. 자연스럽게, 실력을 쌓으면서 재미와 흥미를 느낄 수 있는 부분은 뭐가 있을까로 고민하게 되었다. 2.1 UX를 잘 알고 디벨롭할 수 있는 개발자 갑자기 ux이야기가 나왔다. 프론트엔드 개발자, 그리고 디자인에 관심 있는 사람으로서, 서비스의 첫인상과 신뢰성은 기능도 기능이지만, 사용성도 매우 중요하다고 생각한다. 지금까지 화려하고, 미적으로 아름다운 디자인들, ux가 잘 녹여있는 디자인들을 보았지만, 구현에서 실패하거나, 프론트엔드 개발자가 생각하는 디자인에 대한 중요성 정도 때문에 톤앤매너가 지켜지지 못한 구현물을 보곤 했다. 이런 상황의 해결을 위해서는 디자이너가 개발 친화적으로 디자인을 하거나, 개발자가 디자인시스템을 이해하여 디자이너에게 부족한 시안을 제안해야 한다는 점이다. 전자에 대한 관심도는 요즘 올라가고 있지만 후자는 아직 잘 모르겠다. ux관련 지식을 쌓아 유연하게 적용할 수 있도록 하여 서비스의 품질을 높이는 개발자가 되고 싶다! 2.2 배려심이 있는 믿음을 주는 동료 서비스는 작업자가 한 명이 혼자서 절대 작업할 수 없다. 협업이 필수인데, 바로 전후 단계에 밀접하게 붙어있는 작업자부터, 타 부서의 협력자들까지, 그들에게 믿음을 주는 동료가 되어야 한다고 생각한다. **이는 간단하게 보이면서도 디테일한 부분이라고 생각한다.** 배려심이라는 단어는 추상적이지만, 간단하게 말하자면 개발자는 비개발자들과 협업 시 최대한 그들이 이해하는 언어로 설명해주고, 문서화하는 것. 개발자들과는 나의 작업이 영향이 있을 협업자들과의 커뮤니케이션을 유연하게 하는 것. 진짜 진짜 기본적인 것인데 의외로 간과하는 사람들이 있는 것 같다. 서로 배려하는 문화는 좋은 서비스를 만드는 중요한 부분이라고 생각한다. 3. 스스로에게 증명하는 해, 2019년사실 이런 계획은 이렇게 글이나 혹은 다른 이에게 말로써 이렇게 할 것이다를 얘기하지만, 실제로 실행에 옮기기에는 많은 의지와 시간이 필요하다. 이렇게 정리하는 나도 ㅎㅎ 스스로에게 살짝 의구심은 들지만, 구체적으로 정리하는 것만으로도 실행의 동기를 구체화 시켜준다.무튼, 서론이 길었지만, 올해는 앞으로의 계획 중 하나라도 성취할 수 있도록 실행에 옮겨 스스로에게 보여주고 싶고, 잘 나아가고 있다고 말해주고 싶다. 3.1 디자인 시스템 이해도 높이기 다른말로 antd 파해쳐보기.최근들어 antd를 프로젝트에 적용해 보았는데, antd에서 정리해둔 디자인 시스템의 원칙에 대해서 이해하고 코드를 분석해볼 필요가 있다고 생각했다. 이는 추후 antd를 적용하지 않아도, 기본 뼈대를 잘 설계할 수 있도록 도와줄 수 있다고 생각한다. 3.2 기본 실력 키우기두말하면 잔소리.. 커뮤니케이션도 중요하지만 실력도 당연히 중요..올해는 알고리즘을 꾸준히 풀어보려고 한다!! 자바스크립트 알고리즘 … 3.3 포티폴리오 작업하기스스로에게 증명하는 해라는 키워드에서 가장 중요한 할 일 중에 하나이다. 올해는 내가 재밌어하는 분야(마블, 해리포터, 반지의 제왕..)를 믹스하여 재밌는 서비스를 만들어 보고 싶다.실제 사용할 수 있는 수준까지! > [포터모어](https://www.pottermore.com/)","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"Joy","slug":"Joy","permalink":"http://feel5ny.github.io/tags/Joy/"},{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/tags/blog/"}]},{"title":"Typescript의 Generic을 사용해보자.","slug":"Typescript_14","date":"2018-12-09T06:13:22.000Z","updated":"2024-11-23T12:13:06.930Z","comments":true,"path":"2018/12/09/Typescript_14/","permalink":"http://feel5ny.github.io/2018/12/09/Typescript_14/","excerpt":"","text":"TL;DR**제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다. **한 번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다. 리액트 + 타입스크립트로 프로젝트를 진행하면서 재밌는 이슈에 많이 부딪하고 있다. 그래도 재밌다고 느낀 이유는 부딪힐 때마다 해결 방법을 타입스크립트에서 제공해줬기 때문..이슈 중에 하나는, 비동기 처리를 promise와 async await를 사용하여 작업하고 있는데, 리턴값의 타입을 명시하기가 시점에 따라 달랐기 때문에 실행 시점에 타입을 명시하고 싶었다. 처음에는 예상되는 타입을 await를 받는 변수에 타입을 명시했는데 제네릭은 이를 해결할 수 있는 방법이었다. 1. 제네릭이란.**제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다. **한 번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다. 즉, 선언 시점에서는 제네릭으로 타입을 받을 부분을 뚫어놓고(?) (템플릿화 &lt;T&gt;) 실행 시점에 제네릭으로 타입을 명시하는 것이다. 실행 시점에 제네릭으로 타입을 명시하게 되면, &lt;T&gt;로 뚫어놓은(?) 템플릿에 타입이 명시되면서, 실행 시점에 맞는 타입을 정의할 수 있다. 마치 함수에서 인자를 받는 형태와 비슷하다. 너무 나만의 언어로 설명한 거 같으니.. 코드를 봅시다! T는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 타입 파라미터(Type parameter)라 한다. T는 Type의 약자로 반드시 T를 사용하여야 하는 것은 아니다. 2. 제네릭 사용방법 2번은 공식문서에 있는 내용이니 넘어가도 된다. 제네릭 없이 간단한 identity function을 만들어보자. 123function identity(arg: number): number &#123; return arg;&#125; any 타입을 사용할 수도 있다. 123function identity(arg: any): any &#123; return arg;&#125; any를 사용할 때는 arg가 모든 타입을 받을 수 있기 때문에 공용적으로 사용 가능하지만, 어떤 값을 반환 할지에 대한 정보는 알 수가 없다. 만약 인자와 반환자의 타입을 같게 하고, 이를 공용적으로 사용하고 싶을 경우 제네릭을 사용하면 된다. 1234function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;// 제네릭으로 넣은 타입을 인자와 반환 타입으로 공용적으로 사용하고 있다. 호출 시 아래처럼 제네릭으로 명시하면 된다.두 번째 줄은 제네릭으로 명시하지 않았는데, 이는 인자로 넣어지는 ‘myString’타입으로 인해 컴파일러가 자동으로 T의 타입을 정의하기 때문이다. 12let output = identity&lt;string&gt;(&quot;myString&quot;); let output = identity(&quot;myString&quot;); identity 함수의 타입을 명시할 때도 제네릭을 명시할 수 있다.&lt;T&gt;(arg: T) =&gt; T 알파벳은 표현을 위한 수단이기 때문에 알파벳이 달라져도 상관없다. object 리터럴 타입으로도 명시 가능하다. 12let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 위의 코드를 인터페이스로 표현한다면? 12345interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;let myIdentity: GenericIdentityFn = identity; 재밌게도!! 인터페이스에서 제네릭을 명시하게 할 수도 있다. 12345678910111213141516interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity;myIdentity(&quot;1&quot;);// [ts] &#x27;&quot;1&quot;&#x27; 형식의 인수는 &#x27;number&#x27; 형식의 매개 변수에 할당될 수 없습니다. [2345]let myIdentity2: &#123;&lt;T&gt;(arg: T): T&#125; = identity;myIdentity2&lt;number&gt;(&quot;1&quot;);// [ts] &#x27;&quot;1&quot;&#x27; 형식의 인수는 &#x27;number&#x27; 형식의 매개 변수에 할당될 수 없습니다. [2345] 클래스에서도 제네릭을 명시할 수 있다. 123456class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;(); 타입스크립트를 리액트와 함께 사용할 때 자주 볼 수 있는 패턴이다. 123class Component extends React.Component&lt;Props, State&gt;&#123;...&#125; 제네릭은 인터페이스를 상속받을 수도 있는데, 제네릭을 명시한 함수에서 특정 타입이 들어올 것을 예상하고 로직을 작성해야 할 경우에 인터페이스를 상속받아 사용 가능하다. 123456789interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125; 3. 제네릭은 이런 상황에서는 무의미한 사용이다.typeScript deep dive 문서를 보면, 사람들은 제네릭을 heck스러운 방법으로 사용할 때가 있다고 한다.개발자가 제네릭을 사용할 때! 어떤 부분을 강제할 것인지에 대해 제대로 설명하지 못한다면 제네릭을 사용할 필요가 없다고 한다. 🙅 #1아래 코드를 보면, 제네릭을 명시했지만, 인자 하나에서만 사용되고 있다.이렇게 하나의 인자를 위해서 제네릭으로 받는 상황에서는 제네릭은 쓸모없는 무의미한 명시다. 123declare function foo&lt;T&gt;(arg: T): void; declare function foo(arg: any): void; 🙅 #2아래의 상황에서는 제네릭의 T가 리턴 값으로 한 번만 사용되었다.type assertion 방법과 딱히 다르지 않다.오직 리턴 값 한 번만 사용하기 위한 제네릭은 타입 안정성 측면에서 어셜션보다 나은 방법은 아니다. 12345declare function parse&lt;T&gt;(name: string): T;declare function parse(name: string): any;const something = parse(&#x27;something&#x27;) as TypeOfSomething; 그렇다면 어떤 상황에 사용해야 제네릭을 적합하게 사용하는 것일까.api로 응답 값을 받을 때 제네릭을 사용하면 굉장히 편리하게 사용할 수 있다. 4. ajax콜 이후의 응답 타입을 명시할 때fetch로 github 정보를 받아오는 함수가 있다고 가정하자. (async, await 사용) 123456789const githubUser = await fetchGithubInfo()const fetchGithubInfo = async () =&gt; &#123; const rep = await fetch(&#x27;https://api.github.com/users/feel5ny&#x27;,&#123; method: &quot;GET&quot;, &#x27;Accept&#x27;: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\\ &#125;) return rep.status &gt;= 500 ? null: rep.jsoin()&#125; 제네릭을 몰랐을 때는 아래처럼 써주었다… 1const githubUser: GithubRep | undefined | null = await fetchGithubInfo() 이런 말도 안 되는 8ㅅ8githubUser에는 await 함수가 할당되어있는 상황이기 때문에 Promise 타입을 명시해야 맞는 상황. 때문에 아예 fetchGithubInfo에서 제네릭으로 타입을 받게 변경하였다. 12345678const fetchGithubInfo = async &lt;T&gt;(): Promise&lt;T | null&gt; =&gt; &#123;const rep = await fetch(&#x27;https://api.github.com/users/feel5ny&#x27;,&#123; method: &quot;GET&quot;, &#x27;Accept&#x27;: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,\\ &#125;) return rep.status &gt;= 500 ? null: rep.json()&#125; 1const githubUser= await &lt;GithubRep&gt;fetchGithubInfo() 깔끔! 추후에는 아예 ajax 콜 모듈화한 함수에서 제네릭을 자주 사용하게 되었다. 참고 https://poiemaweb.com/typeScript-generic https://basarat.gitbooks.io/typeScript/docs/types/generics.html https://www.typescriptlang.org/docs/handbook/generics.html","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. TypeScript","slug":"01-Web/03-TypeScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-TypeScript/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"Redux-observable 예제 따라해보기 (feat. React + TypeScript)","slug":"Async_05","date":"2018-11-25T11:12:34.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/11/25/Async_05/","permalink":"http://feel5ny.github.io/2018/11/25/Async_05/","excerpt":"","text":"오류가 있다면 언제든지 지적해주세요.코드: https://github.com/feel5ny/redux-observable-practice https://www.youtube.com/watch?v=AslncyG8whgNot familiar with Observables&#x2F;RxJS v6?redux-observable requires an understanding of Observables with RxJS v6. If you’re new to Reactive Programming with RxJS v6, head over to http://reactivex.io/rxjs/ to familiarize yourself first. redux-observable (because of RxJS) truly shines the most for complex async&#x2F;side effects. If you’re not already comfortable with RxJS you might consider using redux-thunk for simple side effects and then use redux-observable for the complex stuff. That way you can remain productive and learn RxJS as you go. redux-thunk is much simpler to learn and use, but that also means it’s far less powerful. Of course, if you already love Rx like we do, you will probably use it for everything! If you’re not already comfortable with RxJS you might consider using redux-thunk for simple side effects and then use redux-observable for the complex stuff. “만약 당신이 아직 rxjs에 익숙하지 않다면, 간단한 사이드이팩트용으로는 redux-thunk를 사용하는 걸 고려하고, 복잡한 stuff에서는 redux-observable을 사용하는 것이 좋습니다.” 링크 그래서 한번 공부해보기로 했다. ## 1. Basic ### 1.1 epic이라는 개념 리덕스 옵저버블에는 epic이라는 구조를 사용한다. 1function (action$: Observable&lt;Action&gt;, state$: StateObservable&lt;State&gt;): Observable&lt;Action&gt;; It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out. 에픽함수는 액션스트림을 가져가고, 액션스트림을 반환하는 함수이다. 간단하게 말하자면, action 객체를 store에서 ActionObservable로 얻게되는데, 에픽에서는 액션 옵저버블을 스토어에서 받아서 추가적인 처리후 다시 옵저버블로 반환할 수 있다. 추가적인 처리에는 rxjs의 operator 등을 사용한다. 1.2 미들웨어 셋팅 createEpicMiddleware를 사용한다.store로 들어오는 action객체를 옵저버블로 반환하는 역할을 한다. redux 상태변화를 관찰하기 위해 logger 셋팅. store에 리듀서와 미들웨어를 적용하면서 create한다. epic을 모아둔 rootEpic을 등록한다. 1234567891011121314151617181920// store.tsimport &#123; applyMiddleware, createStore &#125; from &quot;redux&quot;;import &#123; createEpicMiddleware &#125; from &quot;redux-observable&quot;;import logger from &quot;redux-logger&quot;;import &#123; rootReudcer &#125; from &quot;./reducers&quot;;import &#123; rootEpic &#125; from &quot;./epics&quot;;const epicMiddleware = createEpicMiddleware();export default function configureStore() &#123; const store = createStore( rootReudcer, applyMiddleware(epicMiddleware, logger) ); epicMiddleware.run(rootEpic); return store;&#125; 12345678910// createEpicMiddleware : index.d.ts...export declare interface Epic&lt;Input extends Action = any, Output extends Input = Input, State = any, Dependencies = any&gt; &#123; (action$: ActionsObservable&lt;Input&gt;, state$: StateObservable&lt;State&gt;, dependencies: Dependencies): Observable&lt;Output&gt;;&#125;export interface EpicMiddleware&lt;T extends Action, O extends T = T, S = void, D = any&gt; extends Middleware &#123; run(rootEpic: Epic&lt;T, O, S, D&gt;): void;&#125;export declare function createEpicMiddleware&lt;T extends Action, O extends T = T, S = void, D = any&gt;(options?: Options&lt;D&gt;): EpicMiddleware&lt;T, O, S, D&gt;; 1.3 액션 셋팅깃헙에서 정보를 받아오는 ajax요청 처리를 해보자. 액션파일에는 시작액션 FETCH_USER 성공액션 FETCH_USER_FULFILLED 실패액션 FETCH_USER_REJECTED 취소액션 (이건 필요에 따라) FETCH_USER_CANCELLED 12345// 액션 타입export const FETCH_USER = &quot;FETCH_USER&quot;;export const FETCH_USER_FULFILLED = &quot;FETCH_USER_FULFILLED&quot;;export const FETCH_USER_CANCELLED = &quot;FETCH_USER_CANCELLED&quot;;export const FETCH_USER_REJECTED = &quot;FETCH_USER_REJECTED&quot;; 1234567891011121314// 액션 함수export const cancelFetch = () =&gt; (&#123; type: FETCH_USER_CANCELLED&#125;);export const fetchUser = (username: string) =&gt; (&#123; type: FETCH_USER, payload: username&#125;);export const fetchUserFulfilled = (payload: any) =&gt; (&#123; type: FETCH_USER_FULFILLED, payload&#125;); 1.4 reducer 셋팅1234567891011121314151617181920212223242526272829303132const users = ( state = &#123; joy: &#123; avatar_url: &quot;&quot; &#125;, error: &quot;&quot;, isFetchingUser: false &#125;, action: ActionInterface) =&gt; &#123; switch (action.type) &#123; case FETCH_USER: return &#123; ...state, isFetchingUser: true &#125;; case FETCH_USER_FULFILLED: return &#123; ...state, joy: action.payload, isFetchingUser: false &#125;; case FETCH_USER_REJECTED: return &#123; ...state, error: action.payload, isFetchingUser: false &#125;; case FETCH_USER_CANCELLED: return &#123; ...state, isFetchingUser: false &#125;; default: return state; &#125;&#125;;export const rootReudcer = combineReducers(&#123; ping: pingReducer, user: users&#125;); ## 2. epic 작업 - epic이 여러개가 있을 경우 combineEpics를 사용한다. - 도트체이닝 없이 pipe를 사용하여 순차적으로 받아서 처리한다. - action type에 따라 처리하기 위해 redux-observable의 `ofType` 메서드를 사용한다. - `mergeMap`: 내부 옵저버블이 방출되면, 해당 값을 바깥 옵저버블과 함께 병합한다. - `race`: 레이스 오퍼레이터. 인자로 들어온 옵저버블 중에 제일 빨리 처리된 옵저버블을 반환한다. - `delay`: 해당 초만큼 딜레이 이후 다음 오퍼레이터를 실행한다. - `takeUntil`: 특정 액션이 들어올 때 동작을 취소할 수 있다. - `catchError`: 에러 핸들링 123456789101112131415161718192021222324252627export const fetchUserEpic = ( action$: Observable&lt;Action&gt;, state$: StateObservable&lt;any&gt;): Observable&lt;Action&gt; =&gt; &#123; return action$.pipe( ofType(FETCH_USER), mergeMap((action: ActionInterface) =&gt; race( ajax.getJSON(`https://api.github.com/users/$&#123;action.payload&#125;`).pipe( delay(1000), map(response =&gt; fetchUserFulfilled(response)), takeUntil(action$.pipe(ofType(FETCH_USER_CANCELLED))), catchError(error =&gt; of(&#123; type: FETCH_USER_REJECTED, payload: error.xhr.response, error: true &#125;) ) ) ) ) );&#125;;export const rootEpic = combineEpics(fetchUserEpic, ...); 참고 https://redux-observable.js.org/docs/basics/Epics.html https://blog.sapzil.org/2017/07/16/redux-observable/ https://wonism.github.io/redux-saga-vs-redux-observable/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"redux","slug":"redux","permalink":"http://feel5ny.github.io/tags/redux/"},{"name":"observable","slug":"observable","permalink":"http://feel5ny.github.io/tags/observable/"},{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"2부/ chap01. RxJs란 무엇인가?","slug":"Async_04","date":"2018-11-18T11:12:34.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/11/18/Async_04/","permalink":"http://feel5ny.github.io/2018/11/18/Async_04/","excerpt":"","text":"**[📕 퀵스타트 Rxjs]**를 보고 메모한 부분을 정리했습니다. 1. RxJS란?RxJS is a library for composing asynchronous and event-based programs by using observable sequences.RxJS는 Observable를 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기 위한 라이브러리이다.(범용적인 데이터 플로우 솔류션을 지향하는 라이브러리라고 책 저자가 정의함) 2. RxJS 시작하기 2.1 RxJS 첫번째 예제목표: 페이지를 클릭했을 경우 event.currentTarget정보를 콘솔로 출력해보자. 12345const &#123;fromEvent&#125; = rxjs;const click$ = fromEvent(document, &#x27;click&#x27;);// 1. fromEvent : 타겟의 이벤트를 옵저버블로 변환한다. const observer = event =&gt; &#123; console.log(event.currentTarget)&#125;click$.subscribe(observer); fromEvent(target: EventTargetLike, eventName: string, selector: function): Observableclick 옵저버블을 구독하고, 옵저버블에서 데이터가 전달되면 옵저버함수가 받는다.이는 addEventListener를 통한 이벤트 핸들러 등록과 유사하다.둘의 차이점은 브라우저를 통해 전달되는 이벤트 정보를 Observable로 변환하는 작업을 추가로 한다는 점 2.2 RxJS 첫번째 예제 개선하기실제 우리가 필요한 정보는 click이 아니라 click이후의 currentTarget정보 pluck 오퍼레이터를 이용하자.pluck(properties: ...string): Observablepluck은 사전적으로 ‘~을 뽑다’라는 의미이다. 추출할 속성들을 ‘문자열’로 지정할 수 있다. pipe 오퍼레이터를 사용하여 파라미터로 전달된 오퍼레이터들이 적용된 새로운 Observable 인스턴스를 반환한다. 12345const &#123;fromEvnet&#125;= rxjs;const &#123;pluck&#125; = rxjs.operators;const currentTarget$ = fromEvent(document, &#x27;click&#x27;).pipe( pluck(&#x27;currentTarget&#x27;) );const observer = currentTarget =&gt; &#123;console.log(currentTarget)&#125;currentTarget$.subscribe(observer) cf__1. RxJS에서 pipe 오퍼레이터를 적용하여서 도트 체이닝없이 오퍼레이터를 받는다.pipe는 처리되어야할 작업들을 순차적으로 받아서 처리한다.pipe(operations: ...): Observable 12345678910111213// 도트체이닝ajax$ .switchMap(data=&gt;...) .filter(user =&gt; ...) .map(user =&gt; ...)// pipe 오프레이터ajax$ .pipe( switchMap(data =&gt; ...), filter(user =&gt; ...), map(user =&gt; ...) ) 도트 체이닝을 구성하기 위해서는 옵저버블 객체가 모든 오퍼레이터를 가지고 있어야한다. Observable.prototype에 사용하는 모든 오퍼레이터가 추가된다. rxjs사용시 불필요한 오퍼레이터를 모두 가지고 있어야 하기 때문에 파일 사이즈를 증가시킨다. pipe오퍼레이터를 사용하면 트리세이킹(tree shaking: 사용하지 않는 모듈을 번들링할 때 제거하는 기능)을 자유롭게 할 수 있다. pipe 오퍼레이터는 함수형태로만 오퍼레이터가 만들어지기 때문에Observable과의 결합도를 떨어뜨려 더더욱 쉽게 오퍼레이터를 작성할 수 있다. 2.3 RxJS 두번째 예제1234567const a = [ &#123;name: &#x27;유비&#x27;, nationality: &#x27;촉&#x27;&#125;, &#123;name: &#x27;손권&#x27;, nationality: &#x27;오&#x27;&#125;, &#123;name: &#x27;관우&#x27;, nationality: &#x27;촉&#x27;&#125;,].filter(user=&gt; user.nationality === &#x27;촉&#x27;)const log = user =&gt; console.log(user);a.forEach(log) from(ish: ObservableInput, mapFn: function, thisArg: any, scheduler: Scheduler): Observable 123456789const &#123;from&#125; = rxjs;const &#123;filter&#125; = rxjs.operators;const a$ = from([ &#123;name: &#x27;유비&#x27;, nationality: &#x27;촉&#x27;&#125;, &#123;name: &#x27;손권&#x27;, nationality: &#x27;오&#x27;&#125;, &#123;name: &#x27;관우&#x27;, nationality: &#x27;촉&#x27;&#125;,]).pipe(filter(user=&gt; user.nationality === &#x27;촉&#x27;))const oberver = user =&gt; console.log(user);a$.subscribe(observer); ---- ## 3. RxJS 4대 천왕 1. Observable 2. 오퍼레이터 3. Observer 4. Subscription --- 5. Subject 6. Scheduler > 다른장에서 설명 3.1 Observable시간을 축으로 연속적인 데이터를 저장하는 컬렉션을 표현한 객체이다.Observable은 데이터를 제공하는 소스를Observer에게 전달한다.이를 **스트림(stream)**이라고 부른다. 3.2 오퍼레이터Observable을 생성 및 조작하는 함수를 오퍼레이터(operator)라고 한다.오퍼레이터는 Observable을 생성하기도 하고,각각의 Observable을 연결하기도 한다.Observable을 분리하거나 합치기도 한다. 오퍼레이터는 현재의 Observable 인스턴스를 기반으로 항상 새로운 Observable 인스턴스를 반환한다. 3.3 ObserverObservable에 의해 전달된 데이터를 소비하는 주체이다.Observers는 next, error, complete함수를 가진 객체를 가리킨다. Observable에 의해데이터가 전달될 때는next함수가 호출되고에러가 발생했을 때는 error함수,데이터 전달이 완료되었을 때는 complete함수가 호출된다. Observer과 Observable은 subscribe 메소드를 통해 연겨로딘다. Observable.prototype.subscribe 함수subscrie는 Observer를 파라미터로 받는다. Observer객체를 전달하는 subscribe 사용 예 123456const observer = &#123; next: x =&gt; console.log(&#x27;Observer가 Observable로부터 받은 데이터: &#x27; + x), error: err =&gt; console.error(&#x27;Observer가 Observable로부터 받은 에러 데이터: &#x27; + err), complete: () =&gt; console.log(&#x27;Observer가 Observable로부터 종료되었다는 알림을 받을 경우&#x27;)&#125;;click$.subscribe(observer) // observer객체를 파라미터로 받는다. next 콜백함수를 전달하는 subscribe 사용 예 1click$.subscribe(x =&gt; console.log(&#x27;Observer가 Observable로 부터 받은 데이터: &#x27; + x)) next, error, complete 콜백 함수를 전달하는 subscribe 사용 예 12345click$.subscribe( x =&gt; console.log(&#x27;Observer가 Observable로 부터 받은 데이터: &#x27; + err), err =&gt; console.error(&#x27;Observer가 Observable로부터 받은 에러 데이터: &#x27; + err), () =&gt; console.log(&#x27;Observer가 Observable로부터 종료되었다는 알림을 받을 경우&#x27;)) 3.4 SubscriptionObservable.prototype.subscribe의 반환값Subscription은 자원의 해제를 담당unsubscribe 메소드를 호출하여 자원해제 가능 12345...const subscription = currentTarget$.subscribe(observer);// subscription으로 자원 해제 가능subscription.unsubscribe(); 4. RxJS 개발 방법RxJS를 사용하여 개발할 경우 프로세스는 대부분 다음과 같은 과정 첫째, 데이터 소스를 Observable로 변경한다. 둘째, 오퍼레이터를 통해 데이터를 변경하거나 추출한다. 또는 여러개의 Observable을 하나의 Observable로 합치거나 하나의 Observable로 만든다. 셋째, 원하는 데이터를 받아 처리하는 Observer를 만든다. 넷째, Observable의 subscribe를 통해 Observer를 등록한다. 다섯째, Observable 구독을 정지하고 자원을 해지한다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"rxjs","slug":"rxjs","permalink":"http://feel5ny.github.io/tags/rxjs/"}]},{"title":"글또 2기_개발자는 어떤 글을 쓰게 될까?","slug":"Joylog_001","date":"2018-11-10T16:23:55.000Z","updated":"2024-11-23T11:39:41.175Z","comments":true,"path":"2018/11/11/Joylog_001/","permalink":"http://feel5ny.github.io/2018/11/11/Joylog_001/","excerpt":"","text":"TL;DR정리해보니 회고가 더 길어졌다..2기 다짐의 핵심은 프로그래밍 의식적 연습하기!! ## 1. 1기 회고 2018년 2월부터 시작된 글쓰기 모임. [글또](https://www.facebook.com/groups/375431516259701/?ref=group_header)!(글쓰는 또라이) 글을 꾸준히, 성실하게! 쓰고 싶다는 생각이 들 즈음, [성윤](https://zzsza.github.io)님의 글또 모집 공고를 보고 바로 지원하게 되었었다. 1기 다짐은 [스팀잇](https://steemit.com/lets-writing/@joy.kim/2rmmkw?fbclid=iwar0u8fm-buus-ni5lx7nn9zn0wsrmcffjj94ayiutwvi-4q0twcpdnv7ses)에 엄청난 열정으로 썼었는데 ㅋㅋㅋ 다시 보니.. 뭐랄까 대학교 1학년 때 모든 수업을 1교시에 넣었던 무모한 열정이 느껴진다.. > 아니야..!! 1기를 지내면서 느낀 건..2주동안 글 하나를 써야 하는 것은 생각보다 많은 노력이 필요하다는 것. 게다가 노출되는 글이기에 좋은 글을 써야겠다는 약간의 강박?이 생겨 글쓰기를 시작도 못한 때도 있었다. ### 1.1 어떤 글을 썼나? 글감 회고 2018년 2월 초 ~ 8월 말 2월 🙆 내가 알고 있는 부분을 정리해보자. Airbnb - lottie - bodymovin 웹에서 사용해보기 ➔ #라이브러리 3월 🙆 내가 알고 있는 부분을 정리해보자 Angular 프로젝트에 prettier 코드포매터 세팅하기 ➔ #라이브러리 🙄 어려운 개념 정리 글이 검색해도 잘 없는데 번역이라도 해서 익혀보자.. (번역) Angular의 observable을 이해하고, 생성하고, 구독해보기 ➔ #비동기패턴 4월 ❌ 인턴에서 정규직 전환 시기. 정신이 안드로메다로 가있어서 쓸 겨를이 없었다. 5월 💡 작업하다가 삽질해서 내 것이 된 지식을 정리하자. (mobile) device-pixel-ratio계산 ➔ #CSS2. 12&#x2F; File Api와 이미지 용량 줄이기 ➔#자바스크립트, #HTML5API 📚 공부하자! 내 스타일로 메모 브라우저와 렌더링 엔진 ➔ #browser 6월 📚 공부하자! 내 스타일로 메모 렌더링 엔진(1) - 파싱과 DOM트리 구축 ➔ #browser2. 렌더링 엔진(2) - 렌더 트리 구축 ➔#browser 아직 마무리 못 지었다. (브라우저 공부는 더 해야 함, 네트워크랑 같이) PASS 한번 7월 ❌ 회사에서 큰 기능이 하나 런칭되었다. 첫 큰 작업이라 시간은 있었지만 글 쓸 여유가 없었다.. 야근 혹은 집에 가면 기절 8월 런칭 이후에 공부 뽐뿌가 오기 시작 📚 같이 일할 팀원이 많다 보니 코드를 클린 하게 짜고 싶었다.. 📓 읽기 좋은 코드가 좋은 코드다. 1번째글 &#x2F; 2번째글 &#x2F; 3번째글 지금 생각하니 관심사 분리, 적절한 네이밍도 중요하지만 설계를 잘하자. #CleanCode 💡 작업하다가 삽질해서 내 것이 된 지식을 정리하자. **13&#x2F; Image 업로드 시 회전에 대하여 (feat. exif 메타데이터 - Orientation) **➔ #자바스크립트, #ImageAPI, #라이브러리 📚 머리 식힐 겸 읽은 책 프로그래밍 정석 1번째글 &#x2F; 2번째글 #프로그래밍 📚 옵저버 패턴이 처음에 참 어려웠다.. 퀵스타트 Rxjs(10%) 1번째글 &#x2F; 2번째글 &#x2F; 3번째글 &#x2F; 4번째글 &#x2F; 5번째글 #비동기패턴 그 이후 📚 인사이드 자바스크립트 자바스크립트 데이터 타입과 연산자 ➔ 함수와 프로토타입 체이닝 1번째글 &#x2F; 2번째글 객체지향 ➔ 함수형 프로그래밍 ➔ #자바스크립트 📚 코드스피츠 강의가 개설되어 듣기 시작 (강의메모) 코드스피츠 ES6+ 함수와 OOP 1번째글 &#x2F; 2번째글 &#x2F; 3번째글 &#x2F; 4번째글 &#x2F; 5번째글 이 강의들은 무한 루프로 봐야 한다!! #자바스크립트, #OOP 글또 기간 동안 쓴 글을 분류해보니 이러했다. (기준: 목적) 🙆: 내가 알고 있는 부분을 정리해보자. 🙄: 어려운 개념 정리 글이 검색해도 잘 없는데 번역이라도 해서 익혀보자.. 💡: 작업하다가 삽질해서 내 것이 된 지식을 정리하자. 📚: 공부하자! 내 스타일로 메모 글을 쓰고 제일 기억에 남는 글은 1번과 3번. 1번은 내가 알고 있던 지식이었고 3번은 삽질해서 정리까지 했기 때문에 머릿속에 더 잘 안착이 되었다. 2번은 모르는 개념을 번역까지 하니.. 글 퀄리티도 좋지 않고, 좋은 글인지도 보장이 안되며, 머릿속에도 잘 안 남는 듯 하여서.. 번역 글은 개인적으로만 해야 할 듯하다. 4번은 제발 머릿속에 남았으면 하는데, 글만 정리해서 올리면 머릿속에 절대 안 남는다.. 그래서 2기 때는 다르게 글을 써보려고 한다. (기준: 분야) 자바스크립트 OOP 비동기패턴 라이브러리 소개 및 사용법 CleanCode browser HTML5API ImageAPI CSS 기초 공부를 더 많이 하고 싶다는 생각이 드는 요즘이다. 다 중요하지만 그래도 자바스크립트! 1.2 글쓰기 습관처음에는 습관들이기가 참 어려웠다. 나름 예전에 네이버 블로그를 했었는데도 말이다. 내 개인 일기장에 쓰는 글이 아닌 SNS에 글을 쓴다는 건 글을 잘 써서 올려야 한다는 강박에 사로잡히게 되는데, 글또 초반에도 그랬었다. 그러다 책 메모, 요약 글을 올리면서 서서히 글쓰기가 재밌어졌고, 출근 때도 블로그 글들을 복습하는 습관도 갖게 되었다. 내가 쓴 글에 작품처럼 애정이 간다고 해야 할까.잘 정리한 건가? 잘 읽히나? 오타는 없나? 1.3 GA를 더 보게 되다구글 애널리틱스에서 자연어 검색 메뉴를 자주 보게 된다. 어느 날 갑자기 pv가 늘어나면 메일로도 알려주기 때문에 보는 쏠쏠한 재미가 있었다. > 2018년 2월 ~ 2018년 8월 26일까지 순위별로 보면 Airbnb - lottie - bodymovin 웹에서 사용해보기 🙆 (번역) Angular의 observable을 이해하고, 생성하고, 구독해보기 🙄 12&#x2F; File Api와 이미지 용량 줄이기 💡 (mobile) device-pixel-ratio계산 💡 Angular 프로젝트에 prettier 코드포매터 세팅하기 💡 💡: 삽질하고 작성한 글들이 상위권. 트렌드 있는 라이브러리 상위권. 알고만 있자.. 이걸 고려하면서까지는 글쓰기에 제약이 있을 듯 :) 1.4 UI를 고민하게 됨Hexo의 Humen이라는 테마인데, UI가 70%로 마음에 들고 30%는 고치고 싶은 곳이 있다. 우선 내가 쓰기에도 불편한 부분을 고침 상단에 목차가 있었으면 좋겠다고 생각했다. 마크다운에 list 필드를 만들어서 json을 넣으면 타이틀과 본문 사이, floating 버튼으로 목차를 띄우게 만들었다. 글이 길 때마다 헤매게 되기 때문 모하비로 업데이트하면서 블로그도 다크 테마로 바꿨다! 폰트 네이버 스퀘어로 변경 앞으로 추가하고 싶은 것블로그 꾸미기는 나의 소확행 ~ 글이 길 때마다 헤매게 되는건 확실하다. 지금 몇 %읽었는지에 대한 ui를 하단 혹은 사이드에 프로그레스바 노출 관련된 글 노출해서 체류시간 높이기? 관련된 글 노출이 잘 안된다. tag기능을 사용해서 댓글 상단에 노출하쟈. 뭐 꼭 체류시간을 높일 목적은 아니지만 다른 글도 읽고 가시면 좋으니까 :) 내가 무슨 글을 쓰고 있는지 한 번에 알게 해주기 글 목록이 썸네일 + 타이틀 + 본문 형태인데 리스트로만 보일 수 있도록 만들긔. 2. 2기 어떻게 진행해볼까 2.1 글의 방향(기준: 목적) 📚: 공부하자! 내 스타일로 메모 💡: 작업하다가 삽질해서 내 것이 된 지식을 정리하자. 🙆: 내가 알고 있는 부분을 정리해보자. 🏃: 세미나 다녀왔습니다. 1번 &gt; 2번, 3번 비율로 쓸 예정이다. 1번의 경우는 메모 이후에도 머릿속에 들어와야 하는데, 이건 글쓰기에서 해결하는 것이 아니라, 책 전체 리뷰를 통해서 해결하려고 한다. 때문에 글 정리를 하고, 문법을 배울 경우에는간단하게 코드 짜는 글을 따로 세트로 적던가, 해당 글의 하단에 적기로 함!! 11월에 거의 모든 세미나가 종료되었지만 ㅎㅎ 그동안 다녀왔던 세미나들이라도 정리해보자. (기준: 분야)현재 확실히 계획된 부분은 이렇다. 📚: 공부하자! 내 스타일로 메모 자바스크립트 - you don’t know JS &#x2F; 코뿔소책 디자인패턴 - 코드스피츠 강의 browser - 저번 정리본 마무리 + 현시점에 나온 기능 추가로 살펴보기 💡: 작업하다가 삽질해서 내 것이 된 지식을 정리하자. 아마도 react 🏃: 세미나 다녀왔습니다. 그동안 다녀왔던 세미나 글 정리하기 2.2 그니까 2기 다짐 글 쓰는 것에 너무 스트레스를 받지 말자. 글감이 없다면 책 요약 가즈아. 그렇다고 너무 책 요약 글만 쓰지 말자. 📚, 💡, 🙆 골고루 잘 쓰자. 세미나가 다 끝나는 마당이지만, 그동안 다녀왔던 세미나 내용들 복습 겸 정리하자. 참고의식적 연습하기","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"}],"tags":[{"name":"글쓰기","slug":"글쓰기","permalink":"http://feel5ny.github.io/tags/%EA%B8%80%EC%93%B0%EA%B8%B0/"}]},{"title":"1/ 함수형 프로그래밍 (🙄)","slug":"FP_01","date":"2018-11-04T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2018/11/04/FP_01/","permalink":"http://feel5ny.github.io/2018/11/04/FP_01/","excerpt":"","text":"📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.함수형 프로그래밍에 대해서 더 깊게 배우길 원한다면 Lisp나 Haskell과 같은 언어를 공부하자. TL;DR Higher-Order Functions (고계 함수, 계산의 효율성) Purity (순수성, 데이터 플로우의 취급) Immutable Data (불변성) Referential Transparency Lazy Evaluation Recursion 커링 bind (with call&#x2F;apply) 래퍼 반복함수 1. 함수형 프로그래밍의 개념함수의 조합으로 작업을 수행함을 의미한다.이 작업이 이루어지는 동안 작업에 필요한 데이터와 상태는 변하지 않는다는 점.함수가 바로 연산의 대상이 된다. FP의 목적 함수형 프로그래밍이 수학에서 출발한 문제 해결 방법론이므로 수학문제를 프로그래밍으로 해결하는 데 있어서 상당한 이득을 볼 수 있다. 상태 변경과 가변 데이터를 피하려는. FP의 목적은 상태 변경을 피하는 것이다. FP에서는 변수를 모든 오류의 근본적인 원인으로 치부한다.누군가에 의해 변수의 값이 변경되기 때문에 이로 인해 오류가 더욱 빈번하게 발생한다고 생각한다. - 따라서 함수형 프로그래밍에서는 이런 변수가 외부에서 명확하게 드러나게 하여 통제 가능하게 만드는 것을 지향한다. 12345678910f1 = encrypt1;f2 = encrypt2;f3 = encrypt3;pure_value = &#x27;zzon&#x27;;encrypted_value = get_encrypted(x);encrypted_value = get_encrypted(f1);encrypted_value = get_encrypted(f2);encrypted_value = get_encrypted(f3); 순수함수 Pure fucntion외부에 영향을 미치지 않는 함수 같은 입력이 주어지면, 항상 같은 출력을 반환한다. 부작용(side effect)를 발생시키지 않는다. 외부의 가변(mutable) 데이터에 의존하지 않는다. 1234567function getCurrentValue(value)&#123; return processAt(value, new Date())&#125;// 사이드 이팩트 없앰function getCurrentValue(value, time)&#123; return processAt(value, time)&#125; 부원인과 부작용 new Date는 외부변수 함수를 실행하는 시점에 따라 결과를 예측하기 어렵ㄴ다. 함수의 정의만 보고 추측하기 어려운 함수를 부원인(side cause)과 부작용(side effect)이 존재하는 함수라고 한다. 함수에 드러나지 않은 입력값 또는 출력값응ㄹ 부원인(side cause)라고 하고 이로인해 발생한 결과를 부작용(side effect)라고 한다. 부작용은 부정적인 의미는 아니지만 프로그래머가 이를 고려하지 않고 사용했을 경우에는 오류를 유발할 수 있다. 함수형 프로그래밍에서는 이러한 상황이 궁극적으로 복잡성을 초래하기 때문에 복잡성을 표면으로 드러내도록 권장한다. 고계 함수 Higher-order function함수를 또 하나의 값으로 간주하여 함수의 인자 혹은 반환값으로 사용할 수 있는 함수 내부 데이터 및 상태는 그대로 둔 채 (pure_value) 제어할 함수를 변경 및 조합함으로써 (encrypt1,2,3) 원하는 결과를 얻어내는 것이 함수형 프로그래밍의 중요한 특성 높은 수준의 모듈화가 가능하다. 주요키워드 Higher-Order Functions (고계 함수, 계산의 효율성) Purity (순수성, 데이터 플로우의 취급) Immutable Data (불변성) Referential Transparency Lazy Evaluation Recursion cf__명령형 프로그래밍순수함수도 있지만,특정 작업을 수행하는 여러가지 명령이 기술되어 있는 함수도 있다.&#x3D;&gt; 프로시저라고 한다. Procedure 2. 자바스크립트에서 함수형 프로그래밍자바스크립트는 다음을 지원하기때문에 함수형 프로그래밍이 가능 일급객체로서의 함수 _ 함수의 인자로 함수를 넘길 수 있는 특징 클로저 _은닉화 12345678910111213141516171819202122232425const f1 = function(input) &#123; let result; result = 1; return result;&#125;const f2 = function(input) &#123; let result; result = 2; return result;&#125;const f3 = function(input) &#123; let result; result = 3; return result;&#125;const get_encrypted = function(func) &#123; const str &#x27;zzoon&#x27;; return function() &#123; return func.call(null, str);&#125; // 클로저, 자유변수 str&#125;const encrypted_value = get_encrypted(f1)();console.log(encrypted_value) //1const encrypted_value = get_encrypted(f2)();console.log(encrypted_value) //2const encrypted_value = get_encrypted(f3)();console.log(encrypted_value) //3 2-1. 배열의 각 원소 총합 구하기(reduce)명령형 프로그래밍으로 작성된 코드. 123456789101112function sum(arr)&#123; const len = arr.length; let i =0, sum =0; for(; i&lt;len; i++)&#123; sum += arr[i]; &#125; return sum;&#125;const arr = [1,2,3,4];console.log(sum(arr)) 함수형 프로그래밍 12345678910111213141516function reduce(func, arr, memo)&#123; // memo: cache 값 const len = arr.length; let i = 0, accum = memo; for(; i&lt;len; i++)&#123; accum = func(accum, arr[i]); &#125; return accum;&#125;const arr = [1,2,3,4];const sum = function(x,y) &#123; return x+y; &#125;const multiply = function(x,y) &#123; return x*y; &#125;console.log(reduce(sum, arr, 0);)console.log(reduce(multiply, arr, 1);) 2-2. 팩토리얼\b명령형 프로그래밍 12345function fact(num) &#123; const val = 1; for(let i = 2; i&lt;=num; i++) val = val*i; return val;&#125; 혹은 재귀호출 1234function fact(num) &#123; if(num == 0) return 1; else return num*fact(num-1);&#125; 앞서 연산한 결과를 캐시에 저장하여 사용하여 함수를 작성한다면 성능 향상에 도움이 된다. 12345678910111213141516const fact = function()&#123; const cache = &#123;&#x27;0&#x27;: 1&#125; const func = function(n)&#123; // 클로저 let result = 0; if(typeof(cache[n] === &#x27;number&#x27;))&#123; result = cache[n]; &#125; else &#123; result = cache[n] = n * func(n-1); // 10 * 9 * 8 * ... * 1 &#125; return result; &#125; return func;&#125;();console.log(fact(10));console.log(fact(20)); cf__2 메모이제이션 패턴 memoization 패턴memoize 계산 결과를 저장해 놓아 이후 다시 계산할 필요 없이 사용할 수 있게 한다는 컴퓨터 용어 메모이제이션 패턴 기본적으로 계산된 결과를 함수 프로퍼티값으로 담아 놓고 나중에 사용한다. jQuery에는 data()라는 메모이제이션 패턴을 사용하는 메서드가 있다. data : 해당 엘리먼트에 JavaScript Type의 value를 저장할 수 있으며, 값으로 저장되어 있는 데이터를 읽습니다.data-XXX 함수의 성능향상을 위해 Function.prototype에 메모이제이션 패턴을 사용할 수 있는 함수를 넣으면 사용가능하다.주의할 점은 한 번 값이 들어간 경우 계속 유지되므로 이를 초기화하는 방법 역시 제공돼야 한다. jQuery에서는 cleanData라는 메서드를 제공한다. 123456789101112131415161718192021function Calculate(key, input, func)&#123; Calculate.data = Calculate.data || &#123;&#125;; //cache if(!Calculate.data[key])&#123; let result; result = func(input); Calculate.data[key] = result; &#125; return Calculate.data[key];&#125;let result = Calculate(1, 5, function(input)&#123; return input * input;&#125;)console.log(result);result = Calculate(2, 5, function(input)&#123; return input*input/4;&#125;);console.log(result);console.log(Calculate(1));console.log(Calculate(2)); Function 프로토타입에 memoization()함수 넣기 123456789101112131415161718192021Function.prototype.memoization = function(key) &#123; const arg = Array.prototype.slice.call(arguments,1); // key에 들어온 인자값의 2번째인자 this.data = this.data || &#123;&#125;; // data객체 있으면 그대로, 없으면 초기화 return this.data[key] !== undefined ? this.data[key] : this.data[key] = this.apply(this,arg); // 해당함수를 인자값을 넘기며 호출, arg는 input으로 들어감&#125;function myCalculate1(input)&#123; return input * input &#125;;function myCalculate2(input)&#123; return input * input/4 &#125;;myCalculate1.memoization(1,5);myCalculate1.memoization(2,4);myCalculate2.memoization(1,6);myCalculate2.memoization(2,7);console.log(myCalculate1.memoization(1));console.log(myCalculate1.memoization(2));console.log(myCalculate2.memoization(1));console.log(myCalculate2.memoization(2)); 2-3. 피보나치 수열메모이제이션 기법 사용한 함수형 프로그래밍 1234567891011121314const fibo = function()&#123; const cache = &#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1&#125;; const func = function(n)&#123; let result = 0; if(typeof(cache[n]) === &#x27;number&#x27;)&#123; result = cache[n]; &#125; else &#123; result = cache[n] = func(n-1) + func(n-2); &#125; return result; &#125; return func;&#125;();console.log(fibo(10)); 팩토리얼 함수와 패턴과 거의 비슷하다.cache의 초기값과 함수를 재귀 호출할 때 산술식만 다르다.&#x3D;&gt; 팩토리얼과 피보나치 수열을 계산하는 함수를 인자로 받는 함수를 모듈화할 수 있다. 1234567891011121314const cacher = function(cache, func)&#123; const calculate = function(n)&#123; if(typeof(cache[n]) === &#x27;number&#x27;)&#123; result = cache[n]; &#125; else &#123; result = cache[n] = func(calculate, n); &#125; return result; &#125; return cacluate;&#125;const fact = cacher(&#123;&#x27;0&#x27;: 0&#125;, function(func,n)&#123; return n* func(n-1); &#125;)const fibo = cacher(&#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1&#125;, function(func,n)&#123; return func(n-1) + func(n-2); &#125;) 3. 자바스크립트에서의 함수형 프로그래밍을 활용한 주요 함수 3-1. 함수 적용Function.prototype.apply왜 이름이 apply? 함수 적용(Applying functions)는 함수형 프로그래밍에서 사용되는 용어다. 함수형 프로그래밍에서는 특정 데이터를 여러가지 함수를 적용시키는 방식으로 작업을 수행한다.여기서 함수는 단순히 입력을 넣고 출력을 받는 기능을 수행하는것 뿐만 아니라,인자 혹은 반환값으로 전달된 함수를 특정 데이터에 적용시키는 개념으로 이해해야한다. func.apply(Obj, Args)와 같은 함수 호출을 **’func 함수를 Obj객체와 Args인자 배열에 적용시킨다’**라고 표현할 수 있다. cf__3. 함수 호출괄호 연산자 대비 call&#x2F;apply를 사용할 때의 장점은함수가 실행되는 컨텍스트를 지정할 수 있다는 점이다(this의 값).이러한 형태는 고차 함수, 특히 이러한 고차 함수가 나중에 실행되는 함수를 소비할 때 볼 수 있다.Function 프로토타입에서 bind 메소드의 내부는 call&#x2F;apply의 훌륭한 예다. 123456// Possible implementation of bind using applyfunction bind(func, context)&#123; return function()&#123; func.apply(context, Array.prototype.slice.apply(arguments)); &#125;&#125; 3-2. 커링특정 함수에서 정의된 인자의 일부를 넣어 고정시키고,나머지를 인자로 받는 새로운 함수를 만드는 것을 의미한다. 12345678910111213141516function calculate(a,b,c)&#123; return a*b+c &#125;;function curry(func) &#123; // 클로저 반환 const args = Array.prototype.slice.call(arguments, 1); // 배열의 2번째 인덱스 이후의 값의 배열 return function() &#123; return func.apply( null, args.concat(Array.prototype.slice.call(arguments)) // 익명함수의 인자 ) &#125;&#125;const new_func1 = curry(calculate, 1); // a를 먼저 받음console.log(new_func1(2,3)); // a를 인자와 합치면서(concat)// === console.log(curry(calculate,1)(2,3));const new_func2 = curry(calculate, 1, 3); // a,b를 먼저 받음console.log(new_func2(3)); 자바스크립트에서 기본으로 제공하지 않기 때문에 Function.prototype에 정의하여 사용할 수 있다. 1234567Function.prototype.curry = function() &#123; const fn = this, args = Array.prototype.slice.claa(arguments); return function() &#123; return fn.apply(this, args.concat(Array.prototype.slice.call(arguments))); &#125;&#125; cf__4 slice 메서드커링에서 함수의 인자를 arguments 객체로 조작할 때 이 메서드를 이용하여 배열로 만든 후 손쉽게 조작 가능 3-3. bind 커링기법을 활용한 함수이다. 사용자가 고정시키고자 하는 인자를bind()함수를 호출할 때 인자로 넘겨주고반환받은 함수를 호출하면서나머지 가변 인자를 넣어줄 수 있다. 123456Function.prototype.bind = function (thisArg)&#123; const fn = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function() &#123; return fn.apply(thisArg, args.concat(slice.call(arguments)))&#125;;&#125; 123456789101112131415const print_all = function(arg)&#123; for (let i in this) console.log(i + &#x27;:&#x27; + this[i]); for (let i in arguments) console.log(i + &#x27;:&#x27; + arguments[i]);&#125;const myobj = &#123;name: &#x27;zzoon&#x27;&#125;;const myfunc = print_all.bind(myobj);myfunc(); // name: zzoonconst myfunc1 = print_all.bind(myobj, &#x27;iamjoy&#x27;, &#x27;others&#x27;);myfunc1(&#x27;insidejs&#x27;);/* name: zzoon 0: iamjoy 1: others 2: insidejs*/ 특정 함수에 원하는 객체를 바인딩시켜 새로운 함수를 사용할 때 bind()함수가 사용된다. 3-4. 래퍼 (클로저를 절묘하게 사용한 함수형 프로그래밍) 🙄특정함수를 자신의 함수로 덮어쓰는 것 OOP에서 다형성을 위해 오버라이드를 지원하는것과 유사하다. 123456789101112131415161718192021function wrap(object: Object, method: string, wrapper)&#123; const fn = object[method]; // 덮여질 함수 return object[method] = function()&#123; return wrapper.apply(this, [fn.bind(this)].concat(Array.prototype.slice.call(arguments)) // fn: original 함수 ) &#125;&#125;Function.prototype.original = function(value)&#123; this.value = value; console.log(&#x27;value : &#x27; + this.value)&#125;const mywrap = wrap(Function.prototype, &#x27;original&#x27;, function(orig_func, value)&#123; this.value = 20; orig_func(value); console.log(&#x27;wrapper value : &#x27; + this.value)&#125;)const obj = new mywrap(&#x27;joy&#x27;); 3-5. 반복 함수3-5-1. eachjQuery 1.0의 each() 1234567891011121314151617function each(obj, fn, args)&#123; if (obj.length === undefined) // 객체로 넘어올 때 for(let i in obj) fn.apply(obj[i], args || [i, obj[i]]); else // 배열로 넘어올 때 for(let i = 0; i&lt;obj.length; i++) fn.apply(obj[i], args || [i, obj[i]]) return obj;&#125;each([1,2,3], function(idx, num)&#123; console.log(idx + &#x27;:&#x27; + num)&#125;)const joy = &#123; name: &#x27;joy&#x27;, company: &#x27;goodoc&#x27;, hasBoyfriend: true&#125;each(joy, function(idx, value)&#123;console.log(idx + &#x27;:&#x27; + value)&#125;) 3-5-2. map123456789101112131415161718Array.prototype.map = function(callback)&#123; // this가 null인지, 배열인지 체크 // callback이 함수인지 체크 const obj = this; let value, mapped_value; const A = new Array(obj.length); //[undefined, undefined, undefined] for(let i = 0; i&lt;obj.length; i++) &#123; value = obj[i]; mapped_value = callback.call(null, value); A[i] = mapped_value; &#125; return A;&#125;const arr = [1,2,3];const new_arr = arr.map(function(value)&#123; return value * value; &#125;)consoel.log(new_arr); 3-5-3. reduce123456789101112131415Array.prototype.reduce = function(callback, memo)&#123; //this가 null인지, 배열인지 체크 // callback이 함수인지 체크 const obj = this; let value, accumulated_value = 0; //accumulated 뜻* : 축적되다. for(let i=0; i&lt;obj.length; i++)&#123; value = obj[i]; accumulated_value = callback.call(null, accumulated_value, value); &#125; return accumulated_value;&#125;const arr = [1,2,3];const accumulated_val = arr.reduce(function(a, b)&#123; return a + b*b; &#125;)consoel.log(accumulated_val); 참고 프로그래밍 패러다임의 변화 ‘제다이급’ 자바스크립트 고수들이 전하는 6가지 개발팁","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"6/ OOP (ES5 기준)","slug":"OOP_02","date":"2018-10-20T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2018/10/20/OOP_02/","permalink":"http://feel5ny.github.io/2018/10/20/OOP_02/","excerpt":"","text":"📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다. 0. 클래스 기반의 언어 - 프로토타입기반의 언어클래스 기반의 언어 클래스로 객체의 기본적인 형태와 기능을 정의하고, 생성자로 인스턴스를 만들어서 사용할 수 있다. 런타임에 바꿀 수 없다. 정확성, 안전성, 예측성등의 관점에서는 프로토타입기반의 언어보다 좀더 나은 결과를 보장. JAVA, C++ 프로토타입 기반의 언어 객체의 자료구조, 메서드 등을 동적으로 바꿀 수 있다. 자바스크립트 1. 클래스, 생성자, 메서드12345678910111213function Person(arg) &#123; // 클래스이자, 생성자의 역할을 함. this.name = arg; this.getName = function() &#123; return this.name; &#125; this.setName = function(value):void &#123; this.name = value; &#125;&#125;const me = new Person(&quot;Kim&quot;);console.log(me.getName()); // Kimme.setName(&quot;Joy&quot;);console.log(me.getName()) // Joy 12const you = new Person(&quot;Gray&quot;);const him = new Person(&quot;Lee&quot;); 공통적으로 사용될 수 있는 setName과 getName 메서드가 중복으로 메모리에 올려놓게 된다. setName과 getName을 재사용하쟈! 12345678910111213141516function Person(arg)&#123; this.name = arg;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;Person.prototype.setName = function(value) &#123; this.name = value;&#125;const you = new Person(&quot;Gray&quot;);const him = new Person(&quot;Lee&quot;);console.log(you.getName()) // this는 자신을 호출한 객체에 바인딩된다.console.log(him.getName()) // 프로토타입 체인으로 접근할 수 있다. 프로토타입 메서드를 만드는 루틴을함수체인의 더 상위인 Function 프로토타입에 method라는 이름으로 만들어놓고재사용하는 방법도 있다.1234567891011121314151617181920Function.prototype.method = function(name, function) &#123; if(!this.prototpye[name]) &#123; this.prototype[name] = function; &#125;// 프로토타입에 같은 이름의 메서드가 없다면&#125;function Person(arg) &#123; this.name = arg;&#125;Person.method(&#x27;setName&#x27;, function(value)&#123; this.name = value;&#125;)Person.method(&#x27;getName&#x27;, function() &#123; return this.name;&#125;)const me = new Person(&quot;me&quot;);const you = new Person(&quot;you&quot;);console.log(me.getName());console.log(you.getName()); 2. 상속 자바스크립트는 클래스를 기반으로 하는 전통적인 상속을 지원하지 않는다. 자바스크립트 특성 중 객체 프로토타입 체인을 이용하여 상속을 구현해낼 수 있다. 상속 구현방법 클래스 기반 전통적인 상속 방식을 흉내냄 (컨텍스트 자체를 상속받음) 클래스 개념 없이 객체의 프로토타입으로 상속을 구현하는 방식 &#x3D;&gt; Prototypeal inheritance 2-1. 프로토타입을 이용한 상속12345function create_object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; // Object.create() 함수로 제공된다. 인자로 들어온 객체(o)를 부모로 하는자식 객체(F)를 생성하여반환한다.&#x3D;&gt; 프로토타입의 특성을 활용하여 상속을 구현하는것 &#x3D; 프로토타입 기반의 상속 예시 12345678910111213141516171819202122function create_object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; var person = &#123; name: &quot;Joy&quot; getName: function() &#123; // ES6의 getter 개념 return this.name; &#125; setName: function(arg)&#123; // ES6의 setter 개념 this.name = arg; &#125;&#125;var me = create_object(person)me.name // Joyme.getName() // Joyme.setName(&quot;Kim&quot;)me.name // Kimme.getName() // Kim 클래스에 해당하는 생성자 함수를 만들지도 않았고, 그 클래스의 인스턴스를 따로 생성하지도 않았다. person 객체와 이 객체를 프로토타입 체인으로 참조할 수 있는 자식 객체 me를 만들어서 사용함. 12me.setAge = function(age) &#123;...&#125;me.getAge = function() &#123;...&#125; 위의 방식으로 확장할 수 있지만, 코드가 지저분해질 수 있다.**extend()**라는 이름의 함수로 객체에 자신이 원하는 객체 혹은 함수를 추가시킨다. __jQuery의 extend 함수 12345678910jQuery.extend = jQuery.fn.extend = function(obj: 자식, prop: 부모) &#123; if (!prop) &#123; prop = obj; // 부모가 없으면 자식이 부모 obj = this; // this를 자식에게 할당 &#125; for ( var i in prop ) &#123; // deep copy ob[i] = prop[i]; &#125; return obj;&#125; jQuery.fn은 jQuery의 프로토타입 $.extend()나 var elem = new jQuery(...); elem.extend()형태로 호출가능 ob[i] = prop[i];은 얕은 복사 (shallow copy) &#x3D;&gt; 참조값을 복사하는 경우 영향이 생긴다.이를 방지하기 위해 깊은 복사를 해야함. 깊은 복사를 위해서빈 객체를 만들어서 extend 함수를 재귀적으로 호출 123456789101112131415161718192021222324252627282930313233// jQuery extend 함수 중 일부...for (; i &lt; length; i++)&#123; if( (options = arguments[i]) != null) &#123; /* 인자로 넘어온 객체의 프로퍼티를 options로 참조시키고, 그 프로퍼티가 null이 아닌 경우 블록 안으로 진입한다. */ for (name in options)&#123; // options를 deep 카피한다. src = target[name]; // src는 반활될 복사본 target을 가리킴 copy = options[name]; // copy는 복사할 원본 프로퍼티를 가리킴 if (target === copy)&#123; // 무한루프 방지 continue; // continue는 루프의 실행을 완전히 종료하지 않고 for 루프에서는 업데이트 표현식으로 점프함. &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) )&#123; // deep 플래그:boolean: extend에서 인자로 받음 : 깊은 복사를 할 것인지 선택 할 수 있게 한다. // copy: 참조형식인 경우 (객체나 배열인 경우) 무조건 deep copy 시작 ) if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; // 배열 복사일 경우 빈 배열 생성 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; // 객체 복사일 경우 빈 객체 생성 &#125; target[name] = jQuery.extend(deep, clone, copy); // 재귀.. &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; return target;&#125; 123456789101112131415161718192021222324252627282930const person = &#123; name: &#x27;joy&#x27;, getName: function()&#123; return this.name; &#125;, setName: function(arg)&#123;this.name = arg;&#125;&#125;function create_object(o) &#123; function F() &#123;&#125;; F.prototype = o; return new F();&#125;function extend(obj, prop) &#123; if(!prop) &#123;prop = obj; obj = this;&#125; /* 인자가 하나만 들어오는 경우, prop 인자에 obj를 할당하고, 현재객체(this)에 객체의 프로퍼티를 복사한다.... */ for (let i in prop) obj[i] = prop[i]; // 얕은 복사임. return obj;&#125;const student = create_object(person);const added = &#123; setAge: function(age)&#123; this.age = age; &#125; getAge: function() &#123;return this.age;&#125;&#125;extend(student, added); // 1student.setAge(25);console.log(student.getAge()); person객체를 갖고있는 프로토타입을 갖고있는 student 인스턴스(컨텍스트)가 added를 상속받는다. (deep copy함) student 인스턴스에는 added 객체가 복사된다. 2-2. 클래스 기반의 상속1번은 객체의 상속이었고, 지금은 클래스의 역할을 하는 함수를 상속하는 것을 설명한다. (컨텍스트 상속) 123456789101112function Person(arg) &#123; this.name = arg;&#125;Person.prototype.setName = function(value) &#123; this.name = value; &#125;;Person.prototype.getName = function() &#123; return this.name; &#125;function Student(arg) &#123;&#125;const you = new Person(&#x27;JoyKim&#x27;); Student.prototype = you;const me = new Student(&#x27;NaYoung&#x27;);me.setName(&#x27;Kim&#x27;);console.log(me.getName()); you는 Person의 인스턴스 (name: JoyKim) Student의 프로토타입은 you를 가리킨다. me는 Student의 인스턴스 Student에는 인자를 받을 name이 없으므로 ‘NaYoung’을 넣어줘도 아무런 적용 안됨 이를 위해서 인스턴스가 생성될때 부모함수가 바로 실행될 수 있도록 Student에 실행코드를 넣는다.123function Student(arg)&#123; Person.apply(this, arg) // 부모함수 Pseron을 실행하고 this는 arg에 바인딩!&#125; me객체에서 setName을 호출하면 프로토타입체이닝에 의해서 Person까지올라간다. 이 로직의 단점은 me의 prototype이 Student.prototype이고, 이는 곳 you를 가리킨다는 것인데,이렇게 되면 me가 you의 자식 개념이 되면서 잘못된 설계가 된다. me와 you의 독립성을 위해서 중간 역할을 해주는 프로토콜 빈 함수 F()를 추가한다. 123456789101112131415function Person(arg) &#123; this.name = arg;&#125;Function.prototype.method = function(name, func) &#123; this.prototype[name] = func &#125;;Person.method(&#x27;setName&#x27;, function(value) &#123; this.name = value; &#125;;)Person.method(&#x27;getName&#x27;, function() &#123; return this.name; &#125;)function Student(arg) &#123;&#125;function F()&#123;&#125;;F.prototype = Person.prototype;Student.prototype = new F();Student.prototype.constructor = Student;Student.super = Person.prototype; const me = new Student(&#x27;NaYoung&#x27;);const you = new Person(&#x27;YoungRan&#x27;);me.setName(&#x27;Kim&#x27;); Function 프로토타입에 프로토타입 함수를 만들어주는, 재사용할 수 있는 method라는 메서드를 추가한다. (아오 네이밍 예시 헷갈) F의 프로토타입을 Person의 프로토타입을 참조하게 함으로써 중간역할을 하게함 그 중간역할을 하는 F의 인스턴스를 Student의 프로토타입이 참조하도록 함. (현재 Student &#x3D;&gt; F &#x3D;&gt; Person) 프로토타입 체인을 위해서 Student 프로토타입의 생성자를 Student로 할당. Student가 Person.prototype에도 접근하기 위해서 super라는 메서드 생성 me는 Person을 상속받은 Student의 인스턴스이고you는 Person의 인스턴스. 위 로직을 모듈화 시키면..(by.스토얀 스테파노프[JavaScript Pattersn]) 123456789const inherit = function(Parent, Child)&#123; const F = function()&#123;&#125;; return function(Paretn, Child)&#123; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.super = Parent.prototype; &#125;&#125; 클로저는 F()함수를 지속적으로 참조한다.F()는 가비지 컬렉션의 대상이 되지 않고 계속 남아 있다.이를 이용해 함수 F()의 생성은 단 한 번 이루어지고 inherit함수가 계속해서 호출되어도 함수 F()의 생성을 새로 할 필요가 없다. 3. 캡슐화 (feat. 클로저) 정보 공개의 여부. 정보 은닉 개념(Typescript에서는 public, private, protected 멤버를 선언함으로써 해당 정보를 외부로 노출시킬지 여부를 결정) 자바스크립트 es6에서는 get, set 키워드로 외부에서 해당 클래스 혹은 함수 내부에 접근 할 수 있다.(get은 readonly) 123456789101112131415const Person = function(arg) &#123; let name = arg? arg: &quot;joy&quot;; this.getName = function() &#123; return name; &#125; this.setName = function(arg) &#123; name = arg; &#125;&#125;const me = new Person();console.log(me.getName());me.setName(&#x27;NaYoung&#x27;);console.log(me.getName());console.log(me.name); Person의 내부 public 함수들은 **클로저**역할을 하면서 name에 접근하고 있다. 1234567891011// 모듈패턴const Person = function(arg)&#123; const name = arg? arg: &#x27;joy&#x27;; // name은 private 멤버 return &#123; getName: function() &#123; return name;&#125;, setName: fucntion(arg)&#123; name = arg;&#125; &#125;&#125;const me = Person()console.log(me.getName()) 접근하는 private 멤버가 객체나 배열이면(레퍼런스) 얕은 복사로 참조만을 반환하므로 사용자가 이후 이를 쉽게 변경할 수 있다. (Deep copy, Shallow copy) 객체만을 반환하기 때문에 Person 함수의 프로토타입에 접근할 수 없다.123456789const Person3 = function(arg)&#123; const name = arg? arg: &#x27;joy&#x27;; var Func = function()&#123;&#125;; Func.prototype = &#123; getName: function() &#123; return name; &#125;, setName: function(arg) &#123;name = arg;&#125; &#125; return Func;&#125;(); 4. 객체지향 프로그래밍 응용 예제 함수의 프로토타입 체인extend 함수인스턴스를 생성할 때 생성자 호출을 이용해서 자바스크립트로 클래스 기능을 하는 함수 만들기 4-1-1. subClass 함수 구조\bsubClass함수는변수 및 메서드가 담긴 객체를 인자로 받은부모 함수를 상속받는 자식 클래스를 만든다. 부모함수는 subClass() 함수를 호출할 때 this 객체를 의미한다. 12const SuperClass = subClass(obj); // 상속받을 클래스const SubClass = SuperClass.subClass(obj); // SubClass는 SuperClass를 상속받는다. 이처럼 SuperClass를 상속받는 subClass를 만들고자 할 때,SuperClass.subClass()의 형식으로 호출하게 구현한다.참고로 최상위 클래스인 SuperClass는 자바스크립트의 Fucntion을 상속받게 한다. 123456789function subClass(obj)&#123; /* 1. 자식 클래스 (함수객체) 생성 2. 생성자 호출 (클래스 함수를 생성하기 위해서) 3. 프로토타입 체인을 활용한 상속 구현 4. obj를 통해 들어온 변수 및 메서드를 자식 클래스에 추가 5. 자식 함수 객체 반환 */&#125; 4-1-2. 자식 클래스 생성 및 상속1234567891011121314function subClass(obj) &#123; ... const parent = this; // 부모클래스를 가리키는 parent는 this를 그대로 참조 const F = function()&#123;&#125;; // 중간역할 const child = function()&#123;&#125;; // 자식객체 F.prototype = parent.prototype; child.prototype = new F(); // 부모의 프로토타입을 참조하는 프로토타입을 갖고있는 F로부터 만들어진 생성자 함수를 child 프로토타입이 참조하도록한다.ㅇ child.prototype.constructor = child; child.parent = parent.prototype; child.parent_constructor = parent; ... return child;&#125; 자식 클래스는 child 라는 이름의 함수 객체를 생성함으로써 만들어졌다. 4-1-3. 자식 클래스 확장12345for (let i in obj)&#123; if (obj.hasOwnProperty(i))&#123; child.prototype[i] = obj[i]; &#125;&#125; hasOwnProperty인자로 넘기는 이름에 해당하는 프로퍼티가 객체 내에 있는지를 판다. 프로토타입 체인을 타고 올라가지 않고 해당객체 내에서만 찾는다는 것에 유의 12345o = new Object();o.prop = &#x27;exists&#x27;;o.hasOwnProperty(&#x27;prop&#x27;); // trueo.hasOwnProperty(&#x27;toString&#x27;); // falseo.hasOwnProperty(&#x27;hasOwnProperty&#x27;); // false 4-1-4. 생성자 호출클래스의 인스턴스가 생성될 때, 클래스 내에 정의된 생성자가 호출돼야하다.부모 클래스의 생성자 역시 호출되어야한다. (초기화를 위해서) 1234const child = function() &#123; if (parent.hasOwnProperty(&#x27;_init&#x27;))&#123; parent._init.apply(this, arguments); &#125; if (child.prototype.hasOwnProperty(&#x27;_init&#x27;))&#123;child.prototype._init.apply(this, arguments);&#125;&#125; 12345const SuperClass = subClass();const SubClass = SuperClass.subClass();const Sub_SubClass = SubClass.subClass();const instance = new Sub_SubClass(); instance 생성시 SuperClass 생성자가 호출되지 않는다.&#x3D;&gt; 부모클래스의 생성자를 호출하는 코드를 재귀적으로 구현하여 해결한다. 12345const child = function() &#123; const _parent = child.parent_constructor; if (_parent &amp;&amp; _parent !== Function)&#123; _parent.apply(this, arguments); &#125; if (child.prototype.hasOwnProperty(&#x27;_init&#x27;))&#123;child.prototype._init.apply(this, arguments);&#125;&#125; 현재 클래스의 부모 생성자가 있으면, 그 함수를 호출하다. 다만 부모가 Function이 경우는 최상위 클래스에 도달했으므로 실행하지 않는다. 최종 1234567891011121314151617181920212223242526272829303132function subClass(obj)&#123; /* 1. 자식 클래스 (함수객체) 생성 2. 생성자 호출 (클래스 함수를 생성하기 위해서) 3. 프로토타입 체인을 활용한 상속 구현 4. obj를 통해 들어온 변수 및 메서드를 자식 클래스에 추가 5. 자식 함수 객체 반환 */ const parent = this === window ? Function : this; const F = function()&#123;&#125; const child = function() &#123; const _parent = child.parent; if(_parent &amp;&amp; _parent !== Function)&#123; parent.apply(this, arguments); &#125; if(child.prototype._init))&#123; child.prototype._init.apply(this, arguments); &#125; &#125; F.prototype = parent.prototype; child.prototype = new F(); child.prototype.constructor = child; child.parent = parent; child.subClass = arguments.callee; for (let i in obj)&#123; if (obj.hasOwnProperty(i))&#123; child.prototype[i] = obj[i]; &#125; &#125; return child&#125; By Joy. 내부함수를 선언할때와 this로 바인딩된 함수를 선언하는 것의 차이점? 기준? 프로토타입 체이닝을 만든 이유객체지향 프로그래밍을 지원하기 위해부모객체를 가리키는 참조링크 형태로 숨겨진 프로퍼티. (Naming)복사시 복사할 대상을 copy, 복사의 결과물을 clone shallow copy와 다르게deep copy는 재귀적으로 호출해야함.(다시 정리)","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"},{"name":"closure","slug":"closure","permalink":"http://feel5ny.github.io/tags/closure/"}]},{"title":"CodeSpitz78 5/ OOAD와 테트리스 (2)","slug":"OOP_07","date":"2018-10-09T12:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2018/10/09/OOP_07/","permalink":"http://feel5ny.github.io/2018/10/09/OOP_07/","excerpt":"","text":"🌕🌑🌑 🔥 코드스피츠 수업을 수강하면서 복습한 내용을 정리했습니다.아직 정리중.. 1. StageStage 클래스는 뭘 필요로 할까? 판 마지막 판이 몇 판일까? &#x3D; 몇 판까지 있을까? 속도 ** 판마다 속도가 증가한다.** 최소 속도 최대 속도 ** 속도는 어떤 객체가 가져가야할까?** - Game보다는 Stage가 적합. - 캡슐화와 은닉화의 속성을 이용하여, 속도의 처리는 stage내에서만 처리하게 한 후, 외부에서는 최종 속도만 받을 수 있도록 한다. (getter) - 초기 속도 자기의 변화를 listener한테 통보하는 것으로 처리만 하고 listner의 형태를 직접 알 필요는 없게 한다. 12// Object.assign 쓰기 번거로워서 함수 만들긔const prop = (target, v) =&gt; Object.assign(target, v); 123456789101112131415161718192021222324const Stage = class &#123; constructor(last, min, max, listener)&#123; // last는 마지막 판 // min,max는 속도 // listener: 다른 객체와 관계를 맺지 않게 해주는 역할 // 게임 패널들의 스테이지 그래픽이 갱신을 위해서 listener를 달아줌. prop(this, &#123;last, min, max, listener&#125;); &#125; clear() &#123; //초기화 this.curr = 0; // 현재 스테이지 넘버 this.next(); &#125; next() &#123; // 속도 비율 = 현재판 - 1 / 마지막 판 - 1 // 블럭 내려올 때 딜레이 속도 = (this.max - this.min) * (1 - rate); // =&gt; 점점 작아진다. =&gt; 최종 속도는 빨라짐 if(this.curr++ &lt; Stage.last) &#123; const rate = (this.curr - 1) / (this.last - 1); this.speed = this.min + (this.max - this.min) * (1 - rate); this.listener(); &#125; &#125;&#125; 2. Score123456789101112131415161718const Score = class &#123; constructor(listener)&#123; prop(this, &#123;listener&#125;); // 스코어의 그래픽을 갱신시키기 위해서 통보용으로 listener 추가 &#125; clear()&#123; this.curr = 0; this.total = 0; &#125; add(line, stage)&#123; // line이 지워지는 갯수를 포인트 증가율 // stage 마다 line하나 지울때마다 점수가 다름 const score = ???; this.curr += score; // 현재 점수값에도 반영 this.total += score; // 전체 점수값에도 반영 this.listener(); &#125;&#125; cf__1 역할, 책임, 협력프로그래밍의 실체는 수행해야하는 job이 누구의 역할과 책임으로 넘어가야하는지를 의사결정하는 행위. 🍡 객체지향객체지향에서는 컨텍스트라는 방법이 있다.인스턴스별로 컨텍스트라는 유지한다. (컨텍스트: 인스턴스마다 고유하게 부여되어 있는 메모리). **함수에서 값을 가져오는 방법 2가지. ** 내가 인자로 값을 가져올지, 컨텍스트로 가져올지. 🍢 함수형 프로그래밍과 객체지향 프로그래밍의 차이점. 함수형 프로그래밍에서는 자유변수를 통해서 함수를 유지한다. 자유변수를 유지하기 위해서는 새로운 함수 생성이 필요하다. (클로저) why? 함수가 태어날때 마다 자유변수로 인지하기 때문에. 🍭 객체지향을 통해서 \b클래스의 인스턴스를 만드는 행위를 함수형으로 바꾸면? 필요한 자유변수를 함수를 \b만들어서 리턴하는 행위와 같다. 그 함수가 컨텍스트 대신 \b자유변수로 해당 상태를 기억하고 있을테니까. 객체지향에서 인스턴스의 수만큼 &#x3D;&gt; 함수를 생성하는 걸로 함수지향으로 바꿀 수 있다. 123456789101112131415161718192021222324252627const Score = class &#123; constructor(listener)&#123; prop(this, &#123;listener&#125;); // 스코어의 그래픽을 갱신시키기 위해서 통보용으로 listener 추가 &#125; clear()&#123; this.curr = 0; this.total = 0; &#125; add(line, stage)&#123; // score 계산을 위해서는 stage만 알 수 있는 값을 이용해야하기 때문에 // stage 내부에 score를 계산하는 책임을 주고,(위임) // Score의 add함수에서는 score를 호출, 점수만 더하는 책임만 준다.(협력) const score = stage.score(line); this.curr += score; // 현재 점수값에도 반영 this.total += score; // 전체 점수값에도 반영 this.listener(); &#125;&#125;const Stage = class &#123; ... score(line) &#123; return parseInt((this.curr * 5) * (2 ** line)) &#125;&#125; 스코어와 스테이지 간의 coupling 관계현재는 약한 바인딩.add 함수 호출시에만 임시적으로 외부 인자로 들어오기때문에 But,하나의 게임 안에서는스테이지와 스코어를 동시에 소유하고 바뀌지 않는다. 게임에서의 스테이지 관리자와 스코어 관리자는 관계가 항구적. 즉, 게임이 진행되는 동안. 즉 매번 인자로 보내면 안된다. 맥락상 맞지 않다는 말. stage를 add함수의 인자로 보낸다는 것은 스코어를 더 할때마다 임시적으로 바인딩한다는 것인데 이는 위의 항구적인 관계와 맞지 않음. (코드의 의미가 맞지 않음.) 때문에 add의 인자가 아니라 컨텍스트 변수로 옮겨줘야한다. 도메인을 바라보고 어디 쪽의 역할이 맞는지 항상 의사결정을 해야한다. 123456789101112131415161718192021const Score = class &#123; constructor(👉stage, listener)&#123; prop(this, &#123;stage, listener&#125;); &#125; clear()&#123; this.curr = 0; this.total = 0; &#125; add(line)&#123; const score = 👉this.stage.score(line); this.curr += score; // 현재 점수값에도 반영 this.total += score; // 전체 점수값에도 반영 this.listener(); &#125;&#125;const Stage = class &#123; ... score(line) &#123; return parseInt((this.curr * 5) * (2 ** line)) &#125;&#125; score와 stage간의 의존성이 생김 코드는 여러분들이 모국어로 쓰지 않기 때문에동작만 하면 다 똑같은 코드로 보인다.코드도 언어이기 때문에 한국어의 미묘한 늬앙스를 다양한 형사와 동사로 표현하는 것처럼,코드도 동작해도 표현방법에 따라서 늬앙스를 다 표현할 수 있다. 3. Block클래스일까 인스턴스일까. 찍어낼 수 있어야 한다. &#x3D;&gt; 클래스 부모클래스 &gt;&gt; 자식클래스 블럭 정의 테트리스 블럭은 회전을 할 수 있다.회전축, 회전점을 정의하자. 세로와 가로의 모습을 보면 **2차원 배열**로 구현할 수 있다는 것이 보인다. (행과 열) cf__2 연산은 데이터로 바꿀 수 있다.데이터 하나로 연\b산화 시킴 or 데이터 2개로 연산비용을 낮춤. 예전에는 머신이 낮고 메모리가 낮았기 때문에 연산을 중심으로 움직이고 메모리 비용을 낮추는 방향으로 갔음. cpu 비용을 아끼고(연산비용을 줄이고) 메모리 비용을 사용하는 방향이 요즘 추세 12345678910111213141516// Block 클래스 : 카테고라이제이션 하는 중.. // =&gt; 모든 자식 블럭들이 공통으로 가져야하는 속성들 const Block = class &#123; constructor(color) &#123; prop(this, &#123;color, rotate:0&#125;;) &#125; // rotate: CW, CCW (시계방향, 시계반대방향 개념) left() &#123; if(--this.rotate &lt; 0) this.rotate = 3; &#125; right() &#123; if(++this.rotate &gt; 3) this.rotate = 0; &#125; getBlock()&#123;throw &#x27;override!&#x27;;&#125;&#125;const blocks = [class extends Block, ...] 123456789101112class extends Block &#123; constructor()&#123; super(&#x27;#f8cbad&#x27;); &#125; getBlock()&#123; return this.rotate % 2 ? [[1], [1], [1], [1]] : [[1,1,1,1]] // [[1], [1], [1], [1]] 컬럼이 하나만 있는 row가 4개인 배열 : | // [[1,1,1,1]] row가 하나만 있는 컬럼이 4개인 배열: ---- &#125;&#125; 12345678910111213class extends Block &#123; constructor()&#123; super(&#x27;#f8cbad&#x27;); &#125; getBlock()&#123; switch(this.rotate)&#123; case 0: return [[0,1,0], [1,1,1]] case 1: return [[1,0], [1,1], [1,0]] case 2: return [[1,1,1], [0,1,0]] case 3: return [[0,1], [1,1], [0,1]] &#125; &#125;&#125; 충분히 추상화가 되었을까?rotation은 부모클래스인 Block에서 관리자식이 부모의 속성을 갖는 것은 은닉을 깨고 있는 것 부모 자식간에도 캡슐화와 은닉화가 성립해야한다. this.rotate로 접근하고 있다. this.rotate % 2 부모의 rotate 정의에 자식이 맞추고 있다. 코드의 책임, 역할을 의인화 시켜서 생각하는 것이 좋다. getBlcok()을 호출할 때마다 배열을 매번 생성하고 있다. 컨텍스트 데이터가 되어야한다. 다시 개선 123456789101112131415161718192021222324252627282930const Block = class &#123; constructor(color, ✨✨...blocks) &#123; prop(this, &#123; color, rotate:0, ✨✨blocks, ✨✨count: blocks.length - 1 // 회전 카운트 &#125;;) &#125; left() &#123; if(--this.rotate &lt; 0) this.rotate = 3; &#125; right() &#123; if(++this.rotate &gt; ✨✨count) this.rotate = 0; &#125; getBlock()&#123; ✨✨ // 클래스를 반환 return this.blocks[this.rotate]; &#125;&#125;const blocks = [ class extends Block &#123; constructor()&#123; super(&#x27;#f8cbad&#x27;, [[1], [1], [1], [1]], [[1,1,1,1]] ); &#125; &#125;] 4. Renderer렌더러는 stage, score, block을 몰라도, data만 알아도 되는 구조 1234567891011121314151617181920212223const Renderer = class &#123; constructor(col, row)&#123; prop(this, &#123;col, row, blocks:[]&#125;); while(row--) this.blocks.push([]); &#125; clear()&#123;throw &#x27;override&#x27;;&#125; // 자식이 클리어 해야한다. // 대체가능성(상속성)과 내적동질성(다형성). // 자식을 다 부모로 보게 하고 싶다. // 어떤 자식이 와도 clear를 호출할 수 있다. // 부모의 clear를 호출해도 내적동질성때문에 자식의 clear가 호출된다. // 명시적으로 clear라는 method를 부모에 할당해주지만, 자식들이 렌더링 하는 방식이 다르기 때문에 실제 clear는 다형성에 의해서 자식들의 clear 메서드가 호출된다. == 무의미한 코드가 아니다. render(data)&#123; if(!(data instanceof Data)) throw &#x27;invalid data&#x27;; // 프로토콜 확인만 해준다. this._render(data); // 내적동질성(다형성)에 의해서 자식의 _render가 호출된다. // 디자인 패턴 중: 템플릿 메서드 패턴 (객체지향 언어가 내적동질성을 보장해주어야한다) // 템플릿 메서드를 사옹하는 이유 // 부모쪽에 있는 메서드가 많은 서비스를 제공하고 실제 할 일을 후킹하고 있는 자식클래스에게 위임하기 위해 &#125; _render(data)&#123;throw &#x27;override!&#x27;;&#125;&#125; Template Method Pattern어떤 작업 알고리즘의 골격을 정의한다. 일부 단계는 서브 클래스에서 구현하도록 할 수 있다. 템플릿 메서드를 이용하면 알고리즘의 구조는 그대로 유지하면서 특정 단계만 서브 클래스에서 새로 정의하도록 할 수 있다. 4-0. Data(protocol)123456// Array를 상속 받는 이유는 형을 확인하기 위해 강제로 만듦.// 마크업 클래스// Array객체를 베이스로 하는 객체가 만들어진다.const Data = class extends Array &#123; constructor(row, col)&#123;prop(this, &#123;row, col&#125;);&#125;&#125; es6는 클래스 내부에서 this를 바꿔 줄 수 있다. 4-1. Table Renderer1234// utilityconst el = el =&gt; document.createElement(el);const back = (s: pixel, v: color) =&gt; s.backgroundColor = v;// 배경 색 변경으로 움직임을 표현한다. 12345678910111213141516171819202122232425262728const TableRenderer = class extends Renderer &#123; // base: 테이블 element // back: background 칼라 constructor(base, back, col, row)&#123; super(col, row); this.back = back; white(row--)&#123; const tr = base.appendChild(el(&#x27;tr&#x27;)), curr = []; // row만큼 tr을 만들어서 넣기. this.blocks.push(curr); // 빈 블럭 배열을 blocks에 넣어준다. this.blocks는 Renderer의 blocks let i = col; while(i--) curr.push(tr.appendChild(&#x27;td&#x27;).style); // 스타일 객체만 넣는다. &#125; this.clear(); &#125; clear()&#123; this.blocks.forEach( curr =&gt; curr.forEach(s =&gt; back(s, this.back)) ) // back함수는 utility의 back // back함수에 현재 back 칼라를 전부 할당한다. &#125; _render(v: Data)&#123; this.blocks.forEach( (curr, row) =&gt; curr.forEach((s, col) =&gt; back(s, v[row][col])) ) &#125;&#125; 변수 사용시 한 번 밖에 사용되지 않는데 변수로 잡는 것은 사실은 중복 for와 forEach 중 어떤걸 사용할까?언어스팩에서 정의되어있는 메서드를 사용하자. forEach성능문제는 우선 고려하지 말자. 4-2. Canvas Renderer1234567891011121314151617181920212223const CanvasRenderer = class extends Renderer&#123; constructor(base, back, col, row)&#123; suepr(col, row); prop(this, &#123; width: base.width = parseInt(base.style.width), height: base.height = parseInt(base.style.height), cellSize: [base.width/col, base.height/row], ctx: base.getContext(&#x27;2d&#x27;) &#125;); &#125; _render(v)&#123; const &#123;ctx, cellSize:[w, h]&#125; = this; ctx.clearRect(0, 0, this.width, this.height); let i = this.row; while(i--)&#123; let j = this.col; while(j--)&#123; ctx.fillStyle = v[i][j]; ctx.fillRect(j *w, j*h, w, h); &#125; &#125; &#125;&#125; 참고자료https://www.bsidesoft.com/?p=2827https://github.com/abhbtbb/tetris1","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"CodeSpitz78 4/ OOAD와 테트리스 (1)","slug":"OOP_06","date":"2018-10-01T12:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2018/10/01/OOP_06/","permalink":"http://feel5ny.github.io/2018/10/01/OOP_06/","excerpt":"","text":"🌕🌑🌑 🔥 코드스피츠 수업을 수강하면서 복습한 내용을 정리했습니다.OOA, OOD까지만의 내용만 다루었습니다. 강의와 추가로 찾아본 자료와 섞여있습니다. 1. 개요1-1 OOAD? 개념 (Object-Oriented Analysis and Design)소프트웨어를 개발하는 하나의 방법론으로모든 소프트웨어 시스템의 주요 기본요소를사물을 가리키는 객체와그 객체들을 하나의 집합으로 묶은 클래스로 구성하는객체지향적인 분석과 설계 방법을 말한다.객체지향적이란 것은 현실세계에 실재하는 사물, 즉 객체들을 지향한다는 것이다. OOA: 분석하자 OOD: 설계하자 OOP: 프로그래밍 하자 1-2 객체 지향의 키워드1-2-1 클래스 class &#x3D;&gt; 추상 (abstract)클래스는 추상,오브젝트는 클래스가 실체로 만들어진 것 클래스클래스는 표현 대상들의 공통적인 특징에 대한 서술(추상)을 말한다 추상추상은 사용자가 구체적인 내용을 생각하지 않고도 사용할 수 있는 기능 프로시져 추상화 Procedural abstraction : 함수 데이터 추상화 Data abstraction : 구조체, 배열, 포인터 1-2-2 오브젝트 object &#x3D;&gt; 실체 (instance)오브젝트는 클래스의 인스턴스이다.오브젝트는 instance of class &#x3D;&gt; 클래스가 실체로 만들어진 것. 오브젝트는 데이터와 데이터에 대한 조작의 묶은 것 오브젝트 모양은 클래스에 서술되어 있다. cf__ 다양한 용어지만 같은 뜻 attribute &#x3D; data &#x3D; member variables &#x3D; state &#x3D; field behavior &#x3D; operation &#x3D; member function &#x3D; method 클래스 class &#x3D; 개념 concept &#x3D; 타입 type 객체 object &#x3D; 실체 instance &#x3D; 변수 variable 1-2-3 캡술화 encapsulation데이터와 (data)데이터를 다루는 방법을 (operation on data)묶는 것 관련 있는 것을 묶어서 이름을 부여한 것 &#x3D;&gt; 추상화 객체지향에서 객체끼리 지켜야할 최소한의 룰은닉: 숨기다. 어디까지 안보여주는 거지? 이상적인 은닉: 아무것도 안보여주겠어! 언어 차원에서도 강제로 뜯어볼 수 없는 장치를 마련했으면 좋겠다. 옵셔널하게 지원하는 기능: 데이터 하이딩을 직접 지원에서 내부를 볼 수 없게 한다. (언어마다 다르다.)캡슐화 은닉과 상관없다. 몰라도 되게 만들고 싶은 것. 자세히 알면 독이 되기 때문. 가장 모르는 수준까지만 알려준다. 추상화된 행위만 알려준다. 예_ ATM 기계 최대한 은닉하고최대한 캡슐화해서 상대방과 대화한다. 솔리드 원칙 헐리우드 원칙 (참고) 드라이 원칙 … 1-2-4 상속성 inheritance하나의 클래스가 가지고 있는 특징들(데이터 + 조작)을 그대로 다른 클래스가 물려 받는 것 상속성은 계보(계층의 의미도 있다.) 재사용과 유연성 대체 가능성 자식이 부모를 대체할 수 있다. 자바스크립트 : prototype chain을 이용해 상속 ⇒ 대체 가능성을 구현한다. (__proto__) Chaining 시스템으로 대체가능성을 구현할 수 있기 때문에 자바스크립트도 객체지향을 지원한다고 얘기할 수 있다. 1-2-5 다형성 polymorphism &#x3D;&#x3D; 내적 동질성상속성의 계층을 따라서 각각의 클래스에 한가지 이름을 줄 수 있다. 같은 명령을 각기 다른 오브젝트에 줄 수 있다. 123456789Dog d;d = new Poodle()d.bark()d = new Bulldog()d.bark()d = new Husky()d.bark() 처음 만들어졌을 때 원형이 누구냐에 따라서 오버라이드 되어있거나 오버라이딩 된 속성을 반드시 만들어진 구상객체를 사용하도록 되어있다. cf__ 메세지 전달 message passing객체지향관점에서 프로그램은 오브젝트에 message를 보내는 것으로 실행 실제 구체적 동작과 관계없이 객체와 객체에 대한 상호작용 관점을 제공.. 객체지향 프로그래밍은 패러다임(관점) 중 하나이다. 구조적 프로그래밍 (파스칼, C) 객체지향 프로그래밍 (자바, C++) 명령형 프로그래밍 (파스칼, C, …) 선언형 프로그래밍 (SQL, 프롤로그) 함수형 프로그래밍 (하스켈, 리스프) 객체기반 (자바스크립트, 에이다,) 이벤트 드리븐 프로그래밍 절차적 프로그래밍 … 1-3. 객체지향 분석 및 설계 문제영역에서 배우(actor)를 찾아내고 각 배우들의 책임과 역할을 정의하고 배우들간의 관계를 지정하고 각 배우들에 대한 대본(script)를 쓴다. 👇 식별하고 일반화하고(object, class), 대상들 간의 관계 (inheritance, embedded)를 설정하고, 상호작용 하도록(behavior)한다. 👇 도메인 &#x3D;&gt; 도메인 개념의 시각화 &#x3D;&gt; 설계 객체를 구현 use case 정의 요구분석 도메인 모델 정의 문제영역 분석 및 표현 객체지향분석은 영역객체를 분류하는 관점에서 관심영역을 기술하는 것과 연관 도메인 : 해결하고자 하는 대상 영\u001c역&#x3D;&gt; 소프트웨어는 도메인의 문제를 해결하기 위한 수단 추상화 인터렉션 다이어그램 정의 상호협력 관계 표현 설계 클래스 정의 난감한 도메인을 만났을때 우리는 어떻게 데이터 분석을 해서 처리할 수 있는가⇒ 데이터 분석의 결과가 객체지향이 될 수 있게 하는 것이 우리의 목표 2. 추상화 Abstraction: 대상에서 특징만 뽑아낸 것사람은 상징체계를 만들고, 발전시켜 다음 세대애 물려준다. (&#x3D;&gt; 추상화 능력)객체지향은 기본적으로 추상화 라는 영역에 속해 있다. 2-1. Categraization분류를 일정한 기준으로 묶어 놓는 것.디테일을 숨기고 카테고리의 특징만 뽑아내서 이해하게 된다. 2-2. 모델링현실세계에 있는 실물에서 내가 기억해야할 것들을 모아 놓은 것. 모델링에서 가장 중요한 것 이 도메인에서 꼭 기억해야할 게 모지? 를 먼저 정해야한다. how? 도메인에서 데이터 분석을 통해서 반드시 기억해야만 하는 후보를 정하는 행위 ⇒ 모델링 기억해야만 할 특징을 정의하는 행위 2-3. 집합 가장 기초적인 추상화 그냥 모아놨기 때문에 카테고라이제이션이라고 하지 않는다. 무작위 적인 그룹핑을 시킬 수 있다. 3. 테트리스 OOAD카테고라이제이션으로 관리할 수 있나? 그냥 그룹화해서 관리할 수 있나?본인이 역할(role)과 책임이 있나?권한과 책임을 일치하게 나눌 수 있냐.. cf__설계시 유의해야할 점 simplex: 의존성이 한쪽 (단방향 참조) multiplex: 의존성이 양쪽 (양방향 참조) - 혹시나 하는 의존성을 찾기 위해서 전체 그림을 그려본다. - UML - 설계시에는 simplex를 유지하자. 인지하기 쉬운 객체 찾기DATA (프로토콜) Render와 게임정보 사이의 프로토콜 역할 상호 간에 약속한 형태(프로토콜)를 끠어넣으면 둘 사이의 의존성이 줄어들게 된다. 프로토콜 &#x3D; 의정서, 합의서, 약정서 게임본체와 렌더러는 서로 몰라도 되고, 프로토콜만 알면 된다. Game 게임본체: stage + score + block + 범용패널 을 포함한다. Stage: 현재 스테이지 정보 Score: 점수 및 계산법 Block: 다양한 타입의 블록 범용패널 시작화면 종료화면 죽음 클리어 결과화면 범용 렌더링 처리기 Renderer : 데이터를 받아서 그리는 역할 Table 렌더러 Canvas 렌더러 프로토콜을 적용하냐 마냐는?변화율에 따라서!변화율이 극심한 경우에는 중간에 반드시 프로토콜을 넣어주어야한다! 참고자료OOAD : http://dollipolly.tistory.com/entry/OOAD-Object-Oriented-Analysis-Designhttp://egloos.zum.com/nom3203/v/2502870객체지향 : https://www.slideshare.net/plusjune/ss-46109239","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"CodeSpitz78 3/ (stack 구조) HTML parser ✨✨","slug":"OOP_05","date":"2018-09-24T12:20:19.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2018/09/24/OOP_05/","permalink":"http://feel5ny.github.io/2018/09/24/OOP_05/","excerpt":"","text":"🌕🌑🌑 🔥 코드스피츠 수업을 수강하면서 복습한 내용을 정리했습니다.참고 : 렌더링 엔진 - 파싱 1. 개요어떤 상황을 보고 구조적이고 재귀적인 형태로 파악을 할 수 있느냐,데이터 분석을 할 수 있느냐.. BNF&lt;기호&gt; ::&#x3D; &lt;표현식&gt; 내부 구성요소로부터 응용구성요소 확장하는 것을 BNF 정의방식 언어의 구성요소를 정의하는 여러 문법들이 있다 (lex, yak) html 기본 패턴1234A = &lt;tag&gt;body&lt;/tag&gt;B = &lt;tag /&gt;C = textbody = (A|B|C)N > 위의 그림을 파싱할 수 있는 파서를 만들고 싶다! > 케이스가 재귀면서 복합적인 상황을 짤 수 있다면 **중급개발자** 파서의 기본 구조 함수의 목표, 인자값과 리턴값이 무엇인지 정의한다. 무슨 인자를 받아서 무엇을 리턴하지? 문자열을 읽어서 구조적으로 객체화 시켜 리턴하게 하고 싶다. 1234567891011121314151617181920212223242526272829interface Result &#123; name?: string, type: string, // text, node children: Result[]&#125;interface StackItem &#123; tag: Result&#125;const parser = (input: string): Result[] =&gt; &#123; input = input.trim(); // 초기화 const result = &#123;name: &#x27;ROOT&#x27;, type: &#x27;node&#x27;, children: []&#125;; const stack = [&#123;tag: result&#125;]; let curr, i = 0, j = input.length; while(curr = stack.pop())&#123; while(i &lt; j)&#123; const cursor = i; // 헷갈리기때문에 조회용으로 따로 if(input[cursor] === &#x27;&lt;&#x27;)&#123; // &#x27;&lt;&#x27;로 시작하면 태그: A,B의 경우 &#125; else &#123; // 텍스트 타입: C의 경우 &#125; &#125; &#125;; return result;&#125; 중첩루프 첫번째 loop는 동적 루프 루프를 결정하는 요인이 안의 루프를 돌다가 변할 수도 있다. 이런 루프가 기본이다. 익숙해지자 ~ 조건이 false가 될때까지 loop 두번째 loop는 정해져있는 루프 스캐너 루프라고 한다. 계획되지 않은 loop는 위험하다는 생각을 버리자. 스택수준으로 loop를 돌아야한다. 때문에 스택구조 루프 아래에 알고리즘이 있는 상황이다 2. 텍스트 노드C타입: 텍스트 2-1. 순서다음 태그까지를 파악 name: 현재 커서 ~ 다음 태그까지의 텍스트 추출 type: ‘text’ children은 없다. 12345678910111213141516171819202122232425262728293031323334353637interface Result &#123; name?: string, type: string, // text, node children: Result[]&#125;interface StackItem &#123; tag: Result&#125;const parser = (input: string): Result[] =&gt; &#123; input = input.trim(); const result = &#123;name: &#x27;ROOT&#x27;, type: &#x27;node&#x27;, children: []&#125;; const stack = [&#123;tag: result&#125;]; let curr, i = 0, j = input.length; while(curr = stack.pop())&#123; while(i &lt; j)&#123; const cursor = i; if(input[cursor] === &#x27;&lt;&#x27;)&#123; // &#x27;&lt;&#x27;로 시작하면 태그: A,B의 경우 &#125; else &#123; // 텍스트 타입: C의 경우 👇👇👇 const idx = input.indexOf(&#x27;&lt;&#x27;, cursor); // cursor위치에서부터 &lt; 위치: 다음 태그 전까지 curr.tag.children.push(&#123; type: &#x27;text&#x27;, text: input.substring(cursor, idx); &#125;); // children이 없기 때문에 children은 패스 i = idx; // 다음 시작지점을 옮김 👆👆👆 &#125; &#125; &#125;; return result;&#125; 2-2. 분리 로직이 독립적이다. 따로 분리 가능 ! curr 때문에 결합도가 올라가지만 어쩔 수 없는 부분 역할을 인식하자마자!! 분리하자.나중에 분리할 때는 이미 오염되어있어서 분리시키기 어렵다. 12345678const textNode = (input: string, cursor: number, curr: StackItem): number =&gt; &#123; const idx = input.indexOf(&#x27;&lt;&#x27;, cursor); curr.tag.children.push(&#123; type: &#x27;text&#x27;, text: input.substring(cursor, idx); &#125;); return idx;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940interface Result &#123; name?: string, type: string, // text, node children: Result[]&#125;interface StackItem &#123; tag: Result&#125;const parser = input =&gt; &#123; input = input.trim(); const result = &#123;name: &#x27;ROOT&#x27;, type: &#x27;node&#x27;, children: []&#125;; const stack = [&#123;tag: result&#125;]; let curr, i = 0, j = input.length; while(curr = stack.pop())&#123; while(i &lt; j)&#123; const cursor = i; // 헷갈리기때문에 조회용으로 따로 if(input[cursor] === &#x27;&lt;&#x27;)&#123; // &#x27;&lt;&#x27;로 시작하면 태그: A,B의 경우 &#125; else &#123; 👇👇👇 i = textNode(input, cursor, curr) 👆👆👆 &#125; &#125; &#125;; return result;&#125;// 목표: textNode를 생성 + result 배열에 추가 =&gt; idx값(텍스트 노드의 마지막 순서값) 반환const textNode = (input: string, cursor: number, curr: StackItem): number =&gt; &#123; const idx = input.indexOf(&#x27;&lt;&#x27;, cursor); curr.tag.children.push(&#123; type: &#x27;text&#x27;, text: input.substring(cursor, idx); &#125;); return idx;&#125; 코드를 짤 때는 무조건 쉬운 것 부터 처리한다. why? 쉬운것의 특징은 : 의존성이 낮다. 독립된 기능일 경우가 높다. 의존성이 낮은 모듈부터 높은 모듈로 올라가자. 3. 태그 노드&lt;가 발동 트리거로 쓰이고 있다. 이렇게 week하게 ? 파서를 만들 때는 이렇게 seperator, token 형태의 트리거가 만들어진다. 트리거가 발동되는 케이스가 3가지 종류가 있다. 시작태그 닫는태그 완료태그 공통점시작태그로 시작해서 닫는태그로 끝난다. 공통점을 찾아서 코드를 중복시키는 것을 피해야한다.눈을 훈련해서 먼저 공통요소를 추상화 할 수 있는 능력을 키워야한다. 3.1 empty element &lt;img /&gt;, open tag &lt;div&gt;empty element가 더 간단해 보이므로 먼저짜긔 123456789101112131415161718192021222324252627282930313233const parser = input =&gt; &#123; input = input.trim(); const result = &#123;name: &#x27;ROOT&#x27;, type: &#x27;node&#x27;, children: []&#125;; // 리턴값 : 이름이 뭐고, 타입이 뭐고, children을 뭘 갖고 잇는지. const stack = [&#123;tag: result&#125;]; // DOM 객체 let curr, i = 0, j = input.length; while(curr = stack.pop())&#123; while(i &lt; j)&#123; const cursor = i; // 헷갈리기때문에 조회용으로 따로 if(input[cursor] === &#x27;&lt;&#x27;)&#123; // &#x27;&lt;&#x27;로 시작하면 태그: A,B의 경우 // 현재 cursor |&lt; const idx = input.indexOf(&#x27;&gt;&#x27;, cursor); // 현재 idx |&gt; i = idx + 1; if(input[cursor + 1] === &#x27;/&#x27;)&#123; // close 태그 &#125; else &#123; 👇👇👇 if(input[idx - 1] === &#x27;/&#x27;)&#123; // empty 태그 &#125; else &#123; // open 태그 &#125; &#125; 👆👆👆 &#125; else i = textNode(input, cursor, curr) &#125; &#125;; return result;&#125;const textNode = (input, cursor, curr) =&gt; &#123;...&#125;; cf__1 코드 설계를 잘하자좋은 코드를 짜는 비밀은 테스트 주도 개발에 있는 것이 아니라, 데이터를 이해하고 재귀적인 로직을 찾아내거나 추상화된 공통점을 찾아내거나 역할을 이해하거나에 있다. 머릿속에 맨톨모델이 그려지면 코드로 똑같이 표현되어야지 정상이다. 그래야 나중에 유지보수가 된다. 그러기 때문에 주석이 필요없다. 바른 데이터 모델링이 돼었으면 코드는 그냥 매핑용이다. 12345678910111213let name, isClose; // 👈 공통 준비사항 층 if(input[idx - 1] === &#x27;/&#x27;)&#123; // 👈 공통 처리사항 층 ~ // empty element 태그 // name은 &#x27;&lt;&#x27;와 &#x27;&gt;&#x27;사이 name = input.substring(cursor + 1, idx - 1); isClose = true;&#125; else &#123; // open 태그 name = input.substring(cursor + 1, idx); isClose = false;&#125;const tag = &#123;name, type: &#x27;node&#x27;, children: []&#125;; // 👈 흡수하는? 층curr.tag.children.push(tag); 케이스는 다 값으로 바꿀 수 있다. 케이스의 차이를 값으로 흡수해서 하나의 알고리즘으로 만듦. 메모리(name, isClose)와 연산(조건문)은 교환된다. 연산을 메모리로 바꿈 &#x3D;&gt; 메모리를 가리키는 하나의 연산만 기술하면 된다. 위의 코드 형태 공통 준비사항 층 공통 처리사항 층 다른점을 기술하는 부분을 흡수하는 층 cf__2 화이트리스화이트리스 whitelist‘안전’이 증명된 것만을 허용하는 것으로 ‘악의성’이 입증된 것을 차단하는 블랙리스트 보안과 상반되는 보안 방식 이다.화이트리스트, 블랙리스트라는 용어 대신 ‘positive’와 ‘nagative’ 보안 방법으로 불려지기도 합니다. 12345678910111213141516171819202122232425262728const idx = input.indexOf(&#x27;&gt;&#x27;, cursor);// 현재 idx |&gt;i = idx + 1;if(input[cursor + 1] === &#x27;/&#x27;)&#123; // close 태그&#125; else &#123; let name, isClose; if(input[idx - 1] === &#x27;/&#x27;)&#123; // empty element 태그 // name은 &#x27;&lt;&#x27;와 &#x27;&gt;&#x27;사이 name = input.substring(cursor + 1, idx - 1); isClose = true; &#125; else &#123; // open 태그 name = input.substring(cursor + 1, idx); isClose = false; &#125; const tag = &#123;name, type: &#x27;node&#x27;, children: []&#125;; curr.tag.children.push(tag); 👇👇👇 if(!isClose)&#123; stack.push(&#123;tag, back:curr&#125;); // ✨✨ 리턴포인트를 수동으로 정의하는 상황. break; // while문의 break &#125; 👆👆👆&#125; 분리 ~ 1234567891011121314151617181920212223242526272829303132333435363738const idx = input.indexOf(&#x27;&gt;&#x27;, cursor);// 현재 idx |&gt;i = idx + 1;if(input[cursor + 1] === &#x27;/&#x27;)&#123; // close 태그&#125; else &#123; if(elementNode(input, cursor, idx, curr, stack)) break;&#125;...const elementNode = ( input: string, cursor: number, idx: number, curr: StackItem, stack: StackItem[]): boolean =&gt; &#123; let name, isClose; if(input[idx - 1] === &#x27;/&#x27;)&#123; // empty element 태그 // name은 &#x27;&lt;&#x27;와 &#x27;&gt;&#x27;사이 name = input.substring(cursor + 1, idx - 1); isClose = true; &#125; else &#123; // open 태그 name = input.substring(cursor + 1, idx); isClose = false; &#125; const tag = &#123;name, type: &#x27;node&#x27;, children: []&#125;; curr.tag.children.push(tag); if(!isClose)&#123; stack.push(&#123;tag, back:curr&#125;); // 리턴포인트를 수동으로 정의하는 상황. return true; &#125; return false;&#125; cf__3 가독성이 높은 코드?(변수명을 이쁘게 쓰던, 컨벤션을 지키던)코드가 리더블하다? Readable 적절한 역할모델로 위임되서그들간의 통신과 협업만 볼 수 있는 코드가가독성이 높은 코드이다. 3.2 close tag1stack.push(&#123;tag, back:curr&#125;); 12345678910111213141516171819202122232425262728293031323334353637...const idx = input.indexOf(&#x27;&gt;&#x27;, cursor);// 현재 idx |&gt;i = idx + 1;if(input[cursor + 1] === &#x27;/&#x27;)&#123; 👇👇👇 // close 태그 curr = curr.back; 👆👆👆&#125; else &#123; if(elementNode(input, cursor, idx, curr, stack)) break;&#125;...const elementNode = (input, cursor, idx, curr, stack) =&gt; &#123; let name, isClose; if(input[idx - 1] === &#x27;/&#x27;)&#123; // empty element 태그 // name은 &#x27;&lt;&#x27;와 &#x27;&gt;&#x27;사이 name = input.substring(cursor + 1, idx - 1); isClose = true; &#125; else &#123; // open 태그 name = input.substring(cursor + 1, idx); isClose = false; &#125; const tag = &#123;name, type: &#x27;node&#x27;, children: []&#125;; curr.tag.children.push(tag); if(!isClose)&#123; stack.push(&#123;tag, back:curr&#125;); // 리턴포인트를 수동으로 정의하는 상황. return true; &#125; return false;&#125; cf__4css압축이나 javascript압축보다html압축이 브라우저의 부하를 줄이는 방법쓸데없는 노드생성을 줄인다. 1234567891011const elementNode = (input, cursor, idx, curr, stack) =&gt; &#123; const isClose = input[idx - 1] === &#x27;/&#x27;; const tag = &#123;name: input.substring(cursor + 1, idx - (isClose ? 1: 0)), type: &#x27;node&#x27;, children: []&#125; curr.tag.children.push(tag); if(!isClose)&#123; stack.push(&#123;tag, back:curr&#125;); // ✨✨ 리턴포인트를 수동으로 정의하는 상황. return true; &#125; return false;&#125; 4. 최종1234567891011121314151617181920212223242526272829303132333435363738394041424344const parser = input =&gt; &#123; input = input.trim(); const result = &#123;name: &#x27;ROOT&#x27;, type: &#x27;node&#x27;, children: []&#125;; const stack = [&#123;tag: result&#125;]; // DOM 객체 let curr, i = 0, j = input.length; while(curr = stack.pop())&#123; while(i &lt; j)&#123; const cursor = i; // 헷갈리기때문에 조회용으로 따로 if(input[cursor] === &#x27;&lt;&#x27;)&#123; const idx = input.indexOf(&#x27;&gt;&#x27;, cursor); i = idx + 1; if(input[cursor + 1] === &#x27;/&#x27;)&#123; // 닫는태그 curr = curr.back; &#125; else &#123; if(elementNode(input, cursor, idx, curr, stack)) break; // 두번째 루프 break &#125; &#125; else i = textNode(input, cursor, curr) &#125;; &#125; return result;&#125;const textNode = (input, cursor, curr) =&gt; &#123; const idx = input.indexOf(&#x27;&lt;&#x27;, cursor); curr.tag.children.push(&#123; type: &#x27;text&#x27;, text: input.substring(cursor, idx), &#125;); return idx;&#125;;const elementNode = (input, cursor, idx, curr, stack) =&gt; &#123; const isClose = input[idx - 1] === &#x27;/&#x27;; const tag = &#123;name: input.substring(cursor + 1, idx - (isClose ? 1: 0)), type: &#x27;node&#x27;, children: []&#125; curr.tag.children.push(tag); if(!isClose)&#123; stack.push(&#123;tag, back:curr&#125;); // ✨✨ 리턴포인트를 수동으로 정의하는 상황. return true; &#125; return false;&#125;","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"CodeSpitz78 2/ 루틴 심화","slug":"OOP_04","date":"2018-09-07T12:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2018/09/07/OOP_04/","permalink":"http://feel5ny.github.io/2018/09/07/OOP_04/","excerpt":"","text":"🌕🌑🌑 🔥 코드스피츠 수업을 수강하면서 복습한 내용을 정리했습니다.공부 후에는 풀어서 쉬운 언어로 설명할 수 있도록 연습하자. 1. 참조 전파의 문제 LA는 간접적으로 B를 물고 있다. 상호 참조(연쇄참조)가 되어서 서로 오염이 된다.. 디버깅이 어려워진다. 참조값은 전체를 오염시키기 쉽다. 복사본을 넘겨야한다. 2. 서브루틴의 체인 > keep의 정확한 대상 인자와 지역변수를 포함하는 곳: 실행컨택스트 - 함수 콜을 return 이후로 옮겼다. - 메모리를 유지할 필요가 없으니, 리턴포인트를 다른 곳으로 지정해주면 어떨까? - 리턴포인트는 언어 수준에서 정해져있다. - 리턴포인트를 처음 호출한 함수로 옮긴다 => tail recursion - 언어수준에서 리턴포인트를 지정하기 때문에 언어마다 재귀꼬리 최적화를 지원하는 언어도 있고, 없기도 하다. - 제어문의 loop 처럼 옮긴다. - 처리하고 => 해제하고 - 제어문은 for문을 돌때마다 메모리를 유지하지 않는다. - index 변수만 남아 있다. - 제어문의 **`stack clear`** 구문. - for문은 처음 loop돌리는 블럭에 대해서 스택영역에 대해서 실행한 다음에 점프시, 앞의 stack 메모리를 전부 해제한다. 3. 재귀 꼬리 최적화 Tail Recursion for문의 도움을 받지 않고도 고성능의 루프를 만들어 낼 수 있다. 사파리가 지원하고 있다. 크롬 X, 엣지 X tail recursion을 지원한다. script time out만 난다. stack over flow는 일어나지 않는다. 언어마다 tail recursion이 이뤄지는 조건을 정의해 둔다. 효율적인 재귀함수를 짤 수 있다. ** *예시 ** 123456const sum = v =&gt; v + (v ? sum(v-1) : 0);sum(3);// 1. 3 + sum(2)// 2. 2 + sum(1)// 3. 1 + 0 더하기 연산자는 꼬리물기 최적화를 방해한다. 모든 연산자는 스택메모리를 유뱔한다. 인자로 옮겨서 스택메모리가 생기지 않도록 하였다. 연산을 인자로 옮긴다!!123456789const sum = (v, prev = 0) =&gt; &#123; prev += v; return (v &gt; 1 ? sum(v-1, prev) : prev);&#125;sum(3);// 1. sum(v:3, prev:0) return sum(2,3)// 2. sum(v:2, prev:3) return sum(1,5)// 3. sum(v:1, prev:5) reutrn 6// 3번째 return값이 첫번째 sum(3)의 리턴포인트로 리턴된다. 자바스크립트에서 tail recursion 안 일으키는 연산자 (언어수준에서 정의되어있음) 삼항연산자 &amp;&amp;연산자 ||연산자 자바스크립트는 이미 ES6에서는 tail recursive를 지원하게끔 스펙으로 지정해놓았다.JVM은 지원하지 않는다. 내 메모리는 다 해제하고 다음쪽 함수메모리의 인자메모리를 사용함으로써 해결한다. 함수 외적 메모리를 알 수 있다. 위의 prev는 외적 메모리라는 것을 알 수 있다. for문의 지역변수도 외적 메모리라고 볼 수 있다. for문의 지역변수에 갱신하는 로직과 같은개념이다. 4. 🚀🚀 재귀를 루프로 Tail Recursion to loop 자유롭게 변환할 수 있어야 한다. 자동으로 변환할 수 있어야 한다.. 1234const sum = (v, prev = 0 ) =&gt; &#123; prev += v; return (v &gt; 1 ? sum(v-1, prev) : prev);&#125; 12345678const sum = (v) =&gt; &#123; let prev = 0; while(v &gt; 1)&#123; prev += v; v--; &#125; return prev;&#125; 5. ✨클로저✨ 언어적인 장치라고 생각하자. 5-1. Static state - 이렇게 작동하는 대표적인 언어가 C언어이다. - 루틴을 만드는 것이 **문**으로 되어있다. 자바스크립트처럼 변수에 대입할 수 있는 값이 아니다. - 서브루틴을 값의 형태로 만들어내는 언어가 있고, 문으로 만들어내는 언어가 있다. - 자바의 메소드는 문이다. 클래스 내부에서만 선언되어야한다. 외부에서 대입될 수 없다. - 값으로 만들 수 있으면 실행 중간에 루틴을 만들어 낼 수 있다. - 람다 - 루틴을 람다로 볼래. - c언어의 함수포인터에서 발전해온 개념. - 런타임에 서브루틴을 만들 수 있다. **클로저는 오직 런타임 중에 루틴을 만들 수 있는 언어에서 생겨난다.** - c에서는 static 메모리 - 그렇다고 이런상황에서 모든 언어가 클로저를 생산하진 않는다.. - 언어 디자이너가 어떻게 결정했냐에 따라 다르다. - 함수를 문으로 만드는 언어의 특성 5-2. Runtime state => 우리가 짠 코드를 만나면 => - 실행 중간(런타임)에 루틴의 정의 자체가 태어난다. - 자기가 태어났을 때의 **자기가 갇혀있던 박스**를 바라볼 수 있는 여지가 생긴다. - 런타임에 루틴을 만들 수 있는 언어들은 루틴을 만들면 루틴정보 안에 자기가 어디서 태어났는지를 기록한다. => 자바스크립트에서는 **스코프**라고 정의한다. - **메인 루틴의 flow를 기억한다.** main flow가 흘러가는 상황을 알고 있다. - flow상에 있는 아이들을 기억하게 된다. - 노란박스에 등장하지 않는 모든 변수를 **자유변수**라고 한다. - 자유변수들은 routine과 무관하게 존재하지만 routine에서 참조할 수 있다. - routine이 한번이라도 자유변수를 갖고오게 되면 자유변수들은 마음대로 해지되거나 조작되지 못한다. **=> routine이 물고 있기 때문** - routine을 자유변수가 갇히는 공간이라고 할 수 있다. - free variables close => closure - 만약 이 상황에서 F 메소드가 외부로 유출될 경우 main flow의 메모리가 다 해지되지 못한다. - 클로저는 자유변수의 클로저이다. 6. 중첩 클로저 nested closure 클로저는 루틴만이 만들어 내는 것이 아니다. ES6에서는 block만 주어도 스코프가 생성된다. 스코프 생성은 클로저를 만드는 행위이다. block만 주어도 클로저가 생성된다. - 연속적인 클로저가 탄생한다. - 중첩되어 있는 클로저를 마구마구 생성된다. 위 그림을 코드로 표현한다면.. 1234567891011121314window.a = 3; // main flow의 전역: globalif(a == 3) &#123; // 첫번째 block const b = 5; const f1 = v =&gt; &#123; // 첫번째 routine const c = 7; if (a +b &gt; c)&#123; // 두번째 block return p =&gt; v + p + a + b; // 두번째 routine // 자유변수를 물고 있음 =&gt; 클로저 &#125; else &#123; return p =&gt; v + p + a + b; &#125; &#125;&#125; 7. 쉐도잉 - 층층이 중첩되어있는 클로저가 있는데 각각의 클로저에서 똑같은 이름의 변수를 소유하고 있을때 일어난다. 12345678const a = 3; // main flow에 Aif(a == 3)&#123; // block scope const a = 5; // ?! a가 또 있음. const f1 = v =&gt; &#123; const a = 7; // ???!! a가 또있음!! console.log(a); &#125;&#125; 쉐도잉을 지원하는 언어는 가장 가까이에 있는 클로저를 사용한다. 서브루틴이 밖에 있는 자유변수를 안건드리게 하기 위해서는(보호하기 위해서는) 쉐도잉 방식을 사용한다. 유일한 방법은 변경하고픈 스코프의 상위에 지키고픈 변수명을 같은 변수명을 사용하여 지킨다. 위의 코드는 서브루틴에서 더 상위로 못가도록 막음 1234567const a = 3; // main flow에 Aif(a == 3)&#123; // block scope const a = 5; // 보호막을 만든 개념 const f1 = v =&gt; &#123; console.log(a); // 서브루틴 상위의 a에 접근 &#125;&#125; 8. 코루틴 커맨드 패턴 실행하다가 중간에 멈출 수 있지 않을까? 라는 생각에 도달함 실행하다가 중간에 멈추고 &#x3D;&gt; 리턴포인트로 보내자! main flow에서 sub routine에 갔다가 20번째에서 멈춤 &#x3D;&gt; 다시 main flow로 흐름 &#x3D;&gt; 또 다시 sub routine의 21번째에서 시작 &#x3D;&gt; 다시 main flow로 흐름 &#x3D;&gt; 또 다시 sub routine의 50번째에서 멈춤 작성한 모든 문을 record라는 객체로 감싸서 메모리에 저장한다. co routine &lt;-&gt; single routine 자바스크립트에서는 ES6의 제너레이터에서 가능하다. 일반적인 루틴 싱글루틴은 루틴이 끝까지 실행되는 것을 보장한다. 코루틴 리턴말고 yield를 사용한다. (언어마다 키워드가 다르다.) 자바스크립트에는 C# 문법이 많이 반영되어있다. (async await도..) yield에서 끊어지고 리턴포인트로 돌아간다. yield에서는 suspension(일시정지)가 일어난다. suspension: 코루틴에 의해서 멈춰있는 상태 suspension을 이용해서 몇번이나 진입했다가 나갔다가를 반복할 수 있다. 문인데도 불구하고 **suspension**를 걸 수 있다. 코루틴을 이용해서 좋은 점 위의 그림의 경우 3개의 함수를 콜해야하기 때문에 R2의 3가지 버전이 필요했을 것이다. 3가지 버전의 함수들이 값을 공유해야했다면 서로 받은 값들을 인자로 넘겨줘야했을 것이다. 넘겨줘야할 인자가 많을 경우 점점 더 복잡한 로직이 되었을 것이다. 코루틴을 이용하면 같은 메모리 내에서 지역변수가 상태를 관리한다. 코드가 훨씬 더 쉬워진다. 루프에서 코루틴 루프 내부에 yield가 있을 경우 루프가 조건이 만족할때까지 반복하는 것이 아니라 yield에서 멈추고 반환한다. 두번째로 다시 함수를 호출하면 이전에 멈췄던 반복문에서 다시 반복문이 시작하게 된다. 루프가 돌때마다 진행하게 된다. 드디어 루프를 멈출 수 있게 할 방법이 생김. 제너레이터123456789const generator = function*(a)&#123; a++; yield a; a++; yield a; a++; yield a;&#125;const coroutine = generator(3); 제너레이터 자체는 코루틴이 아니다. 제너레이터 함수는 제너레이팅 하는 함수이기 때문에 코루틴이 아니고, 제너레이터를 호출하는 함수의 결과값이!! 코루틴이다. 3은 상수인 것 처럼 코루틴이 만들어진다. 코루틴은 인자가 3인 것을 기억하고 태어난다. 123let result = 0;result += coroutine().value;console.log(result); 코루틴은 iterator result object를 반환한다. 이 오브젝트에는 done키와 result키값이 존재한다. value에 값이 존재한다. yield로 출력된 값 123let result = 0;result += coroutine.next().value;console.log(result); // 4 next()라는 메서드를 통해 전진을 시켜야한다. 과제다음의 코드는 구구단을 출력한다.이를 만족하는 제네레이터를 작성하시오. 123456789101112const generator_Joy = function*(i, j)&#123; for(let a = 1; a &lt; i+1; a++)&#123; for(let b = 1; b &lt; j+1; b++)&#123; const c = a * b yield [ a, b, c ] &#125; &#125;&#125;;for(const [i, j, k] of generator_Joy(9,9))&#123; console.log(`$&#123;i&#125; x $&#123;j&#125; = $&#123;k&#125;`);&#125; 1234567891011121314151617181920212223242526272829// 어떤 분의 의식의 흐름const generator_Aus1 = function*(i, j)&#123; for(let a = 1, b = 1; a &lt; i ; b++)&#123; if(b === j)&#123; a++; b=0; &#125; yield [ a, b, a * b ] &#125;&#125;;const generator_Aus2 = function*(i, j)&#123; for(let a = 1, b = 1; a &lt;= i ; b++)&#123; if(b === j)&#123; a++; b=0; &#125; yield [ a, b, a * b ] &#125;&#125;;const generator_Aus3 = function*(i, j)&#123; for(let a = 1, b = 1; a &lt;= i ; b &gt;= j ? b = 0 + !!(a++) : b++)&#123; yield [ a, b, a * b ] &#125;&#125;;","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"CodeSpitz78 1/ 루틴과 결합도-응집도 모델","slug":"OOP_03","date":"2018-08-30T12:20:19.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2018/08/30/OOP_03/","permalink":"http://feel5ny.github.io/2018/08/30/OOP_03/","excerpt":"","text":"🌕🌑🌑 🔥 코드스피츠 수업을 수강하면서 복습한 내용을 정리했습니다.공부 후에는 풀어서 쉬운 언어로 설명할 수 있도록 연습하자. 1. Sub Routine 1-1. sub routine flowflow 메모리에 적재되어있는 명령이 순차적으로 실행되는 과정을 의미한다. sync라고도 한다. routine 메모리에 적재되어있는 명령어 세트 명령어 세트를 한번만 부를 수 있으면 routine이라고 하지 않는다. 여러번 실행할수 있는 방법이 갖춰졌으면 루틴. sub rotine main routine과 상대되는 개념 절대적인 개념이 아니다. 자식클래스 &lt;-&gt; 부모클래스 서브루틴을 부를 때부터 어느 포인트로 반환되는지 지정하고 부른다. 1234567891011121314151617const routineA = b =&gt; &#123; const result = b * 2; console.log(result); return result;&#125;const routineB = d =&gt; &#123; const result = d * 3; console.log(result); return d;&#125;const b = 10, d = 30;const a = routineA(b);console.log(a);const c = routineB(d);console.log(c); 루틴이 개입하게 되면 프로그램의 흐름을 일자로 읽을 수 없다. 루틴에 대한 개념이 flow의 통제를 다른 곳에 줬다 뺏는 거라는 사실 왜 함수라고 안하고 서브루틴 이라고 할까? 함수는 수학적인 개념에 가깝다. flow를 컨트롤할 때 어떤 일이 일어나는지 알고 싶은 것. 이 관점에서는 함수를 function이라고 하지 않고 routine이라고 부른다. Arrow function 참고 : http://webframeworks.kr/tutorials/translate/arrow-function/ 1-2. communicate with routine main flow와 routine사이에 통신이라는 것을 한다. 통신을 할 수 있는 매커니즘이 존재하는데, 이 매커니즘은 인자와 리턴이라고 알고 있다. 자바스크립트에서는 return 없는 루틴은 없다. ### 자바스크립트는 LR 파서를 사용한다. - 자바스크립트로 작성된 파일을 파싱할 때 사용하는 방법 - 왼쪽에서 오른쪽, 위에서 아래로 파싱 - 할당은 RL 파서이다. - 수학적인 컨텍스트로 정의되어있다. 1234567const routineA= arg =&gt; &#123; const result = arg * 2; return result;&#125;;const b = 10, c = 20, d = 30;const a = routineA(b) + routineA(c) + routineA(d); 덧셈 연산자에는 메모리가 필요하다. 갔다와서 들온 값을 기억하지 못하면 그다음 값이 들어올때까지 연산을 진행시킬 수 없다. 연산은 메모리를 만들어내고, 메모리가 연산이 해소될때까지 해제되지 않는다. 더하기 제거와 연산자 제거가 꼬리물기 최적화의 핵심이 된다. 연산이 꼬리물기 최적화에 방해를 된다. 연산이 계속 스택 메모리를 생산해 낸다. 1-3. sub routine in sub routine - 루틴A에서 루틴B가 호출될때 루틴A에서는 keep이 이루어진다. 메모리를 기억하는 행위. 스냅샷으로 기억해둔다. - 루틴B가 진행되고 루틴A로 반환되면 keep은 사라진다. 코드로 표현하면 12345const routineA = arg =&gt; routineB(arg * 2);const routineB = arg =&gt; arg * 3;const b = 10;const a = routineA(b); 스택메모리, 콜스택극단적인 예 R6에 도달하기위해 5개의 메모리를 기억해야한다. 콜스택, 함수의 스택메모리라고 부른다. 자바에서는 메모리를 1000개까지 잡을 수 있도록 도와주고, 자바스크립트에서는 100번만 하라고.. 브라우저마다 콜스택 지원이 다르다. 스택이 너무 넘처서 죽는 상황 : stackoverflow 코드로 표현하면 12345678const r1 = a =&gt; r2(a * 2);const r2 = a =&gt; r3(a * 2);const r3 = a =&gt; r4(a * 2);const r4 = a =&gt; r5(a * 2);const r5 = a =&gt; r6(a * 2);const r6 = a =&gt; a * 5;const b = 10;const a = r1(b); 서브루틴 안에 서브루틴이 들어가면 기본적으로 이런 일이 일어난다. 1-4. Value vs Reference 값과 참조값은 메모리상에서 전달할 때마다 복사되는 형태,참조는 메모리상에서 공유된 객체의 포인터만 전달되는 형식 POINT - 값이 넘어가면 복사된 값이 넘어가기 때문에 해당 루틴에서 값이 변화가 일어나도 main flow에서는 값에 영향을 주지 않는다. - 루틴에서 return 되는 값도 복사본이 넘어가기 때문에 main flow는 새로운 복사본을 받게 되는 개념이다. - 즉, main flow와 루틴 사이에는 **의존성이 낮아진다.** - **값의 정의는 언어마다 다르다.** - 문자열은 자바스크립트에서 값이지만 자바에서는 참조로 정의되고 있다. - 자바스크립트는 6개(es6 기준: number, string, boolean, undefined, null, symbol) - 하나의 루틴이 여러 flow를 상대하고 있어도 아무 문제가 생기지 않는다. - 복사본만 주고받기 때문에 > 상태안정이라고 부른다. **State safe** - 수학적 프로그래밍의 기반이 된다. - 값을 컨택스트로 해서 함수형 프로그래밍을 하려고 한다. - 어디에서 누가 몇번을 부르던 상관없다. - 완전 수학적 함수라고 한다. - 때문에 처음 함수를 작성할 때 인자를 값으로 넘기는지부터 확인해보면 안전한 함수를 짤 수 있다. 123456789101112131415const routine = a =&gt; a*2;const flow1 = _ =&gt; &#123; const b = 10, d = 20; const a = routine(b); const c = routine(c); return a + c;&#125;const flow2 = _ =&gt; &#123; const b = 30, d = 40; const a = routine(b); const c = routine(c); return a + c;&#125;flow1();flow2(); 상황1: 참조로 넘겼을 때 참조값을 바꾸는 상황 1234567891011const routine = ref =&gt; [&#x27;a&#x27;,&#x27;b&#x27;].reduce( (p,c) =&gt; &#123; // p는 콜백의 반환값, 초기값이 있을 경우 그값, 또는 콜백의 마지막 호출에서 이전에 반환된 누적값, // c는 배열 내 현재 처리되고 있는 요소. delete p[c]; return p;&#125;, ref);const ref = &#123;a:3, b:4, c:5, d:6&#125;;const a = routine(ref);ref === a // true // 하나의 객체를 참조하고 있으므로. 잘 통제할 수 없으면 복잡해지는 로직이다. 상황2: 참조로 넘겼을 때 참조값을 readOnly로만 123456const routine = (&#123;a, b, ...rest&#125;) =&gt; rest; // spread 문법// 새로운 객체가 반환된다.const ref = &#123;a:3, b:4, c:5, d:6&#125;;const a = routine(ref);ref !== a // true > spread 문법 (참고: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax) 웬만하면 reference를 인자로 넘기지 말고, 넘길수 밖에 없다면 readonly로 사용해라!! 그래야 함수의 side effect 효과를 줄일 수 있다. 상황3: 지역변수에 객체가 있거나, 리턴값이 객체인 경우12345678const routine = ref =&gt; &#123; const local = ref; // 지역변수에 참조본을 담았다. local.e = 7; // ref 객체의 e에 7이 할당됨, 변화됨.. return local;&#125;const ref = &#123;a:3, b:4, c:5, d:6&#125;;const a = routine(ref);ref === a // true 로컬이나 리턴할때도 새로운 객체를 만들어서 반환해주자!!! 1234const routine = ref =&gt; (&#123;...ref, e:7&#125;);const ref = &#123;a:3, b:4, d:5, d:6&#125;;const a = routine(ref);ref !== a // true spread연산자는 순서에 영향이 있다.이전에는 hash map이였는데, linked hash map이됨.객체를 넣는 순서가 보장이 된다. 2. Structured design높은 응집도, 낮은 결합도 High Cohesion, Loose CouplingLarry constantine_ Structured design 어떤 함수 내부의 코드가 높은 응집도를 갖는다? 하나의 함수로 여러가지 처리를 할 수 있다. 결합도가 높다? 의존성이 높다. 좋은 서브루틴이란 높은 응집도와 낮은 결합도를 갖도록 짜야한다! 2-1. 결합도 coupling 👎👌👍Content (👎 초강결합)A클래스 속성v가 변경되면 즉시 B클래스가 깨짐 12345678910111213const A = class &#123; constructor(v)&#123; this.v = v; &#125;&#125;;const B = class &#123; constructor(a)&#123; this.v = a.v; &#125;&#125;const b = new B(new A(3)); A와 B는 content coupling하고 있다. Common (👎 초강결합)Common클래스 변경 시 즉시 A,B클래스가 깨짐 Common은 전역객체 혹은 공유객체 12345678910111213141516171819const Common = class &#123; constructor(v)&#123; this.v = v; &#125;&#125;const A = class &#123; constructor(c)&#123; this.v = c.v; &#125;&#125;const B = class &#123; constructor(c)&#123; this.v = c.v; &#125;&#125;const a = new A(new Common(3));const b = new B(new Common(5)); External (👎 초강결합)A, B 클래스는 외부의 정의에 의존함.member의 json 구조가 변경되면 깨짐. 나쁘지만 회피할 방법이 없다. 주로 외부에서 주어지는 객체 12345678910111213141516const A = class &#123; constructor(member)&#123; this.v = member.name; &#125;&#125;const B = class &#123; constructor(member)&#123; this.v = member.age; &#125;&#125;fetch(&#x27;/memger&#x27;).then(res =&gt; res.json()).then(member =&gt; &#123; const a = new A(member); const b = new B(member);&#125;) A와 B 클래스는 member json 스팩에 의존해있다. 때문에 api 문서들이 존재한다. 방법은 관리를 잘해야한다… 분기를 잘 태워주는 방법.. Control (👎 초강결합)A클래스 내부의 변화는 B 클래스의 오작동을 유발 회피할 수 있는 방법이 생겼다. 루틴에게 직접적인 대상을 주지 않고 힌트를 주는 현상. class A가 변경될 경우 B가 깨진다. control 변수들 때문에..(case의 값들) 팩토리 패턴이 이런 이슈가 자주 일어난다. 전략패턴으로 바꾸면 해결 가능 123456789101112131415161718192021222324const A = class &#123; process(flag, v)&#123; switch(flag)&#123; case 1: return this.run1(v); case 2: return this.run2(v); case 3: return this.run3(v); &#125; &#125;&#125;const B = class &#123; constructor(a)&#123; this.a = a; &#125; noop() &#123; this.a.process(1); &#125; echo(data)&#123; this.a.process(2, data); &#125;&#125;const b = new B(new A());b.noop();b.echo(&quot;test&quot;); Stamp (👎👌 유사약결합) A와 B는 ref로 통신함. ref에 의한 모든 문제가 발생할 수 있음. 1234567891011121314151617181920212223const A = class &#123; add(data)&#123; data.count++; &#125; // data 전체를 받을 필요가 없고 count만 받았어야 한다. // 넓은 범위로 받게 됨. // count라는 변수명이 바뀌면 다 바뀌어야한다.&#125;const B = class &#123; constructor(counter)&#123; this.counter = counter; this.data = &#123;a:1, count:0&#125;; &#125; count() &#123; // 필요한 값만 내려주자. this.counter.add(this.data); &#125;&#125;;const b = new B(new A());b.count();b.count(); Data (👌 약결합) A와 B는 value로 통신함 (값) 모든 결합문제에서는 자유로워짐 data coupling만 생김. reference로 대화하게 되면 coupling이 높아진다. 12345678910111213141516171819const A = class &#123; add(count)&#123; return count + 1; &#125;&#125;const B = class &#123; constructor(counter)&#123; this.counter = counter; this.data = &#123;a:1, count:0&#125;; &#125; count()&#123; this.data.count = this.counter.add(this.data.count) &#125;&#125;;const b = new B(new A())b.count();b.count(); 2-2. 응집도 cohesion 👎👌👍Coincidental 우연히 👎 우연히 모여 있는.. 아무런 관계가 없음. 다양한 이유로 수정됨 있는줄 모르고 또 만들게 된다. 12345const Util = class &#123; static isConnect()&#123;&#125; static log()&#123;&#125; static isLogin()&#123;&#125;&#125; Logical 👌 사람이 인지할 수 있는 논리적 집합. 언제나 일부만 사용됨. 주관적인 묶음.. 도메인이 더 일반적이거나, 특수할 경우만!! 123456const Math = class &#123; static sin(r)&#123;&#125; static cos(r)&#123;&#125; static random()&#123;&#125; static sqrt(v)&#123;&#125;&#125; Temporal 시간의 순서 👌 시점을 기준으로 관계없는 로직을 묶음. 관계가 아니라 코드의 순서가 실행을 결정. 역할에 맞는 함수에게 위임해야 함. 12345678const App = class &#123; init()&#123; this.db.init(); this.net.init(); this.asset.init(); this.ui.start(); &#125;&#125; Procedural 👌 절차적 순서 외부에 반복되는 흐름을 대체하는 경우. 순서 정책 변화에 대응불가. 12345678const Account = class &#123; login()&#123; p = this.ptoken(); // permanet token s = this.stoken(p); // session token if(!s) this.newLogin(); else this.auth(s); &#125;&#125;; Communicational 👌 하나의 구조에 대해 다양한 작업이 모여있음. 역할에 맞게 묶음. 123456const Array = class &#123; push(v)&#123;&#125; pop()&#123;&#125; shift()&#123;&#125; unshift(v)&#123;&#125;&#125; Sequential 실행순서가 밀접하게 관계되며 같은 자료를 공유하거나 출력결과가 연계됨 chaining 되고 있는 함수 메서드. Procedural + Communicational 개념 12345678910111213141516const Account = class &#123; ptoken()&#123; return this.pk || (this.pk = IO.cookie.get(&quot;ptoken&quot;)); &#125; stoken()&#123; if(this.sk) return this.sk; if(this.pk)&#123; const sk = Net.getSessionFromPtoken(this.pk); sk.then(v =&gt; this.sk); &#125; &#125; auth()&#123; if(this.isLogin) return; Net.auth(this.sk).then(v =&gt; this.isLogin); &#125;&#125; Functional 👍 역할모델에 충실하게 단일한 기능이 의존성 없이 생성된 경우 앞으로 수업시간에 배워야할 부분 결합도와 응집도의 조화높은 응집성을 갖게 되면 높은 커플링은 갖게된다.결합도와 응집도의 조화를 목표로 로직을 짜야한다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"}]},{"title":"4/ 함수와 프로토타입 체이닝 (2)","slug":"JS_16","date":"2018-08-25T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2018/08/25/JS_16/","permalink":"http://feel5ny.github.io/2018/08/25/JS_16/","excerpt":"","text":"📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다. 4. 함수 호출과 this 함수호출시 암묵적으로 arguments 객체와 this인자가 전달된다. 4.1 arguments 객체 유사배열 객체 정의된 함수의 인자보다 적게 함수를 호출할 경우 넘겨지지 않은 인자는 undefined 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다. arguments 객체가 그 역할을 한다. 함수가 호출될 당시의 인자들에 배열 형태로 접근할 수 있다. - 함수 호출할 때 넘겨진 인자 (배열형태) - length : 인자갯수 - callee : 현재 실행 중인 함수의 참조값 123456789function sum()&#123; let result = 0; for(let i = 0; i &lt; arguments.length; i++) &#123; result += arguments[i]; &#125; return result;&#125;sum(1,2,3); // 6sum(1,2,3,4,5,6,7,8,9); // 45 ## 4.2 호출패턴과 this 바인딩함수가 호출되는 방식(호출패턴)에 따라 this가 다른 객체를 참조한다.(this 바인딩)- 객체의 메서드 호출할 때 this바인딩- 함수 호출할 때 this바인딩- 생성자 함수를 호출할 때 this 바인딩4.2.1 객체의 메서드 호출할 때 this바인딩자신을 호출한 객체에 바인딩된다! 123456789101112131415161718const myObject = &#123; name: &#x27;foo&#x27;, sayName: function()&#123; console.log(this.name); &#125; // sayName은 function()&#123;console.log(this.nmae)&#125;을 가리킴&#125;const otherObject = &#123; name: &#x27;bar&#x27;&#125;otherObject.sayName = myObject.sayName;// myObject.sayName의 참조값을 할당함.// otherObject.sayName은 생성과 동시에 function()&#123;console.log(this.nmae)&#125;을 가리킴// this는 자신을 호출한 객체에 바인딩되므로, 결과값이 다름myObject.sayName(); // foootherObject.sayName(); //bar 4.2.2 함수 호출할 때 this바인딩자바스크립트의 모든 전역 변수는 전역 객체의 프로퍼티들이다.(브라우저는 window, node는 global) 함수 내부에서의 this는 전역 객체를 가리킨다. 내부 함수에서도 this는 전역 객체를 가리킨다. 12345678910111213141516171819202122const value = 100;const myObject = &#123; value: 1, func1: function()&#123; this.value += 1; console.log(&#x27;func1()&#x27; + this.value); // 2 func2 = function()&#123; this.value += 1; console.log(&#x27;func2()&#x27; + this.value); // 101 func3 = function() &#123; this.value += 1; console.log(&#x27;func3()&#x27; + this.value); // 102 &#125; func3(); &#125; func2(); &#125;&#125;;myObject.func1(); 부모함수의 this를 내부 함수가 접근 가능한 다른변수에 저장하는 방법이 사용된다. 보통 관례상 this값을 저장하는 변수의 이름을 that이라고 짓는다. 명시적으로 bind를 사용할 수도 있다. 12345678910111213141516171819202122232425const value = 100;const myObject = &#123; value: 1, func1: function()&#123; const that = this; this.value += 1; console.log(&#x27;func1()&#x27; + this.value); // 2 const _func2 = func2.bind(this) func2 = function()&#123; that.value += 1; console.log(&#x27;func2()&#x27; + that.value); // 101 func3 = function() &#123; that.value += 1; console.log(&#x27;func3()&#x27; + that.value); // 102 &#125; func3(); &#125; // const _func2 = func2.bind(this) // _func2(); func2(); &#125;&#125;;myObject.func1(); 4.2.3 생성자 함수를 호출할 때 this 바인딩객체를 생성하는 방법 객체 리터럴 방식 Object() 생성자 함수 생성자 함수 이용 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.일반 함수에 new를 붙여 호출하면 원치 않는 생성자 함수처럼 동작할 수 있다.특정함수가 생성자 함수로 정의되어 있음을 알리려고 함수 이름의 첫 문자를 대문자로 쓴다. 생성자 함수에서의 this는 함수호출방식의 this 바인딩과 다르게 동작한다.이를 이해하기 위해 생성자 함수의 동작방식을 이해하면 된다! 1. 생성자 함수가 동작하는 방식123456const Person = function(name)&#123; this.name = name;&#125;var foo = new Person(&#x27;foo&#x27;);console.log(foo.name); // foo 위 의 예시를 토대로 설명 빈 객체 생성 및 this 바인딩 빈 객체가 생성된다. new Person()을 통해서 빈 객체는 this로 바인딩된다. 즉, 생성자 함수 내의 this는 빈 객체를 가리킨다. 빈 객체에는 기본적으로 [[Prototype]]이 생성된다. 이 __proto__는자신을 생성한 생성자 함수Person()의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. this를 통한 프로퍼티 생성 함수코드 내부에서 this를 통해 foo에 동적으로 프로퍼티나 메서드를 생성할 수 있다. 생성된 객체 리턴 - 2. 객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이123456789101112const foo = &#123; name: &#x27;foo&#x27;, age: 35,&#125;function Person(name, age)&#123; this.name = name; this.age = age;&#125;const bar = new Person(&#x27;bar&#x27;, 33);const baz = new Person(&#x27;baz&#x27;, 25); 3. 생성자 함수를 new를 붙이지 않고 호출할 경우 객체 생성을 목적으로 작성한 생성자 함수를new 없이 호출하거나 일반함수를 new를 붙여서 호출할 경우 오류 발생 일반 함수 호출과 생성자 함수를 호출할 때 this 바인딩 방식이 다르기 때문 일반함수의 경우 this &#x3D;&gt; window생성자함수의 경우 this &#x3D;&gt; 새로 생성되는 빈 객체 대문자 표기 네이밍 규칙을 권장하나 휴먼에러가 발생 할 수 있기 때문에 다음과 같은 분기문이 있는 코드 패턴을 사용하기도 한다. 123456// 강제로 인스턴스 생성하기function A(arg)&#123; if (!(this instanceof arguments.callee)) return new A(arg); this.value = arg? arg : 0;&#125; 4.2.4 call과 apply 메서드를 이용한 명시적인 this 바인딩내부적인 this 바인딩 이외에도this를 특정 객체에 명시적으로 바인딩 시키는 방법 apply() call() 함수의 부모 객체인 Function.prototype 객체의 메서드들이다. apply()메서드를 호출하는 주체가 함수고,apply() 메서드도 this를 특정 객체에 바인딩할 뿐결국 본질적인 기능은 함수호출이라는 것이다. Person()이라는 함수가 있고, Person.apply() 이렇게 호출한다면 이것의 기본적인 기능은 Person() 함수를 호출하는 것이다. 12function.apply(thisArg, argArray)function.call(thisArg, argItem1, argItem2, argItem3, ...) function을 호출하라, 이때 this는 thisArg에 바인딩해라. thisArg : apply를 호출한 함수 내부에서 사용한 this에 바인딩할 객체 argArray: 인자배열 call : call은 인자를 각각 넘긴다. 12345678910function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;const foo = &#123;&#125;Person.apply(foo, [&#x27;foo&#x27;, 30, &#x27;main&#x27;]);// Person 메서드를 호출해라, 이때 this는 foo객체에 바인딩해라.// 명시적인 바인딩 유사배열 객체에서 사용하는 경우 1234567function A()&#123; console.dir(arguments); // __proto__는 Object // arguments.shift() // 에러 const args = Array.prototype.slice.apply(arguments); console.dir(args); // __proto__는 Array&#125;A(1,2,3); Array.prototype.slice를 호출하라, 이때 Array.prototype.slice의 this는 arguments 객체로 바인딩하라. 4.3 함수리턴일반 함수나 메서드는 리턴값을 지정하지 않을 경우, undefined 값이 리턴된다.생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴된다. 생성자 함수에서 별도의 리턴값을 지정하지 않을 경우 this로 바인딩 된 새로 생성된 객체가 리턴된다. 때문에 생성자 함수에서는 일반적으로 리턴값을 지정하지 않는다. 생성자 함수가 명시적으로 객체를 리턴할 경우 새로운 객체를 생성하더라도, 명시적으로 넘긴 객체나 배열이 리턴된다. 불린, 숫자, 문자열을 리턴할 경우 무시된다. 5. 프로토타입 체이닝 5.1 프로토타입의 두가지 의미자바스크립트는 프로토타입기반의 객체지향 프로그래밍을 지원자바스크립트의 모든 객체는 자신의 부모인 프로토타입 객체를 가리키는 참조 링크 형태로 숨겨진 프로퍼티가 있다.implicit prototype link : [[Prototype]] prototype객체와 [[Prototype]]링크는 다른 개념이다. 5.2 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝프로토타입 체이닝자바스크립트에서 특정 객체의 프로퍼티나 메서드에 접근하려고 할 때,해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면[[Prototype]]링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것 5.3 생성자 함수로 생성된 객체의 프로토타입 체이닝객체 리터럴 방식과 약간 다른 프로토타입 체이닝이 이뤄지지만 아래의 기본 원칙은 지킨다. 자바스크립트에서 모든 객체는 자신을 생성한 생성자함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입객체(부모객체)로 취급한다. 5.4 프로토타입 체이닝의 종점Object.prototype이 프로토타입 체이닝의 종점이다. 5.5 기본 데이터 타입 확장자바스크립트는 Object.prtototype, String,prototype 등과 같이표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다. 공용적으로 사용하는 메서드의 경우 prototype에 선언하긔angular에서 pipe의 성격으로 사용하는 함수들을 prototype에 넣어도 됨 5.6 프로토타입도 자바스크립트 객체다프로토타입 객체 역시 자바스크립트 객체이므로, 일반 객체처럼 동적으로 프로퍼티를 추가&#x2F;삭제하는 것이 가능하다. 5.7 프로토타입 메서드와 this 바인딩메서드 호출패턴에서의 this는 그 메서드를 호출한 객체에 바인딩된다.프로토타입 객체도 이 this바인딩 규칙이 적용된다. 5.8 디폴트 프로토타입은 다른 객체로 변경이 가능하다 이 특징을 이요해서 객체지향의 상속을 구현한다. 5.9 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"4/ 함수와 프로토타입 체이닝 (1)","slug":"JS_15","date":"2018-08-24T12:20:19.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2018/08/24/JS_15/","permalink":"http://feel5ny.github.io/2018/08/24/JS_15/","excerpt":"","text":"📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다. 1. 함수 정의 함수 선언문1234// 함수 선언문function add(x,y)&#123; return x + y;&#125; 함수 표현식1234// 함수 표현식var add = function (x,y)&#123; return x + y;&#125; add는 함수 변수 add는 함수의 참조값을 가진다. 함수이름이 없는 함수를 익명함수라고 부른다. anonymous function 익명 함수를 이용한 함수 표현식 방법(익명함수 표현식) 익명함수의 호출은 호출연산자 ()를 붙여서 기술한다. 기명함수 표현식 함수 이름이 포함된 함수 표현식12345678// add 변수가 sum 함수를 참조한다. // 때문에 외부에서 sum함수에 접근할 수 없고, add변수를 통해 접근가능하다.var add = function sum(x,y)&#123; return x + y;&#125;console.log(add(3,4)) //7console.log(sum(3,4)) //error 함수를 재귀적으로 호출하거나, 디버거에서 함수를 구분할 때 사용 함수 선언문은 자바스크립트 엔진에 의해서 함수 표현식 형태로 변경되기 때문에 호출가능하다.12345678910111213141516171819function add(x,y)&#123; return x + y;&#125;// 위 함수는 자바스크립트 엔진에 의해서 아래와 같은 형태로 변환되다.var add =function add(x,y)&#123; return x + y;&#125;// 팩토리얼 함수var factorialVar = function factorial(n)&#123; if(n &lt;= 1)&#123; return 1; &#125; return n * factorial(n-1);&#125;factorialVar(3); // 6factorial(3); // error 관습적으로 함수 표현식 뒤에는 세미콜론을 붙인다. Function() 생성자 함수함수도 일반 객체처럼 값으로 취급된다. (일급객체) 1var add = new Function(&#x27;x&#x27;,&#x27;y&#x27;,&#x27;return x + y&#x27;); 자주 사용되지 않는다. 함수 호이스팅 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로, 코드의 구조를 엉성하게 만들 수 있다. 함수 표현식을 권장한다.이를 자세히 알기 위해서는 실행컨택스트를 이해하면 된다. 자바스크립트의 변수 생성과 초기화의 작업이 분리되서 진행되기 때문이다. 2. 함수 객체: 함수도 객체다. 2.1 자바스크립트에서는 함수도 객체다.함수 자체가 일반 객체처럼 프로퍼티들을 가질 수 있다. 123456function add(x,y)&#123; return x + y;&#125;add.result = add(3,2);add.status = &#x27;OK&#x27;; 2.2 자바스크립트에서 함수는 값으로 취급된다. (일급객체)자바스크립트에서 함수는 일급객체이다. 변수나 배열 요소, 객체의 프로퍼티 등에 할당 가능 함수의 인자로 전달가능 함수의 리턴값으로 리턴 가능 리터럴에 의해 성성 동적으로 프로퍼티를 생성 및 할당 가능 이 특징때문에 함수형 프로그래밍이 가능하다.자바스크립트의 함수를 제대로 이해하려면함수가 일급 객체이며이는 곧 함수가 일반 객체처럼 값으로 취급된다는 것을 이해해야한다. 2.2.1 변수나 프로퍼티의 값으로 할당 변수나 프로퍼티의 값으로 할당될 수 있다.12345678910111213const foo = 100;const bar = function()&#123;return 100;&#125;;console.log(bar()); // 100const obj = &#123;&#125;;obj.baz = function()&#123;return 200;&#125;console.log(obj.baz()) // 200;/* obj = &#123; baz: function()&#123;reutrn 200&#125; &#125;*/ 2.2.2 함수 인자로 전달.2.2.3 리턴값으로 활용. 클로저 2.3 함수 객체의 기본 프로퍼티함수 객체만의 표준 프로퍼티가 정의되어 있다. ECMA5 스크립트 명세서에는 모든 함수가 length와 prototype프로퍼티를 가져야 한다도 기술되어있다.length, prototype 이외의 프로퍼티는 ECMA 표준이 아니다. arguments caller name __proto__ name 함수의 이름 익명함수라면 빈배열 caller 자신을 호출한 함수를 나타낸다. arguments 파라미터값을 모아둔 유사배열객체이다. __proto__ Function.prototype객체의 프로토타입 객체는? 대박 처음에 프로토타입 공부할 때 한참 헷갈렸던 부분 모든 함수들의 부모 객체는 Function Prototype객체라고 했다. ECMAScript 명세서에서는 Function.prototype은 함수라고 정의하고 있다. Function.prototype 함수 객체도 결국 함수이니까,Function.prototype객체, 즉 자기 자신을 부모가 갖는 것인가?? ECMAScript 명세서에서는 예외적으로 Function.prototype 함수 객체의 부모는 Object.prototype 객체라고 설명하고 있다. Function.prototype 객체가 표준으로 가지는 프로퍼티나 메서드. constructor 프로퍼티 toString() 메서드 (Object.prototype에도 존재한다.) apply(thisArg, argArray) 메서드 call(thisArg, [, arg1 [,arg2,]]) 메서드 bind(thisArg, [, arg1 [,arg2,]]) 메서드 2.3.1 length인자의 개수를 나타내고 있다. 2.3.2 prototype 프로퍼티모든 함수는 객체로서 prototype 프로퍼티를 갖고 있다. 함수 객체만 가지고 있는 프로퍼티이다. 내부 프로퍼티인 __proto__와 혼동되면 안된다. __proto__는 부모 역할을 하는 프로토타입 객체를 가리킨다. prototype 프로퍼티는 이 함수가 생성자로 사용될 때,이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킨다. 123456789101112131415161718function Person(name, gender) &#123; this.name = name; this.gender = gender; this.sayHello = function()&#123; console.log(&#x27;Hi! my name is &#x27; + this.name); &#125;;&#125;var foo = new Person(&#x27;Lee&#x27;, &#x27;male&#x27;);console.dir(Person);console.dir(foo);console.log(foo.__proto__ === Person.prototype); // ① trueconsole.log(Person.prototype.__proto__ === Object.prototype); // ② trueconsole.log(Person.prototype.constructor === Person); // ③ trueconsole.log(Person.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true > (이미지출처 : https://poiemaweb.com/js-prototype) 3. 함수의 다양한 형태 3.1 콜백함수함수 표현식에서 함수이름은 꼭 붙이지 않아도 되는 선택사항이다. (익명함수)익명함수의 대표적인 용도가 콜백함수. 콜백함수는 코드를 통해 명시적으로 호출하는 함수가 아니라,개발자는 단지 함수를 등록하기만 하고,어떤 이벤트가 발생하거나 특정 시점에 도달했을 때시스템에서 호출되는 함수를 말한다. 또한, 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백함수가 될 수 있다. 대표적인 콜백함수는 이벤트 핸들러 처리. DOM 이벤트가 발생할 경우, 이벤트 핸들러를 발생시킨다. 3.2 즉시실행함수&#x3D; 함수를 정의함과 동시에 바로 실행하는 함수 123(function(name)&#123; console.log(&#x27;test&#x27;)&#125;)() 사용하는 곳 초기화 코드 같은 함수를 다시 호출할 수 없다. 최초 한번의 실행만을 필요로 하는 초기화 코드 부분 등에 사용한다. 자바스크립트 라이브러리나 프레임워크 소스들 (like Jquery) 123(fucntion(window, undefined)&#123; ...&#125;)(window) 변수 스코프를 위해서 사용한다. 함수 코드 내부에서만 유효할 수 있도록 라이브러리 내의 변수들은 함수 외부에서 접근할 수 없다. 3.3 내부 함수함수 코드 내부에서 함수 정의 공용으로 쓰이지 않고 정말 내부에서만 쓰일때 예_ html을 만드는 함수에서 받은 data에서 특정 추가작업을 해야하고, 공용함수로 쓰이지 않을 경우 내부함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다. 내부 함수는 일반적으로 자신이 정의된 부모함수내부에서만 호출 가능하다. 12345678910111213function parent()&#123; const a = 100; const b = 200; function child()&#123; const b = 300; console.log(a); console.log(b); // 내부에서 참조가 시작하므로, 내부에서 참조가능했다면 부모스코프까지 가지 않는다. &#125; child();&#125;parent(); // 100 300child(); //error 하지만, 함수 외부에서도 특정 함수 스코프 안에 선언된 내부 함수 호출이 가능하다. (클로저)12345678910function parent()&#123; const a = 100; function child()&#123; console.log(a); &#125; return child&#125;var inner = parent(); // inner에 child 함수변수가 리턴된다. inner(); // 클로저 3.4 함수를 리턴하는 함수","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"3/ 자바스크립트 데이터 타입과 연산자","slug":"JS_14","date":"2018-08-23T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2018/08/23/JS_14/","permalink":"http://feel5ny.github.io/2018/08/23/JS_14/","excerpt":"","text":"📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다. 목차 객체 프로퍼티 읽기&#x2F;쓰기&#x2F;갱신 객체 프로퍼티에 접근하는 방법 for in문 객체 프로퍼티 출럭 객체 프로퍼티 삭제 delete 배열과 객체 배열과 객체의 유사점과 차이점 배열의 프로퍼티 동적생성 유사배열객체 1. 객체 프로퍼티 읽기&#x2F;쓰기&#x2F;갱신1-1. 객체 프로퍼티에 접근하는 방법 대괄호 표기법 마침표 표기법 123456789101112131415161718192021222324var foo = &#123; name: &#x27;foo&#x27;, major: &#x27;computer science&#x27;&#125;// 객체 프로퍼티 읽기console.log(foo.name) // fooconsole.log(foo[&#x27;name&#x27;]) // foo// 객체 프로퍼티 갱신foo.major = &#x27;electronics engineering&#x27;;console.log(foo.major);console.log(foo[&#x27;major&#x27;]);// 객체 프로퍼티 동적 생성foo.age = 30;console.log(foo.age);// 대괄호 표기법만을 사용해야 할 경우foo[&#x27;full-name&#x27;] = &#x27;foo bar&#x27;;console.log(foo[&#x27;full-name&#x27;]);console.log(foo.full-name);console.log(foo.full);console.log(name); 대괄호 표기법만 사용해야하는 경우 접근하려는 프로퍼티가 표현식이거나 예약어 일 경우. 1-2. for in문 객체 프로퍼티 출럭 for in 문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. 키 값을 출력할 수 있음 12345678910111213const foo = &#123; name: &#x27;foo&#x27;, age: 30, major: &#x27;computer science&#x27;&#125;const prop;for(prop in foo)&#123; console.log(prop, foo[prop]); // name foo // age 30 // major &#x27;computer science&#x27;&#125; 1-3. 객체 프로퍼티 삭제 delete12delete foo.majorconsole.log(foo.major) //undefined 2. 배열과 객체2-1. 배열과 객체의 유사점과 차이점 자바스크립트에서 배열 역시 객체인데, 배열과 일반객체와는 약간 차이가 있다. 123456789101112131415//colorsArray 배열const colorsArray = [&#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;];console.log(colorsArray[0]); // orangeconsole.log(colorsArray[1]); // yellowconsole.log(colorsArray[2]); // green// colorsObj 객체const colorsObj = &#123; &#x27;0&#x27;: &#x27;orange&#x27;, &#x27;1&#x27;: &#x27;yellow&#x27;, &#x27;2&#x27;: &#x27;green&#x27;&#125;console.log(colorsObj[0]); // orangeconsole.log(colorsObj[1]); // yellowconsole.log(colorsObj[2]); // green 대괄호 안에는 접근하려는 프로퍼티의 속성을 문자열 형태로 적어야 한다.하지만 자바스크립트 엔진이 [] 연산자 내에 숫자가 사용될 경우,해당 숫자를 자동으로 문자열 형태로 바꿔준다. 2-2. 배열의 프로퍼티 동적 생성 123const arr = [&#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;];arr.color = &#x27;white&#x27;;arr.name = &#x27;number_array&#x27;; 신기하다!! 2-3. 유사배열객체 array like objects일반 객체에 length라는 프로퍼티가 있으면 어떻게 될까?자바스크립트에서는 length라는 프로퍼티를 갖고 있는 객체를 유사배열객체라고 한다. apply()메서드를 사용하여 객체지만 표준 배열 메서드를 활용하는 것이 가능하다. 12345678const arr = [&#x27;bar&#x27;];const obj = &#123; name: &#x27;foo&#x27;, length: 1&#125;;arr.push(&#x27;baz&#x27;)console.log(arr); // [&#x27;bar&#x27;, &#x27;baz&#x27;]Array.prototype.push.apply(obj, [&#x27;baz&#x27;]);","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"1부/ chap03. RxJs가 해결하려고 했던 문제(3)_로직 오류","slug":"Async_03","date":"2018-08-15T11:12:34.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/08/15/Async_03/","permalink":"http://feel5ny.github.io/2018/08/15/Async_03/","excerpt":"","text":"**[📕 퀵스타트 Rxjs]**를 보고 메모한 부분을 정리했습니다. 목차 웹 어플리케이션의 로직 로직의 복잡성 그리고 오류 자바스크립트의 솔루션 1. 웹 어플리케이션의 로직데이터를 추출하고 변환하는 작업을 빈번하게 하고 있다. 반복문 사용, 분기문 사용, 변수 사용 2. 로직의 복잡성 그리고 오류반복문, 분기문, 변수는 우리 코드를 복잡하게 만든다.반복문 : 가독성을 떨어뜨림분기문 : 확인해야 할 프로그램의 흐름을 여러 개로 만듦변수 : 누군가에 의해 변경 될 수 있다.&#x3D;&gt; 오류 발생 빈도를 높인다. 2.1 반복문과 분기문로직의 복잡성을 줄이는 방법 : 기능을 쪼개기 (관심사 분리)기능을 추상화 2.3 변수는 오류의 시작변수의 사용은 오류를 발생시킬 수 잇는 확률을 높인다는 것. 3. 자바스크립트의 솔루션함수형 프로그래밍의 특성을 가진 자바스크립트 함수를 이용하면실제 로직과 상관없는 반복분, 분기문을 분리할 수 있다. 자바스크립트는 일급객체! 함수를 변수 혹은 데이터 구조에 저장할 수 있다. 파라미터로 함수를 전달 할 수 있다. 반환값으로 사용할 수 있다. 3.1 로직의 분리고차함수 Higher-order function 다른 함수를 인자로 받거나 그 결과로 함수를 반환하는 함수 고차 함수는 변경되는 주요 부분을 함수로 제공함으로써 동일한 패턴 내에 존재하는 문제를 손수비게 해결할 수 있는 고급 프로그래밍 기법이다. 고차 함수를 이용하면 함수의 합성, 변형과 같은 작업을 손쉽게 할 수 있다.더불어 커링, 메모이제이션과 같은 기법도 사용할 수 있다. 1234567891011function process(people)&#123; const html = []; for (const user of people.results) &#123; if(/male|female/.test(user.gender)) &#123; const result = logic(user.height, user.mass, user.gender); Object.assign(user,result); html.push(makeHtml(user)); &#125; &#125; return html.join(&#x27;&#x27;);&#125; 12345678910// 고차 함수를 이용하여 개선function process(people)&#123; return people.results .filter(user =&gt; /male|femail/.test(user.gender)) .map(user =&gt; Object.assign(user, logic(user.height, user.mass, user.gender))) .reduce((acc,user)=&gt; &#123; acc.push(makeHtml(user)) return acc; &#125;, []).join(&#x27;&#x27;)&#125; 개선된 process에서는 반복문, 분기문, 변수가 존재하지 않는다.핵심로직은 분리되었고코드의 흐름은 단일화 되었다.변수를 사용하지 않음으로써 오류 발생 빈도도 크게 줄었다. 4. rxjs는 어떻게 개선하였나?4.1 rxjs가 제공하는 오퍼레이터http://reactivex.io/rxjs/manual/index.htmlrxjs에서 제공하는 오퍼레이터를 이용하면 observable을 생성할 수도 있고,전달된 데이터를 변환하거나 필요한 데이터만을 추출할 수도 있다. 참고 4.2 불변 객체 observableES5 Array의 고차함수들이 반환값으로 새로운 Array 객체를 반환하여 각각에 영향을 미치지 않도록 하는 것과 같이,rxjs의 오퍼레이터는 항상 새로운 observable을 반환함으로써 array의 고차 함수와 같이 불변 객체(immutable object)를 반환한다. 차이점 : Array의 리턴 객체는 새로운 레퍼런스 객체지만,observable과 달리 객체 자체가 불변객체는 아니다. 1234var arr = [1,2,3];var mappedArr = arr.map(v =&gt; v);console.log(arr === mappedArr); // false Array의 경우 새로운 Array 객체 생성 작업만 함 Observable은 **새로운 Observable을 만들고, **그 Observable이 오퍼레이터를 호출한 원래의 Observable을 내부적으로 구독한다!! 링크드 리스트 형태로 기존 Observable 객체와 새롭게 만든 Observable 객체를 오퍼레이터로 연결한다. 1234567891011map = function(transformationFn)&#123; const source = this; const result = new rxjs.Observable(observer =&gt; &#123; source.subscribe( function(x) &#123; observer.next(transformationFn(x))&#125; function(err) &#123; observer.error(err)&#125; function() &#123; observer.complete()&#125; ) &#125;) return result;&#125; 123456789101112ajax$.pipe( switchMap(data =&gt; of(...data.results)), filter(user =&gt; /male|female/.test(user.gender)), map(user =&gt; Object.assign(user, logic(user.height, user.mass, user.gender))), reduce((acc,user)=&gt; &#123; acc.push(makeHtml(user)); return acc; &#125;, []), map(htmlArr =&gt; htmlArr.join(&quot;&quot;))).subscribe(v =&gt; &#123; document.getElementById(&quot;users&quot;).innerHtml = v;&#125;) ∴ rxjs의 오퍼레이터로 생성된 Observable은 항상 불변 객체를 반환한다. 오퍼레이터의 인자로 순수함수를 받음으로써, 함수형 프로그래밍에서 추구하는 부원인과 부작용을 제거한다. 참고링크http://reactivex.io/rxjs/manual/index.html","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"rxjs","slug":"rxjs","permalink":"http://feel5ny.github.io/tags/rxjs/"}]},{"title":"1부/ chap02. RxJs가 해결하려고 했던 문제(2)_상태 전파 문제","slug":"Async_02","date":"2018-08-15T05:12:34.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/08/15/Async_02/","permalink":"http://feel5ny.github.io/2018/08/15/Async_02/","excerpt":"","text":"**[📕 퀵스타트 Rxjs]**를 보고 메모한 부분을 정리했습니다. 목차 웹 어플리케이션의 상태 웹 어플리케이션의 상태 변화로 인한 문제점 우리가 이미 알고 있는 솔류션 흔한 예 적용하기 rxjs는 무엇을 해결하고자 했는가? rxjs는 어떻게 개선하였나? observable은 리액티브하다. 상태 전파 오류상태 전파. state propagation 1. 웹 어플리케이션의 상태각각의 상태 머신들은 각자의 상태를 가지고 있고, 상태 머신들은 각자의 역할에 따라 서로 유기적으로 연결되어 있다.모듈간의 의존성.예_ 사용자정보(상태)를 System 클래스가 check()함수에서 사용하고 있는 예제 변경에 대한 전파가 원활하게 이루어지지 않는다. 3. 우리가 이미 알고 있는 솔류션3.1 Loosely Coupling 옵저버 패턴에서는 상태가 변경될 대상을 Subject라고 한다.그리고, 그 상태 변화를 관찰하는 대상을 Observer라고 한다. subject와 observer는 서로 느슨하게 연결되어 있다. (낮은 결합도) 여기서 **느슨하게(Loosely Coupling)**의 의미는 Subject와 Observer가 서로 상호작용을 하지만 서로 잘 모른다라는 뜻!! subject가 observer에 대해서 아는건 observer가 특정 인터페이스를 구현한다는 것 뿐. subject와 observer는 서로 독립적으로 사용할 수 있으며, observer가 바뀌더라도 서로에게 영향을 미치지 않는다. 3.2 자동 상태 전파pull 시나리오 기존 방식과 같이 데이터를 얻고자 하는 대상이데이터를 직접 가져오는 방식은매번 요청을 하여 변경사항을 확인해야만 한다. push 시나리오 하지만 옵서버 패턴은 이와 다르게의존 관계의 대상(Subject)으로 부터데이터를 제공받는 방식이다. push 방식으로 구성된 옵서버패턴은subject의 상태가 변경되었을 경우관찰하는 observer에게 자동으로 알려준다.(subscribe) subject와 observer가 1:n의 상황에서는 더욱 효과적이다.다수의 observer를 subject에 등록하기만 하면subject의 변경사항이 등록된 다수의 observer에게 자동으로 전달된다. 3.3 인터페이스의 단일화옵저버 패턴은 Observer.update만 존재하기 때문에 Subject에서는 옵저버 인터페이스에 대한 별도의 비용이 존재하지 않는다. 4. 옵저버 패턴의 흔한 예뉴스를 발행하는 신문사와 이를 구독하는 고객 뉴스를 발행하는 신문사 &#x3D; subject고객 &#x3D; observer 신문사는 고객을 등록하고 신문이 발행될 때 각각의 고객에게 신문이 발행되었다고 알려준다.(notify) 신문이 발행되면어떤 고객은 뉴스를 스크랩하거나,어떤 고객은 뉴스를 읽기 시작한다. 6. RxJS는 무엇을 해결하고자 했는가?rxjs도 상태 변화에 대한 문제를 옵저버 패턴을 기반으로 해결하려고 하였다. 6.1 상태 변화는 언제 종료되는가?옵저버 패턴에는 종료 flag가 없기 때문에 별도의 규칙을 정해야한다. rxjs에서는 complete 6.2 상태 변화에서 에러가 발생하면?옵저버 패턴은 에러 발생여부를 observer들에게 전달할 방법은 딱히 없다. rxjs에서는 error 6.3 observer에 의해 subject의 상태가 변경되는 경우?코드의 복잡도를 증가시키는 경우가 많다. rxjs에서는 옵저버블은 오직 read-only 7. rxjs는 어떻게 개선하였나?rxjs에서 전달되는 데이터는 모두 observable형태로 변환된다.observable은 구독과정(subscribe)후부터 데이터를 전달받기 시작한다. rxjs의 observable 1234567891011const &#123;fromEvent&#125; = rxjs;const clikc$ = fromEvent(document, &#x27;click&#x27;);clikc$.subscribe(function(v)&#123; console.log(v)&#125;)click$.subscribe(&#123; next: function(v)&#123; console.log(v) &#125;&#125;) observer pattern 123456let newsPaper = new Subject();newPaper.add(&#123; update: function(v)&#123; console.log(v); &#125;&#125;) subject와 observer 상태가 변경되는 아이 : subject, observable rxjs의 observable ≒ 옵서버 패턴의 Subject 변경된 상태를 알아야 하는 아이 : observer 옵서버 패턴의 observer는 add라는 메소드를 통해 subject에게 전달된다.rxjs의 observer는 함수와 객체 둘 다 가능하며 subscribe라는 메소드를 통해 subject에게 전달된다. rxjs가 기존 옵저버 패턴의 아쉬웠던 점을 개선하고자 했기 때문이다. cf_Rxjs의 Observable과 SubjectRxjs에는 observable도 있고 subject도 있다. rxjs의 subject는 기능적으로 정확히 옵저버패턴의 subject와 일치한다.rxjs의 subject는 다수의 observer에게 공통의 데이터를 전달하고, update와 같은 메소드가 존재하여 데이터 변경도 가능하다. rxjs의 observable은 기능적으로 옵저버 패턴의 subject와는 엄격히 다르다.observable은 하나의 observer에게 독립적인 데이터를 전달한다. 7.1 인터페이스의 확장 update &#x3D;&gt; next데이터의 연속적인 변화를 observer에서 표현할 수 있도록 기존 update메서드를 next로 바꾸었다. 개인적으로는 update가 더 명시적이다 ..ㅜ 종료시점, 에러시점옵저버 패턴에는 없던 종료시점, 에러시점을 개선,종료는 compleate에러는 error > rxjs > 옵저버패턴 왜 객체가 아닌 함수를 사용하는 것인가?observable.subscribe는 객체, 함수 모든 형태로 전달 받을 수는 있다.subscribe는 특별한 경우를 제외하고는 가급적 함수 형태를 사용한다. 객체는 상태를 가질 수 없기 때문이다.객체가 상태를 가진다는 의미 &#x3D;&gt; 또다른 상태 머신이 될 수 있다는 의미.반면 함수는 상태가 존재하지 않는 기능만을 담당하기 때문에 상태에 관한 문제에서는 보다 자유롭다. 7.2 옵저버블은 Read-onlyobservable은 subscribe를 통해 데이터를 전달할 대상에게 데이터를 전달할 수는 있지만,반대로 observer에게 데이터를 전달받을 수 없다. 데이터 흐름을 단순화함으로 복잡도를 낮추고 오류 발생 빈도를 줄인다. 8. Observable은 리액티브하다.데이터가 발생하게 되면 옵저버에게 자동으로 빠르게 변경된 데이터를 전달한다.이를 보고 리액티브하다고 이야기한다. 리액티브 프로그래밍이란?데이터 흐름과 상태 변화 전파에 중점을 둔 프로그램 패러다임이다.사용되는 프로그래밍 언어에서데이터 흐름을 쉽게 표현할 수 있어야 하며기본 실행 모델이 변경 사항을 데이터 흐름을 통해 자동으로 전파한다는 것을 의미한다. 예: 엑셀 이런 고민의 해결책이 옵저버 패턴이고,rxjs는 이런 옵저버 패턴을 개선하여 애플리케이션에서 발생하는 모든 데이터를 리액티브하게 전달할 수 있게 해준다. ∴ rxjs는 리액티브 프로그래밍을 지향하는 라이브러리이다","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"rxjs","slug":"rxjs","permalink":"http://feel5ny.github.io/tags/rxjs/"}]},{"title":"1부/ chap01. RxJs가 해결하려고 했던 문제(1)_입력데이터의 오류","slug":"Async_01","date":"2018-08-15T02:12:34.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/08/15/Async_01/","permalink":"http://feel5ny.github.io/2018/08/15/Async_01/","excerpt":"","text":"**[📕 퀵스타트 Rxjs]**를 보고 메모한 부분을 정리했습니다. 목차 웹 어플리케이션의 입력 데이터 입력 데이터의 전달 시점이 다양하다. - 동기&#x2F;비동기 동기와 비동기를 함께 사용할 수 밖에 없는가? rxjs는 어떻게 개선하였나? Observable 모든 데이터는 Observable 인스턴스로 만들 수 있다. 1. 웹 어플리케이션의 입력 데이터게시판을 예로 생각.목록화면 : 서버에 저장된 글을 보여주는상세화면 : 게시글의 내용을 보여주는 상세화면 서버로부터 저장된 글에 대한 정보를 받아서 화면과 관련 UI작업을 한다. 게시글 등록&#x2F;수정하는 편집화면 수정이 끝나면 서버에 저장 게시글 &#x2F; 서버 -&gt; 브라우저 &#x2F; 비동기 &#x2F; ajax통신으로 json데이터를 받는다. 게시글 &#x2F; 브라우저 -&gt; 브라우저 UI객체 &#x2F; 동기 &#x2F; json 데이터를 ui에 반영한다. 사용자가 입력한 내용 &#x2F; 사용자 -&gt; 브라우저 UI 객체 &#x2F; 비동기 &#x2F; &lt;textarea&gt;를 통해 사용자 입력을 받는다. 사용자가 입력한 내용 &#x2F; 브라우저 UI객체 -&gt; 브라우저 -&gt; 서버 &#x2F; 동기, 비동기 &#x2F; &lt;textarea&gt;에 있는 데이터를 json객체로 저장 후, 서버로 ajax요청을 한다. 2. 입력 데이터의 전달 시점이 다양하다.동기 synchronous: 작업이 들어온 순서에 맞게 차근차근 하나씩 진행되는 것을 의미한다. 장점 : 개발이 쉬움 단점 : 속도가 느려짐. 웹 브라우저는 단일 UI 스레이드 이므로 해당 작업이 끝날때까지 브라우저는 대기해야한다. 비동기 asynchronous: 작업이 들어온 순서에 상관없이 산발적으로 작업이 진행된다. 별도의 이벤트나 콜백함수를 통해 결과를 전달하는 방식 장점 : 효율적인 작업 진행 개발은 복잡해지고 오류 확률이 높아질 우려가 있다. 3. 동기와 비동기를 함께 사용할 수 밖에 없는가? 동기 방식은 프로세스를 독점하기 때문에 효율적인 작업이 불가능. 비동기 방식은 효율적으로 작업할 수 있지만 호출순서를 보장하기 어렵다. 웹 브라우저는 단일 스레드 기반이기때문에 성능상 문제가 발생한다. 4. rxjs는 어떻게 개선하였나?입력데이터에 대한 구조적 문제를 개선하고자 하였다.rxjs는 동기와 비동기의 차이점을 시간이라는 개념을 도입함으로써 해결하려고 했다. > 비동기 > 동기 동기와 비동기는 시간의 축으로 봤을 때는 같은 형태이다.&#x3D;&gt; 시간을 인덱스로 둔 컬렉션으로 생각할 수 있다.&#x3D;&gt; Rxjs는 이를 스트림이라고 표현한다.&#x3D;&gt; Rxjs는 이런 스트림($)을 표현하는 Observable 클래스를 제공한다. 4.1 Observable시간을 인덱스로 둔 컬렉션을 추상화한 클래스이다.동기나 비동기 동작 방식으로 전달된 데이터를 하나의 컬렉션으로 바라볼 수 있게 해준다.개발자는 데이터가 어떤 형태로 전달되는지에 대해 더이상 고민할 필요가 없어진다.Observable을 통해 데이터를 전달받기만 하면된다. 동기던 비동기던 옵저버블로 데이터를 받긔 4.2 모든 데이터는 Observable 인스턴스로 만들 수 있다. 키보드를 눌러서 입력된 데이터 마우스를 이동하거나 클릭해서 입력된 데이터 ajax&#x2F;fetch 요청을 통해 얻은 데이터 web socket을 통해 전달된 데이터 messages를 통해 전달된 데이터… rxjs는 observable을 만들기 위해 rxjs 네임스페이스에 다양한 함수를 제공한다.(오퍼레이터)이벤트를 observable로 만들때 fromEvent를 사용한다.단일데이터를 연속으로 전달하는 경우는 of Observable 객체의 변수명은 관용적으로 접미사로 $를 붙인다.Observable 객체는 스트림(stream)이다. 따라서 Stream을 뜻하는 S와 유사한 $를 Stream의 약어로 사용한다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"rxjs","slug":"rxjs","permalink":"http://feel5ny.github.io/tags/rxjs/"}]},{"title":"chap02.원칙 - 프로그래밍의 가이드라인","slug":"principle_02","date":"2018-08-12T03:12:34.000Z","updated":"2024-11-23T13:46:05.173Z","comments":true,"path":"2018/08/12/principle_02/","permalink":"http://feel5ny.github.io/2018/08/12/principle_02/","excerpt":"","text":"**[프로그래밍의 정석]**을 보고 메모한 부분을 정리했습니다. 목차 KISS :: Keep It Simple, Stupid 오컴의 면도날 DRY :: Don’t Repeat Yourself YAGNI :: You Aren’t Going to Need it PIE :: Program Intently and Expressively (의도를 표현해서 프로그래밍하라) SLAP :: Single Level of Abstraction Principle (추상화 수준의 통일) OCP :: Open-Closed Principle (개방-폐쇄의 원칙) 서론 1. KISS _Keep It Simple, Stupid*코드는 단순하게 유지한다.*why_아무생각 없이 수정하게 되면 코드는 무질서로 향한다.함수의 경우 관심사 분리를 목표로 간결하게 유지한다. 단순한 코드는 읽기 쉽고 수정이 용이하다. 의사소통 유지비용을 절약할 수 있다. *how_코드에 불필요한 것을 하지 않는다.단순함을 프로그래밍의 나침반으로 삼자. 아래 상황을 경계하자. 새롭게 배운 기술을 사용하고 싶다. 장래의 필요에 대비하고 싶다. 지금 필요할게 아니면 지금 작성할 것이 아니다. 멋대로 요구사항을 추가한다. 요구사항을 결정하는 쪽은 사용자다. 프로그래머가 요구사항을 결정해서는 안된다. 케바케일듯 *Less is more 단순한 것이 더 아름답다.지금 작성하는 코드가 정말로 필요한지를 항상 자문자답해야한다. *오컴의 면도날어떤 상황을 설명하는 데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식.&#x3D; 뭔가에 관해 여러 가지 설명이 가능하다면 가장 단순한 방식이 옳다. 2. DRY*코드 복사는 금물 로직 한 덩어리를 다른 부분에 복붙 같은 로직이 여러 군데로 흩어진다. 같은 조건을 다루는 제어문 블록이 여러군데 중복 같은 의미의 값(상수, 정수..) *why_코드를 개선할 수 없다 코드를 읽는 작업이 어려워진다. 양적으로 많아지고 질적으로 복잡해진다. 코드를 수정하는 작업이 어려워진다. 신중하게 수정하지 않으면 수정에 누락이 생길 위험성이 있다. 미세한 차이가 있다면 코드를 더욱 깊게 읽어야한다. 테스트가 없다. 열심히 수정하더라도 테스트가 없는 상태에서는 새로운 오류가 발생할 위험이 커진다. *how_코드를 추상화한다.코드를 추상화함으로써 중복을 제거하자.코드 로직을 추상화하려면처리하는 코드를 묶고 이름을 붙여 함수화, 모듈화한다. 추상화의 장점 코드의 양이 줄어 읽는 양을 줄일 수 있다. 이름을 붙였으므로 코드가 읽기 쉽다. 같은 코드를 한군데 집약했기 때문에 코드 수정이 용이, 품질을 담보하기 쉽다. 추상화한 부분은 재사용하기 쉬워진다. *DRY의 적용범위구체적으로 반복되는 작업은 자동화 자동화의 대표적인 작업 테스트, 빌드, 배포 (지속적인 통합) 빌드, 테스트, 배포 등을 정확하고 빈번하게 자동 실행하는 것. 장점 반복 수작업이 없어진다. 빌드 품질이 안정된다. 빌드가 속인화하지 않는다. 문제를 조기에 발견할 수 있다. *DRY와 프로그래밍 기술코드 중복을 제거하는 것을 목적 중 하나로 삼고 있다. 구조화 프로그래밍 객체지향 프로그래밍 기술함수나 모듈 구성을 통해 중복을 제거하기 위한 기법이 내제되어있음. 디자인 패턴: 코드를 재사용 가능(확장가능)하게 하려고 코드 구조 패턴을 제공한다.사고의 중복이 일어나지 않게 하는 기법이라고도 할 수 있다. 일반적으로 기술이나 기법은 특정 목적을 갖고 고안된다.: 기법을 배울 때는 방식 자체만을 모방하지말고목적을 파악하는 것이 습득에 이르는 지름길이다. *WET (Write Every Tiem, Write EveryThing Twice)DRY가 되어 있지 않은 코드에 대해 비꼬는 표현이다. *OFOP (One Fact in One Place)한 곳에는 하나의 사실데이터베이스 논리 설계에서 테이블 설계의 핵심이 되는 원칙이다.*OAOO (Once and Only Once)한번만, 단 한번만DRY와 유사한 의미 3. YAGNI You Are Not Going to Need It*코드는 필요할 때 최소한으로!*why_코드의 예측은 빗나간다.시간이 지날수록 이렇게 사용하지도 않는 코드가 있는 것인지 영문을 알 수 없다. 오히려 방해물이 된다. *코드는 지금 필요한 것만우선 사용할 수 있는 데 가치를 주자.범용성보다는 단순성이라는 가치에 기준을 두고 고른다.단순한 방식이 사실 범용성이 더 높을 때가 많다. 4. PIEProgram Intently and Expressively의도를 표현해서 프로그래밍하라 *코드의 의도를 전한다.블로그에 글을 쓰듯이 명확한 의도사람이 읽기 위한 것이기 때문 *why_코드가 유일한 실마리코드는 소프트웨어 동작을 정확하고 완벽하게 알기 위한 유일한 실마리 요구사항 정의서 : 어떤 기능을 원하는지가 적혀 있을 뿐 기본 설계서 : 어떤 식의 소프트웨어로 요구사항을 실현할지 적혀있을 뿐 상세 설계서 : 어떤 식의 구조로 소프트웨어를 작서할지에 관한 예정 코드와 가장 밀접하지만, 실시간으로 코드와 동기화되지 않는다. 결국 코드가 유일한 실마리 *코드는 읽기 쉬운 것이 최우선읽기 쉬움을 중시하자.작성효율보다는 읽는 효율이 우선시된다.!!읽기 쉽다면 나중에 실행 효율을 높이기는 간단하다. 다른 사람이 내 코드를 볼 때 이해가 잘 되도록 노력하자. *두더지 잡기식 개발은 피한다.읽기 쉽고오류가 없으며품질이 좋은 코드와테스트를 작성하려면 시간이 걸린다. 이는 단기적으로 손실로 보이지만, 두더지 잡기식 개발이 되지 않으므로장기적으로 반드시 이익을 가져다 준다. *주석을 작성한다.주석으로 설명하지 않아도 되는 이해하기 쉬운 코드를 지향하면서,표현할 수 없는 부분에는 주석을 활용하는 식으로균형잡힌 코드를 작성하도록 하자. *문학적 프로그래밍literate programming코드 자체를 문서화하는 기법문서를 기술하기 위한 언어가 프로그래밍 언어와 결함되어 있다.코드는 곧 문서이며, 문서는 곧 코드다. groc 5. SLAPSingle Level of Abstraction Principle :: 추상화 수준의 통일 *코드 수준을 맞춘다.고수준 추상화 개념과 저수준 추상화 개념을 분리해야한다.상하 2계층이 아니라 기능의 복잡도에 따라 여러 계층으로 분리한다.각 계층에서는 추상화 수준을 일치시킨다. 1234567891011121314151617181920212223242526function 고수준() &#123; //수준 1의 목차 중수준1(); 중수준2();&#125;function 중수준1() &#123; //수준2의 목차-1 저수준1(); 저수준2();&#125;function 저수준1() &#123; //본문 내용 //처리&#125;function 저수준2() &#123; //본문 내용 //처리&#125;function 중수준2() &#123; //수준2의 목차-2 저수준3();&#125;function 저수준3() &#123; //본문 내용 //처리&#125; *why_코드에 요약성과 열람성을 가져다준다 함수의 일람 : 목차, 요약성을 지님 분할된 함수 : 작은 코드 묶음, 열람성이 좋아짐. *how_함수를 구조화한다.함수를 구조화하자.함수를 구조화하면 각 함수는 자신보다 한 단계 낮은 수준의 함수를 호출하는 처리가 중심이 된다. 다른 함수를 호출하는 코드로 구성된 함수 : 복합함수 (composed method) 복합함수 최대한 작게 만든다. 추상화 수준이 다른 함수를 호출하지 않도록 한다. *SLAP의 적용범위함수 뿐만 아니라 모듈 등에도 적용된다. 개념을 저장할 저장소는 추상클래스와 해당 상속클래스가 된다. 추상클래스 : 무엇인가 덜 구체화 된 것 객체 : 상태와 행동을 가진 것 클래스 : 객체를 만들기 위한 틀 초기화 : 클래스를 이용하여 객체를 생성 추상 클래스에 높은 수준의 개념을 갖게 하고 상속 클래스에 낮은 수준의 개념을 갖게 한다. *SLAP의 순서글을 쓸때는내용을 쓰는 것과내용을 이해하기 쉽게 전하기 위한 구성을 생각하는 것을 별개의 작업으로 본다. 구체적인 처리를 작성하는 작업 추상화 수준을 일치시키는 작업은모드를 전환해서 별개의 작업으로 수행하도록 하자.그래야 작업이 쉬워지고 결과적으로 더 좋은 코드가 만들어진다. 6. OCPOpen-Closed Principle : 개방-폐쇠의 원칙 *코드의 변경은 파급시키지 않는다.코드는 확장에 대해서 열려 있고수정에 대해서 닫혀 있는2가지 속성을 동시게 충족하도록 설계한다. 확장에 열려있다. : 코드의 동작을 확장할 수 있다 수정에 닫혀있다. : 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다는 의미 *why_코드의 변경에 유연하게 대응한다.변경에 대해 유연하게 대응할 수 있는 유연한 설계가 요구된다. *OCP의 적용 범위코드의 모든 부분에 OCP를 적용하는 것은 과한 방식이다.코드의 단순함을 우지할 수 없다. 변경내용을 지나치게 예측하지 말아야 한다.실제 변경이 발생하기를 기다리는 전략.첫번째 변경을 감수하고, 두번째부터 OCP를 적용한다.기본적으로 예측 가능한 부분에는 확장성 있게 작업한다. *OCP의 구현과 설계대표적인 기술 : 객체지향의 다향성 다향성(polymorphism)은 특정 기능을 선언(설계)부분(&#x3D;인터페이스)과 구현(동작)부분으로 분리한 후 구현부분을 다양한 방법으로 만들어 선택해서 사용할 수 있게 하는 기능. 선언부분과 구현부분은 1:N의 다향성 관계가 형성 다향성 선언부분: 인터페이스(interface)와 추상클래스(abstract class) 다향성 구현부분: 클래스(class) 대표적인 디자인 패턴 strategy pattern 교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정한다. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리 시킨다. 바뀌는 부분은 따로 뽑아서 캡슐화 시킨다. Observer 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다. template method pattern decorater pattern 참고링크객체지향의 다향성 : http://webclub.tistory.com/406strategy pattern : http://hyeonstorage.tistory.com/146","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Principle","slug":"00-Clean-Code/Principle","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Principle/"}],"tags":[{"name":"programming","slug":"programming","permalink":"http://feel5ny.github.io/tags/programming/"},{"name":"principle","slug":"principle","permalink":"http://feel5ny.github.io/tags/principle/"}]},{"title":"chap01.전제 - 프로그래밍 불변의 진실","slug":"principle_01","date":"2018-08-11T11:12:34.000Z","updated":"2024-11-23T13:46:05.173Z","comments":true,"path":"2018/08/11/principle_01/","permalink":"http://feel5ny.github.io/2018/08/11/principle_01/","excerpt":"","text":"**[프로그래밍의 정석]**를 보고 메모한 부분을 정리했습니다. 목차1.1 프로그래밍에 은제탄환은 없다.1.2 코드는 설계서다1.3 코드는 반드시 변경된다. 서론 1.1 프로그래밍에 은제 탄환은 없다.*WHY_소프트웨어는 본질적으로 난해하다. 복잡성 동조성 : 실세계와 계속 동조해야한다. 가변성 : 소프트웨어가 사용자의 인식에 영향을 미치며 새로운 요구사항이 생긴다. 비가시성 : 추상화해서 단순한 도면으로 만드는 작업은 가능하나, 이때의 정보가 사상되므로 모든 정보를 표현할 수 없다. *HOW_역사를 배워 복잡함에 맞선다.소프트웨어 개발의 역사는 복잡함과 투쟁의 역사. *소프트웨어의 우유적인 부분을 개선 본질 : 어떤 대상에서 그것이 없으면 대상물이라고 할 수 없는 성질 비본질(우유) : 부차적이고 부수적이라는 의미로 그것이 없어도 대상물이라고 할 수 있는 성질 소프트웨어 개발 현장에서 필요한 기술이라고 알려진 것의 대부분은 우유적인 부분빌드 환경, 프로그래밍언어, 라이브러리, 프레임워크 등등은 우유적.. 우유적인 부분의 개선 중에서 큰 성과는 자동화(테스트, 빌드, 환경 설정 등을 자동화 작업 품질 향상) 우유적인 부분을 자동화 본질적인 부분에 시간을 할애하자. 1.2 코드는 설계서다.*what_코드가 곧 설계서 설계 상세설계 프로그래밍 테스트 디버깅 설계서 코드 공정(제조) 배포 컴파일러, 빌드시스템 *how_우수한 설계자(프로그래머)가 필요설계란 창조적이며 기예가 필요한 행위다.(설계 &#x3D; 기본설계 + 상세설계 + 프로그래밍 + 테스트 + 디버깅)신입에게 맡길 첫 업무가 아니라 고도로 숙련된 프로그래머의 업무여야 한다. *로제타 스톤장래의 유지보수 담당자에게 필요한 가이드북: 소프트웨어 개발 환경을 이해하기 위한 정보와소프트웨어 아키텍처를 이해하기 위한 정보가 담겨 있다.소프트웨어 개발 환경을 이해하기 위한 정보 빌드와 테스트 프로세스를 수행하는 방법 소프트웨어를 파악할 때 함정에 빠지는 일을 방지해 준다. 소프트웨어 아키텍처 전체를 파악하기 위해 필요한 그림 코드로부터 파악할 수 없는 코드 전체를 부감(높은 곳에서 내려다봄)해서 본 그림을 기술한다. 1.3 코드는 반드시 변경된다. 최초 배포만으로 요구사항을 완전히 망라한 소프트웨어를 만들어 내는 것은 불가능하다. 변경에 강한 코드를 작성한다.","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Principle","slug":"00-Clean-Code/Principle","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Principle/"}],"tags":[{"name":"programming","slug":"programming","permalink":"http://feel5ny.github.io/tags/programming/"},{"name":"principle","slug":"principle","permalink":"http://feel5ny.github.io/tags/principle/"}]},{"title":"1부/ chap0. RxJs를 시작하기 전에","slug":"Async_00","date":"2018-08-10T11:12:34.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/08/10/Async_00/","permalink":"http://feel5ny.github.io/2018/08/10/Async_00/","excerpt":"","text":"**[퀵스타트 Rxjs]**를 보고 메모한 부분을 정리했습니다. 목차 웹 환경의 변화 웹 개발 복잡도 증가 웹 애플리케이션은 상태 머신이다. &#x3D;&gt; 웹 애플리케이션 오류가 발생하는 경우 &#x3D;&gt; RxJS는 무엇인가? 그리고 웹 어플리케이션과 무슨 관련이 있는가? 서론대부분 처음 개발을 시작할 때는 요구사항을 어떻게 프로그래밍할 것인지를 고민하게 된다.즉, 구현 자체에만 초점을 맞추게 된다. 물론, 이는 개발에서 무엇보다 중요한 문제이다. 하지만, 시간이 지나 초급 개발자 딱지를 떼고 경험이 쌓이기 시작하면 구현보다는 소프트웨어를 얼마나 효과적으로 유지보수할 수 있는지? 또는 얼마나 많은 문제점을 설계나 테스트 코드를 통해 사전에 해결할 수 있을지를 고민하게 된다.그래서 우리는 자연스레 기존 문제들을 해결하기 위해 고심했던 라이브러리나, 디자인 패턴들을 하나둘씩 적용하게 되고,결국에는 이런 고민들이 녹아들어 간 프레임워크에 관심을 갖게 된다.…결과물(프레임워크)을 잘 사용하는 것도 중요하지만 그 기술의 결과물이 어떤 고민의 산물인지 아는 것이 더 중요하다. 3. 웹 어플리케이션은 상태 머신이다.상태머신이란? state machine주어진 시간의 상태(state)가 존재하고,어떤 한 사건(input)에 의해다른 상태 (state)로 변할 수 있는수학적 모델을 의미힌다. 시스템으로 input이 발생한다. 프로그램 로직은 input과 현재 프로그램 상태에 따라 행위를 결정한다. 프로그램 로직은 결정에 따라, 프로그램 상태를 변경한다. 경우에 따라서는 프로그램 로직은 output을 생산하기도 한다. 웹 어플리케이션은 이런 기능들의 집합으로 구성되어있다.크게 보면 웹 어플리케이션도 하나의 큰 상태 머신인 셈. 4. 웹 애플리케이션 오류가 발생하는 경우**웹 어플리케이션을 하나의 상태 머신으로 본다면정확한 입력과 로직으로 상태를 관리하는 방법이 중요하다.&#x3D;&gt; 이에 따라 오류의 발생 여부가 결정된다. ∴ 각 구성요소의 상태를 어떻게 관리하느냐에 따라 안정적인 어플리케이션을 만들 수 있다. 4-1. 입력 오류서버로부터 전달받은 데이터를 입력값으로 사용하는 경우 서버에서 전달받은 응답 결괏값이 정상적으로 왔을 경우에만 입력값을 전달해야 한다.- 입력값을 별도로 제어해야함. 응답 데이터의 결과가 미처 오기도 전에 데이터를 입력값으로 전달하거나 응답 중에 에러가 발생하여 비정상적인 응답 데이터를 입력값으로 전달하면 오류가 발생할 수 있다.- 오류처리 필요 4-2. 상태 오류상태 오류가 발생하는 이유는 상태 변화를 정확하게 전달하지 못하는 경우이다. 구성요소 간에 의존도가 있는 경우 구성요소 간 의존도가 있는 경우, 구성요소의 변경 상태는 적시에 다른 구성요소에 전달되어야 한다. 두번째 호출 순서에 의존도가 있는 경우 구성요소 간 호출 순서에 의존도가 있는 경우, 구성요소는 순서에 맞게 호출되어야만 한다. cf__1. redux의 옵저버 패턴 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function createStore(reducer, initialState) &#123; let state = initialState; // 상태 초기화 // Setup listners to keep track of when the state is changed // to triger rerenders (observer pattern) const listeners = []; // const subscribe = (listener) =&gt; listeners.push(listener); // 구독함수. listener가 들어오면 listeners에 담는다. const getState = () =&gt; (state); // get 함수 const dispatch = (action) =&gt; &#123; // action을 가져다주는 아이.. state = reducer(state, action); // state에 초기값, 액션을 넣고 상태값 담겨있는 객체 반환 // call each listener function when the state is changed // its just a notification that state is changed listeners.forEach(l =&gt; l()); // &#125;; return &#123; subscribe, getState, dispatch, &#125;;&#125;function reducer(state, action) &#123; if(action.type === &#x27;ADD_MESSAGE&#x27;) &#123; return &#123; messages: state.messages.concat(action.message), &#125; &#125;; if(action.type === &#x27;DELETE_MESSAGE&#x27;) &#123; return &#123; messages: [ ...state.messages.slice(0, action.index), ...state.messages.slice(action.index + 1, state.messages.length), ], &#125;; &#125;; return state;&#125;// set initial state to pass into to storeconst initialState = &#123; messages: [] &#125;;// initialize the storeconst store = createStore(reducer, initialState);class Messages extends React.Component &#123; componentDidMount() &#123; store.subscribe(() =&gt; this.forceUpdate()); &#125; render() &#123; const messages = store.getState().messages; return ( &lt;div className=&#x27;ui segment&#x27;&gt; &lt;MessageView messages=&#123;messages&#125; /&gt; &lt;MessageInput /&gt; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"rxjs","slug":"rxjs","permalink":"http://feel5ny.github.io/tags/rxjs/"}]},{"title":"13/ Image 업로드 시 회전에 대하여 (feat. exif 메타데이터 - Orientation)","slug":"JS_13","date":"2018-08-06T12:20:19.000Z","updated":"2024-11-23T12:13:00.744Z","comments":true,"path":"2018/08/06/JS_13/","permalink":"http://feel5ny.github.io/2018/08/06/JS_13/","excerpt":"","text":"웹 브라우저에서 이미지를 업로드 할 때 type이 file인 input을 통해 이미지를 받고, file API를 사용하여 이미지를 read합니다. 이때 핸드폰을 세워서 촬영할 경우 사진 이미지가 멋대로 회전되서 read될때가 있습니다. 이를 잡기 위해서는 사진의 메타정보(exif)에 있는 orientation이라는 정보를 확인해야합니다.exif가 무엇인지 간략하게 알아보고, 라이브러리를 사용하여 회전 버그를 픽스하는 방법에 대해서 정리해보았습니다. 목차 exif란? 출처 JavaScript 로드 시 회전 픽스방법 1. exif란?교환 이미지 파일 형식 (Exif; EXchangable Image File format)디지털 카메라에서 이용되는 이미지 파일 포맷이다.이 데이터는 JPEG, TIFF 6.0과 RIFF, WAV 파일 포맷에서 이용되며**사진에 대한 정보를 포함하는 메타데이터**를 추가한다.Exif는 JPEG 2000, PNG나 GIF파일에서는 지원하지 않는다. EXIF의 메타데이터EXIF 메타데이터는 다음 정보를 포함한다. 날짜와 시간 정보 카메라 설정 저작권 정보에 대한 설명 지리정보 기록교환 이미지 파일 형식은 위치 정보를 기록하는 표준을 갖고 있다.기존에는 GPS 수신기를 내장한 극소수의 카메라만이 사진이 찍힌 장소의 정보를 저장할 수 있었다.니콘 D300이나 니콘 D90, 파인픽스 S5 Pro, (캐논 EOS 6D 는 내부 장착)는 카메라 플래시 연결부에 별도의 GPS 수신기를 장착하여 지리 정보를 기록할 수 있다. 기록된 GPS 데이터는 컴퓨터에서 다른 디지털 사진에도 추가될 수 있다. 그러나 최근에는 GPS 수신기를 장착하고 사진 촬영이 가능한 수많은 휴대폰과 태블릿PC 등이 있어해당 기기로 사진 촬영을 할 경우 위치 정보를 같이 저장할 수 있는 옵션을 지원하여 위치 정보를 함께 기록하여 촬영하기 쉬워졌다. Exif : 이미지 정보Exif 데이터는 이미지 파일 자체에 끼워진다.많은 그래픽 소프트웨어에서 Exif 데이터를 인식하고,파일이 변경될 때에도 메타데이터를 보존한다.단 구버전의 경우에는 해당되지 않는다.많은 이미지 갤러리 프로그램 역시 Exif 데이터를 인식하고, 이미지 옆에 Exif 정보를 보여 준다. Exif 메타데이터는 카메라 제조사 카메라 모델 회전 방향 날짜와 시간 색 공간 초점 거리 플래시 ISO 속도 조리개 셔터 속도 gps등의 정보를 제공한다. 포토샵이나 라이트룸에서 사진을 import한 후 info를 확인하면 사진 정보를 바로 확인할 수 있는데, 이 사진이 갖고 있는 exif데이터로 확인하는 듯 2. JavaScript 로드 시 회전 픽스방법전체 flow는 이렇습니다. 123456789101. input file에서 image upload2. File API중 FileReader를 사용하여 file의 data 확인3. reader.onload 에서 Image 인스턴스 생성4. read의 result값 == binary 데이터5. img src에 result값 삽입6. binary 데이터에서 orientation 관련 태그값 select =&gt; orientation 값 추출7. orientation 값에 따라 img 회전 8. canvas 생성, img를 canvas에서 다시 그림 (drawImage)9. 해당 canvas의 toDataURL를 사용하여 dataUrl추출... exif 중 - orientation 값 fileList => file => binary Data => exif의 주소값을 찾아서 사진 정보를 get해오기 (exif라는 라이브러리를 들춰보면 재밌는 것이!!많습니다.) 123456789101112131415161718192021222324252627282930313233343536373839...// Tiff : Tagged Image File Formatvar TiffTags = EXIF.TiffTags = &#123; 0x0100 : &quot;ImageWidth&quot;, 0x0101 : &quot;ImageHeight&quot;, 0x8769 : &quot;ExifIFDPointer&quot;, 0x8825 : &quot;GPSInfoIFDPointer&quot;, 0xA005 : &quot;InteroperabilityIFDPointer&quot;, 0x0102 : &quot;BitsPerSample&quot;, 0x0103 : &quot;Compression&quot;, 0x0106 : &quot;PhotometricInterpretation&quot;, 0x0112 : &quot;Orientation&quot;, &lt;== 0x0115 : &quot;SamplesPerPixel&quot;, 0x011C : &quot;PlanarConfiguration&quot;, 0x0212 : &quot;YCbCrSubSampling&quot;, 0x0213 : &quot;YCbCrPositioning&quot;, 0x011A : &quot;XResolution&quot;, 0x011B : &quot;YResolution&quot;, 0x0128 : &quot;ResolutionUnit&quot;, 0x0111 : &quot;StripOffsets&quot;, 0x0116 : &quot;RowsPerStrip&quot;, 0x0117 : &quot;StripByteCounts&quot;, 0x0201 : &quot;JPEGInterchangeFormat&quot;, 0x0202 : &quot;JPEGInterchangeFormatLength&quot;, 0x012D : &quot;TransferFunction&quot;, 0x013E : &quot;WhitePoint&quot;, 0x013F : &quot;PrimaryChromaticities&quot;, 0x0211 : &quot;YCbCrCoefficients&quot;, 0x0214 : &quot;ReferenceBlackWhite&quot;, 0x0132 : &quot;DateTime&quot;, 0x010E : &quot;ImageDescription&quot;, 0x010F : &quot;Make&quot;, 0x0110 : &quot;Model&quot;, 0x0131 : &quot;Software&quot;, 0x013B : &quot;Artist&quot;, 0x8298 : &quot;Copyright&quot; &#125;;... 번거로운 작업이기 때문에.. 아래 라이브러리를 사용합니다. load-image-orientation.js exif.js 개인적으로는 load-image-orientation가 좋습니다 :)orientation값에 따른 회전 이외에도 crop기능도 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839// load-image-orientation.jsswitch (orientation) &#123; case 2: // horizontal flip ctx.translate(width, 0) ctx.scale(-1, 1) break case 3: // 180° rotate left ctx.translate(width, height) ctx.rotate(Math.PI) break case 4: // vertical flip ctx.translate(0, height) ctx.scale(1, -1) break case 5: // vertical flip + 90 rotate right ctx.rotate(0.5 * Math.PI) ctx.scale(1, -1) break case 6: // 90° rotate right ctx.rotate(0.5 * Math.PI) ctx.translate(0, -height) break case 7: // horizontal flip + 90 rotate right ctx.rotate(0.5 * Math.PI) ctx.translate(width, -height) ctx.scale(-1, 1) break case 8: // 90° rotate left ctx.rotate(-0.5 * Math.PI) ctx.translate(-width, 0) break&#125; 라이브러리 내부를 보시면, orientation 값에 따라 image를 회전하는 것을 볼 수 있습니다. 이미지 resizing 함수도 따로 작업했었는데, 이번 이슈를 통해서 찾은 load-image 라이브러리에 리사이징관련된 메서드들도 있는 것을 확인했습니다. 참고링크 https://ko.wikipedia.org/wiki/%EA%B5%90%ED%99%98_%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D https://magnushoff.com/jpeg-orientation.html http://code.flickr.net/2012/06/01/parsing-exif-client-side-using-javaScript-2/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"File API","slug":"File-API","permalink":"http://feel5ny.github.io/tags/File-API/"},{"name":"EXIF","slug":"EXIF","permalink":"http://feel5ny.github.io/tags/EXIF/"}]},{"title":"📓 읽기 좋은 코드가 좋은 코드다. || part3. 코드 재작성하기","slug":"Clean_code_3","date":"2018-08-03T11:12:34.000Z","updated":"2024-11-23T13:46:05.173Z","comments":true,"path":"2018/08/03/Clean_code_3/","permalink":"http://feel5ny.github.io/2018/08/03/Clean_code_3/","excerpt":"","text":"**[읽기 좋은 코드가 좋은 코드다.]**를 보고 메모할 부분을 정리했습니다. 목차 상관없는 하위문제 추출하기 ⇒ 관심사 분리 ⇒ 한번에 하나씩 ⇒ 관심사 분리 방법 ⇒ 생각을 코드로 만들기 ⇒ 코드 분량 줄이기 ⇒ 서론좋은 코드는 무슨 일이 일어나고 있는지를 빠르게 전달해준다.사용하기에도 즐겁고, 자신에게도 더 좋은 코드를 만들어야 하겠다는 욕구를 불러일으키기도 한다. PART 3 ) 코드 재작성하기엔지니어링은 커다란 문제를작은 문제들로 쪼갠 다음,각각의 문제에 대한 해결책을 구하고,다시 하나의 해결책으로 맞추는 일련의 작업을 한다.이러한 원리를 코드에 적용하면 코드가 더 튼튼해지며 가독성도 좋아진다. 주어진 함수나 코드 블록을 보고, 스스로에게 질문하라“상위수준에서 본 이 코드의 목적은 무엇인가?” 코드의 모든 줄에 질문을 던져라“이 코드는 직접적으로 목적을 위해서 존재하는가?혹은 목적을 위해서 필요하긴 하지만 목적 자체와 직접적으로 상관없는 하위문제를 해결하는가?” 상당히 원래의 목적과 직접적으로 관련되지 않은 하위문제를 해결하는 코드 분량이 많으면,이를 추출해서 별도의 함수로 만든다. 10. 상관없는 하위문제 추출하기 ⇒ 관심사 분리 11. 한번에 하나씩 ⇒ 관심사 분리 방법함수는 오직 한 가지 작업만 수행해야 한다. 코드가 수행하는 모든 ‘작업’을 나열한다. 이러한 작업을 분리하여 서로 다른 함수로 혹은 적어도 논리적으로 구분되는 영역에 놓을 수 잇는 코드로 만들면 됟나. 11-1. **작업은 작을 수 있다. 예시 ) 투표** 123456789101112131415vote_changed(old_vote, new_vote); // 각 투표는 &#x27;추천&#x27;,&#x27;반대&#x27; 혹은 &#x27;&#x27;이다.var vote_changed = function(old_vote, new_vote)&#123; var scroe = get_score(); if(new_vote !== old_vote)&#123; if(new_vote == &#x27;Up&#x27;)&#123; score += (old_vote === &#x27;Down&#x27;? 2 : 1); &#125; else if (new_vote == &#x27;Down&#x27;)&#123; score -= (old_vote === &#x27;Up&#x27; ? 2 : 1); &#125; else if (new_vote === &#x27;&#x27;)&#123; score += (old_vote === &#x27;Up&#x27; ? -1 : 1); &#125; &#125; set_score(score);&#125; 위 코드의 흐름 old_vote와 new_vote가 수치 값으로 ‘해석’된다. 점수가 변경된다.투표를 수치값으로 해석한다.12345678910111213141516var vote_value = function(vote)&#123; if(vote === &#x27;Up&#x27;)&#123; return +1; &#125; if(vote === &#x27;Down&#x27;)&#123; return -1; &#125; return 0;&#125;var vote_changed = function(old_vote, new_vote)&#123; var score = get_score(); score -= vote_value(old_vote); socre += vote_value(new_vote); set_score(score);&#125; 11-2. 객체에서 값 추출하기! 한번에 한 가지일 원리 적용하기1. 작업의 흐름을 적고 한 함수당 한가지 일만 적용되도록 한다. 12. 생각을 코드로 만들기 코드가 할 일을 옆의 동료에게 말하듯이 평범한 영어로 묘사하라. 설명에 들어가는 핵심적인 단어와 문구를 포착하라. 설명과 부합하는 코드를 작성하라 13. 코드 분량 줄이기 요구사항에 질문을 던지고 질문을 잘게 나누어 분석하라 상점위치 추적기","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"}],"tags":[{"name":"cleanCode","slug":"cleanCode","permalink":"http://feel5ny.github.io/tags/cleanCode/"},{"name":"refactoring","slug":"refactoring","permalink":"http://feel5ny.github.io/tags/refactoring/"}]},{"title":"📓 읽기 좋은 코드가 좋은 코드다. || part2. 루프와 논리를 단순화하기","slug":"Clean_code_2","date":"2018-08-02T11:12:34.000Z","updated":"2024-11-23T13:46:05.174Z","comments":true,"path":"2018/08/02/Clean_code_2/","permalink":"http://feel5ny.github.io/2018/08/02/Clean_code_2/","excerpt":"","text":"**[읽기 좋은 코드가 좋은 코드다.]**를 보고 메모할 부분을 정리했습니다. 목차 읽기 쉽게 흐름제어 만들기 ⇒ 거대한 표현을 잘게 쪼개기 ⇒ 변수와 가독성 ⇒ 서론좋은 코드는 무슨 일이 일어나고 있는지를 빠르게 전달해준다.사용하기에도 즐겁고, 자신에게도 더 좋은 코드를 만들어야 하겠다는 욕구를 불러일으키기도 한다. PART 2 ) 루프와 논리를 단순화하기 흐름제어 control flow 논리식 logical expression 변수 등에 대해서 알아보자. 코드가 코드를 읽는 사람에게 정신적 부담을 더 많이 부과할 수록,버그는 좀처럼 눈에 보이지 않고,코드 수정 작업은 더 어려워지고,결국 그런 코드로 작업하는 일이 즐겁지 못하게 된다. 7. 읽기 쉽게 흐름제어 만들기분기문과 점프문은 어려운 대상이며, 코드를 복잡하게 만드는 원인이다. 7-1. 조건문에서 인수의 순서A &gt; B 왼쪽 : 값이 더 유동적인 질문을 받는 표현 오른쪽 : 더 고정적인 값, 비교대상으로 사용되는 표현 cf_ 요다표기법 (옛날에 쓰던.. NULL == obj ) 7-2. if&#x2F;else 블록의 순서 부정이 아닌 긍정을 다루어라. 즉 if(!debug)가 아니라 if(debug)를 선호하자. 간단한 것을 먼저 처리하라. 더 흥미롭고, 확실한 것을 먼저 다루어라. 7-3. (삼항 연산자로 알려진) ?:를 이용하는 조건문 표현 줄 수를 최소화하는 일보다 다른 사람이 코드를 읽고 이해하는 데 걸리는 시간을 최소화하는 일이 더 중요하다. 7-4. do&#x2F;while 루프를 피하라7-5. 함수 중간에서 반환하기7-7. 중첩을 최소화하기루프와 조건문을 비롯한 그외 분기문을 읽기 쉽게 만드는 방법을 살펴본 것이다.하지만 자신의 프로그램에 존재하는 ‘흐름’을 상위수준에서 조망해볼 필요가 있다.프로그램의 전체 실행 경로를 쉽게 따라갈 수 있게 만드는 게 궁극의 목표다. 8. 거대한 표현을 잘게 쪼개기코드의 표현이 커지면 커질수록 이해하기 더 여렵다. ⇒ 예시: 대왕오징어 식도주변의 도넛뇌 설명 변수 커다란 표현을 쪼개는 가장 쉬운 방법은 작은 하위표현을 담을 ‘추가변수‘를 만드는 것이다. ( 추가변수 &#x3D;&#x3D; 설명변수 ) 요약 변수 의미를 쉽게 파악할 수 있어 별도의 설명을 요구하지 않는 표현이라고 해도, 새로운 변수로 담아두는 방법은 여전히 유용할 수 있다. 드모르간의 법칙 사용하기 De Morgan’s Laws if (!(file_exists &amp;&amp; !is_protected)) if (!file_exists &amp;&amp; is_protected) 쇼트 서킷 논리 오용 말기 if ( a || b ) a가 참이면 b는 평가하지 않는다. 예; 복잡한 논리와 씨름하기123456bool Range:;OverlapsWith(Range other)&#123; // &#x27;begin&#x27;dlsk &#x27;end&#x27;가 &#x27;other&#x27;에 속하는지검사한다. return (begin &gt;= other.begin &amp;&amp; begin &lt; other.end) || (end &gt; other.begin &amp;&amp; end &lt;= other.end) || (begin &lt;= other.begin &amp;&amp; end &gt;= other.end);&#125; 더 우아하게 접근하기123456bool Range:;OverlapsWith(Range other)&#123; if (other.end &lt;= begin) return false; // 우리가 시작하기 전에 끝난다. if (other.begin &gt;= begin) return false; // 우리가 끝난 후에 시작한다. return true; // 마지막 가능성만 남았다. 즉 겹친다.&#125; 거대한 구문 나누기 반복되는 부분을 ⇒ 요약변수로 추출할 때 (DRY : Don’t Repeat Yourself) 타이핑 실수를 피할 수 있다. 코드를 한눈에 훓어보는게 용이하도록 코드의 길이를 조이라도 더 줄여준다. 클래스명을 변경해야 할 때 한 곳만 바꾸면 된다. 표현을 단순화하는 다른 창의적인 방법들 9. 변수와 가독성변수를 엉터리로 사용하면 코드를 이해하기가 얼마나 어려워지는지 살펴본다. 변수의 수가 많을수록 기억하고 다루기 더 어려워진다. 변수의 범위가 넓어질수록 기억하고 다루는 시간이 더 길어진다. 변수 값이 자주 바뀔수록 현재 값을 기억하고 다루기가 더 어려워진다. 9-1. 변수 제거하기 불필요한 임시 변수들이러한 변수가 구지 필요하지 않는 이유 복잡한 표현을 잘게 나누지 않는다. 명확성에 도움이 되지 않는다. 한번만 사용되어 중복된 코드를 압축하지 않는다. 중간 결과 삭제하기 123456789101112131415161718192021222324var remove_one = function (array, value_to_remove) &#123; var index_to_remove = null; for (var i = 0; i &lt; array.length; i +=1 )&#123; if (array[i] === value_to_remove) &#123; index_to_remove = i; break; &#125; &#125; if (index_to_remove !== null) &#123; array.splice(index_to_remove, 1); &#125;&#125;/** 위의 방법보다는 아래방법 **/var remove_one = function (array, value_to_remove) &#123; var index_to_remove = null; for (var i = 0; i &lt; array.length; i +=1 )&#123; if (array[i] === value_to_remove) &#123; array.splice(i, 1); return; &#125; &#125;&#125; 9-2. 흐름 제어 변수 제거하기 흐름제어 변수? : 프로그램의 실행과 관련된 방향을 설정하는 데 있다. 9-3. 변수의 범위를 좁혀라 ‘전역변수를 피하라’는 조언을 한번쯤 들었을 것이다. 전역 변수는 어디에서 어떻게 사용되는지 일일이 확인하기 어려우므로 이는 합당한 조언이다. 또한, 전역 변수의 이름과 지역 변수의 이름이 중복되어 이름공간이 더러워질 수도 있고, 어떤 코드가 지역 변수를 변경할 때 실수로 전역 변수를 변경하거나 혹은 그 반대의 경우가 일어날 수 있으므로 타당하다. 사실 전역 변수 뿐만 아니라 모든 변수의 범위를 좁히는 일은 언제나 좋다. 많은 프로그래밍 언어는 모듈, 클래스, 함수, 블록 범위 같은 다양한 범위&#x2F;접근 수준을 제공한다. 자바스크립트에서 프라이빗 변수 만들기 12345678submitted = false;var submit_form = function(form_name)&#123; if(submitted)&#123; return; // 폼을 두 번 제출하지 말라. &#125; ... submitted = true;&#125; submit_form()만이 전역변수 submitted를 사용하는 유일한 함수처럼 보이지만, 확실히 알 수 없다. ⇒ 다른 자바스크립트 파일에서 이와는 다른 목적으로 submitted라는 이름이 붙은 전역 변수를 사용할 지도 모르는 일이다! ⇒ submitted 변수를 클로저 내부에 집어 넣어서 이런 문제를 해결한다. 12345678910var submit_form = (function()&#123; var submitted = false; return function(form_name)&#123; if(submitted)&#123; return; // 폼을 두 번 제출하지 말라. &#125; ... submitted = true; &#125;&#125;()); ⇒ 프라이빗한 범위를 만드는 효과를 갖는다.","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"}],"tags":[{"name":"cleanCode","slug":"cleanCode","permalink":"http://feel5ny.github.io/tags/cleanCode/"},{"name":"refactoring","slug":"refactoring","permalink":"http://feel5ny.github.io/tags/refactoring/"}]},{"title":"📓 읽기 좋은 코드가 좋은 코드다. || part1. 표면적 수준에서의 개선","slug":"Clean_code_1","date":"2018-08-01T11:12:34.000Z","updated":"2024-11-23T13:46:05.173Z","comments":true,"path":"2018/08/01/Clean_code_1/","permalink":"http://feel5ny.github.io/2018/08/01/Clean_code_1/","excerpt":"","text":"**[읽기 좋은 코드가 좋은 코드다.]**를 보고 메모한 부분을 정리했습니다. 목차 코드는 이해하기 쉬워야 한다. ⇒ 이름에 정보 담기 ⇒ 오해할 수 없는 이름들 ⇒ 미학 ⇒ 주석에 담아야 하는 대상 ⇒ 명확하고 간결한 주석 달기 ⇒ 서론좋은 코드는 무슨 일이 일어나고 있는지를 빠르게 전달해준다.사용하기에도 즐겁고,자신에게도 더 좋은 코드를 만들어야 하겠다는 욕구를 불러일으키기도 한다. PART 1 ) 표면적 수준에서의 개선 1. 코드는 이해하기 쉬워야 한다. 코드는 다른 사람이 그것을 이해하는 데 들이는 시간을 최소화하는 방식으로 작성되어야 한다. ⇒ 바로 인지 가능하도록 time-til-understanding 분량이 적으면 항상 더 좋은가? 더 분량이 적은 코드로 똑같은 문제를 해결할 수 있다면 그것이 더 낫다. 이해를 위한 시간은 다른 목표와 충돌되는가? 정리가 되지 않은 코드를 고치고 싶을 때는 뒤로 한걸음 물러나서 스스로에게 물어보는 게 중요하다. 이 코드는 이해하기 쉬운가? 1-1. 표면적 수준 좋은 이름을 짓고, 좋은 설명을 달고 코드를 보기 좋게 정렬하는 따위를 의미 ⇒ 이런 수정은 코드를 리팩토링하거나 프로그램이 동작하는 방식을 바꾸지 않고 그 자리에서 곧바로 만들 수 있기 때문에 수정 반영이 쉽다.⇒ 코드베이스를 흔드는 행위이므로 결과적으로 작성하는 모든 코드에 영향을 줄 수 있다. 2. 이름에 정보 담기변수, 함수, 혹은 클래스 명을 결정할 때⇒ 이름에 정보를 담아내라 2-1. 특정한 단어 고르기2-1.1 보편적인 단어 피하기get은 지나치게 보편적이다. fetch download 2-1-2. 더 화려한 단어 고르기send 보다는 deliver dispatch(보내다) announce distribute(분배하다) route find 보다는 search extract locate recover start 보다는 launch create begin open make 보다는 create set up build generate compose add new 2-1-3. 명확하고 간결한 이름이 더 좋다. 2-2. (tmp, retval, foo같은)보편적인 이름 피하기 (혹은 언제 그런 이름을 사용해야 하는지 깨닫기) tmp, retval(: 반환된 값), foo 같은 이름은내 머리로는 이름을 생각해낼수 없어요.. 더 좋은 이름은: 변수의 목적이나 담고 있는 값을 설명해주어야한다. tmp : 변수 목적 자체가 코드 몇 줄에서만 사용하는 임시저장소의 역할을 할 경우에는 사용해도 ok 루프반복자 i, j, iter, it 인덱스나 루프 반복자로 사용된다. 배열이름과 + 인덱스를 합친 반복자로 사용하면 좋다.12345for(let i = 0; i &lt; clubs.size(); i++) for(let j = 0; j &lt; clubs[i].members.size(); j++) for(let k = 0; k &lt; users.size(); k++) if(clubs[i].members[k] == users[j]) cout &lt;&lt; &quot;user[&quot; &lt;&lt; j &lt;&lt; &quot;] is in club[&quot;&lt;&lt; i &lt;&lt;&quot;]&quot; &lt;&lt;endl; i, j, k보다는 ⇒ club_i, members_i, users_i 혹은 ci, mi, ui tmp, it, retval 같은 보편적인 이름을 사용하려면,꼭 그러게 해야하는 이유가 있어야 한다. 2-3. 추상적인 이름 대신 구체적인 이름 사용하기 2-4. 접두사 혹은 접미사로 이름에 추가적인 정보 덧붙이기2-4-1. 단위를 포함하는 값들 (ex. 밀리세컨즈 : ~&#96;_ms&#96;)변수가 시간의 양이나 바이트의 수와 같은 측정치를 담고 있다면,⇒ 변수명에 단위를 포함시키는 게 도움이 된다. 12345678910111213const start = (new Date()).getTime();...const elapsed = (new Date()).getTime() - start;document.writeIn(&quot;Load time was: &quot; + elapsed + &quot;seconds&quot;);/** 위보다는 아래 **/const start_ms = (new Date()).getTime();...const elapsed_ms = (new Date()).getTime() - start_ms;document.writeIn(&quot;Load time was: &quot; + elapsed_ms + &quot;seconds&quot;); 2-4-2. 다른 중요한 속성 포함하기 (ex. 인코딩된 data : data_urlenc) 보안 취약한, 불안전함을 인지하고 싶을 때 untrustedUrl &#x2F; unsafeMessageBody …⇒ 안전하게 만드는 함수 호출 후에는⇒ trustedUrl, safeMessageBody에 담는다. 변수의 의미를 제대로 이해하는 것이 중요한 상황일때 사용하긔 예시 패스워드가 plaintext에 담겨 있고, 추가적인 처리를 하기 전에 반드시 암호화되어야 한다. password 보다는 ⇒ plaintext_password 사용자에게 보여지는 설명문이 화면에 나타나기 전에 이스케이프 처리가 되어야한다. comment 보다는 ⇒ unescaped_comment html의 바이트가 UTF-8으로 변환되었다. html ⇒ html_utf8 입력데이터가 url encoded 되었다. data 보다는 ⇒ data_urlenc 2-5. 이름이 얼마나 길어져도 좋은지 결정하기 좁은 범위에서는 짧은 이름이 괜찮다. 2-5-1. 약어와 축약형 특정 프로젝트에 국한된 의미를 가진 약어 사용은 좋은 생각이 아니다. 팀에 새로 합류한 사람이 이름이 의미하는 바를 이해할 수 있을까? 축약할 때는 보편적인 것은 괜찮다. string 대신 str, evaluation 대신 eval 2-5-2. 불필요한 단어 제거하기 convertToString()보다는 ToString() DoServeLoop()보다는 ServeLoop() 2-6. 추가적인 정보를 담을 수 있게 이름 구성하기&lt; 다른 포맷팅 **관습** &gt; jQuery 함수 호출시 jQuery의 결과를 저장하는 변수 앞에 $ 붙이기1var $all_images = $(&quot;img&quot;); 밑줄로 id안에는 단어를 구분하고, 대시로 클래스 안에 있는 단어를 구분 할 수 있다.1&lt;div id=&quot;middle_column&quot; class=&quot;main-content&quot;&gt; ... 3. 오해할 수 없는 이름들본인이 지은 이름을**’다른 사람들이 다른 의미로 해석할 수 있을까?’**라는 질문을 던져보며철저하게 확인해야 한다. Filter() 고르는 행위인지 제거하는 행위인지 모호하다. ⇒ 보편적인 뜻을 갖고 있는 단어를 최대한 사용을 자제하자. select()나 exclude() 접두어** 경계를 포함하는 한계값을 다룰 때는 min과 max를 사용하라 경계를 포함하는 범위에는 first와 last를 사용하라 경계를 포함하고&#x2F;배제하는 범위에는 begind과 end를 사용하라 불리언 변수에 이름 붙이기 is &#x2F; has &#x2F; can &#x2F; should 사용자의 기대에 부응하기 get*() : 가벼운접근자(lightweight accessors)로서 단순히 내부 멤버를 반환한다고 관행적으로 생각한다. 이름을 짓기 위해서 복수의 후보를 평가하기 예 ) template, reuse, copy, inherit 4. 미학좋은 소스 코드는 ‘눈을 편하게’ 해야한다. 코드의 열을 맞춰라 의미 있는 순서를 선택하고 일관성 있게 사용하라⇒ 개인적인 기준이 있으면 좋을듯⇒ 중요한 것 먼저 등등.. 선언문을 블록으로 구성하라 우리의 뇌는 자연스럽게 그룹과 계층구조를 따라서 동작하므로,코드를 이런 방식으로 조작하면 코드를 읽는 데 도움을 준다. 코드를 **문단**으로 쪼개라 문단 첫줄에는 주석으로 사용한다. 핸들러, 헬퍼함수 핸들러이벤트에 응답해서 호출되는 함수를 이벤트 핸들러(이벤트 리스너)라고 합니다. 헬퍼함수함수를 재사용할 수 있는 헬퍼함수 5. 주석에 담아야 하는 대상5-1. 설명하지 말아야 하는 것 무가치한 주석은 달지 말자 코드에서 빠르게 유추할 수 있는 내용은 주석으로 달지 말자 즉, 코드를 읽으면 무슨 일을 수행하는지 알 수 있으면.. 설명 자체를 위한 설명은 달지 말자 나쁜이름에 주석을 달지마라!! ⇒ 대신 이름을 고쳐라 좋은 코드 &gt; 나쁜코드 + 좋은 주석 5-2. 코딩을 행하면서 머릿속에 있는 정보를 기록하기 감독의 설명을 포함하라 중요한 통찰은 기록하자. 12// 이 클래스는 점점 엉망이 되어가고 있다. 어쩌면 &#x27;ResourceNode&#x27; // 하위 클래스를 만들어서 정리해야할지도 모르겠다. 코드에 있는 결함을 설명하라 12// TODO: 더 빠른 알고리즘을 사용하라.// TODO(더스틴): JPEG말고 다른 이미지 포맷도 처리할 수 있어야 한다. 코드가 불완전 할 때는 개선 아이디어를 설명하는 것도 좋다. 널리 사용되는 표시 TODO: 아직 하지 않은 일 FIXME: 오작동을 일으킨다고 알려진 코드 HACK: 아름답지 않은 해결책 XXX: 위험! 여기 큰 문제가 있다 TextMate: ESC 상수에 대한 설명 그 상수가 무엇을 하는지, 그것이 왜 특정한 값을 갖게 되었는지 ‘사연’이 존재하기 마련 사연을 주석에 남기면 좋다. 명확한 변수명이면 구지 안붙여도 됨. 5-3. 코드읽는 사람의 입장에서 필요한 정보가 무엇인지 유추하기 나올 것 같은 지문 예측하기 사람들이 쉽게 빠질 것 같은 함정을 경고하기 5-3-1. 큰 그림에 대한 주석팀에 새롭게 합류한 사람들은 ‘큰 그림’을 이해하는 데 어려움을 겪는다. 클래스들이 어떻게 상호작용하고, 전체 시스템에서 데이터가 어떻게 흘러 다니고, 출발점이 어디인지 등을 파악해야한다. 이는 **상위 수준 주석**에 포함되어야 한다. 파일 수준의 주석의 설명은 파일 시스템에 편리한 인터페이스를 제공하는 헬퍼 함수들을 담고 있다. 파일의 퍼미션과 다른 자세한 세부 사항을 처리한다. 5-3-2. 요약 주석 함수가 수행하는 기능의 글머리 요약 역할을 수행할 수 있다. 주석을 보고 요점을 파악할 수 있다.12345678def GenerateUserReport(): # 이 사용자를 위한 lock을 얻는다. ... # 데이터베이스에서 사용자의 정보를 읽는다. ... # 정보를 파일에 작성한다. ... # 사용자를 위한 lock을 되덜려 넣는다. 6. 명확하고 간결한 주석 달기 주석을 간결하게 하라 모호한 대명사는 피하라 엉터리 문장을 다듬어라 함수의 동작을 명확하게 설명하라 코너케이스를 설명해주는 입&#x2F;출력 예를 사용하라 예시를 주석에 적는 것도 좋다. 인자로 어떤 데이터가 들어가고 (입력)어떤 데이터를 반환하는지를 적으면 된다. (출력) 코드의 의도를 명시하라 → 버그를 잡을 수 있다. 이름을 가진 함수 파라미터 주석 정보 축약형 단어를 사용하라 경험적인, 주먹구구식, 순진한 해법과 같이 다양한 의미를 함축하는 단어나 표현이 많다.","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"}],"tags":[{"name":"cleanCode","slug":"cleanCode","permalink":"http://feel5ny.github.io/tags/cleanCode/"},{"name":"refactoring","slug":"refactoring","permalink":"http://feel5ny.github.io/tags/refactoring/"}]},{"title":"렌더링 엔진(2) - 렌더 트리 구축","slug":"rendering_engine_2","date":"2018-06-07T12:20:19.000Z","updated":"2024-11-23T12:12:05.051Z","comments":true,"path":"2018/06/07/rendering_engine_2/","permalink":"http://feel5ny.github.io/2018/06/07/rendering_engine_2/","excerpt":"","text":"https://d2.naver.com/helloworld/59361 를 읽고 정리했습니다. 브라우저의 주요 기능 브라우저의 기본 구조 렌더링 엔진 동작 과정 HTML 파싱 (for DOM트리 구축) 렌더 트리 구축 렌더 트리 배치 렌더 트리 그리기 렌더 트리 구축 HTML 마크업을 처리하고 DOM 트리를 빌드합니다. CSS 마크업을 처리하고 CSSOM 트리를 빌드합니다. DOM 및 CSSOM을 결합하여 렌더링 트리를 형성합니다. DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축한다. 표시해야 할 순서와 문서의 시각적인 구성 요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적이 있다. 파폭 : 형상 frames 웹킷 : 렌더러, 혹은 렌더 객체 &lt; DOM과 CSSOM을 결함 &#x3D; 렌더링트리 &gt; 렌더러는 CSS2 명세에 따라 노드의 CSS박스에 부합하는 사각형을 표시한다. 렌더러는 너비, 높이 그리고 위치와 같은 기하학적 정보를 포함한다. 박스 유형은 노드와 관련된 display 스타일 속성의 영향을 받는다. 렌더링 엔진에는 display 속성에 따른 DOM 노드를 위한 렌더러를 만드는 코드가 있다. 렌더링 트리는 표시되는 각 요소의 레이아웃을 계산하는 데 사용되고 픽셀을 화면에 렌더링하는 페인트 프로세스에 대한 입력으로 처리됩니다. 1. DOM 트리와 렌더 트리의 관계 렌더러와 DOM 요소는 1:1 대응 관계가 아니다. head 요소와 같은 비시각적 DOM 요소는 렌더 트리에 추가되지 않는다. display 속성의 none값이 할당된 요소는 트리에 나타나지 않는다. 여러 개의 시각 객체와 대응하는 DOM요소도 있는데 이것들은 보통 하나의 사각형으로 묘사할 수 없는 복잡한 구조다. 직업선택 학생 회사원 기타 - 예1) select 요소 = 표시영역 + 드롭다운 목록 + 버튼 **(3개의 렌더러)** - 예2) 한 줄에 충분히 표시할 수 없는 문자가 여러 줄로 바뀔 때 새 줄은 별도로 렌더러로 추가 - 예3) CSS 명세에 의하면 인라인 박스는 블록 박스만 포함하거나 인라인 박스만을 포함해야 하는데 **인라인과 블록 박스가 섞인 경우 인라인 박스를 감싸기 위한 익명의 블록 렌더러가 생성된다.** 어떤 렌더 객체는 DOM노드에 대응하지만 트리의 동일한 위치에 있지 않다. float처리된 요소는 position 속성값이 absolute로 처리된 요소는 흐름에서 벗어나 트리의 다른 곳에 배치된 상태로 형상이 그려진다. 2. 트리를 구축하는 과정 DOM 트리의 루트에서 시작하여 표시되는 노드 각각을 트래버스합니다. 일부 노드는 표시되지 않으며(예: 스크립트 태그, 메타 태그 등), 렌더링된 출력에 반영되지 않으므로 생략됩니다. 일부 노드는 CSS를 통해 숨겨지며 렌더링 트리에서도 생략됩니다. 예를 들어,—위의 예시에서—span 노드의 경우 ‘display: none’ 속성을 설정하는 명시적 규칙이 있기 때문에 렌더링 트리에서 누락됩니다. 표시된 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용합니다. 표시된 노드를 콘텐츠 및 계산된 스타일과 함께 내보냅니다. 웹킷: attachment &#x3D;&gt; 렌더러를 만드는 과정: RenderView &#x3D;&gt; 렌더트리 루트 파폭: 형상구축 &#x3D;&gt; 렌더러를 만드는 과정: ViewPortFrame &#x3D;&gt; 렌더트리 루트 3. 스타일 계산 렌더 객체의 시각적 송성에 대한 계산이 필요하다. 최초의 스타일 시트 : 브라우저가 제공하는 기본 스타일 시트 메모리 문제가 생길 수 있다. 스타일 데이터는 구성이 매우 광범위한데 수 많은 스타일 속성들을 수용하면서 메모리 문제를 야기할 수 있다. 최적화의 필요성 최적화되어 있지 않다면 각 요소에 할당된 규칙을 찾는 것은 성능 문제를 야기할 수 있다. 각 요소에 할당된 규칙 목록을 전체 규칙으로부터 찾아내는 것은 과중한 일이다. 맞는 규칙을 찾는 과정은 얼핏 보기에는 약속된 방식으로 순탄하게 시작하는 것 같지만 실상 쓸모가 없거나 다른 길을 찾아야만 하는 복잡한 구조가 될 수 있다. 예를 들어 이런 복합 선택자가 있다. div div div div { … } 이 선택자는 3번째 자손 &lt;div&gt;에 규칙을 적용한다는 뜻이다. 규칙을 적용할 &lt;div&gt; 요소를 확인하려면 트리로부터 임의의 줄기를 선택하고 탐색하는 과정에서 규칙에 맞지 않는 줄기를 선택했다면 또 다른 줄기를 선택해야 한다. 규칙을 적용하는 것은 계층 구조를 파악해야 하는 꽤나 복잡한 다단계 규칙을 수반한다. 참고링크 https://d2.naver.com/helloworld/59361 https://developers.google.com/web https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"01. Browser","slug":"01-Web/01-Browser","permalink":"http://feel5ny.github.io/categories/01-Web/01-Browser/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://feel5ny.github.io/tags/Web/"},{"name":"browser","slug":"browser","permalink":"http://feel5ny.github.io/tags/browser/"}]},{"title":"렌더링 엔진(1) - 파싱과 DOM트리 구축","slug":"rendering_engine_1","date":"2018-06-06T12:20:19.000Z","updated":"2024-11-23T12:12:05.051Z","comments":true,"path":"2018/06/06/rendering_engine_1/","permalink":"http://feel5ny.github.io/2018/06/06/rendering_engine_1/","excerpt":"","text":"https://d2.naver.com/helloworld/59361 를 읽고 정리했습니다. 브라우저의 주요 기능 렌더링 엔진 동작 과정 HTML 파싱 (for DOM 트리 구축) 렌더 트리 구축 렌더 트리 배치 렌더 트리 그리기 파싱과 DOM 트리 구축 파싱에 대하여문법 &#x2F; 파서-어휘 분석기 조합 &#x2F; 변환 &#x2F; 파싱 예 &#x2F; 어휘와 구문에 대한 공식적인 정의 &#x2F; 파서의 종류 &#x2F; 파서 자동 생성 HTML 파서 &#x3D;&gt; DOM 트리문맥자유문법이 아니다 &#x2F; HTML DTD &#x2F; DOM &#x2F; 파싱 알고리즘 &#x2F; 파싱이 끝난 이후의 동작 &#x2F; 브라우저의 오류 처리 CSS 파서 &#x3D;&gt; CSSOM 트리 스크립트와 스타일 시트의 진행 순서 1. 파싱 일반 문서 파싱 : 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것 파싱 트리(문법트리 syntax tree) : 파싱결과는 보통 문서 구조를 나타내는 노드 트리 2 + 3 - 1 1-1. 문법 파싱은 문서에 작성된 언어 또는 형식의 규칙에 따른다. 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다. 문맥 자유 문법 (Context-free grammar, CFG) 인간의 언어는 이런 모습과 다르기 때문에 기계적인 파싱이 불가능하다. 1-2. 파서-어휘 분석기 조합 파싱은 어휘 분석과 구문 분석으로 구분할 수 있다. 어휘 분석 : 자료를 토큰으로 분해하는 과정 ( 사전에 등장하는 모든 단어를 말한다고 볼수 있다. ) 구문 분석 : 언어의 구문 규칙을 적용하는 과정 자료를 유효한 토큰으로 분해하는 **어휘 분석기(lexical analysis)**가 있고,언어 구문 규칙에 따라 문서 구조를 분석함으로써 파싱 트리를 생성하는 파서가 있다. 어휘 분석기는 공백과 줄 바꿈 같은 의미 없는 문자를 제거한다. 파싱과정은 반복됨 파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인 (언어 규칙들..) 규칙과 맞으면 토큰에 해당하는 노드가 파싱 트리에 추가되고 파서는 또 다른 토큰을 요청 규칙과 맞지 않으면 파서는 토큰을 내부적으로 저장, 토큰과 일치하는 규칙이 발견될 때까지 요청한다. 맞는 규칙이 없는 경우 예외로 처리하는데 &#x3D;&gt; 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미 1-3. 변환 (컴파일!!) 파싱트리는 최종 결과물이 아니다. 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예가 된다. 소스 코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환한다! 1-4. 파싱 예 어휘 : 수학언어는 정수, 더하기 기호, 빼기 기호를 포함한다. 구문 언어 구문의 기본적인 요소는 표현식, 항(정수), 연산자(+,-)이다. 언어에 포함되는 표현식의 수는 제한이 없다. 표현식은 “항” 뒤에 “연산자” 그 뒤에 또 다른 항이 따르는 형태로 정의한다. 연산자는 더하기 토큰 또는 빼기 토큰이다. 정수 토큰 또는 하나의 표현식은 항이다. 2++는 어떤 규칙과도 맞지 않기 때문에 유효하지 않은 입력이 된다. 1-5. 어휘와 구문에 대한 공식적인 정의어휘는 보통 정규표현식으로 표현한다.123INTEGER : 0|[1-9][0-9]*PLUS : +MINUS : - 구문은 보통 BNF ( &lt;기호&gt; ::&#x3D; &lt;표현식&gt;)라고 부르는 형식에 따라 정의한다.123expression := term operation termoperation := PLUS | MINUSterm := INTEGER | expression 문법이 문맥자유문법(&#x3D; 완전히 BNF 로 표현 가능한 문법)이라면,언어는 정규 파서로 파싱할 수 있다. 1-6. 파서의 종류 하향식 파서 : 구문의 상위 구조로부터 일치하는 부분을 찾는다. 상향식 파서 : 낮은 수준에서 점차 높은 수준으로 찾는다. 1-7. 파서 자동 생성파서 생성기파서를 생성해 줄 수 있는 도구 언어에 &#x3D;&gt; 어휘나 구문규칙 같은 문법을 부여하면 &#x3D;&gt; 동작하는 파서를 만들어줌 파싱에 대한 깊은 이해를 필요로 하고 수동으로 파서를 최적화하여 생성하는 것은 쉬운일이 아니기 때문에 파서 생성기는 유용 웹킷 플렉스 Flex (fast lexical analyzer generator): lex 의 기능을 개선한 자유 소프트웨어 (문법정의 프로그램): 어휘 생성을 위한 어휘 분석기 발생기토큰의 정규 표현식 정의를 포함한 파일을 입력 받는다. (?) 바이슨 Bison: 파서 생성을 위한 파서생성기: BNF 형식의 언어 구문 규칙을 입력 받는다.상향식 이동 감소 파서 2. HTML 파서 HTML 파서는 HTML 마크업을 파싱 트리로 변환한다. 2-1. HTML 문법 정의W3C 의 명세 2-2. 문맥 자유 문법이 아님 모든 전통적인 파서는 HTML 에 적용할 수 없다. 파싱은 CSS 와 자바스크립트를 파싱하는 데 사용된다. HTML 은 파서가 요구하는 문맥 자유 문법에 의해 쉽게 정의할 수 없다. HTML 은 너그럽다. 암묵적으로 태그 생략이 가능하다. 시작태그, 종료 태그등을 생략한다. 뻣뻣하고 부담스러운 XML 에 반하여 HTML 은 유연한 문법이다. 공식적인 문법으로 작성하기 어렵게 만드는 문제가 있다.. 2-3. HTML DTD (문석 형식 정의: Document Type Definition) DTD는 문맥 자유 문법이 아니다. HTML 정의는 DTD 형식 안에 있다. (SGML 계역 언어의 정의를 이용한 것) HTML5, XHTML, HTML의 세가지 문서 유형이 존재하며, 기술한 유형에 따라 마크업 문서의 요소와 속성등을 처리하는 기준이 되며 유효성 검사에 이용된다. 이전 버전의 HTML(HTML2~HTML4)은 SGML(Standard Generalized Markup Language)에 기반을 두어 만들어졌기 때문에 DTD 참조가 필요하며, 이 때문에 DOCTYPE 선언을 하려면 공개 식별자와 시스템 식별자가 포함된 긴 문자열을 작성해야 한다. HTML5에서는 SGML 에 기반을 두지 않아서 DTD 참조가 필요 없으며, 최소한의 코드 작성이 기본 방향이라 매우 간단히 선언할 수 있다. 2-4. DOM (문서 객체 모델) 파싱트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. 문서 객체 모델 : HTML 문서의 객체 표현이다. HTML 요소의 연결지점. 즉, 트리의 최상위 객체는 문서이다. HTML 정의 DOM 정의 2-5. 파싱 알고리즘HTML 은 일반적인 하향식 혹은 상향식 파서로 파싱이 안된다. 언어의 너그러운 속성 잘 알려져 잇는 HTML 오류에 대한 브라우저의 관용 변경에 의한 재파싱.일반적으로 소스는 파싱하는 동안 변하지 않지만HTML 에서 **document.write**을 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 실제로는 입력 과정에서 파싱이 수정된다. 일반적인 파싱 기술을 사용할 수 없기 때문에 브라우저는 HTML 파싱을 위해 별도의 파서를 생성한다. TL;DR 바이트 → 문자 → 토큰 → 노드 → 객체 모델. HTML 마크업은 DOM(Document Object Model)으로 변환되고, CSS 마크업은 CSSOM(CSS Object Model)으로 변환됩니다. DOM 및 CSSOM 은 서로 독립적인 데이터 구조입니다. Chrome DevTools Timeline 을 사용하면 DOM 및 CSSOM 의 생성 및 처리 비용을 수집하고 점검할 수 있습니다. 알고리즘은 토큰화와 트리구축 이렇게 2 단계로 되어 있다. byte stream decoder 브라우저가 HTML 의 원시 바이트를 디스크나 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩(예: UTF-8)에 따라 개별 문자로 변환합니다. 토큰화 어휘 분석(lexical analysis)으로서 입력 값을 토큰으로 파싱한다. HTML 에서 토큰은 시작 태그, 종료 태그, 속성 이름과 속성 값이다. 트리구축 토큰을 인지해서 트리 생성자로 넘기고 &#x3D;&gt; 다른 토큰을 확인하기 위해 다음 문자를 확인 이 과정을 반복 (HTML 파싱 과정그림) 아래가 더 세분화된 과정 2-5-1. 토큰화 알고리즘 알고리즘의 결과물은 HTML 토큰 알고리즘은 상태기계라고 볼 수 있다. 각 상태는 하나 이상의 연속된 문자를 입력받아 이 문자에 따라 다음 상태를 갱신 예시 &gt; 12345&lt;html&gt; &lt;body&gt; Hello world &lt;/body&gt;&lt;/html&gt; 0.초기상태 : 자료 상태 &lt;html&gt; &lt;body&gt; 태그 열림 상태 : &lt; 문자를 만나면 변함 태그 이름 상태: a 부터 z 까지의 문자를 만나면 시작 태그 토큰생성: &gt;를 만날 때까지 유지한다.: 각 문자에는 새로운 토큰 이름이 붙는다. 이때 생성된 토큰은 html 토큰 자료 상태 : &gt;문자에 도달하면 현재 토큰이 발행된다. Hello world 문자 토큰 생성 발행 &lt;문자를 만날 때까지 진행 &lt;/body&gt; &lt;/html&gt; 태그 열림 상태 태그 이름 상태 : /문자는 종료 태그 토큰 생성 자료 상태 : &gt;문자에 도달하면 현재 토큰이 발행된다. 2-5-2. 트리 구축 알고리즘 파서 생성 후 문서 객체 생성 트리 구축이 진행되는 동안, 문서 최상단에서는 DOM 트리가 수정되고 요소가 추가된다. 토큰화에 의해 발행된 각 노드는 트리 생성자에 의해 처리된다. 각 토큰을 위한 DOM 요소의 명세는 정의되어 있다. DOM 트리에 요소를 추가하는 것이 아니라면 열린 요소는 스택(임시 버퍼 저장소)에 추가된다. 이 스택은 부정확한 중첩과 종료되지 않은 태그를 교정한다. 알고리즘은 상태 기계라고 설명할 수 있고 상태는 삽입 모드 라고 부른다. 예시 &gt; 12345&lt;html&gt; &lt;body&gt; Hello world &lt;/body&gt;&lt;/html&gt; 트리 구축 단계의 입력 값은 토큰화 단계에서 만들어지는 일련의 토큰이다. 노드화 초기모드: 받은 html 토큰은 html 이전 모드가 되면서 이 모드에서 처리된다.: 이것은 HTMLHtmlElement 요소를 생성하고 문서 객체의 최상단에 추가된다. head 이전 모드: “body” 토큰을 받았다. head 안쪽 모드: “head” 토큰이 없더라도 HTMLHeadElement 는 묵시적으로 생성되어 트리에 추가될 것이다. head 다음 모드: body 토큰이 처리 되었고 (토큰화) HTMLBodyElement 가 생성되어 추가됐으며 “body 안쪽” 모드가 되었다. body 안쪽 모드: 문자토큰 받음(Hellow world): 첫 번째 토큰이 생성되고 “본문” 노드가 추가되면서 다른 문자들이 그 노드에 추가될 것이다. body 다음 모드: body 종료 토큰을 받으면 body 다음 다음 모드: html 종료 토큰을 받으면 2-8. 파싱이 끝난 이후의 동작 문서 파싱 이후에 실행되어야 하는 “지연” 모드 스크립트를 파싱하기 시작한다. 문서 상태는 “완료 complete”가 되고 load이벤트가 발생한다. 보다 자세한 내용은 HTML5 의 토큰화 알고리즘과 트리 구축에서 볼 수 있다. 2-9. 브라우저의 오류 처리HTML 페이지에서 “유효하지 않은 구문”이라는 오류는 볼 수 없는데,이는 브라우저가 모든 오류 구문을 교정하기 때문이다. 파서는 토큰화된 입력 값을 파싱하여 문서를 만들고 문서 트리를 생성한다.때문에 파서는 적어도 다음과 같은 오류를 처리해야한다. 어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다. 파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다. 인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다. 이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다. &lt; 웹킷의 오류 처리하는 예 &gt; 2-9-1. &lt;br&gt; 대신 &lt;/br&gt; 어떤 사이트는 &lt;br&gt; 대신 &lt;/br&gt;을 사용한다. 인터넷 익스플로러, 파이어폭스와 호환성을 갖기 위해 웹킷은 이것을 &lt;br&gt;으로 간주한다. 2-9-2. 어긋난 표어긋난 표는 표 안에 또 다른 표가 th 또는 td 셀 내부에 있지 않은 것을 의미한다.웹킷은 표의 중첩을 분해하여 형제 요소가 되도록 처리한다. 2-9-3. 중첩된 폼 요소폼 안에 또 다른 폼을 넣은 경우 안쪽의 폼은 무시된다. 2-9-4. 태그 중첩이 너무 깊을 때최대 20 개의 중첩만 허용하고 나머지는 무시한다. 2-9-5. 잘못 닫힌 html 또는 body 태그깨진 html 을 지원한다. 일부 바보 같은 페이지는 문서가 끝나기 전에 body 를 닫아버리기 때문에 브라우저는 body 태그를 닫지 않는다. 대신 종료를 위해 end()를 호출한다. DOM 트리는 문서 마크업의 속성 및 관계를 포함하지만 요소가 렌더링될 때 어떻게 표시될지에 대해서는 알려주지 않습니다.이것은 CSSOM 의 역할. 3. CSS 파싱 문맥 자유 문법이다. 때문에 일반적인 파서 유형을 이용하여 파싱이 가능하다. CSS 명세 어휘 문법은 각 토큰을 위한 정규 표현식으로 정의되어 있다. 구문 문법은 BNF 로 설명되어 있다. 3-1. 웹킷 CSS 파서 웹킷은 자동으로 파서를 생성하기 위해 플렉스와 바이슨 파서 생성기를 사용한다. 웹킷의 바이슨을 사용하여 상향식 이동 감소 파서를 생성 파이어폭스 : 직접 작성한 하양식 파서를 사용한다. 모두 CSS 파일은 스타일 시트 객체로 파싱되고, CSS 규칙을 포함한다. 3-2. 브라우저별 사용자 에이전트 스타일 위의 트리는 완전한 CSSOM 트리가 아니고 스타일시트에서 재정의하도록 결정한 스타일만 표시한다는 점에 유의 모든 브라우저는 ‘사용자 에이전트 스타일’이라고 하는 기본 스타일 집합, 즉 개발자가 고유한 스타일을 제공하지 않을 경우 표시되는 스타일을 제공합니다. 개발자가 작성하는 스타일은 이러한 기본 스타일(예: 기본 IE 스타일)을 간단하게 재정의합니다. 4. 스크립트와 스타일 시트의 진행 순서4-1. 스크립트 웹은 파싱과 실행이 동시에 수행되는 동기화 모델이다. &lt;script&gt;태그를 만나서 실행되는 동안 문서의 파싱은 중단된다. (그래서 바디 전에 넣음) 스크립트가 외부에 있는 경우 우선 네트워크로부터 자원을 가져와야 하는데 이 또한 실시간으로 처리되고 자원을 받을 때까지 파싱은 중단된다. 스크립트를 “지연(defer)”으로 표시할 수 있는데 지연으로 표시하게 되면 문서 파싱은 중단되지 않고 문서 파싱이 완료된 이후에 스크립트가 실행된다. (비동기) 4-2. 예측 파싱 (Speculative parsing) 스크립트를 실행하는 동안 다른 스레드는 네트워크로부터 다른 자원을 찾아 내려받고 문서의 나머지 부분을 파싱한다. 이런 방법은 자원을 병렬로 연결하여 받을 수 있고 전체적인 속도를 개선한다. 참고로 예측 파서는 DOM 트리를 수정하지 않고 메인 파서의 일로 넘긴다. 예측 파서는 외부 스크립트, 외부 스타일 시트와 외부 이미지와 같이 참조된 외부 자원을 파싱할 뿐이다. 4-3. 스타일 시트 이론적으로 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단할 이유가 없다. 그러나 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하는 경우라면 문제가 된다. 스타일이 파싱되지 않은 상태라면 스크립트는 잘못된 결과를 내놓기 때문에 많은 문제를 야기한다. 파이어폭스는 아직 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단한다. 웹킷은 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때에만 스크립트를 중단한다. 참고링크 https://d2.naver.com/helloworld/59361 https://developers.google.com/web https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko [WEBDIR] http://webdir.tistory.com/40 https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"01. Browser","slug":"01-Web/01-Browser","permalink":"http://feel5ny.github.io/categories/01-Web/01-Browser/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://feel5ny.github.io/tags/Web/"},{"name":"browser","slug":"browser","permalink":"http://feel5ny.github.io/tags/browser/"}]},{"title":"브라우저와 렌더링 엔진","slug":"rendering_engine_0","date":"2018-05-29T12:20:19.000Z","updated":"2024-11-23T12:12:24.851Z","comments":true,"path":"2018/05/29/rendering_engine_0/","permalink":"http://feel5ny.github.io/2018/05/29/rendering_engine_0/","excerpt":"","text":"https://d2.naver.com/helloworld/59361 를 읽고 정리했습니다. 브라우저의 주요 기능 브라우저의 기본 구조 렌더링 엔진 1. 브라우저의 주요 기능 URI를 입력할 수 있는 주소 표시 줄 이전 버튼과 다음 버튼 북마크 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼 홈 버튼 2. 브라우저의 기본 구조 사용자 인터페이스 주소 표시줄, 이전&#x2F;다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다. 브라우저 엔진 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어. 렌더링 엔진 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함. 통신 HTTP 요청과 같은 네트워크 호출에 사용됨. 플랫폼 독립적인 인터페이스이고, 각 플랫폼 하부에서 실행됨. UI 백엔드 콤보 박스와 창 같은 기본적인 장치를 그림. (콤보박스 : 드롭다운 목록과 텍스트 상자와 조합한 것) 자바스크립트 해석기 자바스크립트 코드를 해석하고 실행. 자료 저장소 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 ‘웹 데이터 베이스’가 정의되어 있다. 3. 렌더링 엔진 요청 받은 내용을 브라우저 화면에 표시한다. HTML 및 XML 문서와 이미지를 표시할 수 있다. XMLXML이란 문자 기반의 마크업 언어, HTML처럼 데이터를 보여주는 목적이 아닌, 데이터를 저장하고 전달할 목적으로 만들어졌음. XML태그는 HTML태그처럼 미리 정의되어 있지 안혹, 사용자가 직접 정의할 수 있다. 3-1. 렌더링 엔진들파이어복스, 크롬, 사파리는 두 종류의 렌더링 엔진으로 제작되어있다. 파이어폭스 : 게코엔진 사파리 : 웹킷 크롬 : 블링크(크로미움 프로젝트 공식 블로그는 웹킷에서 블링크로 넘어간 이유를 “웹킷이 여러 아키텍처를 지원하면서 웹킷과 크로미움 프로젝트의 복잡성이 증가했고, 이에 따라 집단 혁신 속도가 저하되었기 때문”이라고 밝혔다. 출처) Comparison of browser engines 3-2. 동작 과정렌더링 엔진은 1. [HTML 파싱](#html_parse) (for DOM트리 구축) 2. [렌더 트리 **구축**](#setting) 3. [렌더 트리 **배치**](#layout) 4. [렌더 트리 **그리기**](#draw) 일련의 과정들이 동기적으로 진행되지 않는다. HTML을 파싱할 때까지 기다리지 않고 렌더 트리 배치와 그리기 과정을 시작한다. 렌더링 엔진에 따라서 동작과정이 약간 다르다. 3-2-1. 웹킷 렌더트리 (렌더객체로 구성) 렌더객체 배치(layout)라는 용어를 사용 attachment : 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 시각 정보를 연결하는 과정. 3-2-2. 게코 - 형상트리(frame tree) : 시각적으로 처리되는 렌더 트리 - 형상(frame) : 형상 - 배치라는 뜻으로 리플로(`reflow`)라는 용어를 사용 - 콘텐츠 싱크 (content sink) : DOM 요소를 생성하는 공정 궁금 1. URI와 URL의 차이점URL Uniform Resource Locator의 약자 인터넷 상의 자원 위치 URI Uniform Resource Identifier의 약자 인터넷 상의 자원을 식별하기 위한 문자열의 구성 URI이 URL보다 상위개념 참고링크 https://d2.naver.com/helloworld/59361 https://developers.google.com/web https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"01. Browser","slug":"01-Web/01-Browser","permalink":"http://feel5ny.github.io/categories/01-Web/01-Browser/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://feel5ny.github.io/tags/Web/"},{"name":"browser","slug":"browser","permalink":"http://feel5ny.github.io/tags/browser/"}]},{"title":"12/ File Api와 이미지 용량 줄이기","slug":"JS_12","date":"2018-05-27T12:20:19.000Z","updated":"2024-11-23T12:13:00.744Z","comments":true,"path":"2018/05/27/JS_12/","permalink":"http://feel5ny.github.io/2018/05/27/JS_12/","excerpt":"","text":"오늘은 이미지 용량을 줄이는, (리사이징이 더 맞는 말이겠죠.) 방법에 대해서 알아보려고 합니다. 로컬에서 이미지 파일을 올리는 것부터 시작하죠. 이를 위해서는 HTML5관련 API 중 하나인 파일 API를 이용하고, 이미지 리사이징을 위해서 캔버스를 이용할 것입니다. 파일API를 다뤄보고 Blob에 대해서도 알아보죠..(Blob의 더 자세한 내용을 위해 포스팅을 따로 해야 할 것 같습니다.) ( + 제이커리 사용했습니다.) 보통 웹에서 글을 게시할 때 이미지를 첨부해야 하는 기능이 있죠. 이미지 업로드시 용량 축소가 기본적으로 들어가야 하고, 이는 프론트단에서 작업해주는게 보통입니다! 유저들이 보통 올리는 이미지는 스마트폰 사진이 일반적일 텐데, 요즘 스마트폰 카메라 성능이 좋아지면서 많게는 개당 8MB까지 나오는 경우도 있죠. 서버단에서 리사이징할 경우 비용이 아깝게 들기 때문에.. 클라이언트에서 이를 작업합니다. 전체 플로우는 이렇습니다. File API를 이용하여 이미지 파일 접근 (FileReader) img 엘리먼트 생성, dataUrl 삽입 canvas 생성, img를 다시 리사이징하여 drawing canvas의 dataURL를 이용하여 Blob 객체 생성 전송 1. File API, FileReaderinput의 type=file를 이용해서 이미지 파일에 접근, file 객체들을 files 컬렉션에 담습니다. 각 객체가 파일 하나를 나타냅니다.(Blob)파일 객체에는 여러가지 읽기 전용 프로퍼티가 존재합니다. name: 로컬 시스템의 파일 이름 size: 바이트 단위인 파일 크기 type: 파일의 망미 타입을 나타내는 문자열 (ex_ “image&#x2F;png”) lastModifiedDate: 파일이 마지막으로 수정된 시점을 나타내는 문자열입니다. 이 프로퍼티는 크롬에만 구현되어있습니다. 파일 API는 FileReader 타입을 통해 파일 데이터를 읽을 수 있습니다. 1-1. FileReader 타입FileReader 타입은 비동기적으로 파일을 읽는 메커니즘입니다. 서버에서 파일을 읽는 것이 아닌, 파일 시스템에서 파일을 읽는 것이라고 이해하자.FileReader 타입에는 파일 데이터를 읽는 여러 가지 메서드가 존재합니다. readAsText(file, encoding) : 파일을 평범한 텍스트로 읽고 그 텍스트를 result 프로퍼티에 저장한다. 두 번째 매개변수는 옵션. readAsDataURL(file) : 파일을 읽은 다음 이를 표현하는 데이터 URI를 result 프로퍼티에 저장. readAsBinaryString(file) : 파일을 읽은 다음 각 문자가 1바이트를 나타내는 문자열을 result 프로퍼티에 저장. readAsArrayBuffer(file) : 파일을 읽은 다음 파일 콘텐츠를 포함하는 ArrayBuffer를 result 프로퍼티에 저장. 읽는 과정은 비동기적이므로 FileReader는 progress, error, load 이벤트를 일으킵니다. progress : 읽어올 데이터가 더 있을 때 50밀리 초마다 발생, lengthComputable, loaded, total 같은 정보를 제공한다. loaded &#x2F; total &#x3D; 버퍼링 error : 에러 생겼을 때 1 : 파일을 찾을 수 없음 2 : 보안 에러 3 : 읽기 거부 4 : 파일을 읽을 수 없음 5 : 인코딩 에러 load : 파일을 완전히 읽었을 때 load 이후에는 readAsDataURL 메서드를 통해 result 프로퍼티에 데이터 URI가 저장되도록 해야 합니다. 1234567891011&lt;!-- html 🚀🚀 --&gt; &lt;div class=&quot;upload-wrapper&quot;&gt; &lt;label for=&quot;upload&quot; class=&quot;upload-label&quot;&gt; &lt;p&gt;✨UPLOAD IMAGE ✨&lt;/p&gt; &lt;img class=&quot;upload-imgBtn&quot; src=&quot;https://uploads.codesandbox.io/uploads/user/1dcc6c5f-ac13-4c27-b2e3-32ade1d213e9/2Go1-photo.svg&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;!-- fileReader를 통해 읽은 파일을 넣는 부분 --&gt;&lt;div class=&quot;image-preview&quot;&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; id=&quot;upload&quot; class=&quot;image-upload&quot; style=&quot;display:none;&quot; multiple&gt; input type&#x3D;”file” 태그에 onchange 이벤트를 걸어둡니다. 12345678910111213141516const load_image = e =&gt; &#123; const files = e.target.files; const filesArr = Array.prototype.slice.call(files); // 여러장의 이미지를 불러올 경우, 배열화 filesArr.forEach(file =&gt; &#123; const reader = new FileReader(); reader.onload = e =&gt; &#123; // 뭔가 썸팅 할 것을 넣습니다. &#125;; &#125;; reader.readAsDataURL(file); ✨✨ &#125;);&#125;;$(&quot;.image-upload&quot;).on(&quot;change&quot;, e =&gt; load_image(e)); 2. img 엘리먼트 생성, dataUrl 삽입이미지는 용량에 따라 로드 속도가 다릅니다. 웹은 이미지에 대해서 비동기적으로 동작하는데 완전히 로드될 때까지 기다리지 않고 웹 페이지를 일단 표시한 후 이미지는 따로 읽습니다. 때문에 이미지를 읽은 직후 바로 출력하면 제대로 동작하지 않습니다. filereader를 통해서 파일을 읽은 이후 이미지 리사이징을 하려고 했지만, 이미지가 아직 로드되지 않았는데 리사이징하면 당연히 canvas의 이미지는 존재하지 않겠죠? image가 읽혀진 후에 리사이징이 이루어지도록 하기 위해서 filereader와 마찬가지로 load 콜백 내부에 리사이징 함수를 넣어둘 것입니다.load 이벤트를 사용하기 위해 Image 인스턴스를 생성합니다.reader.onload의 콜백 내부에 image 인스턴스를 생성하고, image가 읽을 수 있는 형태가 되면 image.onload가 발생되도록 합니다. (자세한건 코드..!) 123456789101112131415161718192021const load_image = e =&gt; &#123; const files = e.target.files; const filesArr = Array.prototype.slice.call(files); // 여러장의 이미지를 불러올 경우, 배열화 filesArr.forEach(file =&gt; &#123; const reader = new FileReader(); reader.onload = e =&gt; &#123; const image = new Image(); image.className = &quot;img-item&quot;; // 스타일 적용을 위해 image.src = e.target.result; image.onload = imageEvent =&gt; &#123; // 이미지가 로드가 되면! 리사이즈 함수가 실행되도록 합니다. resize_image(image); &#125;; &#125;; reader.readAsDataURL(file); ✨✨ &#125;);&#125;;$(&quot;.image-upload&quot;).on(&quot;change&quot;, e =&gt; load_image(e)); 3. canvas 생성, img를 다시 리사이징하여 drawingresize_image 함수에 인자로 앞서 생성한 image 요소를 넘겨받게 했습니다.리사이징을 위해서 캔버스 엘리먼트를 생성한 후, 캔버스에 2d 컨텍스트의 image를 리사이징된 폭과 높이로 그릴 것입니다. 캔버스 엘리먼트를 생성. 해당 image의 높이와 폭을 측정한 후, 원하는 최대 사이즈의 크기보다 높이가 클 경우 리사이징할 비율을 폭에 곱하고, 반대의 경우 반대로 적용합니다. ( 폭이 클 경우 비율을 높에 곱한다. ) 리사이징된 폭과 높이를 canvas의 높이와 폭이 할당한 후 drawing 합니다. canvas의 drawImage() 사용합니다. 매개변수로는 이미지&#x2F; 원본의 x y 좌표 &#x2F; 너비와 높이 &#x2F; 컨텍스트의 x y 좌표 &#x2F; 컨텍스트 너비&#x2F; 높이 canvas의 dataURL을 toDataURL 메서드를 이용하여 구합니다. toDataURL 메서드에 이미지 마임 타입을 매개변수로 전달하여 data URI를 받습니다. getContext()는 브라우저 별로 지원 범위가 있습니다. 123456789101112131415161718192021222324252627const resize_image = image =&gt; &#123; let canvas = document.createElement(&quot;canvas&quot;), max_size = 1280, // 최대 기준을 1280으로 잡음. width = image.width, height = image.height; if (width &gt; height) &#123; // 가로가 길 경우 if (width &gt; max_size) &#123; height *= max_size / width; width = max_size; &#125; &#125; else &#123; // 세로가 길 경우 if (height &gt; max_size) &#123; width *= max_size / height; height = max_size; &#125; &#125; canvas.width = width; canvas.height = height; canvas.getContext(&quot;2d&quot;).drawImage(image, 0, 0, width, height); const dataUrl = canvas.toDataURL(&quot;image/jpeg&quot;); // 미리보기 위해서 마크업 추가. $(&quot;.image-preview&quot;).append(&#x27;&lt;img src=&quot;&#x27; + dataUrl + &#x27;&quot; class=&quot;img-item&quot;&gt;&#x27;);&#125;; 4. canvas의 dataURL를 이용하여 Blob 객체 생성Data URIs는 네 가지 파트로 구성됩니다data:[&lt;mediatype&gt;][;base64],&lt;data&gt; 접두사(data:) 데이터의 타입을 가리키는 MIME 타입 텍스트가 아닌 경우 사용될 부가적인 base64 토큰 그리고 데이터 자체 Base64바이너리 데이터를 문자 코드에 영향을 받지 않는 공통 ASCII 문자로 표현하기 위해 만들어진 인코딩이다. 네이버 지식iN 등의 URL에서 자주 볼 수 있는 형태의 바로 그것.ASCII 문자 하나가 64진법의 숫자 하나를 의미하기 때문에 BASE64라는 이름을 가졌다. BlobBlob은 일련의 데이터를 처리하거나 간접 참조하는 객체다. Blob이란 이름은 SQL 데이터베이스에서 유래하였으며 ‘대형 이진 객체(Binary Large Object)’를 의미한다. 자바스크립트에서 Blob은 흔히 이진 데이터를 나타내며 해당 데이터의 크기가 매우 클 수 있지만, 두 가지 특징 모두 강제된 사항은 아니다. 즉, 작은 텍스트 파일의 내용도 Blob으로 나타낼 수 있다. Blob은 대개 바이트의 크기를 알아내거나, 해당 MIME 타입이 무엇인지 요청하며, 데이터를 작은 Blob으로 잘게 나누는 등의 작업에 사용된다. 즉, 데이터 자체라기보다는 데이터를 간접적으로 접근하기 위한 객체인 것이다. Blob.size Blob 객체에 포함된 데이터의 바이트 단위의 사이즈를 의미한다.Blob.type Blob에 포함된 데이터의 MIME 타입을 의미한다. 만약 unknown으로 나올 경우, 이 문자열은 비어있는 것이다. 1234567891011121314151617181920212223242526272829const dataURLToBlob = dataURL =&gt; &#123; const BASE64_MARKER = &quot;;base64,&quot;; // base64로 인코딩 되어있지 않을 경우 if (dataURL.indexOf(BASE64_MARKER) === -1) &#123; const parts = dataURL.split(&quot;,&quot;); const contentType = parts[0].split(&quot;:&quot;)[1]; const raw = parts[1]; return new Blob([raw], &#123; type: contentType &#125;); &#125; // base64로 인코딩 된 이진데이터일 경우 const parts = dataURL.split(BASE64_MARKER); const contentType = parts[0].split(&quot;:&quot;)[1]; const raw = window.atob(parts[1]); // atob()는 Base64를 디코딩하는 메서드 const rawLength = raw.length; // 부호 없는 1byte 정수 배열을 생성 const uInt8Array = new Uint8Array(rawLength); // 길이만 지정된 배열 let i = 0; while (i &lt; rawLength) &#123; uInt8Array[i] = raw.charCodeAt(i); i++; &#125; return new Blob([uInt8Array], &#123; type: contentType &#125;);&#125;; 5. 전송ajax로 보낼 경우 FormData 생성후 최종 생성한 Blob 객체를 추가하면 됩니다. 참고링크 http://mohwa.github.io/blog/javaScript/2015/08/31/binary-inJS/ http://www.soen.kr/html5/html3/3-1-3.htm 프론트엔드개발자를 위한 자바스크립트 - File API https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Data_URIs https://namu.wiki/w/BASE64 https://developer.mozilla.org/ko/docs/Web/API/Blob https://firejune.com/1787/HTML5+ArrayBuffer+API+%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0 (ArrayBuffer - 추후 더 공부하기) http://iamawebdeveloper.tistory.com/106 [나는 웹개발자!]","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"File API","slug":"File-API","permalink":"http://feel5ny.github.io/tags/File-API/"},{"name":"canvas","slug":"canvas","permalink":"http://feel5ny.github.io/tags/canvas/"}]},{"title":"(mobile) device-pixel-ratio계산","slug":"mediaQuery_01","date":"2018-05-13T12:20:19.000Z","updated":"2024-11-23T12:12:54.695Z","comments":true,"path":"2018/05/13/mediaQuery_01/","permalink":"http://feel5ny.github.io/2018/05/13/mediaQuery_01/","excerpt":"","text":"**목차** &#128075;&#128075; 서론 @media 대하여.. -webkit-device-pixel-ratio 2-1. 픽셀비율 계산하기 2-2. device width와 height 계산하기 0. 서론 현재 작업 중인 프로젝트는 데스크탑 브라우저(여러 브라우저 대응) 뿐만아니라 모바일 기기 대응도 진행해야한다. 너무도 당연히 대응해야하지만!! 기기의 종류들의 크기가 다양해짐에 따라서 미디어쿼리를 적절히 사용해야할 필요가 생겼다.(아이폰X나 갤럭시S9같은.. 스크린이 긴 단말기ㅜ) 게다가 네이티브앱에서 웹뷰를 이용하는 일이 빈번했기 때문에 더더욱.. 1. 특정 모바일 디바이스 대응 @mediaCSS3의 @media 쿼리를 이용해서 screen의 크기에 따라서 레이아웃 구성을 다르게하는 방법을 구현할 수 있다. 반응형 웹에서는 다른 특별한 설정 없이 max-width같은 media features를 추가하여 브라우저의 width값마다 스타일을 조정할 수 있다. 1234/*syntax*/@media not|only (media type) and (media feature) &#123; CSS-Code;&#125; media type all : 모든 디바이스에 적용 print : printer에 사용 screen : 컴퓨터 스크린, 태블릿, 스마트폰 등에 쓰임 speech : 스크린 리더기에 사용, 스크린 내용을 읽어주는 미디어 일때 media features(조건문)(정말 많군요! &#128064;) height, width : 둘 다 해당, 둘 다 미디어에 따라 다른 값들이 검출 됨 width : 320px : 미디어가 320px일때 max-width : 320px : 320px 이하의 미디어 일 때 min-width : 320px : 320px 이상의 미디어 일 때 device : device의 물리적인 값들을 기준으로(해상도와 너비는 같지 않을 수 있다) device-width : 320px : 기기의 너비가 320px일때 max-device-width : 320px : 320px 이하의 화면일 때 min-device-width : 320px : 320px 이상의 화면일 때 orientation :화면 회전 width, height가 아닌 portrait, landscape값으로 구분한다.대부분 세로로 긴 핸드폰의 형태이기 때문에 기본상태는 portrait, 가로로 돌렸을 때는 landscape.데스크톱에는 가로 세로 개념이 없음. 그렇다고 이 개념이 모바일 개념은 아니다. aspect-ratio, min-aspect-ratio, max-aspect-ratio(화면비율) : width&#x2F;height (가로 나누기 세로) aspect-ratio:1 : 화면 비율이 1:1인경우 aspect-ratio:16/9 : 일반적인 화면 비율인 16:9를 의미합니다(1920*1080) device-aspect-ratio, min-device-aspect-ratio, max-device-aspect-ratio : 단말기의 물리적인 화면 비율 color, min-color, max-color : 단말기에서 사용하는 최대 색상 비트 수에 대응(단위는 자연수) color:3 : 2³ &#x3D; 8개의 색상 사용 color-index, min-color-index, max-color-index : 최대 색상 수에 대응 monochrome, min-monochrome, max-monochrome : 흑백만 사용하는 단말기에서의 픽셀당 비트수, 얼마나 자유롭게 표현되는지를 확인함 resolution, min-resolution, max-resolution : 단말기의 해상도 grid : 단말기가 grid방식인지 bitmap방식인지 grid:1 ⇒ 문자로만 표기되는 tty, 주로 터미널, 전화액정 grid:0 ⇒ 대부분의 컴퓨터와 스마트폰 웹 브라우저에 해당 -webkit-min-device-pixel-ratio : 단말기의 화소와 실제 화면의 pixel간의 비율 2. -webkit-device-pixel-ratio사실 단말기에 따른 media query는 인터넷 서핑을 잘 하다보면 구할 수 있다.(여긴 내가 좋아하는 정리 사이트)나 또한 정리되어있는 자료에서 device width와 height, -webkit-min-device-pixel-ratio를 구할 수 있었다. 정리된 수치로 잘 사용하고 있었지만, 종종 서치하기 힘든 디바이스까지 대응해야할 경우도 생기곤 한다. 그리고 나에게도 그런 상황이 다가왔다! 1. 픽셀 비율을 계산해보자.내가 대응해야할 폰은 LG X400이라는 디바이스였다. 최근에 나온 기종이고, 내가 알 수 있는 정보는 아래 표밖에 없었다. 5.3인치 1280*720, 294ppi@media only screen and(device-width: ?px) and(device-height: ?px) and(-webkit-device-pixel-ratio: ?) { 위의 값들이 필요하다. 먼저 픽셀 비율부터 구해보자.디바이스 픽셀 비율을 계산하는 데는 세 단계가 필요하다. 1-1. 들고있는 디바이스로부터 시야까지의 실제 거리와 레퍼런스 픽셀의 거리를 비교. 스펙에 따르면 28인치에서 이상적인 것은 인치 당 96 픽셀이다.(표준밀도는 96ppi) 그러나 스마트 폰이기때문에 사람들은 노트북을 들고 다니는 것보다 디바이스를 얼굴에 가깝게 들고있는다. 그 거리를 18 인치로 추정 해본다. 1-2. 주어진 거리에 대해 이상적인 픽셀 밀도를 얻으려면 거리 비에 표준 밀도 (96ppi)를 곱한다.idealPixelDensity &#x3D; (28&#x2F;18) * 96 &#x3D; 150 픽셀&#x2F;인치 (대략) 1-3. 물리적 픽셀 밀도와 이상적인 픽셀 밀도의 비율을 사용하여 장치 픽셀 비율을 얻는다.devicePixelRatio &#x3D; 294&#x2F;150 &#x3D; 1.96 &#x3D;&gt; 반올림 &#x3D;&gt; 2 2. device-width와 height현재 알 수 있었던 해상도는 표에서 1280*720 라고 알 수 있었다.device의 너비와 height는 픽셀 비율을 해상도에서 나누면 된다. device-width &#x3D; 720&#x2F;2 &#x3D; 360 device-height &#x3D; 1280&#x2F;2 &#x3D; 640 123456@media only screen and(device-width: 360px) and(device-height: 640px) and(-webkit-device-pixel-ratio: 2) &#123; 💅💅💅💅&#125; 요약 해당기기의 ppi와 해상도를 알고 있다면,devicePixelRatio &#x3D; 해당 기기의 ppi &#x2F; 150 (왜 150인지는 위에 설명)deviceWidth &#x3D; 해당기기의 해상도 &#x2F; devicePixelRatio 특정 기기 이외에는 min이나 max를 이용하여 정의하면 비슷한 해상도와 픽셀비율을 가진 디바이스에 적용가능하다. 참고https://medium.com/@junghan_61455/css-media-query-5969b004bd7https://www.html5rocks.com/en/mobile/high-dpi/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. CSS","slug":"01-Web/03-CSS","permalink":"http://feel5ny.github.io/categories/01-Web/03-CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://feel5ny.github.io/tags/css/"},{"name":"media-query","slug":"media-query","permalink":"http://feel5ny.github.io/tags/media-query/"},{"name":"mobile","slug":"mobile","permalink":"http://feel5ny.github.io/tags/mobile/"},{"name":"log","slug":"log","permalink":"http://feel5ny.github.io/tags/log/"}]},{"title":"(번역) Angular의 observable을 이해하고, 생성하고, 구독해보기","slug":"angular_observable","date":"2018-03-25T01:23:55.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/03/25/angular_observable/","permalink":"http://feel5ny.github.io/2018/03/25/angular_observable/","excerpt":"","text":"원문 : https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3 엥귤러 version2가 나왔을때, 엥귤러는 옵저버블을 소개했다. 옵저버블은 엥귤러의 특정 기능은 아니고, ES7 릴리스에 포함될 비동기 데이터를 관리하기위한 새로운 표준이다. Angular는 이벤트 시스템과 HTTP 서비스에서 옵저버블을 광범위하게 사용한다. 옵저버블들을 이해하는 건 꽤 중요한 일일 수 있다. 그러므로 쉬운 방법으로 옵저버블을 설명하려고 왔다. Observables옵저버블은 시간이 지남에 따라 여러값을 가질 수 있는 지연 콜렉션이다.옵저버블은 사실.. 꽤 쉽습니다. 1. Observables는 lazy하다.지연 옵저버블을 뉴스 레터로 생각할 수 있다. 각 구독자(subscriber)마다 새로운 뉴스 레터가 만들어진다. 그 뉴스레터들은 구독자들에게만 보내고 다른 사람에게는 보내지 않는다. 2. Observables는 시간이 지남에 따라 여러 값을 가질 수 있다.뉴스 레터 구독을 계속 열어두면, 매번 새로운 뉴스 레터를 받게된다. 발신자(sender)는 받은 시간을 결정하지만 받은 편지함에 곧바로 올 때까지 기다려야한다. 여러분이 promise의 세상에서 왔다면, 옵저버블과 프로미스간의 다른 중요한 차이점이 있는데, promise은 항상 오직 하나의 값만을 반환한다는 점이다. 또 하나는 옵저버블의 구독을 취소 할 수 있다는 점이다. 뉴스 레터를 더 이상 원하지 않으면 구독을 취소하면된다. 프로미스를 사용하면 이점이 다른건데, 프로미스는 취소 할 수 없다. 프라미스가 당신에게 건네지면, 그 프라미스의 resolve가 이미 진행되고 있으며, 일반적으로 프라미스의 resolve가 실행되는 것을 막을 수 있는 권한이 없다. Push vs pullobservables를 사용할 때 이해해야 할 핵심 사항은 observables가 push한다는 것이다. (옵저버블은 push 시나리오를 따른다는 말) push와 pull은 데이터 생성자가 데이터 소비자와 커뮤니케이션하는 방법을 설명하는 두 가지 방식이다. PullPulling일 때 데이터 소비자는 데이터 생성자로부터 데이터를 가져 오는 시점을 결정한다. 생산자는 언제 데이터가 소비자에게 전달되는지를 알지 못한다.모든 자바 스크립트 함수는 pull 시나리오를 사용한다. 함수는 데이터의 프로듀서이며 함수를 호출하는 코드는, 호출에서 하나의 반환 값을 “꺼내”(pull) 가져와 이를 소비한다. PushPushing일 때, 다른 방향으로 동작한다. 데이터 생성자 (뉴스 레터 생성자)는 소비자 (뉴스 레터 구독자)가 데이터를 가져 오는 시점을 결정합니다. 프로미스는 오늘날 자바 스크립트에서 사용하는 가장 일반적인 push 방법입니다. 프로미스(생산자) 전달자는 등록된 콜백(소비자)에게 resolve된 값을 전달하고, 프로미스는 함수와는 달리 콜백에 그 값이 “푸시 (push)”되는 시기를 정확하게 결정한다. Observables는 JavaScript로 데이터를 푸시하는 새로운 방법이다. 옵저버블은 여러 값의 생산자로서 구독자에게 “푸시 (pushing)”한다. 엥귤러에서 ObservablesAngular를 사용하기 시작하면 아마도 HTTP 요청을 설정할 때 옵저버블을 만날 것이다. http 요청부분부터 시작해봅시다. 123456789101112131415161718import &#123; Observable &#125; from &quot;rxjs/Rx&quot;import &#123; Injectable &#125; from &quot;@angular/core&quot;import &#123; Http, Response &#125; from &quot;@angular/http&quot;@Injectable()export class HttpClient &#123; constructor( public http: Http ) &#123;&#125; public fetchUsers() &#123; return this.http.get(&quot;/api/users&quot;) .map((res: Response) =&gt; res.json()) &#125;&#125; 우리는 이제 observable을 반환하는 fetchUsers 메서드를 사용하여 간단한 HttpClient를 만들었다. 어떤 종류의 리스트에 사용자를 표시하고 싶으므로 fetchUsers 메서드를 사용해서 해보자. 이 메소드는 옵저버블을 반환하기 때문에 우리는 그것을 구독해야 한다. Angular에서 우리는 두 가지 방식으로 Observable을 구독 할 수 있다 : 방식 1:비동기 파이프를 사용하여 템플릿의 옵저버블을 구독하는 방법이 있다. 이로 인해 Angular는 컴포넌트의 생명주기 동안 구독을 처리한다. Angular는 자동으로 구독하고 구독취소한다. 비동기 파이프가 노출되야하므로 모듈에 “CommonModule”을 import하는 것을 잊지 마세요. 12345678910111213141516171819202122232425262728import &#123; Component &#125; from &quot;@angular/core&quot;import &#123; Observable &#125; from &quot;rxjs/Rx&quot;// clientimport &#123; HttpClient &#125; from &quot;../services/client&quot;// interfaceimport &#123; IUser &#125; from &quot;../services/interfaces&quot;@Component(&#123; selector: &quot;user-list&quot;, templateUrl: &quot;./template.html&quot;,&#125;)export class UserList &#123; public users$: Observable&lt;IUser[]&gt; constructor( public client: HttpClient, ) &#123;&#125; // do a call to fetch the users on init of component // the fetchUsers method returns an observable // which we assign to the users$ property of our class public ngOnInit() &#123; this.users$ = this.client.fetchUsers() &#125;&#125; 123456&lt;!-- We use the async pipe to automatically subscribe/unsubscribe to our observable --&gt;&lt;ul class=&quot;user__list&quot; *ngIf=&quot;(users$ | async).length&quot;&gt; &lt;li class=&quot;user&quot; *ngFor=&quot;let user of users$ | async&quot;&gt; &#123;&#123; user.name &#125;&#125; - &#123;&#123; user.birth_date &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 달러 기호에 유의하세요. 옵저버블 변수 이름에 달러 기호를 사용하면 모범 사례로 간주된다. ($를 Stream의 약어로 쓴다.)이렇게하면 변수가 관찰 가능 여부를 쉽게 식별 할 수 있다. 방식 2:우리는 실제 subscribe() 메소드를 사용하여 옵저버블을 구독한다. 데이터를 표시하기 전에 먼저 데이터에 뭔가 작업하기를 원한다면 편리할 수 ​​있다. 단점은 구독을 직접 관리해야한다는 것다. 12345678910111213141516171819202122232425262728293031323334import &#123; Component &#125; from &quot;@angular/core&quot;// clientimport &#123; HttpClient &#125; from &quot;../services/client&quot;// interfaceimport &#123; IUser &#125; from &quot;../services/interfaces&quot;@Component(&#123; selector: &quot;user-list&quot;, templateUrl: &quot;./template.html&quot;,&#125;)export class UserList &#123; public users: IUser[] constructor( public client: HttpClient, ) &#123;&#125; // do a call to fetch the users on init of component // we manually subscribe to this method and take the users // in our callback public ngOnInit() &#123; this.client.fetchUsers().subscribe((users: IUser[]) =&gt; &#123; // do stuff with our data here. // .... // asign data to our class property in the end // so it will be available to our template this.users = users &#125;) &#125;&#125; 12345&lt;ul class=&quot;user__list&quot; *ngIf=&quot;users.length&quot;&gt; &lt;li class=&quot;user&quot; *ngFor=&quot;let user of users&quot;&gt; &#123;&#123; user.name &#125;&#125; - &#123;&#123; user.birth_date &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 템플릿 로직이 꽤 비슷하다는 것을 알 수 있듯이, 당신이 2번 방식으로 간다면 구성 요소 논리는 훨씬 더 복잡해 질 수 있다. 일반적으로 나는 방식1을 선택하는 것이 좋다. 가장 쉽고 구독을 수동으로 관리할 필요가 없다. 2번방법에서 구독을 사용하지 않는 동안 열어두면 메모리 누수가 발생하므로 좋지 않다. Creating an observable yourselfAngular가 제공한 일반적인 옵저버블을 다루는 방법을 알았으므로 옵저버블을 어떻게 생성하는지 알고있는 것이 좋다. 가장 간단한 버전은 다음과 같다. 123456789101112131415import &#123; Observable &#125; from &quot;rxjs/Observable&quot;// create observableconst simpleObservable = new Observable((observer) =&gt; &#123; // observable execution observer.next(&quot;bla bla bla&quot;) observer.complete()&#125;)// subscribe to the observablesimpleObservable.subscribe()// dispose the observablesimpleObservable.unsubscribe() 예제에서 볼 수 있듯이 observables는 새로운 Observable() 호출을 사용하여 만든 다음 observer에 가입하고 next()를 호출하여 실행하고 unsubscribe()를 호출하여 삭제한다. observable 만들기observables를 만드는 것은 쉽다. 새로운 Observable()을 호출하고 옵저버를 나타내는 하나의 인수를 전달하면됩니다. 그러므로 저는 보통 그것을 “observer”라고 부릅니다. 옵저버블 구독하기옵저버블은 느긋하다는걸 기억하세요. 구독하지 않으면 아무 일도 일어나지 않을 것이다. 옵저버를 구독 할 때 subscribe()를 호출 할 때마다 옵저버블에 독립 설정이 실행된다는 사실을 알면 좋다. 구독 요청은 동일한 옵저버블에 대한 여러 구독자간에 공유되지 않는다. 옵저버블 실행하기 **observables 안의 코드는 observables의 실행을 나타낸다. 옵저버블을 만들 때 주어진 매개 변수(observer)에는 옵저버블의 구독자에게 데이터를 보낼 수있는 세 가지 함수가 있다. next: Number나 Array나 객체같은 여러 값을 subscribers에게 보낸다. error: 자바스크립트 에러나 예외값을 보낸다. complete : 어떤 값도 보내지 않는다. next 콜은 구독자에게 실제로 데이터를 전달할 때 가장 일반적이다. 옵저버블의 실행 중에는 observer.next()의 무한 호출이있을 수 있지만 observer.error() 또는 observer.complete()가 호출되면 실행이 중지되고 더 이상 데이터가 subscribers에게 전달되지 않는다. 옵저버블 처분옵저버블의실행은 무한한 시간 동안 실행될 수 있기 때문에, 실행을 막을 수있는 방법이 필요하다. 각 구독자마다 각 실행이 실행되기 때문에, 메모리와 컴퓨팅 성능이 낭비, 즉 더 이상 데이터가 필요없는 구독자는 구독을 멈추는 것이 중요하다. 옵저버블을 구독할 때, 진행중인 실행을 취소하면 구독이 반환된다. 실행을 취소하려면 unsubscribe()를 호출하면 됨. 결론이 게시물을 통해 옵저버블이 실제로 어떻게 작동하는지 더 잘 이해할 수 있다. 다음 시간에 옵저버블에 대해서 더 많이 알기 위해 Rxjs의 강력함을 이해하고 이 제공하는 모든 헬퍼 함수를 이해하는 것이다.","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://feel5ny.github.io/tags/angular/"},{"name":"prettier","slug":"prettier","permalink":"http://feel5ny.github.io/tags/prettier/"},{"name":"formatter","slug":"formatter","permalink":"http://feel5ny.github.io/tags/formatter/"}]},{"title":"Angular 프로젝트에 prettier 코드포매터 세팅하기","slug":"angular_prettier","date":"2018-03-11T09:23:55.000Z","updated":"2024-11-23T12:32:16.626Z","comments":true,"path":"2018/03/11/angular_prettier/","permalink":"http://feel5ny.github.io/2018/03/11/angular_prettier/","excerpt":"","text":"개인의 경험을 바탕으로 적은 글이기에 피드백은 언제나 댓글로 환영합니다. :) 목차 모듈 세팅 프리티어 설치하기 에디터에만 세팅하기 프로젝트에 세팅하기 프리티어 옵션 값 precommit, 커밋 전 옵션에 맞춰 재포맷 하는 hook 추가. lint stage husky 한 프로젝트에 프론트엔드 개발자가 여러 명일 경우 각자의 코드 스타일이 다르기 때문에 통일성을 위해 코드 포메터를 사용하면 코드를 깔끔하게 공유할 수 있다. 현재 진행 중인 angular 프로젝트에 react 프로젝트에서 사용했었던 Prettier라는 포매터를 사용하기로 결정했다. 초반에 어떻게 세팅할지만 논의하면 된다. 프리티어를 엥귤러 프로젝트에 적용하면서 겪었던 부분을 글로 공유하고자 한다.참고로 에디터는 vscode를 사용하고 있다. 1. 모듈 세팅angular cli 로 프로젝트를 생성하면 기본 구조가 세팅이 되는데, 엥귤러는 타입스크립트가 주력 언어이므로 타입스크립트를 위한 tslint.json 파일과 tsconfig.json 파일이 함께 세팅된다.tslint.json 파일은 tslint 가 사용하는 linting(구문 체크) 설정 파일이다. tslint 란 An extensible linter for the TypeScript language. 즉 타입스크립트 린터이다!vscode 에서는 tslint 확장 프로그램을 설치하면 구문과 다른 곳을 빨간 줄로 표시해준다.tsconfig.json파일은 타입스크립트 컴파일 옵션 설정 파일이다. 우리는 tslint의 옵션 포맷에 + Prettier의 커스텀 옵션을 추가하기로 결정하였다. 1-1. 프리티어 설치하기 * 에디터에만 적용하기프리티어 패키지를 설치하는 방법과 플러그인으로 세팅하는 방법이 있다.개인적으로만 사용하거나 다른 개발자들이 모두 vscode 를 사용한다면 프리티어 플러그인을 설치하고 workspace settings 에만 설정해도 프리티어 세팅은 완료된다.Code &gt; Preference &gt; Settings &gt; Workspace Settings 위처럼 폴더가 생성된다. 폴더를 팀원들과 공유해도 괜찮고, 혹은 아래 옵션 객체만 팀 내의 docs에 공유해도 괜찮다. (나중에 들어올 팀원이 vscode를 쓴다는 전제가 있어야..ㅎ) * 프로젝트에 적용하기패키지 매니저로 프리티어를 설치한다. 1npm install prettier -D 123456&#123; &quot;prettier.printWidth&quot;: 80, &quot;prettier.useTabs&quot;: false, &quot;prettier.tabWidth&quot;: 2, &quot;prettier.bracketSpacing&quot;: true&#125; 프리티어 옵션은 여러 가지 방식으로 세팅이 가능하다. rc 파일을 따로 만들어서 관리할 수도 있고, json 파일로 만들어서 관리를 할 수 있다. 우리 프로젝트에서는 package.json 파일에 포함시키기로 했다. 12345678910 ... &quot;typeScript&quot;: &quot;~2.4.2&quot; &#125;, &quot;prettier&quot;: &#123; &quot;printWidth&quot;: 80, &quot;useTabs&quot;: false, &quot;tabWidth&quot;: 2, &quot;bracketSpacing&quot;: true &#125;&#125; vscode 세팅에서 &quot;editor.formatOnSave&quot;: true를 설정하면 저장하는 것과 동시에 프리티어가 적용된다. 1-2. 프리티어 옵션 값프리티어에는 여러 가지 기본 옵션 값들이 있다. Prettier 자세한 내용은 홈페이지에서 확인 가능하다. Print Width 한 줄에서 wrap 이 되는 기준의 글자 수를 정한다. default 80 Tab Width 탭의 스페이스 사이즈 default 2 Tabs 탭을 쓸 건지 안 쓸 건지 boolean Semicolons 문장 마지막에 세미콜론을 붙일지 안 붙일지 boolean Quotes true 이면 single quate Trailing Commas 마지막에 콤마 붙이기 none &#x2F; es5 &#x2F; all Bracket Spacing JSX Brackets Arrow Function Parentheses Range Parser FilePath Require pragma Insert Pragma Prose Wrap 우리의 프로젝트에서는 아래의 옵션을 세팅했다. 123456&#123; &quot;printWidth&quot;: 80, &quot;useTabs&quot;: false, &quot;tabWidth&quot;: 2, &quot;bracketSpacing&quot;: true&#125; printWidth 를 120 으로 하기도 하던데, 그건 취향껏! (에어비엔비는 80) 2. precommit, 커밋 전 재포맷 하는 hook 추가.개발자마다 쓰는 에디터가 다르고, 각자가 각자 에디터에 세팅하는 부분에서 나올 수 있는 에러들을 방지하기 위해 프로젝트 자체에 세팅한 후 커밋 할 때마다 세팅하는 방법이 있다.pre-commit 툴과 함께 사용하면 되는데 많이들 사용하는 husky와 lint-staged 모듈을 사용하면 된다. 프리커밋 툴을 사용하면 git add 을 입력할 때 (husky : hook) 린트 옵션에 맞춰서 재포맷을(lint-staged : 재포맷) 시켜준다. 이때 옵션에 tslint 옵션도 재포맷 설정에 넣어줄 수 있으므로 git add 명령어 만으로 tslint 와 prettier 의 옵션들을 적용시킬 수 있다. 모듈 설치 1npm install --save-dev lint-staged husky package.json 에 precommit 스크립트를 추가하고 lint-staged 옵션을 추가하면 된다.이때 prettier 를 읽는 스크립트와tslint 를 검사하고 fix 하는 스크립트를 추가한다. tslint --fix -c tslint.json -p tsconfig.jsonc 는 config 의 약어. tslint.json 파일의 옵션들을 확인하고 규칙에 맞춰서 fix 한다.p 는 project 의 약어. tsconfig.json 파일에 적힌 파일 경로에서 린트될 파일을 찾는다. package.json 1234567891011121314&#123; &quot;scripts&quot;: &#123; ..., &quot;precommit&quot;: &quot;lint-staged&quot; ... &#125;, &quot;lint-staged&quot;: &#123; &quot;*.&#123;ts,tsx&#125;&quot;: [ &quot;prettier --write&quot;, &quot;tslint --fix -c tslint.json -p tsconfig.json&quot;, &quot;git add&quot; ] &#125;,&#125; Reference Setting up Prettier in an Angular CLI Project","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"02. Code","slug":"03-DevOps/02-Code","permalink":"http://feel5ny.github.io/categories/03-DevOps/02-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://feel5ny.github.io/tags/angular/"},{"name":"prettier","slug":"prettier","permalink":"http://feel5ny.github.io/tags/prettier/"},{"name":"formatter","slug":"formatter","permalink":"http://feel5ny.github.io/tags/formatter/"}]},{"title":"Airbnb - lottie - bodymovin 웹에서 사용해보기","slug":"interaction_01","date":"2018-02-25T12:20:19.000Z","updated":"2024-11-23T12:49:15.678Z","comments":true,"path":"2018/02/25/interaction_01/","permalink":"http://feel5ny.github.io/2018/02/25/interaction_01/","excerpt":"","text":"airbnb 앱을 쓰다보면 곳곳에서 다양한 애니메이션을 볼 수 있다. 한 서비스에 애니메이션이 있으면 있을수록 자연스러운 사용성 유도, 사용자의 감성에도 메세지를 전할 수 있고, 서비스의 브랜드가 더 기억에 오래남고 강해진다고 생각한다. 모션을 좋아하는 성향과 모션이 줄 수 있는 위의 특징때문에 곳곳에 모션을 넣는 것을 좋아하는데, 그러던 중 airbnb의 lottie 서비스가 눈에 들어왔다. 예전부터 테스트만해보고 넣어보는 것을 시도했었는데, react-native로 앱을 만드는 부분에 로딩애니메이션으로도 넣어보았지만 아직 웹에서는 넣어보지 않아서 이번 기회에 해당 블로그 header의 아바타에 움직임을 넣어보았다.(최근 antd의 메인에서도 쓴걸 확인!) 장단점 작업을 다하고 든 생각은.. gif보다 경량화시킬 수 있을거라는 생각을 했지만, gif보다 3배나 파일이 컸다. 대신 svg로 이미지가 들어가기 때문에 벡터상태로 선명하게 들어간다. gif는 움직이는대신 화질이 떨어지는 단점이 있는데 이를 보안한다는 점에서 굉장한 장점. after effect를 좀 다뤄야한다는 .. 진입장벽이 있다. 간단 작업 순서 after effect로 작업하기 after effect에 bodymovin 플러그인 설치 작업 후 최종 렌더링할 컴포넌트 &#x3D;&gt; bodymovin 플러그인을 사용하여 렌더링 렌더링 옵션이 여러개가 있다. 본인의 프로젝트에 맞춰서 렌더링하면 됨. 렌더링 이후 export된 json파일, js파일을 html에 잘 임포트를 시키면 끝! 1. after effect로 작업하기shape animation이나 여러가지 모션그래픽은 에프터이펙트로 작업합니다. bodymovin 플러그인을 사용하기 위해서는 after effect로 작업된 파일이 필요합니다. 작업할 때 알아야할 점 (버그) 레이어 그룹해제 : 일러스트레이터를 임포트할 때 해당 레이어 내부에 group되어있는 부분을 전부 단일 레이어로 만들어야합니다. (그룹이 모두 해제되어있는 상태여야함) 마스크는 레이어당 하나만 : 하나의 shape 레이어에서 마스크를 동시에 2개를 사용시 둘중 하나만 인식이 됩니다. (아직 로티의 버그인 듯) 로티에서 해결해줄때까지 ㅠ 우선은 마스크를 한 레이어당 하나만 사용하면서 모션을 잡으셔야합니다. 너무 많은 레이어와 긴 시간의 모션은 스크립트도 용량이 크게 나옵니다. 웬만하면 loop되는 애니메이션으로 작업하셔야 합니다. 2. after effect에 bodymovin 플러그인 설치bodymovin이라는 플러그인을 설치하고 해당 플러그인을 사용하여 렌더링 해야합니다. 설치방법 에펙이 실행되고 있다면 닫으십시오. ZXP installer를 설치해야합니다. 설치경로 bodymovin 확장프로그램을 설치합니다. 다운로드를 클릭하여 다운받으세요. 설치경로 ZXP installer를 실행시킨후 3번에서 다운받은 bodymovin.zxp을 드래그하여 ZXP installer에 넣습니다. (에펙에 플러그인 설치완료) 에펙을 오픈한 후 “Window &gt; Extensions”를 보시면 “Bodymovin”가 있는걸 확인할 수 있습니다. 참고 &gt; http://airbnb.io/lottie/after-effects/bodymovin-installation.html 3. bodymovin으로 렌더링하기https://www.youtube.com/watch?v=5XMUJdjI0L8&amp;ab_channel=hernantorrisi 위의 방법대로 진행하면 오케이! 에펙에서 \"Window > Extensions\"의 \"Bodymovin\"를 오픈하면 위의 그림처럼 창이 하나 오픈됩니다. 우리가 필요한 파일은 `json`파일과 `js`파일입니다. 3-1. json파일로 렌더링하기 렌더링할 컴포넌트를 선택합니다. 어떤 포맷으로 렌더링할지 settings에서 선택해야합니다. 옵션은 여러가지가 있는데, 다중선택이 가능합니다. 셋팅이 완료되면 경로를 지정합니다. &#x3D;&gt; 어떤 포맷으로 렌덜이되는지 확인할 수 있습니다. 위의 렌더링버튼을 누르시면 렌더링 시작. 3-2. js파일로 렌더링하기 오른쪽 상단의 get the player를 선택합니다. 왼쪽의 get the player를 누르면 js파일을 받을 수 있습니다. 4. 렌더링 이후 export된 파일 프로젝트에 import시키기hexo블로그에 셋팅할 경우 파일은 아래 경로로 옮깁니다.themes &gt; hueman &gt; source &gt; js 필요한 파일 bodymoivn.js data.json 셋팅방법은 https://codepen.io/airnan/project/editor/ZeNONO/의 구조를 참고하였습니다. js파일 로드하는 스크립트 코드 html에 추가. index.js파일에서 아래처럼 json파일을 불러오면 home이외의 메뉴에서는 로드되지 않습니다. (hexo의 generate방식때문)123456789&lt;script&gt; var animation = bodymovin.loadAnimation(&#123; container: document.getElementById(&quot;bm&quot;), renderer: &quot;svg&quot;, loop: true, autoplay: true, path: &quot;logo_ny.json&quot; &#125;);&lt;/script&gt; 해결방법좋은 방법이라고는 생각되지 않으므로 피드백환영합니다. index.js의 경로를 아래처럼 수정 후, js폴더에 json파일을 넣습니다. json파일도 따로 로드합니다. 12345678// lottie_index.jsvar animation = bodymovin.loadAnimation(&#123; container: document.getElementById(&quot;bm&quot;), renderer: &quot;svg&quot;, loop: true, autoplay: true, path: &quot;../../../../logo_ny.json&quot;&#125;); 123// scripts.ejs&lt;%- js(&#x27;js/lottie&#x27;) %&gt;&lt;%- js(&#x27;js/lottie_index&#x27;) %&gt;","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Motion","slug":"01-Web/03-Motion","permalink":"http://feel5ny.github.io/categories/01-Web/03-Motion/"}],"tags":[{"name":"lottie","slug":"lottie","permalink":"http://feel5ny.github.io/tags/lottie/"},{"name":"bodymovin","slug":"bodymovin","permalink":"http://feel5ny.github.io/tags/bodymovin/"}]},{"title":"앵귤러 미리 예습해보기_ToDoList","slug":"Angular_practice","date":"2018-02-15T09:23:55.000Z","updated":"2024-11-23T12:13:17.755Z","comments":true,"path":"2018/02/15/Angular_practice/","permalink":"http://feel5ny.github.io/2018/02/15/Angular_practice/","excerpt":"","text":"출처 inflearn : Angular 기본과 간단한 To-Do 어플리케이션 만들기 http://poiemaweb.com/ : angular 파트 요약 목차 Angular CLI Angular Hello world Module Component 알아보기 Templete 알아보기 컴포넌트 커뮤니케이션 컴포넌트 스타일 처리 Pipe 1. Angular CLIAngular CLI는 Node.js의 프로젝트이기때문에 노드의 설치가 필요하다. 노드버전은 6.9.0 이상이어야한다. 0. 셋팅하기 노드 설치 후 npm i -g @angular/cli ng new 프로젝트 이름 1. Angular CLItree src라고 명령어를 입력하면 src 하위 파일 디렉토리 tree가 출력된다.tree -L 1 해당 디렉토리의 첫번째 레벨 트리만 출력된다. 1234567891011121314151617181920src/├── app│ ├── app.component.css│ ├── app.component.html│ ├── app.component.spec.ts│ ├── app.component.ts│ └── app.module.ts├── assets├── environments│ ├── environment.prod.ts│ └── environment.ts├── favicon.ico├── index.html├── main.ts├── polyfills.ts├── styles.css├── test.ts├── tsconfig.app.json├── tsconfig.spec.json└── typings.d.ts app 폴더어플리케이션 관련된 파일들이 들어가게 된다.app&#x2F;app.component.{ts, html, css, spec.ts}루트 컴포넌트를 구성하는 컴포넌트 클래스, HTML 템플릿. CSS, 유닛테스트 파일app&#x2F;app.module.tsAngular 구성요소를 등록하는 루트 모듈.environments.prod 프로젝트를 빌드할 때 프러덕션 모드로 빌드하게 되면 environment.prod.ts 내용들이 environment.ts 여기에 덮여쓰여지게된다. 앱에서 쓴 환경변수(서버 url…)를 프러덕션용 환경변수로 쓸 수 있게 된다. 1ng serve 서버를 실행시키면 로컬호스트에서 확인이 가능하다. CLI를 살펴보자.ng help를 입력하면 ng cli 리스트들이 쭉 나온다. 아래는 자주 사용하는 명령어만 적어둠. ng build &lt;options...&gt;Build커맨드는 소스코드를 빌드해서 dist&#x2F; 에 빌드해주는 명령어이다. 주로 사용하는 CLI --aot (Boolean) Build using Ahead of Time compilation. --watch (Boolean) (Default: false) Run build when files change. ng completion &lt;options...&gt;CLI 명령어를 자동 완성시켜주는 것을 설정하겠다 라는 커맨드이다. ng doc &lt;keyword&gt; &lt;options...&gt;앵귤러 공식 docs를 열어줍니다. ng e2e &lt;options...&gt;end to end 테스트를 하겠다는 것이다. 브라우저를 띄어서 테스트 하는 것. ng eject &lt;options...&gt;우리가 만든 앵귤러 CLI 프로젝트는 웹팩기반인데, webpack configuration를 밖으로 빼내어서 webpack configuration를 수정해서 프로젝트에 맞게 바꾸고 싶을 때 사용한다. ★★ ng generate &lt;blueprint&gt; &lt;options...&gt;사용 빈도수가 높다. 우리가 새로운 컴포넌트나 라우트나 모듈, 클래스 등을 agular CLI를 통해서 만들어지는데, 각각의 만들어지는 방법이 다르다. (옵션이 다르다.) ng get &lt;options...&gt;configuration를 한번 읽어오는 것 ng lint &lt;options...&gt;프로젝트의 코드의 스타일 가이드에 맞춰서 작성이 잘 되고 있는지 체킹해준다. ng new &lt;options...&gt; ng serve &lt;options...&gt;어플리케이션을 서버로 띄어준다. (빌드 후에) ng set &lt;options...&gt;앵귤러 CLI는 configuration(설정파일들)들이 있는데 그것들을 셋팅해준다. ng test &lt;options...&gt;유닛테스트 관련한 CLI, 컴포넌트나 서비스등 각각의 컴포넌트를 테스트 할때 ng version &lt;options...&gt; ng xi18n &lt;options...&gt;다국어 처리하는 시간에 자세히 살펴보도록 한다. 2. Angular Hello world.angular-cli.json 파일은 description이라고 생각하면된다. 2-1. main.ts12345678910111213// main.tsimport &#123; enableProdMode &#125; from &#x27;@angular/core&#x27;;import &#123; platformBrowserDynamic &#125; from &#x27;@angular/platform-browser-dynamic&#x27;;import &#123; AppModule &#125; from &#x27;./app/app.module&#x27;;import &#123; environment &#125; from &#x27;./environments/environment&#x27;;if (environment.production) &#123; enableProdMode();&#125;platformBrowserDynamic().bootstrapModule(AppModule); platformBrowserDynamic메서드 : 엥귤러가 우리가 만든 코드를 컴파일을 해서 실제 실행될 수 있는 자바스크립트 코드로 만들어내는데 브라우저에서 다이나믹하게 동적으로 하겠다는 메서드이다. (just-in-time으로)bootstrapModule(루트모듈) : 우리가 사용할 어플리케이션의 루트모듈을 설정하고 앵귤러 어플리케이션을 실행시키는 것이다. 루트모듈을 부트스트랩한다 라고도 한다. 2-2. app.module.ts@NgModule 데코레이터의 인자로 전달되는 메타데이터에 애플리케이션 전체의 설정 정보를 기술한 루트 모듈이다. 1234567891011121314151617// app.module.ts@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent] // 부트스트랩은 배열이라는 값을 갖고 있는데 이는 AppComponent에 index.html에 넣어주겠다는 말이다. // AppComponent에는 app-root라는 셀력터에 연결되어있다.&#125;)export class AppModule &#123; &#125;// @NgModule은 데코레이터// 앵귤러 모듈이라는 것(NgModule)을 정의한 클래스가 되는 것이다.// 앵귤러의 루트모드를 설정하는 클래스이다. 앵귤러의 루트모듈(AppModule)를 설정하는 클래스이다. 2-3. app.component.ts1234567891011import &#123; Component &#125; from &#x27;@angular/core&#x27;;@Component(&#123; selector: &#x27;app-root&#x27;, templateUrl: &#x27;./app.component.html&#x27;, styleUrls: [&#x27;./app.component.css&#x27;]&#125;)export class AppComponent &#123; title = &#x27;app&#x27;;&#125; 모든 컴포넌트의 부모 역할을 담당하는 루트 컴포넌트이다. > Anuglar 어플리케이션의 흐름 [+](http://poiemaweb.com/angular-architecture) 3. index.html/dist/index.html는 빌드(ng build)의 결과물로 실제 배포 시에는 서버로 이관된다.ng serve 명령어에 의해 내장 개발 서버를 사용하여 로컬 환경에서 프로젝트를 실행(preview)하는 경우, Angular CLI 내부적으로 빌드를 자동 수행하므로 빌드(ng build)를 별도 실행하여 &#x2F;my-app&#x2F;dist&#x2F;index.html를 생성할 필요는 없다.자동으로 빌드되어 가상 드라이브에 저장되어 있는 index.html를 내장개발 서버가 로드한다고 이해하면 된다. inline.bundle.js : 웹팩 유틸리티가 포함된 Webpack loaderpolifills.bundle.js : polyfil 의존성 모듈(core-js, zone.js)를 번들링한 파일styles.bundle.js : 스타일 전의를 번들링한 파일vendor.bundle.js : 의존성 모듈(@angular&#x2F;*, RxJS 등)을 번들링한 파일main.bundle.js : 개발자가 작성한 컴포넌트, 디렉티브, 서비스 등 소스코드를 번들링한 파일 3. Module3-1. ES6 모듈모듈이란 세부 구현이 숨겨지고 공개 API를 이용해 다른 코드에서 재사용 가능한 코드 각각의 파일들이 모듈이 된다. 변수 스코프가 모듈로 제한이 된다. 2016년 08월 1.0.0-beta.11부터 Angular의 빌드 시스템은 SystemJS에서 Webpack으로 변경되었다. We moved the build system from SystemJS to Webpack. 3-2. 엥귤러 모듈컴포넌트, 파이프, 서비스 등과 같은 앵귤러 어플리케이션의 주요 부분을 기능단위로 그룹핑하게 해준다. 모든 앵귤러 어플리케이션은 하나의 Root Module을 가진다. 여러 Feature Module을 가질 수 있다. 재사용할 수 있는 기능을 외부에 배포하기 위해 사용되기도 한다. 1ng g m todo app 하위에 todo라는 폴더가 생성되고 todo.module.ts라는 모듈파일이 만들어진다. 1ng g c todo/todos --module todo/todo.module.ts --export g는 generate,c는 component,m은 module,todo 밑에 todos라는 폴더를 둔다.todos에서 만들어진 component를 관리하는 모듈을 지정해주기 위해서 --module이라는 플래그를 사용, 관리하는 모듈 이름을 붙여준다.todo/todo.module.ts해당 모듈파일이 다른 곳에서 사용할 수 있다는 의미의 –export라는 플래그를 추가한다. –export플래그를 추가하면 NgModule 데코레이터의 메타데이터 내부에 export 옵션이 추가되며 todoComponent가 자동으로 추가된다. 123456789101112import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; CommonModule &#125; from &#x27;@angular/common&#x27;;import &#123; TodosComponent &#125; from &#x27;./todos/todos.component&#x27;;@NgModule(&#123; imports: [ CommonModule ], declarations: [TodosComponent], exports: [TodosComponent]&#125;)export class TodoModule &#123; &#125; declarations는 탬플릿에서 사용하는 컴포넌트를 의미한다. 모듈 정리 외부컴포넌트를 export하고싶을 때나 import하고 싶을 때는 module파일의 데코레이터에 옵션값을 추가한다. cli에서 컴포넌트를 생성하면서 자동으로 export 옵션에 추가하는 방법은 --export 플래그를 사용하는 것이다. 4. Component 빌딩 블록 LEGO HTML 요소들의 그룹 뷰와 로직으로 구성 1234567891011121314import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;// 함수라고 생각하면 된다. 함수를 호출하는 것처럼 사용하고 있다.// 데코레이터 내부의 메타데이터를 정의하고 있다.@Component(&#123; selector: &#x27;app-todos&#x27;, templateUrl: &#x27;./todos.component.html&#x27;, styleUrls: [&#x27;./todos.component.css&#x27;],&#125;)export class TodosComponent implements OnInit &#123; constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125; selector.이나 #을 앞에 붙여서 css에서의 선택자와 유사하게 사용도 가능하다. 현재는 .이나 #이 없기 때문에 태그명으로 정의된 것이다. templateUrlview에 대한 정의를 template에서 정의한다. styleUrlsstyle이 작성된 url을 정의한다. 1ng g c todo/todos/todo –inline-template –inline-style template이 따로 html파일로 생성되지 않고, todo내부에 생성된 component의 컴포넌트 데코레이터의 메타데이터에 template이 생성된다. template에는 리터럴로 html을 넣을 수 있다. 이를 inline방식으로 넣어지는 template스타일인데 위의 명령어로 자동으로 해당 방식의 컴포넌트를 생성할 수 있다. 5. Agular Template HTML 코드로서 템플릿을 표현 Tempate 표현식과 Template 문장이 있음 바인딩 바인딩의 대상 : 속성, 이벤트 ngModel, class, style 123456789101112&lt;div class=&quot;title&quot;&gt; &lt;h1&gt;나의 하루&lt;/h1&gt; &lt;h2&gt;2월 15일&lt;/h2&gt;&lt;/div&gt;&lt;div&gt; &lt;div *ngFor=&quot;let todo of todos&quot;&gt; &lt;input type=&quot;checkbox&quot; [checked]=&quot;todo.done&quot;&gt; &#123;&#123;todo.text&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;할 일 추가하기&quot;&gt;&lt;/div&gt; `*ngFor=\"let todo of todos\"` todos라는 객체의 todo요소들을 referencing한다고 생각하면 된다. ngForAngular의 ngFor “repeater” 지시자(directive) 5-1. 내장 directive 디렉티브(Directive &#x2F; 지시자)는 DOM의 모든 것(모양이나 동작 등)을 관리하기 위한 지시(명령)이다. HTML 요소 또는 어트리뷰트의 형태로 사용하여 디렉티브가 사용된 요소에게 무언가를 하라는 지시(directive)를 전달한다. 디렉티브는 애플리케이션 전역에서 사용할 수 있는 공통 관심사를 컴포넌트에서 분리하여 구현한 것으로 컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다. 컴포넌트도 뷰를 생성하고 이벤트를 처리하는 등 DOM을 관리하기 때문에 큰 의미에서 디렉티브로 볼 수 있다. 5-1-1. 컴포넌트 디렉티브 컴포넌트의 템플릿을 표시하기 위한 디렉티브 @Component데코레이터의 메타데이터 객체의 selector 프로퍼티에 임의의 디렉티브의 이름을 정의한다. 5-1-2. 어트리뷰트 디렉티브 어트리뷰트 디렉티브는 HTML요소의 어트리뷰트와 같이 사용하여 해당 요소의 모양이나 동작을 제어한다. ngClass, ngStyle와 같은 빌트인 어트리뷰트 디렉티브가 있다. 클래스 바인딩은 표현식 또는 클래스 리스트를 나타내는 문자열을 바인딩한다. ngClass 디렉티브는 문자열, 배열, 객체를 바인딩할 수 있다. 5-1-3. 구조 디렉티브 DOM 요소를 반복생성(ngFor) 조건에 의한 추가 또는 제거 (ngIf, ngSwitch)를 통해 돔 레이아웃을 변경한다. *를 접두사로 추가하며 []를 사용하지 않는다. ngIfngIf 디렉티브는 우변 표현식의 연산 결과가 참이면 해당 요소(호스트 요소)를 DOM에 추가하고 거짓이면 해당 요소(호스트 요소)를 DOM에서 제거한다. 우변의 표현식은 true 또는 false로 평가될 수 있어야한다. 1&lt;element *ngIf=&quot;expression&quot;&gt;...&lt;/element&gt; ngIf 디렉티브 앞에 붙은 *(asterisk)는 아래 구문의 문법적 설탕(syntactic sugar)이다. 즉 위 코드는 아래의 코드로 변환된다. 123&lt;ng-template [ngIf]=&quot;expression&quot;&gt; &lt;element&gt;...&lt;/element&gt;&lt;/ng-template&gt; Angular는 *ngIf를 만나면 호스트 요소를 ng-template 디렉티브로 래핑하고 *ngIf를 프로퍼티 바인딩으로 변환한다.([ngIf]=&quot;expression&quot;) ngFor와 ngSwitch 디렉티브도 동일한 패턴을 따른다. ng-template 디렉티브는 페이지에서 렌더링 될 요소를 div 또는 span 등의 요소와 함께 사용할 필요가 없는 요소들을 그룹화할 때 사용한다. ngIf else 123456789101112&lt;!-- if else --&gt;&lt;element *ngIf=&quot;expression; else elseBlock&quot;&gt;Truthy condition&lt;/element&gt;&lt;ng-template #elseBlock&gt;Falsy condition&lt;/ng-template&gt;&lt;!-- if else --&gt;&lt;element *ngIf=&quot;expression; then thenBlock else elseBlock&quot;&gt;&lt;/element&gt;&lt;ng-template #thenBlock&gt;Truthy condition&lt;/ng-template&gt;&lt;ng-template #elseBlock&gt;Falsy condition&lt;/ng-template&gt;&lt;!-- if --&gt;&lt;element *ngIf=&quot;expression; then thenBlock&quot;&gt;&lt;/element&gt;&lt;ng-template #thenBlock&gt;Truthy condition&lt;/ng-template&gt; ngForngFor 디렉티브는 컴포넌트 클래스의 컬렉션을 반복하여 호스트 요소(ngFor 디렉티브가 선언된 요소) 및 하위 요소를 DOM에 추가한다. 컬렉션은 일반적으로 배열을 사용한다. 123&lt;element *ngFor=&quot;let item of items&quot;&gt;...&lt;/element&gt;&lt;element *ngFor=&quot;let item of items; let i=index; let odd=odd; trackBy: trackById&quot;&gt;...&lt;/element&gt; 인덱스를 취득할 필요가 있는 경우, 인덱스를 의미하는 index를 사용하여 변수에 인덱스를 할당받을 수 있다. index 이외에도 first, last, even, odd와 같은 로컬 변수가 제공된다. 자세한 내용은 ngFor API reference를 참조하기 바란다. ngFor 디렉티브 앞에 붙은 *(asterisk)는 아래 구문의 문법적 설탕(syntactic sugar)이다. 즉 위 코드는 아래의 코드로 변환된다. 1234567&lt;ng-template ngFor let-item [ngForOf]=&quot;items&quot;&gt; &lt;element&gt;...&lt;/element&gt;&lt;/ng-template&gt;&lt;ng-template ngFor let-item [ngForOf]=&quot;items&quot; let-i=&quot;index&quot; let-odd=&quot;odd&quot; [ngForTrackBy]=&quot;trackById&quot;&gt; &lt;element&gt;...&lt;/element&gt;&lt;/ng-template&gt; ngSwitch 12345678&lt;element [ngSwitch]=&quot;expression&quot;&gt; &lt;!-- switch 조건이 &#x27;case1&#x27;인 경우 DOM에 추가 --&gt; &lt;element *ngSwitchCase=&quot;&#x27;case1&#x27;&quot;&gt;...&lt;element&gt; &lt;!-- switch 조건이 &#x27;case2&#x27;인 경우 DOM에 추가 --&gt; &lt;element *ngSwitchCase=&quot;&#x27;case2&#x27;&quot;&gt;...&lt;element&gt; &lt;!-- switch 조건과 일치하는 ngSwitchCase가 없는 경우 DOM에 추가 --&gt; &lt;element *ngSwitchDefault&gt;...&lt;element&gt;&lt;/element&gt; ngSwitch 디렉티브 앞에 붙은 *(asterisk)는 아래 구문의 문법적 설탕(syntactic sugar)이다. 즉 위 코드는 아래의 코드로 변환된다. 1234567891011&lt;element [ngSwitch]=&quot;expression&quot;&gt; &lt;ng-template [ngSwitchCase]=&quot;&#x27;case1&#x27;&quot;&gt; &lt;element&gt;...&lt;/element&gt; &lt;/ng-template&gt; &lt;ng-template [ngSwitchCase]=&quot;&#x27;case2&#x27;&quot;&gt; &lt;element&gt;...&lt;/element&gt; &lt;/ng-template&gt; &lt;ng-template ngSwitchDefault&gt; &lt;element&gt;...&lt;/element&gt; &lt;/ng-template&gt;&lt;/element&gt;","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://feel5ny.github.io/tags/angular/"}]},{"title":"11/ 정규표현식","slug":"JS_11","date":"2018-01-20T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2018/01/20/JS_11/","permalink":"http://feel5ny.github.io/2018/01/20/JS_11/","excerpt":"","text":"목차 정규표현식 플래그 패턴 자주사용하는 정규표현식 JS Regular Expression RegExp Constructor RegExp Method1. RegExp.prototype.exec()2. RegExp.prototype.test() 1. 정규표현식 `RegExp.prototype.exec(text)` : `RegExp.prototype.test(text)` : boolean값이 반환된다. `String.prototype.match(rxgexr)` : 매치되는 문자열들을 반환한다. `String.prototype.replace(rxgexr, '')` : 첫번째 인자로 찾아진 문자열을 두번째 인자로 교체한다. `String.prototype.search(rxgexr)` : 배열의 길이 `String.prototype.split(rxgexr)` : 인자값을 제외하고, 인자값을 기준으로 split된 배열이 반환됨. 123456789101112var targetStr = &#x27;This is a pen.&#x27;;var regexr = /is/ig;// RegExp 객체의 메소드console.log(regexr.exec(targetStr)); // [ &#x27;is&#x27;, index: 2, input: &#x27;This is a pen.&#x27; ]console.log(regexr.test(targetStr)); // true// String 객체의 메소드console.log(targetStr.match(regexr)); // [ &#x27;is&#x27;, &#x27;is&#x27; ]console.log(targetStr.replace(regexr, &#x27;IS&#x27;)); // ThIS IS a pen.console.log(targetStr.search(regexr)); // 2console.log(targetStr.split(regexr)); // [ &#x27;Th&#x27;, &#x27; &#x27;, &#x27; a pen.&#x27; ] 1.1 플래그플래그는 옵션이므로 선택적으로 사용한다.플래그를 사용하지 않은 경우 문자열 내 검색 매칭 대상이 1개 이상이더라도 첫번째 매칭한 대상만을 검색하고 종료한다. i : ignore Case : 대소문자를 구별하지 않고 검색한다. g : Global : 문자열 내의 모든 패턴을 검색한다. m : Multi Line : 문자열의 행이 바뀌더라도 검색을 계속한다. 1.2 패턴패턴에는 찾고자 하는 대상을 문자열로 지정한다.또한 패턴은 특별한 의미를 가지는 메타문자(Metacharacter) 또는 기호로 표현할 수 있다. 1.2.1 /.../1234var targetStr = &#x27;AA BB Aa Bb&#x27;;// 임의의 문자 3개var regexr = /.../;console.log(targetStr.match(regexr)); // [ &#x27;AA &#x27;, index: 0, input: &#x27;AA BB Aa Bb&#x27; ] .은 임의의 문자 한 개를 의미한다. 문자의 내용은 무엇이든지 상관없다. 위의 경우 .를 3개 연속하여 패턴을 생성하였으므로 패턴과 일치하는 3자리 문자를 추출한다.플래그가 없으므로 추출을 반복하지 않는다. 문자열 내의 모든 패턴을 검색하기 위해 g사용 1234var targetStr = &#x27;AA BB Aa Bb&#x27;;// 임의의 문자 3개를 반복하여 검색var regexr = /.../g;console.log(targetStr.match(regexr)); // [ &#x27;AA &#x27;, &#x27;BB &#x27;, &#x27;Aa &#x27; ] 1.2.2 일치하는 문자 또는 문자열 추출 + | []1234567var targetStr = &#x27;AA BB Aa Bb&#x27;;// &#x27;A&#x27;를 검색var regexr1 = /A/;console.log(targetStr.match(regexr1)); // &#x27;A&#x27;var regexr2 = /A/ig;console.log(targetStr.match(regexr2)); // [ &#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;, &#x27;a&#x27; ] 앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 +를 붙인다. 아래의 경우 앞선 패턴는 A이므로 A+는 AA 또는 A를 의미한다. 1234var targetStr = &#x27;AA AAA BB Aa Bb&#x27;;// &#x27;A&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /A+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA&#x27;, &#x27;AAA&#x27;, &#x27;A&#x27; ] |를 사용하면 or의 의미를 가지게 된다. 1234var targetStr = &#x27;AA BB Aa Bb&#x27;;// &#x27;A&#x27; 또는 &#x27;B&#x27;를 반복 검색var regexr = /A|B/g;console.log(targetStr.match(regexr)); // [ &#x27;A&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;A&#x27;, &#x27;B&#x27; ] 분해되지 않은 단어 레벨로 추출하기 위해서는 +를 같이 사용하면 된다. 1234var targetStr = &#x27;AA AAA BB Aa Bb&#x27;;// &#x27;A&#x27; 또는 &#x27;B&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /A+|B+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA&#x27;, &#x27;AAA&#x27;, &#x27;BB&#x27;, &#x27;A&#x27;, &#x27;B&#x27; ] 위 예제는 패턴을 or로 한번 이상 반복하는 것인데 간단히 표현하면 아래와 같다.[]내의 문자는 or로 동작한다. 그 뒤에 +를 사용하여 앞선 패턴을 한번 이상 반복하게 한다. 1234var targetStr = &#x27;AA BB Aa Bb&#x27;;// &#x27;A&#x27; 또는 &#x27;B&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[AB]+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA&#x27;, &#x27;BB&#x27;, &#x27;A&#x27;, &#x27;B&#x27; ] 1.2.3 범위지정대문자 알파벳1234var targetStr = &#x27;AA BB ZZ Aa Bb&#x27;;// &#x27;A&#x27; ~ &#x27;Z&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[A-Z]+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA&#x27;, &#x27;BB&#x27;, &#x27;ZZ&#x27;, &#x27;A&#x27;, &#x27;B&#x27; ] 대소문자 구별없는 알파벳 \\w1234var targetStr = &#x27;AA BB Aa Bb&#x27;;// &#x27;A&#x27; ~ &#x27;Z&#x27; 또는 &#x27;a&#x27; ~ &#x27;z&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[A-Za-z]+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA&#x27;, &#x27;BB&#x27;, &#x27;Aa&#x27;, &#x27;Bb&#x27; ] \\w는 알파벳과 숫자를 의미한다. \\W는 \\w와 반대로 동작한다. 12345678var targetStr = &#x27;AA BB Aa Bb 24,000&#x27;;// 알파벳과 숫자 또는 &#x27;,&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\w,]+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA&#x27;, &#x27;BB&#x27;, &#x27;Aa&#x27;, &#x27;Bb&#x27;, &#x27;24,000&#x27; ]// 알파벳과 숫자가 아닌 문자 또는 &#x27;,&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\W,]+/g;console.log(targetStr.match(regexr)); // [ &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27;,&#x27; ] 숫자 추출하기1234var targetStr = &#x27;AA BB Aa Bb 24,000&#x27;;// &#x27;0&#x27; ~ &#x27;9&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[0-9]+/g;console.log(targetStr.match(regexr)); // [ &#x27;24&#x27;, &#x27;000&#x27; ] ,때문에 분리되는 것을 막기 위해 ,를 범위 안에 포함시킨다. 1234var targetStr = &#x27;AA BB Aa Bb 24,000&#x27;;// &#x27;0&#x27; ~ &#x27;9&#x27; 또는 &#x27;,&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[0-9,]+/g;console.log(targetStr.match(regexr)); // [ &#x27;24,000&#x27; ] 숫자 추출하기를 간단하게 표현하면 아래와 같다.\\d는 숫자를 의미한다. \\D는 \\d와 반대로 동작한다. 12345678var targetStr = &#x27;AA BB Aa Bb 24,000&#x27;;// &#x27;0&#x27; ~ &#x27;9&#x27; 또는 &#x27;,&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\d,]+/g;console.log(targetStr.match(regexr)); // [ &#x27;24,000&#x27; ]// &#x27;0&#x27; ~ &#x27;9&#x27;가 아닌 문자(숫자가 아닌 문자) 또는 &#x27;,&#x27;가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\D,]+/g;console.log(targetStr.match(regexr)); // [ &#x27;AA BB Aa Bb &#x27;, &#x27;,&#x27; ] 1.3 자주 사용하는 정규표현식1.3.1 특정단어로 시작? ^1234var targetStr = &#x27;abcdef&#x27;;// &#x27;abc&#x27;로 시작하지 검사var regexr = /^abc/;console.log(regexr.test(targetStr)); // true 1.3.2 특정단어로 끝나나? $1234var targetStr = &#x27;abcdef&#x27;;// &#x27;ef&#x27;로 끝나는지 검사var regexr = /ef$/;console.log(regexr.test(targetStr)); // true 1.3.3 숫자인가?1234var targetStr = &#x27;12345&#x27;;// 모두 숫자인지 검사var regexr = /^\\d+$/;console.log(regexr.test(targetStr)); // true 1.3.4 공백인가? \\s\\s는 공백을 의미한다. 1234var targetStr = &#x27; Hi!&#x27;;// 1개 이상의 공백으로 시작하는지 검사var regexr = /^[\\s]+/;console.log(regexr.test(targetStr)); // true 1.3.5 아이디로 사용 가능한가? &#123;&#125;&#123;&#125; : 자리수를 의미한다. 1234var targetStr = &#x27;abc123&#x27;;// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사var regexr = /^[A-Za-z0-9]&#123;4,10&#125;$/console.log(regexr.test(targetStr)); // true 1.3.6 메일주소 형식인가?123var targetStr = &#x27;ungmo2@gmail.com&#x27;;var regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]&#123;2,3&#125;$/;console.log(regexr.test(targetStr)); // true 1.3.7 현드폰 번호 형식인가?123var targetStr = &#x27;010-1234-5678&#x27;;var regexr = /^\\d&#123;3&#125;-\\d&#123;3,4&#125;-\\d&#123;4&#125;$/;console.log(regexr.test(targetStr)); // true 1.3.8 특수문자 포함인가?123var targetStr = &#x27;abc#123&#x27;;var regexr = /[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\&#x27;\\&quot;]/giconsole.log(regexr.test(targetStr)); // true 2. JS Regular Expression 참고링크 http://poiemaweb.com/js-regexp","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"기타 용어들","slug":"CS_07","date":"2018-01-02T09:23:55.000Z","updated":"2024-11-23T12:12:30.097Z","comments":true,"path":"2018/01/02/CS_07/","permalink":"http://feel5ny.github.io/2018/01/02/CS_07/","excerpt":"","text":"목록 dns subnet NAT port socket mac address 1. dnsDNS(도메인 네임 시스템)는 .com 또는 .net과 같은 특정 최상위 도메인(TLD)의 모든 도메인 네임 및 해당하는 IP 주소를 저장하는 데이터베이스입니다. DNS는 인터넷에서 컴퓨터 시스템과 리소스를 식별하고 찾습니다. 예를 들어, 웹 주소 또는 URL을 입력하면 DNS가 입력된 이름과 해당 위치의 IP 주소를 일치시키고 사용자를 해당 사이트에 연결시켜 줍니다. 2. subnet 서브넷(subnet)은 “subnetwork”을 줄인 말로서 어떤 기관에 소속된 네트웍이지만 따로 분리되어 있는 한 부분으로 인식될 수 있는 네트웍을 말한다. 일반적으로 하나의 서브넷은 하나의 지역, 한 빌딩 또는 같은 근거리통신망 내에 있는 모든 컴퓨터들을 나타낼 수 있다. 여러 개의 서브넷으로 나뉘어진 어떤 조직의 네트웍은 인터넷에 하나의 공유된 네트웍 주소로 접속될 수 있다. 만약 서브넷이 없다면, 그 조직은 물리적으로 분리된 서브 네트웍마다 하나씩, 여러 군데의 인터넷 접속을 가지게 될 것이며, 그렇게 함으로써 한정된 량의 인터넷 주소가 쓸모 없이 낭비될 수도 있게된다. 인터넷은 네트웍 사용자들 간에 서로 커뮤니케이션을 하기 위한 네트웍의 집합이다. 커뮤니케이션을 위해서는 양측의 사용자 또는 호스트가 관련되어 있는 발신지와 도착지 네트웍, 그리고 네트웍 내의 특정한 컴퓨터의 주소가 있어야 한다. 이 주소를 IP 주소라고 부른다. 32 비트의 IP 주소는 크게 두 부분으로 나뉘는데, 하나는 네트웍을 식별하는 네트웍 번호이고, 다른 하나는 네트웍 내의 특정한 컴퓨터나 호스트를 식별하는 호스트 번호이다. 한 기관에서 특정한 서브넷을 확인시키기 위해 컴퓨터나 호스트를 식별하는 주소 내의 비트들을 일부 사용할 수 있다. 그러므로 실제로는 IP 주소에는 네트웍 번호, 서브넷 번호, 그리고 컴퓨터 번호 등 세 부분이 포함되어 있는 셈이다. HTTPs://www.icann.org/ 3. NAT (&#x3D; Network Address Translation) NAT는 외부 네트웍에 알려진 것과 다른 IP 주소를 사용하는 내부 네트웍에서, IP 주소를 변환하는 것이다. 일반적으로, 한 회사는 자신의 내부 네트웍 주소를 하나 또는 그 이상의 공인 IP 주소로 사상한다. 그리고 들어오는 패킷들 상의 공인 IP 주소를 다시 사설 IP 주소로 변환한다. 이렇게 함으로써 나가거나 들어오는 각 요구들은 주소 변환과정을 반드시 거쳐야 하기 때문에, 보안문제를 확실하게 하는데 도움이 되며, 또한 요구를 제한하거나 인증하고, 또 이전의 요구와 일치시키는 기회를 제공한다. NAT은 또한 회사에서 필요한 공인 IP 주소의 수를 보존하며, 회사가 외부 네트웍과의 통신에서 단 하나의 공인 IP 주소를 사용할 수 있게 한다. NAT은 라우터의 일부로서 포함되며, 종종 통합된 방화벽의 일부가 되기도 한다. 네트웍 관리자들은 공인 IP 주소에서 사설 IP 주소로, 사설 IP 주소에서 공인 IP 주소로 사상하기 위한 NAT 표를 만든다. NAT은 라우팅 정책과 함께 사용될 수도 있다. NAT은 IP 주소를 정적으로 정의하거나, 또는 동적으로 변환하도록 설정될 수 있다. 시스코에서 만든 NAT 버전은 관리자가 다음과 같은 것들의 사상을 위한 표를 만들도록 해 준다. 4. port네트워크의 입출력단자들을 포트(PORT)라고 하며 번호로 지정되는데 포트의 번호는 0에서 65535까지 입니다.TCP&#x2F;IP 네트웍에서 포트 번호는, 들어오는 트래픽을 컴퓨터 내에서 실행되고 있는 적절한 프로그램에 분배시키기 위해 할당되는 숫자를 말한다. 이것은 물리적인 플러그나 소켓이 아니며, 다만 논리적인 할당일 뿐이다 프로그래밍에서, 포트는 “논리적인 접속장소”이며, 특히 인터넷 프로토콜인 TCP&#x2F;IP를 사용할 때에는 클라이언트 프로그램이 네트웍 상의 특정 서버 프로그램을 지정하는 방법으로 사용된다. 웹 프로토콜인 HTTP와 같이, TCP&#x2F;IP의 상위 프로토콜을 사용하는 응용프로그램에서는 미리 지정된 포트번호들을 가지고 있다. 이런 것들은 IANA에 의해 지정되었으며, “잘 알려진 포트들”이라고 불린다. 다른 응용프로그램 프로세스들은 매번 접속할 때마다 포트번호가 동적으로 부여된다. 서버 프로그램이 처음 시작되면, 지정된 포트번호로 바인드된다. 그 서버를 사용하려는 모든 클라이언트 프로그램들은 지정된 포트번호에 바인드해야만 한다. 바인드가 되면 두개의 컴퓨터간 네트워크를 이용한 통신시 발신지 컴퓨터에서 출발한 사용자 데이터(패킷)는 TCP&#x2F;IP의 각 계층을 거치면서 최종적으로 목적지 주소(IP)를 가지고 있는 컴퓨터에 도착하게 됩니다. 패킷을 수신한 컴퓨터는 전송시에 사용되었던 주소필드를 제거하고, 패킷 안에 있는 데이터만을 응용프로그램에 넘겨줍니다. 이 포트들은 크게 세 가지 영역으로 나누어서 지정되어 있습니다. 1. 0번 포트에서 1023포트 까지well-known port number 라고 하며 미리 특수용도로 지정되어 있습니다. (IANA(Internet Assigned Numbers Authority)에서 관리한다.) 21번: FTP22번: SSH23번: TELNET25번: SMTP(이메일송신)53번: DNS61번: SNMP(네트워크관리)80번: HTTP(웹페이지를 열기 위한 용도)110번: POP3(이메일수신)115번: SFTP135번: RPC139번: NetBIOS143번: IMAP194: IRC443: SSL445: SMB 2. 등록된 포트로 사용할 경우 1024~49151번을 사용합니다.1433: MSQL3306: MySQL3389: Remote Desktop5632: PCAnywhere5900: VNC6112: Warcraft III 3. 개인적 용도라면 49152~65535번을 사용하도록 규정되어 있습니다.클라이언트&#x2F;서버 방식의 프로그램에서 포트의 사용 서버&#x2F;클라이언트 프로그램에서는 서버에서 사용하는 포트번호를 클라이언트 프로그램에서도 동일하게 맞추어 주어야 합니다. 서버&#x2F;클라이언트 프로그램에서 사용하는 포트가 개방되도록 라우터 또는 공유기 등의 설정메뉴에서 개방해야 합니다. 서버&#x2F;클라이언트 프로그램에서 포트를 설정하지 않으면 임의로 포트를 설정해 주는 프로그램이 일부 있습니다. 5. socket 두 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 양쪽에 생성되는 링크의 단자입니다. 두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있습니다. 결국 소켓이 구현됨으로써 네트워크 및 전송 계층의 캡슐화가 가능해집니다. 소켓은 원래 캘리포니아 버클리 대학 분교에서 UNIX용으로 개발되었으며, UNIX에서의 입출력 메소드의 표준인 개방&#x2F;읽기&#x2F;쓰기&#x2F;닫기 메커니즘을 따릅니다. 소켓 함수는 동기모드(블록킹) &#x2F; 비동기 모드 (논블록킹)으로 동작합니다. 차이점은 만약 데이터가 도착하지 않는 상태에서 recv()로 데이터를 수신하고자 했을 때 데이터가 올 때까지 대기(block)하느냐 , 그냥 수신된 데이터가 없다는 정보만 리턴하고 넘어가느냐 입니다. 실제로 대기한다는 의미는 시스템을 멈추고 기다린다는 것이 아니라 다른 쓰레드나 프로세스(process)로 실행 권을 넘기는 것이기 때문에 프로세서는 항상 적절한 동작을 하게 됩니다. 비동기 모드로 데이터가 올 떄까지 풀링(polling)하면서 대기하는 것과는 기다린다는 의미에서는 동일하지만 프로세서를 활용한다는 면에서는 하늘과 땅 차이라고 할 수 있습니다. 이런 병렬적인 처리에 대한 고려가 필요하게 됩니다. 그리고 직접적인 소켓 통신을 처리하는 함수는 아니지만 소켓 처리에 대해서 Multiplex처리(하나의 쓰레드, 혹은 적은 수의 쓰레드에서 여러 개의 소켓을 처리)를 해주는 select , epoll , IOCP 같은 기능적인 함수군도 염두해 두어야겠습니다. 6. MAC address (&#x3D; Media Access Control Address)MAC 주소는, 무선 LAN 카드 또는 무선 LAN 기능 내장 기기에 개별적으로 부여되는 16진수 12자리의 단말 식별 번호(예:12:34:56:78:90:AB)입니다. OS에 따라 “물리적 주소” 또는”Wi-Fi 주소”라고 표시됩니다. DHCP 동적 IP 할당 특정 IP에서 오는 것 차단 ex. 특정 사이트 차단. 접속을 못하게 함. 공유기 안에 혹은 라우팅 컴퓨터 안에서 설정. 특정 포트만 전송 가능 참고링크 https://www.verisign.com/ko_KR/website-presence/online/domain-name-system/index.xhtml https://www.verisign.com/assets/DNS101_ko_KR.pdf http://www.terms.co.kr/subnet.htm http://www.terms.co.kr/NAT.htm http://egloos.zum.com/Esunny/v/4130787 http://popbox.tistory.com/66 https://ko.wikipedia.org/wiki/MAC_%EC%A3%BC%EC%86%8C http://popbox.tistory.com/66","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. Network","slug":"01-Web/02-Network","permalink":"http://feel5ny.github.io/categories/01-Web/02-Network/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"},{"name":"network","slug":"network","permalink":"http://feel5ny.github.io/tags/network/"}]},{"title":"3 way handshake","slug":"CS_06","date":"2018-01-01T01:23:55.000Z","updated":"2024-11-23T12:12:30.097Z","comments":true,"path":"2018/01/01/CS_06/","permalink":"http://feel5ny.github.io/2018/01/01/CS_06/","excerpt":"","text":"3 way handshakeClient와 Server 또는 P2P Socket 통신 등, 네트워크를 사용한 통신시 TCP 통신을 많이 사용한다.TCP 통신을 위한 네트워크 연결은 3 way handshake 라는 방식으로 연결된다.쉽게 이야기 하면, 서로의 통신을 위한 관문(port)을 확인하고 연결하기 위하여 3번의 요청&#x2F;응답 후에 연결이 되는 것이다. 먼저 Server에서 열려있는 포트는 LISTEN 상태이고 Client에서는 Closed 상태이다. Client에서 Server에 연결 요청을 하기위해 SYN 데이터를 보낸다. (SYN &#x3D; synchronize sequence numbers) Server에서 해당 포트는 LISTEN 상태에서 SYN 데이터를 받고 SYN_RCV로 상태가 변경된다.그리고 요청을 정상적으로 받았다는 대답(ACK)와 Client도 포트를 열어달라는 SYN 을 같이 보낸다.(ACK &#x3D; acknowledgment) Client에서는 SYN+ACK 를 받고 ESTABLISHED로 상태를 변경하고 서버에 요청을 잘 받았다는 ACK 를 전송한다.ACK를 받은 서버는 상태가 ESTABLSHED로 변경된다. 위와 같이 3번의 통신이 정상적으로 이루어지면, 서로의 포트가 ESTABLISHED 되면서 연결이 되게 된다. Status Closed : 닫힌 상태 LISTEN : 포트가 열린 상태로 연결 요청 대기 중 SYN_RCV : SYNC 요청을 받고 상대방의 응답을 기다리는 중 ESTABLISHED : 포트 연결 상태 현재의 포트 상태 확인은 netstat 명령어로 할 수 있다. 참고링크 http://hyeonstorage.tistory.com/286 http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. Network","slug":"01-Web/02-Network","permalink":"http://feel5ny.github.io/categories/01-Web/02-Network/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"},{"name":"network","slug":"network","permalink":"http://feel5ny.github.io/tags/network/"}]},{"title":"8/ DOM 확장","slug":"JS_08_4","date":"2017-12-28T12:20:19.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2017/12/28/JS_08_4/","permalink":"http://feel5ny.github.io/2017/12/28/JS_08_4/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차 선택자 API querySelector() 메서드 querySelectorAll() 메서드 matchesSelector() 메서드 요소 간 이동 HTML5 클래스 관련 추가사항- getElementsByClassName() 메서드- classList 프로퍼티 포커스 관리 HTMLDocument의 변화- readyState 프로퍼티- 호환성 모드 문자셋 프로퍼티 커스텀 데이터 속성 마크업 삽입- innerHTML- outerHTML- insertAdjacentHTML() 메서드- 메모리와 성능 문제 scrollIntoView() 메서드 전용 확장 문서모드 children 프로퍼티 contains() 메서드 마크업 삽입- innerText 프로퍼티- outerText 프로퍼티 스크롤 DOM은 그 자체로도 매우 잘 정의된 API이긴 하지만, 특정 브라우저 전용 방법으로 확장하여 기능을 추가할 때도 많다. 1. 선택자 API 자바스크립트 라이브러리 중에 가장 인기 있는 기능은 CSS 선택자로 패턴을 만들고 그에 맞는 DOM 요소를 선택하는 능력이다. 선택자 API는 CSS 쿼리에 대한 브라우저의 네이티브 지원으로 W3C에서 명세화를 시작햇다. 이 기능을 구현한 자바스크립트 라이브러리들은 모두 기초적인 CSS 파서를 직접 만들고, 기존의 DOM 메서드를 이용해 문서 노드를 이동하며 패턴에 일치하는 노드를 골라내는 방식을 사용했다. querySelector() querySelectorAll() Document 타입과 Element타입에서 사용가능하다. 1-1. querySelector() 메서드 매개변수로 CSS 쿼리를 받는다. 패턴에 일치하는 첫번째 자손 요소를 반환한다. 없으면 null 1234567891011// body 요소를 가져온다.const body = document.querySelector(&quot;body&quot;);// ID가 &quot;myDiv&quot;인 요소를 가져온다.const myDiv = document.querySelector(&quot;#myDiv&quot;);// 클래스가 &quot;selected&quot;인 요소 중 첫 번째를 가져온다.const selected = document.querySelector(&quot;.selected&quot;);// 클래스가 &quot;button&quot;인 이미지 중 첫 번째를 가져온다.const img = document.querySelector(&quot;img.button&quot;); 1-2. querySelectorAll() 메서드 querySelector()와 유사한데, 일치하는 노드 전체를 반환한다. 즉, HTMLCollection(live)이 아닌 NodeList(non-live), 정적 인스턴스를 반환한다. (유사배열 형태) 매개변수에는 여러 CSS 쿼리를 넣어도 된다. &quot;h1, h2, h3&quot; 1-3. matchesSelector() 메서드 ( matches()로 변경됨 ) + 선택자 API 레벨2 명세 매개변수로 CSS 선택자를 받고 요소가 그에 일치하면 true, 일치하지 않으면 false 2. 요소 간 이동 버전 9 미만의 IE는 타 브라우저와 달리 요소 사이의 공백을 텍스트 노드로 반환하지 않는다. 이 때문에 childNodes나 firstChild 같은 프로퍼티를 사용할 때 차이가 발생한다. DOM 명세를 유지하면서 브라우저 사이의 차이를 극복하려는 노력으로 요소간 이동 명세에서는 새 프로퍼티 그룹을 정의햇다. 요소간 이동 API에서 추가된 새 프로퍼티들 childElementCount : 자식 요소 숫자를 반환하되 텍스트 노드와 주석은 제외한다. firstElementChild : 첫번째 자식 요소를 가리킨다. lastElementChild : 마지막 자식 요소를 가리킨다. previousElementSibling : 이전 형제 요소를 가리킨다. nextElementSibling : 다음 형제 요소를 가리킨다. 3. HTML5 이전의 HTML 명세는 자바스크립트 인터페이스에 대해서는 간단히만 설명하고 마크업 언어에만 집중했으며 자바스크립트와의 연결은 DOM으로 미뤘다. HTML5 명세는 마크업 언어와 함께 사용하도록 디자인된 자바스크립트 API를 상세히 설명하고 정의한다. 3-1. 클래스 관련 추가사항getElementsByClassName() 메서드 클래스 이름 문자열을 매개변수로 받는다. 반환값 : HTMLCollection (live) 호출한 요소의 자손만 쿼리하여 반환한다. 반환값이 살아있는 객체라서 생기는 이슈12345678// HTMLCollection을 반환한다.var elems = document.getElementsByClassName(&#x27;red&#x27;);for (var i = 0; i &lt; elems.length; i++) &#123; // 클래스 어트리뷰트의 값을 변경한다. elems[i].className = &#x27;white&#x27;;&#125;// white red white HTMLCollection은 실시간으로 Node의 상태 변경을 반영한다. (live HTMLCollection)실시간으로 Node의 상태 변경을 반영하기 때문에 loop가 필요한 경우 주의가 필요하다.아래와 같은 방법으로 회피할 수 있다. 방법1 &gt; 역방향으로 돌리기 1234var elems = document.getElementsByClassName(&#x27;red&#x27;);for (var i = elems.length - 1; i &gt;= 0; i--) &#123; elems[i].className = &#x27;white&#x27;;&#125; 방법2 &gt; none-live NodeList를 반환하는 querySelectorAll을 사용한다. 12345// querySelectorAll는 Nodelist(non-live)를 반환한다. IE8+var elems = document.querySelectorAll(&#x27;.red&#x27;);for (var i = 0; i &lt; elems.length; i++) &#123; elems[i].className = &#x27;white&#x27;;&#125; classList 프로퍼티 클래스 이름을 조작할 때는 className 프로퍼티를 이용해 클래스 이름을 추가하거나 제거, 교체했다. 한 요소에 클래스가 3가지가 적용되어 있을 경우 이름 변경에 불편함이 있다. classList 프로퍼티는 DOMTokenList란 새 컬렉션 타입의 인스턴스이다. 다른 DOM 컬렉션과 마찬가지로 length존재 item() 메서드나 대괄호 표기법을 통해 데이터를 갖고올 수 있다. 크롬과 파폭3.6이상 가능 DOMTokenList의 메서드 add(value) : 주어진 문자열 값을 목록에 추가한다. contains(value) : 주어진 값이 목록에 존재하면 true, 그렇지 않으면 false remove(value) : 주어진 문자열 값을 목록에서 제거 toggle(value) : 값이 목록에 존재하면 제거하고 그렇지 않으면 추가 3-2. 포커스 관리 어느 요소에 포커스가 있는지, 현재 문서에 포커스가 있는지 판단하는 능력은 웹 접근성에 대단히 중요. document.activeElement 항상 현재 포커스를 가진 DOM 요소를 가리키는 포인터를 포함한다. 키보드 탭 키를 통한 포커스, focus() 메서드로 자동 포커스를 받는다. document.hasFocus() 문서에 포커스가 있는지 나타내는 불리언 값을 반환한다. 3-3. HTMLDocument의 변화readyState 프로퍼티 readyState 프로퍼티에 가능한 값은 2가지 이다. loading complete 문서를 불러왔는지 확인하는 것 보통은 onload 이벤트 핸들러를 사용했다. &lt;head&gt; 프로퍼티 document.head로도 &lt;head&gt;요소 참조가 가능하다. 크롬과 사파리 5 가능 3-4. 문자셋 프로퍼티 문서의 문자셋을 다루는 프로퍼티 document.charset 문서의 문자셋을 나타내며, 새 문자셋 지정도 가능 파폭, 사파리, 오페라, 크롬 document.defaultCharset 브라우저 및 시스템의 기본 설정에 따라 문서에 기본적으로 적용해야 할 문자셋을 나타낸다. IE, 사파리, 크롬 3-5. 커스텀 데이터 속성 data- HTML5 요소에서는 요소의 렌더링에 필요한 정보나 시맨틱 값이 아닌 데이터를 접두사 **data-**가 붙은 비표준 속성에 제공하도록 한다. data- 뒤에는 자유롭게 네이밍 요소의 dataset프로퍼티를 통해 접근할 수 있다. 이름-값 쌍으로 이루어진 DOMStringMap 인스턴스이다. 커스텀 데이터 속성은 요소에 데이터를 연결해야 하지만 사용자에게는 보이고 싶지 않을 때 유용하다. 이 테크닉은 링크 추적, 매시업에서 페이지 각 부분의 식별자로 흔히 쓰인다. 3-6. 마크업 삽입마크업이 포함된 콘텐츠를 추가하는 것은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. innerHTML 읽기모드 : 요소와 주석, 텍스트 노드 등의 자식 노드를 모두 나타내는 HTML 표현을 반환한다. innerHTML이 어떤 텍스트를 반활할지는 브라우저마다 다르다. 쓰기모드 : 주어진 값을 바탕으로 새 DOM 서브트리를 만들어서 요소의 잣기 노드를 완전히 교체한다. 주어진 문자열을 DOM 서브트리로 파싱해 이미 존재하는 자식 노드를 모두 교체한다. 모든 요소가 innerHTML을 지원하지 않는다. col, colgroup, framset, head, html, style, table, tbody, thead, tfoot, tr, title도 지원하지 않는다. outerHTML 읽기모드 : 호출한 HTML 요소를 자식 노드와 함께 반환 쓰기모드 : 주어진 HTML 문자열을 파싱하여 DOM 서브트리를 생성하고 호출한 노드 전체를 교환하다. 나머지 특징은 innerHTML과 동일 insertAdjacentHTML() 메서드 삽입할 위치와 HTML 텍스트 두 가지를 매개변수로 받는다. 삽입할 위치 매개변수 beforebegin : 호출한 요소 바로 앞에 삽입 afterbegin : 호출한 요소 첫번째 자식 요소 바로 앞에 삽입 beforeend : 호출한 요소 마지막 자식 요소 바로 다음에 삽입 afterend : 호출한 요소 바로 다음에 삽입 메모리와 성능 문제 위의 메서드들로 자식 노드를 교체하면 메모리에 문제가 생길 수 있는데 IE가 특히 심하다.문제가 발생하는 지점 제거한 서브트리 요소에 이벤트 핸들러나 기타 자바스크립트 객체가 할당되어 있을 때 위의 상태에서 해당 핸들러나 프로퍼티를 사용하여 요소를 문서트리에서 제거한다면, 요소와 이벤트 핸들러 사이의 연결이 메모리에 남는다. 이른 작업이 계속되면 메모리 사용량이 점점 늘어난다. innerHTML, insertAdjacentHTML() 사용할 때는 제거할 요소의 이벤트 핸들러나 자바스크립트 객체 프로퍼티를 모두 제거하길 권한다. 3-7. scrollIntoView() 메서드모든 HTML요소에 존재하며 브라우저 창이나 컨테이너 요소를 스크롤해서 해당 요소가 뷰포트에 보이게 한다. 매개변수로 true나 생략하면 창 전체를 스크롤하여 요소 상단과 뷰포트 상단을 맞춘다. 4. 전용 확장 문서모드 children 프로퍼티 contains() 메서드 마크업 삽입- innerText 프로퍼티- outerText 프로퍼티 스크롤 참고링크 http://poiemaweb.com/js-dom 생소했던 단어","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"8/ DOM(1) - 노드의 계층 구조(2)","slug":"JS_08_2","date":"2017-12-27T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2017/12/27/JS_08_2/","permalink":"http://feel5ny.github.io/2017/12/27/JS_08_2/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차 Node 타입 Document 타입 Element 타입 Text 타입 텍스트 노드 생성 텍스트 노드 통일 텍스트 노드 분할 Comment 타입 CDATASection 타입 DocumentType 타입 DocumentFragment 타입 Attr 타입 4. Text 타입 이 노드에는 평범한 텍스트가 포함되고 글자 그대로 사용된다. 이스케이프된 HTML 문자는 포함할 수 있지만 HTML 코드는 포함할 수 없다. Text 노드의 특징 nodeType은 3 nodeType은 “#text” parentNode는 Element 자식 노드를 가질 수 없다. Text 노드에 포함된 텍스트는 nodeValue 프로퍼티나 data 프로퍼티로 가져올 수 있다. 둘중에 하나를 바꾸면 노드에 반영된다. 공백도 length값에 포함된다. 텍스트 노드의 값을 바꿀때 알아둬야 할 점은 문자열이 문서 타입에 따라 HTML 또는 XML에 맞게 인코드 된다. 텍스트를 조작하는 메서드 appendData(text) : 노드 마지막에 text 추가. deleteData(offset, count) : offset부터 count만큼 삭제 insertData(offset, count, text) : offset 위치에 text 삽입 replaceData(offset, count, text) : offset부터 (offset + count) 까지의 텍스트를 text로 교체 splitText(offset) : offset 위치를 기준으로 텍스트 노드를 둘로 나눈다. substringData(offset, count) : offset위치부터 (offset + count)까지의 텍스트를 꺼낸다. 텍스트 노드 생성 document.createTextNode() 매개변수로 삽입할 텍스트를 받는다. 새 텍스트 노드를 생성하면 ownerDocument 프로퍼티가 설정되지만 문서 트리에 삽입하기 전에는 브라우저 창에 표시되지 않는다. 일반적으로 요소는 단 하나의 자식 텍스트 토드만 가진다. 여러 개를 가질 때도 있다. 이때 normalize()를 사용하면 두 가지 텍스트가 공백없이 합쳐진다. 1234567const element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;const textNode = document.createTextNode(&quot;Hello world!&quot;)element.appendChild(textNode);document.body.appendChild(element); 텍스트 노드 통일 normalize()텍스트 노드 분할 splitText() 5. Comment 타입 6. CDATASection 타입 7. DocumentType 타입 8. DocumentFragment 타입 9. Attr 타입 참고링크 http://meetup.toast.com/posts/89 생소했던 단어 MIME타입 Gecko","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"8/ DOM(1) - 노드의 계층 구조(1)","slug":"JS_08_1","date":"2017-12-26T12:20:19.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2017/12/26/JS_08_1/","permalink":"http://feel5ny.github.io/2017/12/26/JS_08_1/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요.넘나 많은 프로퍼티와 메서드들 @_@ 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM(문서 객체 모델: Document Object Model)을 생성한다. 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하기 위해서는 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다. 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다. 즉 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다. 이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다. 이러한 웹 문서의 동적 변경을 위해 DOM은 프로그래밍 언어가 자신에 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 JavaScript 객체로 제공된다. 이를 DOM API(Application Programming Interface)라고 부른다. 달리 말하면 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법은 메모리 상에 존재하는 DOM을 변경하는 것이고, 이때 필요한 것이 DOM에 접근하고 변경하는 프로퍼티와 메소드의 집합인 DOM API이다. DOM은 HTML, JavaScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이며 플랫폼&#x2F;프로그래밍 언어 중립적이다. DOM은 다음 두 가지 기능을 담당한다. 목차 Node 타입 nodeName, nodeValue 요소의 경우 nodeName은 태그명, nodeValue는 null 노드 사이의 관계 ChildNodes &#x2F; ParentNodes &#x2F; firstChild &#x2F; lastChild &#x2F; hasChildNodes(), ownerDocument 프로퍼티 노드 조작 appendChild() &#x2F; insertBefore() &#x2F; replaceChild() &#x2F; removeChild() 기타 메서드 cloneNode() &#x2F; nomalize() Document 타입 Document 자식 노드 documentElement(&#x3D;&lt;html&gt;) 문서 정보 document.title &#x2F; document.URL &#x2F; document.domain &#x2F; document.referrer 요소 위치 getElementById() &#x2F; getElementByTagName() (namedItem) &#x2F; getElementByName() 특별한 컬렉션 document.anchors &#x2F; document.applets &#x2F; document.forms &#x2F; document.images &#x2F; document.links DOM 준수 탐지 hasFeature() 문서에 쓰기 write() &#x2F; writeIn() &#x2F; open() &#x2F; close() Element 타입 HTML 요소 id &#x2F; title &#x2F; lang &#x2F; dir &#x2F; className 속성 얻기 getAttribute() 속성 설정 setAttribute() 속성 제거 removeAttribute() attributes 프로퍼티 getNamedItem() &#x2F; removeNamedItem(name) &#x2F; setNamedItem(), item() 요소 생성 createElement() 요소의 자식—- 2편 &#128071; Text 타입 Comment 타입 CDATASection 타입 DocumentType 타입 DocumentFragment 타입 Attr 타입 노드의 계층 구조 문서 객체 모델 DOM은 HTML과 XML 문서에 대한 애플리케이션 프로그래밍 인터페이스이다. (api) DOM은 문서를 노드의 계층 구조 트리로 표현한다. 개발자는 이를 통해 페이지 각 부분을 추가, 제거, 수정한다. 자바스크립트를 통해 HTML에 접근이 가능한 이유는 html이 document object model에 따라 기술되고 이 dom 인터페이스를 통해 기술된 html element가 객체로써 자바스크립트와 연결되기 때문에 접근이 가능한 것이다. 노드 타입에는 여러 가지가 있으며 각 타입은 문서에서 서로 다른 정보나 마크업을 표현한다. 노드 타입은 서로 다른 특징, 데이터, 메서드를 가지며 각 노드는 다른 노드와 관계가 있을 수 있다. 특정 노드에 뿌리를 둔 트리 구조로 표현된다. 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Pate&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; - 여기서 문서(Document) 노드가 루트이다. - 문서 요소 : 문서 노드의 자식. 여기서는 `` - 문서 하나에 문서 요소 하나만 있을 수 있다. - HTML페이지에서 문서요소는 항상 `` 요소이다. - 각 마크업은 트리에서 노드로 표현된다. - 총 12가지 노드 타입이 있으며 모든 노드틑 `기반 타입`(base type)을 상속한다. 1. Node 타입 DOM 레벨 1에는 Node라는 인터페이스가 있다. DOM에 존재하는 노드 타입은 모두 이 인터페이스를 구현한다. 모든 브라우저에서는 Node 타입에 접근할 수 있다. 자바스크립트 노드 타입은 모두 Node를 상속하므로 모든 노드 타입에서 같은 기본 프로퍼티와 메서드를 고융한다. 모든 노드에는 타입을 나타내는 nodeType 프로퍼티가 있다. 123456789101112Node.ELEMENT_NODE (1)Node.ATTRIBUTE_NODE (2)Node.TEXT_NODE (3)Node.CDATA_SECTION_NODE (4)Node.ENTITY_REFERENCE_NODE (5)Node.ENTITY_NODE (6)Node.PROCESSING_INSTRUCTION_NODE (7)Node.COMMENT_NODE (8)Node.DOCUMENT_NODE (9)Node.DOCUMENT_TYPE_NODE (10)Node.DOCUMENT_FRAGMENT_NODE (11)Node.NOTATION_NODE (12) 1234567if (someNode.nodeType == Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element.&quot;)&#125; // IE에서는 오류if (someNode.nodeType == 1)&#123; alert(&quot;Node is an element.&quot;)&#125; // 모든 브라우저에서 동작 1-1. nodeName, nodeValue nodeName과 nodeValue는 해당 노드의 정보를 제공한다. 요소(element)의 nodeName은 요소의 태그명과 일치하고, nodeValue는 null이다. 텍스트 노드일 경우 nodeValue는 문자열이다. 1-2. 노드 사이의 관계1-2-1. ChildNodes 프로퍼티NodeList가 저장된다. 유사배열 객체 노드를 순서 있는 목록으로 저장하여 위치 기반으로 접근 가능. length 프로퍼티 : 호출 당시 노드리스트에 담긴 노드 숫자임을 기억하자. Array의 인스턴스는 아니다. DOM 구조의 쿼리 결과 계속 바뀌므로 살아있는 객체라고도 부른다. childNodes는 모든 자식요소 찾기 children은 모든 자식요소 찾기이지만 요소노드만 찾는다. 노드 리스트에 저장된 노드를 접근하는 방법 (어느쪽을 더 권잔하진 않는다.) 대괄호 표기법 item() 메서드123const firstChild = someNode.childNodes[0];const secondChild = someNode.childNodes.item(1);const count = someNode.childNodes.length; 1-2-2. parentNode 프로퍼티 childNodes 목록에 포함된 노드는 모두 부모가 같으므로 각각의 parentNode 프로퍼티는 같은 노드를 가리킨다. childeNOdes 목록의 각 노드들은 형제관계이며 previousSibling 및 nextSibling 프로퍼티로 이동할 수 있다. 자식 노드가 하나 뿐이라면 해당 노드의 nextSibling과 previousSibling은 모두 null이다. 1-2-3. firstChild 프로퍼티childNodes 목록에서 첫번째 노드를 가리킨다.someNode.firstChild &#x3D; someNode.childNodes[0] 1-2-4. lastChild 프로퍼티childNodes 목록에서 마지막 노드를 가리킨다.someNode.lastChild &#x3D; someNode.childNodes[someNode.childNodes.length-1] 1-2-5. hasChildNodes() 메서드노드에 자식 노드가 있으면 true를 반환.length로 자식 노드 확인하는 것보다 효과적. 1-2-6. ownerDocument 프로퍼티전체 문서를 표현하는 문서 노드에 대한 포인터노드 계층 구조를 따라 위로 거슬러 올라갈 필요 없이 문서 노드에 빠르게 접근 가능하다. 1-3. 노드 조작 노드 사이의 관계 포인터는 모두 읽기 전용 아래 4가지 메서드는 자식에서만 동작하므로 부모 노드를 정확히 알아야한다. 1-3-1. appendChild() childNodes 목록 마지막에 노드를 추가한다. 새로 추가한 노드, 부모 노드, childNodes 목록에 포함된 이전의 마지막 자식 노드에서 모든 관계 포인터가 업데이트 된다. 이미 문서에 존재하고 있는 노드를 추가한다면, 해당 노드는 이전 위치에서 추가된 위치로 옮겨진다. 1-3-2. insertBefore(삽입할 노드, 기준 노드) 삽입할 노드와 기준 노드 2가지를 매개변수로 받는다. 삽입한 노드는 기준 노드의 이전형제가 되며, 이동이 끝나면 메서드는 삽입한 노드를 반환한다. 1-3-3. replaceChild(삽입할 노드, 교체할 노드) 기존 노드를 교체한다. 교체할 노드(B)에 있던 자리에 삽입할 노드(A)가 들어간다. B의 관계 표인터는 모두 A에 복사한다. B는 같은 문서 소유이긴 하지만 문서에서 위치를 지정받지 못한 채 붕 떠 있는 상태이다. 1-3-4. removeChild() 제거할 노드 하나만 매개변수로 받는다. 제거된 노드는 아직 해당 문서 소유이긴 하지만 문서에서 위치를 지정받지는 못했다. 1-4. 기타 메서드1-4-1. cloneNode(boolean) 자신을 호출한 노드의 복제본을 생성한다. 매개변수로는 자손 노드까지 복제할지 나타내는 불리언이다. true : 자손 노드 전체를 복제 false : 해당 노드 하나만 복제 복제된 노드를 반환하는데, 이는 여전히 문서 소유이지만 부모 노드가 할당되지 않는다. 고아노드라고 한다. appendChild()나 insertBefore(), replaceChild()를 통해 문서에 추가하기 전에는 트리 안에 존재하지 않는다. 12345&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt; 12345const deepList = myList.cloneNode(true) // myList에 ul요소에 대한 참조를 저장했다고 가정console.log(deepList.childNodes.length) // 3 or 7(공백포함)const shallowList = myList.cloneNode(false);console.log(shallowList.childNodes.length) //0 1-4-2. nomalize() 문서 서브트리에 존재하는 텍스트 노드를 다루는 것 뿐. 파서의 구현 방식이나 DOM 조작 결과로 텍스트 없는 텍스트 노드가 생기거나 텍스트 노드끼리 형제 노드가 될 가능성이 있다. nomalize를 호출하면 노드의 자손에서 이 두가지 상황이 생기지 않았는지 검색한다. 빈 텍스트 노드를 찾으면 제거하고 텍스트 노드끼리 형제인 경우를 발견하면 두 노드를 하나로 합친다. 2. Document 타입 자바스크립트는 문서 노드를 Document 타입으로 표현한다. 브라우저에서 전체 HTML 페이지를 표현하는 문서 객체는 HTMLDocument의 인스턴스 HTMLDocument는 Document를 상속한다. document 객체는 window의 프로퍼티이므로 전역에서 접근할 수 있다. window.document Document 타입은 HTML 페이지 또는 XML 기반 문서를 표현한다. document 객체를 통해 페이지에 대한 정보를 얻고 구조 및 외관을 조작한다. Document 노드의 특징 nodeType은 9 nodeName은 “#document” nodeValue는 null parentNode는 null ownerDocument는 null 자식 노드로 DocumentType(최대 1개) Element(최대 1개), Processing Instruction, Comment를 가질 수 있다. 2-1. Document 자식 노드Document 자식으로 DocumentType Element ProcessingInstruction Comment 2-1-1. documentElement 프로퍼티 HTML페이지의 &lt;html&gt;요소를 가리킨다. childNodes의 document 요소보다 documentElement프로퍼티가 해당 요소에 더 빨리, 더 직접적으로 접근한다.12const html = document.documentElement;console.log(html === document.childNodes[0] === document.firstChild) document 객체는 HTMLDocument의 인스턴스이므로 &lt;body&gt;요소를 직접적으로 가리키는 body 프로퍼티를 갖는다. document 객체 2-1-2. DocumentType&lt;!DOCTYPE&gt; 태그는 문서의 다른 부분과는 별도의 엔티티로 간주하며 포함된 정보는 다음과 같이 doctype 프로퍼티를 통해 접근할 수 있다. 1const doctype = document.doctype 2-2. 문서 정보 document 객체는 HTMLDocument의 인스턴스이므로 표준 Document 객체에는 존재하지 않는 프로퍼티를 여럿 가진다. 이들 프로퍼티는 현재 불러들인 웹 페이지에 대한 정보이다. 2-2-1. document.title &lt;title&gt; 요소 텍스트가 들어있다. 읽을 수도 있고 재설정도 가능하다. 2-2-2. 웹페이지 요청과 관련한 프로퍼티HTTP 헤더에 들어있다. URL : 페이지의 완전한 URL domain : 페이지의 도메인 이름, referrer : 이 페이지를 링크한 페이지의 URL. 없으면 빈 문자열 2-3. 요소 위치특정 요소나 요소 그룹에 대한 참조를 얻는 일을 자주한다.대표적인 2가지 메서드. getElementById(), getElementByTagName() 2-3-1. getElementById() 찾으려는 요소 ID를 매개변수로 받고 해다 요소를 찾아 반환하며 그런 ID의 요소가 존재하지 않으면 null반환. 소문자와 대문자를 구분해야한다. 같은 요소가 2개 이상 존재하면 첫 번째 요소를 반환한다. document.getElementBy~ : 단일 엘리먼트를 선택하는 메소드 document.getElementsBy~ : 다중 엘리먼트를 선택하는 메소드 배열형태로 받아진다. 2-3-2. getElementByTagName() 요소의 태그 이름을 매개변수로 받고 해당하는 요소가 담긴 NodeList를 반환한다. HTML 문서에서는 HTMLCollection 객체를 반환한다. - NodeList 객체와 마찬가지로 HTMLCollection 객체의 데이터 역시 대괄호기법과 item() 메서드로 접근 가능하다. - HTMLCollection의 `namedItem()` 메서드 - name 속성을 통해 컬렉션 데이터에 대한 참조를 얻는다. 1&lt;img src=&quot;myimage.jpg&quot; name=&quot;myImage&quot;&gt; 123const images = document.getElementByTagName(&quot;img&quot;)const myImage = images.namedItem(&quot;myImage&quot;)const myImage = images[&quot;myImage&quot;] HTMLCollection 객체에서는 대괄호 표기법에 숫자형 색인과 &#x3D;&gt; item()사용 문자형 색은을 모두 사용할 수 있다. &#x3D;&gt; namedItme() 사용 문서 전체는 아리테스크*를 사용한다.1const allElements = document.getElementByTagName(&quot;*&quot;) 2-3-4. getElementByName()name 속성 값이 주어진 문자열에 일치하는 요소를 반환한다. 라디오 버튼에 자주 사용한다. id 속성은 label요소와 연결하는 역할을 하며 name 속석은 값을 서버에 보낼 때 이중 단 하나만 보내는 역할을 한다. (체크된)1234567891011121314151617&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt; &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt; &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;white&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt; &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/fieldset&gt; 2-4. 특별한 컬렉션document객체에는 특별하 컬렉션이 몇가지 있다.각 컬렉션은 모두 HTML Collection 객체이고,문서에 공통된 요소들에 빠르게 접근할 수 있도록 만들어졌다. document.anchors : name속성이 있는 &lt;a&gt; 요소를 모두 갖고온다. (폐기)document.applets : &lt;applet&gt; 요소를 모두 갖고온다. document.forms : &lt;form&gt; 요소를 모두 가져온다. (document.getElementsByTagName(“form”)과 같다.) document.images : &lt;img&gt; 요소를 모두 갖고온다. document.links : href속성이 있는 &lt;a&gt;요소를 모두 가져온다. 2-5. DOM 준수 탐지hasFeature() 2-6. 문서에 쓰기write() : 넘겨 받은 텍스트를 그대로 추가하고writeIn() : 줄바꿈을 문자(\\n)를 문자열 마지막에 추가한다.open() : 페이지 스트림을 열고close() : 페이지 스트림을 닫습니다. 3. Element 타입Element 요소의 특징 nodeType은 1이다. nodeName은 요소의 태그 이름이다. nodeValue는 null이다. parentNode는 Document 또는 Element이다. 자식노드로 Element나 Text, Comment, ProcessingInstruction, CDATASection, EntityReference를 가질 수 있다. 3-1. HTML 요소HTMLElement 타입을 통해 표현된다.HTMLElement는 Element를 직접적으로 상속한다. id : 요소의 고유한 식별자title : 요소에 대한 추가 정보, 일반적으로 툴팁으로 표현됨lang : 요소 콘텐츠의 언어 코드. 거의 사용되지 않는다.dir : 언어의 표기 반향. ltr은 왼쪽 &#x3D;&gt; 오른쪽, rtl은 오른쪽 &#x3D;&gt; 왼쪽. 거의 사용되지 않는다.className : CSS 클래스인 class 속성을 나타낸다. class가 ECMAScript의 예약어이기 때문에 className이라고 사용한다. 1&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt; 3-2. 속성 얻기 (getAttribute())getAttribute(속성이름) : 공식 속성 이외에 커스텀 속성을 가져오는데도 쓸 수 있다.setAttribute(속성이름, 속성이름의 값)removeAttribute(속성이름) 속성이름은 대소문자를 구분하지 않는다. HTML5 명세에서는 커스텀 속성 앞에 전치사 data-를 붙여야 유효한 것으로 인정한다. getAttribute(“style”)은 객체를 반환, getAttribute(“onclick”)은 함수를 반환한다. 위의 속성과 차이점때문에 개발자들은 getAttribute()는 거의 사용하지 않고 객체 프로퍼티를 사용한다. getAttribute() 메서드는 주로 커스텀 속성의 값을 가져올 때 사용하다. 123456789101112131415161718var four = document.getElementById(&#x27;four&#x27;);// class 어트리뷰트가 존재하지 않으면if (!four.hasAttribute(&#x27;class&#x27;)) &#123; // four에 class 어트리뷰트를 추가하고 값으로 &#x27;white&#x27;를 설정 four.setAttribute(&#x27;class&#x27;, &#x27;white&#x27;);&#125; else &#123; // four에 class 어트리뷰트가 존재하면 four.className = &#x27;white&#x27;;&#125;// class 어트리뷰트의 값을 취득console.log(four.getAttribute(&#x27;class&#x27;)); // white// class 어트리뷰트를 제거four.removeAttribute(&#x27;class&#x27;);// class 어트리뷰트의 존재를 확인console.log(four.hasAttribute(&#x27;class&#x27;)); // false 3-3. 속성 설정 (setAttribute()) 속성 이름과 설정할 값 두가지를 매개변수로 받는다. 해당 속성이 존재하지 않으면 솏어을 새로 생성하고 값을 설정한다. 속성 이름은 소문자로 통일된다. 3-4. 속성 제거 (removeAttribute()) 속성의 값만 지우는 것이 아니라 요소에서 속성을 완전히 제거한다. 자주 쓰이지는 않는다. 3-5. attributes 프로퍼티 Element 타입은 DOM 노드 타입 중에서 attributes 프로퍼티를 갖는 유일한 타입이다. attributes 프로퍼티에는 NodeList처럼 살아있는 컬렉션 NamedNodeMap이 저장된다. 요소 속성은 모두 Attr 노드로 표현되며 각 Attr노드는 NamedNodeMap 객체에 저장된다. attributes 프로퍼티 안의 각 노드는 nodeName이 속성 이름 nodeValue는 속성 값 보통은 아래 메서드들 보다는 getAttribute(), removeAttribute(), setAttribute() 메서드가 더 많이 사용된다. NamedNodeMap 객체의 메서드들 getNamedItem(name) : nodeName 프로퍼티가 name인 노드를 반환한다. removeNamedItem(name) : nodeName 프로퍼티가 name인 노드를 목록에서 제거한다. setNamedItem(node) : node를 목록에 추가하고 nodeName 프로퍼티에 따라 색인한다. item(pos) : 인덱스가 pos인 노드를 반환한다. attributes 메서드들이 유용한 경우는 요소의 속성을 대상으로 루프가 필요할 때.각 속성의 이름과 값을 문자열에 추가한다. 1234567891011121314function outputAttributes(element) &#123; const pairs = new Array(), attrName, attrValue, i, len; for (i = 0, len = element.attributes.length.length; i &lt; len; i++) &#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; pairs.push(attrName + &quot;=\\&quot;&quot; + attrValue + &quot;\\&quot;&quot;); &#125; return pairs.join(&quot; &quot;);&#125; 3-6. 요소 생성 (document.createElement()) - createElement() 메서드는 새 요소를 생성하고 ownerDocument 프로퍼티를 설정한다. - 생성 이후에는 문서 트리의 일부가 아니므로 appendChild(), insertBefore(), replaceChild() 메서드를 통해 요소를 문서 트리에 추가해야한다. - IE7이전 버전에는 HTML을 통으로 인자로 넘길 수 있다. 3-7. 요소의 자식 요소는 자식 요소나 자손 요소를 가질 수 있고, 그 숫자는 제한이 없다.12345&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt;요소 자식 노드가 7개 생긴다. &lt;li&gt;는 3개, &lt;text&gt; 4개 (&lt;li&gt;와 텍스트 사이의 공백) 참고링크 http://poiemaweb.com/js-dom http://webclub.tistory.com/339 생소했던 단어 MIME타입 Gecko","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"7/ BOM (브라우저 객체 모델)","slug":"JS_07_2","date":"2017-12-25T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2017/12/25/JS_07_2/","permalink":"http://feel5ny.github.io/2017/12/25/JS_07_2/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차 window 객체—- 1편 &#128070; location 객체 2.1 쿼리스트링 확장 2.2 location 조작 navigator 객체 3.1 플러그인 감지 3.2 처리기 등록 screen 객체 history 객체 2. location 객체 BOM에서 가장 유용한 객체중 하나. 문서 정보와 함께 내비게이션 기능을 제공하다. location객체는 window의 프로퍼티인 동시에 document의 프로퍼티이다. window.location과 document.location은 같은 객체를 가리킨다. location은 현재 문서에 대한 정보를 갖고 있으며 URL을 파싱해서 몇 가지 조각으로 분리해 각각을 프로퍼티에 저장한다. location의 프로퍼티들을 살펴보자. hash (예: “#&#x2F;0&#x2F;1” http://slides.com/nayoung/deck-8#/0/1) #기호 다음에 문자가 오는 형태의 URL 해시. URL에 해시가 없다면 빈 문자열 host (예: “localhost:4000”) 서버 이름과 포트번호 (있다면) hostname (예: “localhost”) 포트 번호를 제외한 서버 이름 href (예: “http://localhost:4000/2017/12/28/JS_07/“) 현재 페이지의 완전한 URL location의 toString()메서드는 이 값을 반환 pathname (예: “&#x2F;2017&#x2F;12&#x2F;28&#x2F;JS_07&#x2F;“) URL에 포함된 디렉터리 및 파일 이름 port (예: “4000”) URL의 요청 포트(존재한다면)이다. URL에 포트가 없으면 이 프로퍼티는 빈 문자열 반환 protocol (예: “http:”) 페이지에서 사용하는 프로토콜. 일반적으로 “http:”나 “https:”중 하나이다. 프로토콜을 스키마라고 부르기도 한다. search (예: “?q&#x3D;window”) URL의 쿼리스트링 부분. 물음표 기호로 시작하는 문자열을 반환 2.1 쿼리스트링 확장URL 정보 중 쿼리스트링은 다루기 쉬운 형태로 제공되지 않는다.즉, 하나씩 분리해서 제공하지 않는다는 말.아래 함수를 이용하면 쿼리스트링을 파싱해서 각 매개변수를 프로퍼티로 갖는 객체를 반환한다. 1234567891011121314151617181920212223242526function getQueryStringArgs(teset)&#123; const qs = &#123;location.search.length &gt; 0 &gt; location.search.substring(1) : &quot;&quot;&#125;, // 쿼리스트링이 존재하면 물음표를 제외하고 qs에 할당한다. args = &#123;&#125;, items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null, name = null, value = null, // for 루프에서 사용할 변수 i = 0, len = items.length; // 각각 매개변수를 args 객체에 할당 for (i = 0; i &lt; len; i++)&#123; item = item[i].split(&quot;=&quot;); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 물음표 제거. args를 객체 리터럴 형식으로 생성 args의 객체에 split으로 분리된 배열의 첫번째 인자가 name, 두번째 인자가 value에 들어간다. 결과 12https://www.google.co.kr/search?newwindow=1&amp;tbm=isch&amp;q=그리드+다단&amp;cad=hargs = &#123;newwindow: &quot;1&quot;, tbm: &quot;isch&quot;, q: &quot;그리드+다단&quot;, cad: &quot;h&quot;&#125; * decodeURIComponentHTML에서 한글이 섞인 주소는 오작동할 수 있기 때문에 이스케이프 시켜야한다.예 : “나영” &#x3D;&gt; “%EB%82%98%EC%98%81”이를 인코딩이라고 하며, 반대로 다시 언어화를 시켜주는 디코딩이 있습니다.decodeURIComponent는 http:// 부터 모두 디코딩을 해줍니다. 2.2 location 조작 location.assign(“https://feel5ny.github.io/“) 메서드 해당 URL로 이동한다. location.href &#x3D; “” 현재 위치해있는 URL 뒤에 추가된다. location.hash &#x3D; “” #와 함께 인자가 URL 뒤에 추가된다. hash 프로퍼티를 바꿀 때는 새 URL로 페이지를 다시 읽지 않는다. location.search &#x3D; “q&#x3D;test” 현재 주소값에 search가 있는 경우, q= 뒤에 검색 단어를 추가한다. location.hostname &#x3D; “www.naver.com“ 현재 주소에서 앞부분 main 주소값이 바뀐다. location.pathname 첫번째 path가 바뀐다.123// https://developer.mozilla.org/ko/?q=naynlocation.pathname = &quot;en-Us&quot;// https://developer.mozilla.org/en-US/?q=nayn 위의 프로퍼티들은 브라우저 히스토리 스택에 쌓이기 때문에 뒤로가기 버튼이 적용된다.replace는 그렇지 않다. location.replace(“www.naver.com“) 히스토리 스택에 쌓이지 않는다. location.reload(true) 현재 페이지를 다시 불러온다. 매개변수 없이 호출하면 페이지를 가능한 한 가장 효과적인 방법으로 다시 읽는다.즉, 페이지가 바뀌지 않았다면 브라우저 캐시에서 읽어온다. 매개변수로 true를 넘기면 서버에서 읽어오도록 강제하게된다. reload() 호출 이후의 코드는 네트워크 지연이나 시스템 자원같은 요인에 따라 실행될 수도 있고 아닐 수도 있기 때문에 코드 마지막에 둔다. 3. navigator 객체클라이언트에서 브라우저를 구별하는 방법의 표준으로 쓰였다.navigator 객체의 프로퍼티는 일반적으로 웹 페이지를 실행 중인 브라우저 타입을 판단하는 데 사용한다.( *은 크롬 ) 프로퍼티&#x2F;메서드 설명 IE 파이어폭스 사파리&#x2F;크롬 오페라 *appCodeName 브라우저 이름이다. 모질라 브라우저가 아니어도 일반적으로 “Mozila” 3.0+ 1.0+ 1.0+ 7.0+ appMinorVersion 추가적인 버전 정보이다. 4.0+ - - 9.5+ *appName 완전한 브라우저 이름이다. 3.0+ 1.0+ 1.0+ 7.0+ *appVersion 브라우저 버전입니다. 일반적으로 브라우저 실제 버전과는 다르다. 3.0+ 1.0+ 1.0+ 7.0+ buildID 브라우저의 빌드 번호이다. - 2.0+ - - *cookieEnabled 쿠키가 활성화되어 있는지 나타낸다. 4.0+ 1.0+ 1.0+ 7.0+ cpuClass 클라이언트 컴퓨터의 CPU 타입이다. “x86”, “68K”, “Alpha”, “PPC”, “Ohter”가 있습니다. 4.0+ - - - *javaEnabled 브라우저에 자바가 활성화되어 있는지 나타낸다. 4.0+ 1.0+ 1.0+ 7.0+ *language 브라우저의 우선적 언어(한국어, 영어..)를 나타낸다. - 1.0+ 1.0+ 7.0+ *mimeTypes 브라우저에 등록된 마임 타입을 나열한 배열이다. 4.0+ 1.0+ 1.0+ 7.0+ onLine 브라우저가 인터넷에 연결되어 있는지 나타낸다. 4.0+ 1.0+ - 9.5+ opsProfile 브라우저가 인터넷에 연결되어 있는지 나타낸다. 4.0+ - - - oscpu 거의 사용하지 않으며 문서도 없다. - 1.0+ - - *platform 브라우저가 실행중인 운영체제와 CPU를 타나낸다. 4.0+ 1.0+ 1.0+ 7.0+ *plugins 브라우저에 설치된 플러그인을 나열한 배열이다. IE에서는 페이지의 요소를 나열한 배열이다. 4.0+ 1.0+ 1.0+ 7.0+ preference() 사용자 선호사항을 설정한다. 특권모드에서만 접근가능 - 1.5+ - - *product 브라우저 이름. 일반적으로 “Gecko”이다. - 1.0+ 1.0+ - *productSub 브라우저에 대한 추가정보. 일반적으로 게코 버전 정보. - 1.0+ 1.0+ - registerContentHandler() 웹사이트를 특정 마임 타입 처리기로 등록한다. - 2.0+ - - registerProtocolHandler() 웹사이트를 특정 프로토콜 처리기로 등록한다. - 2.0+ - - securityPolicy 보안 정책 이름이지만 폐기되었다. - 1.0+ - - systemLanguage 운영체제의 언어이다. 4.0+ - - - taintEnabled() 변수 테인트가 활성화 되어 잇는지 나타내지만 폐기된 기능. 4.0+ 1.0+ - 7.0+ *userAgent 브라우저 문자열이다. 3.0+ 1.0+ 1.0+ 7.0+ userLanguage 운영체제의 기본 언어이다. 4.0+ - - 7.0+ userProfile 사용자 프로필 정보에 접근할 때 사용하는 객체 4.0+ - - - *vendor 브라우저 제조사 이름이다. - 1.0+ 1.0+ - *vendorSub 제조사에 대한 추가 정보이다. - 1.0+ 1.0+ - 3.1 플러그인 감지현재 크롬의 plugins 1234567891011121314[ &#123; 0: MimeType, application/x-google-chrome-pdf: MimeType, name: &quot;Chrome PDF Plugin&quot;, // 플러그인 이름 filename: &quot;internal-pdf-viewer&quot;, // 플러그인의 파일 이름 description: &quot;Portable Document Format&quot;, // 플러그인 설명 length: 1 // 플러그인이 처리하는 마임 타입 숫자 &#125;, &#123;0: MimeType, application/pdf: MimeType, name: &quot;Chrome PDF Viewer&quot;, filename: &quot;mhjfbmdgcfjbbpaeojofohoefgiehjai&quot;, description: &quot;&quot;, length: 1&#125;, &#123;0: MimeType, 1: MimeType, application/x-nacl: MimeType, application/x-pnacl: MimeType, name: &quot;Native Client&quot;, filename: &quot;internal-nacl-plugin&quot;, description: &quot;&quot;, …&#125;, &#123;0: MimeType, 1: MimeType, application/x-shockwave-flash: MimeType, application/futuresplash: MimeType, name: &quot;Shockwave Flash&quot;, filename: &quot;PepperFlashPlayer.plugin&quot;, description: &quot;Shockwave Flash 28.0 r0&quot;, …&#125;, &#123;0: MimeType, application/x-ppapi-widevine-cdm: MimeType, name: &quot;Widevine Content Decryption Module&quot;, filename: &quot;widevinecdmadapter.plugin&quot;, description: &quot;Enables Widevine licenses for playback of HTML audio/video content. (version: 1.4.8.1030)&quot;, length: 1&#125;] 3.2 처리기 등록 4. screen 객체window의 프로퍼티이다.픽셀 너비와 높이 등 클라이언트 화면에 대한 정보가 들어있다. 개인적인 생각 : UI나 인터렉션부분에서 많이 적용될 듯 하다. (*은 크롬) 프로퍼티&#x2F;메서드 설명 IE 파이어폭스 사파리&#x2F;크롬 오페라 *availHeight 시스템 요소를 제외한 화면의 픽셀 높이이다. ○ ○ ○ ○ *availLeft 시스템 요소가 아닌 영역 중 왼쪽에서 첫 번째 픽셀이다. (읽기전용) ○ ○ *availTop 시스템 요소가 아닌 영역 중 위에서 첫 번째 픽셀이다. (읽기전용) ○ ○ *availWidth 시스템 요소를 제외한 화면의 픽셀 너비이다. (읽기전용) ○ ○ ○ ○ bufferDepth 시스템 요소를 제외한 화면의 픽셀 너비이다. (읽기전용) ○ *colorDepth 색깔 비트 숫자이며 대부분 32이다. (읽기전용) ○ ○ ○ ○ deviceXDPI 화면의 실제 가로 DPI이다. (읽기전용) ○ deviceYDPI 화면의 실제 세로 DPI이다. (읽기전용) ○ fontSmoothingEnabled 폰트를 부드럽게 처리하는 기술이 활성화되어있는지 나타낸다. (읽기전용) ○ *height 화면의 픽셀 높이이다. ○ ○ ○ ○ left 현재 화면의 왼쪽 모서리로부터의 픽셀 거리이다. ○ logicalXDPI 화면의 논리적 가로 DPI이다. (읽기전용) ○ logicalYDPI 화면의 논리적 세로 DPI이다. (읽기전용) ○ *pixelDepth 화면의 픽셀당 비트 숫자이다. (읽기전용) ○ ○ ○ top 현재 화면의 위쪽 모서리로부터의 픽셀 거리이다. ○ updateInterval 화면을 몇 밀리초마다 업데이트하는지 나타낸다. ○ *width 화면의 픽셀너비이다. ○ ○ ○ ○ 5. history 객체 window의 프로퍼티. 창을 첫 번째 연 이후 사용자의 내비게이션 히스토리를 보관한다. 브라우저 창, 탭, 프레임은 각각 자신의 window 객체에 속한 history객체를 가진다. 보안을 이유로 사용자가 방문했던 URL은 알 수 없다. > 알 수 없는 url 메서드1. go()history.go(-1) : 한페이지 뒤로history.go(1) : 한페이지 앞으로history.go(2) : 두페이지 앞으로 2. back()한페이지 뒤로 3. forward()한페이지 앞으로 프로퍼티length : history 스택에 기록이 얼마나 많이 있는지 나타낸다. 0일경우 사용자가 페이지를 처음 열었을 때인 것이다. 참고링크 http://meetup.toast.com/posts/89 생소했던 단어 MIME타입 Gecko","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"7/ BOM (브라우저 객체 모델)","slug":"JS_07_1","date":"2017-12-24T12:20:19.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2017/12/24/JS_07_1/","permalink":"http://feel5ny.github.io/2017/12/24/JS_07_1/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차 window 객체 1.1 전역 스코프 : window.전역변수명, window.전역함수명 1.2 창 사이의 관계와 프레임 1.3 창의 위치 : screenLeft, screenTop 1.4 창의 크기 : innerWidth, outerWidth 1.5 내비게이션과 열기 : window.open, window.close 1.6 인터벌과 타임아웃 : setInterval, setTimeout 1.7 시스템 대화상자 : alert, prompt, confirm, print, find—- 2편 &#128071; location 객체 navigator 객체 screen 객체 history 객체 1. window 객체BOM은 웹 페이지 콘텐츠와 무관하게 브라우저 기능을 노출하는 객체이다. 브라우저의 인스턴스 &#x3D;&gt; window 객체웹페이지에서 정의한 모든 객체, 변수, 함수에서는window가 Global 객체(&#x3D; 표준내장객체) 구실을 하고,window에 정의된 parseInt()등의 메서드를 이용한다. + global objects와 global object는 다르다.global objects는 표중내장객체, global object는 전역객체이다.(실행 컨택스트에서 GO) 1.1 전역 스코프전역에서 선언한 변수와 함수는 모두window 객체의 프로퍼티 및 메서드가 된다. 12345678const age = 29;const sayAge = () =&gt; &#123; alert(this.age); // 전역을 가리키는 this&#125;alert(window.age); // 29sayAge(); // 29window.sayAge(); // 29 전역변수와 window 프로퍼티로 직접 정의하는 것의 차이. 전역 변수는 delete연산자로 제거할 수 없고, window 프로퍼티는 가능하다. 1234567const age = 29;window.color = &quot;red&quot;;delete window.age; // 제거 안됨delete window.color; // 제거 됨alert(window.color) 선언하지 않았을 가능성이 있는 변수의 존재 여부는 window 객체를 통해 확인 가능 1.2 창 사이의 관계와 프레임페이지에 프레임이 들어 있으면 각 프레임은 독자적인 window객체를 가지며, frames 컬렉션에 저장된다. 1.3 창의 위치screenLeft : 디바이스 화면 왼쪽에서 브라우저 창까지 가로 거리screenTop : 디바이스 화면 위쪽에서 브라우저 창까지 세로 거리moveBy(가로이동 픽셀수, 세로이동 픽셀수) : (왼-&gt;오 &#x2F; 위-&gt; 아래)moveTo(x좌표, y좌표) moveBy moveTo 크롬, 오페라, IE7이상은 안됨 1.4 창의 크기크기측정 innerWidth : 브라우저 창 내부의 페이지 뷰포트 크기 (모바일도 가능) innerHeight : 브라우저 창 내부의 페이지 뷰포트 크기 (모바일도 가능) outerWidth : 브라우저 창의 크기 outerHeight : 브라우저 창의 크기 크기조절 (IE6이상 크롬 오페라에서는 금지) resizeTo(최종너비, 최종높이) resizeBy(너비 얼만큼 바꿀지, 높이 얼만큼 바꿀지) 1.5 내비게이션과 열기window.open() : URL로 이동한 후 브라우저 창을 새로 연다. 이동할 URL, 대상 창, 기능을 나타내는 string 마지막으로 새 페이지가 브라우저 히스토리에서 현재 페이지를 대체할지 나타내는 boolean12window.open(&quot;http://feel5ny.github.io&quot;, &quot;topFrame&quot;)// 두번째 인자는 a태그에서 target과 같다. 두번째 인자에는 _self,_parent,_top,_blank사용가능 팝업창 소셜 인증시 팝업창이 open되고, close될 때 사용된다. 12window.open(&quot;http://feel5ny.github.io&quot;, &quot;topFrame&quot;, &quot;height=400, width=400, top=10, left=10, resizable=yes&quot;) 옵션 값 설명 fullscreen “yes” or “no” 브라우저 창을 최대 크기로 생성할지 나타낸다. height 숫자 새 창의 높이이다. 최소값은 100 left 숫자 새 창의 x좌표이다. 음수는 쓸 수 없다. location “yes” or “no” 주소 표시줄을 표시할지 나타낸다. 기본 값은 브라우저에 따라 다르다. “no”로 지정하면 브라우저에 따라 주소 표시줄을 숨기거나 비활성화한다. menubar “yes” or “no” 메뉴 바를 표시할지 나타낸다. 기본값은 “no” resizable “yes” or “no” 새 창의 테두리를 드래그해서 크기를 조절할 수 있는지 나타냅니다. 기본값은 “no” scrollbars “yes” or “no” 새 창 콘텐츠가 뷰표트를 넘칠 때 스크롤을 허용할지 나타낸다. 기본값은 “no” status “yes” or “no” 상태 바를 표시할지 나타낸다. 기본 값은 브라우저에 따라 다르다. toolbar “yes” or “no” 툴바를 표시할지 나타낸다. 기본값은 “no” top 숫자 새 창의 y좌표. 음수는 쓸 수 없다. width 숫자 새 창의 너비. 최솟값은 100 window.open()메서드는 새로 생성한 창에 대한 참조를 반환한다.기본적으로 주요 브라우저 창의 위치나 크기를 스크립트에서 바꿀 수 없게 금지되지만, .open으로 생성한 창은 가능하다. (크롬은 CORS에 걸림)window.close()는 window.open()으로 생성된 창에서만 적용가능하다. 12345var wroxWin = window.open(&quot;http://feel5ny.github.io&quot;, &quot;topFrame&quot;, &quot;height=400, width=400, top=10, left=10, resizable=yes&quot;)wroxWin.resizeTo(500, 500);wroxWin.moveTo(100, 100); wroxWin은 opener프로퍼티를 갖고 있는데, window.open()을 호출한 창이나 프레임을 가리키는 포인터이다.그 역은 존재하지 않는다. 1234var wroxWin = window.open(&quot;http://feel5ny.github.io&quot;, &quot;topFrame&quot;, &quot;height=400, width=400, top=10, left=10, resizable=yes&quot;)alert(wroxWin.opener === window) // true 1.6 인터벌과 타임아웃window에는 코드가 특정 시간에 실행되게끔 해주는 메서드가 있다.setTimeout(실해코드, 시간(밀리초)) : 일정 시간 뒤에 코드를 실행setInterval() : 일정 시간마다 코드를 반복 실행 &#128336; setTimeout()자바스크립트는 큐를 이용해 각 코드의 실행을 관리한다. 큐? Task 큐와 이벤트 루프이다. Task 큐는 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이라 할 수 있고, 이벤트 루프는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 해 준다. clearTimeout(setTimeout이 할당된 변수이름. 혹은 id값) : 타임아웃을 취소할 때 사용한다. &#128171; setInterval()페이지가 종료되거나 인터벌을 취소하기 전에는 일정 시간마다 코드를 반복 실행한다. 123setInterval(function()&#123; alert(&#x27;test&#x27;)&#125;,1000) clearInterval() : 인터벌을 취소한다.인터벌을 취소하지 않으면 페이지가 떠 있는 동안은 계속 실행되므로 인터벌 취소는 timeout 취소보다 중요 1.7 시스템 대화상자alert() : Okconfirm() : Ok &#x2F; cancelprompt() : input &#x2F; Ok &#x2F; cancel 대화상자의 외관은 css가 아니라 운영체제&#x2F;브라우저 설정에 따라 다르다. 동기적이고 modal 성질이 있어서 대화상자가 떠 있을 때는 코드 실행이 중지된다. window.print() : 인쇄 대화상자 표시window.find(&#39;찾을 단어&#39;) : 찾기 대화상자 표시 참고링크 http://meetup.toast.com/posts/89","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"TCP / UDP","slug":"CS_04","date":"2017-12-21T09:23:55.000Z","updated":"2024-11-23T12:12:30.097Z","comments":true,"path":"2017/12/21/CS_04/","permalink":"http://feel5ny.github.io/2017/12/21/CS_04/","excerpt":"","text":"TCPTCP 소켓은 신뢰할 수 있는 프로토콜이다. 두 머신에서 데이터를 주고 받을 때, 파일에 쓰는 것처럼 한 쪽에서 쓰고 다른 쪽에서 읽을 수 있다.연결은 신뢰할 수 있고 순차적이다.즉, 한 쪽에서 보낸 데이터는 다른 쪽에서 안전하게 받을 수 있다.TCP 소켓도 데이터 스트림이다. 데이터를 잘라 패킷에 담아 네트워크로 보낸다. TCP가 단순할 수 있었던 기반에는 IP가 있다.IP에는 커넥션과 관련된 컨셉은 없다. 대신 패킷이 한 컴퓨터에서 다른 컴퓨터로 전달되는 것과 관련이 있다. 교실에서 손편지를 써서 건너건너 친구에게 전달하는 걸 떠올려보자.어떻게든 친구에게 편지가 도착하긴 하겠지만, 여러 사람을 거쳐 전달될 거다.편지가 친구에게 정확하게 도착할 거란 보장은 없다.단지, 잘 도착하기만 바라고 보낼 뿐이다.편지가 잘 도착했는지 알 수 있는 방법이 없다.물론, 실제론, 어떤 컴퓨터도 가장 빠르게 도달할 수 있는 방법을 알지 못하기 때문에 이보다 더 복잡하기도 하다.가끔은 패킷을 복사해 여러 경로로 보낼 수도 있다. 이에 따라 각각 도착시간이 달라질 수도 있다. UDP (user datagram protocol)다른 방법으로, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결하는 건 어떨까?이 때 UDP를 사용할 수 있다.UDP는 “user datagram protocol”의 약자인데, TCP와 같이 IP 기반 위에 구현되어 있다.하지만, 다른 것과 달리 간단한 작업을 하는 아주 얇은 레이어만 올려져 있다. UDP를 사용해서, 목적지의 IP(예: 112.140.20.10) 주소와 포트(예:52432)로 메시지를 보낼 수 있고,컴퓨터를 거쳐 거쳐 목적지까지 도달할 수도 있고, 아님 도착하지 않을 수도 있다. 받는 곳에서는 포트(52432)를 열어두고, 패킷이 올 때까지 기다린다.이 때, 어떤 컴퓨터에서 온 것이든 모두 받아들인다. (커넥션이 없다는 것을 기억한다)받는 쪽에서는 패킷이 도착했을 때 이게 어느 IP의 어느 포트에서 왔고 크기가 얼마나 되는지 알 수 있다.그리곤 패킷 데이터를 읽을 수 있다. UDP는 안정적이지 않은 프로토콜이다.일반적으로는 1~5% 정도의 데이터를 잃는 경우가 많고, 심지어는 전혀 받지 못할 수도 있다. 패킷이 전송된 순서 또한 보장되지 않는다. UDP는 IP에서 많은 일을 하지 않는다.데이터가 전송될 수도 안될 수도 있지만, **UDP가 보장해주는 건 데이터의 ‘양’**이다.한 쪽에서 256바이트를 보냈으면, 받는 쪽에서도 무조건 256바이트를 받는다.처음 100바이트를 받을 수는 없다. 정리 TCP 커넥션 기반 안정성과 순서를 보장한다 패킷을 자동으로 쪼개준다 적당한 속도로 보내준다. (회선이 처리할 수 있을 만큼) 파일을 쓰는 것처럼 사용하기 쉽다 UDP 커넥션 기반이 아니다. 직접 구현해야 한다 안정적이지 않고 순서도 보장되지 않는다. 데이터를 잃을 수도, 중복될 수도 있다. 데이터가 크다면, 보낼 때 직접 패킷 단위로 잘라야 한다. 회선이 처리할 수 있을만큼 나눠서 보내야 한다. 패킷을 잃었을 경우, 필요하다면 다양한 방법으로 이를 찾아내서 다시 보내야 한다. 참고링크1.http://ohgyun.com/431","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. Network","slug":"01-Web/02-Network","permalink":"http://feel5ny.github.io/categories/01-Web/02-Network/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"},{"name":"network","slug":"network","permalink":"http://feel5ny.github.io/tags/network/"}]},{"title":"네트워크 basic","slug":"CS_03","date":"2017-12-20T09:23:55.000Z","updated":"2024-11-23T12:12:30.102Z","comments":true,"path":"2017/12/20/CS_03/","permalink":"http://feel5ny.github.io/2017/12/20/CS_03/","excerpt":"","text":"수업 전 미리 알아보기 목차 네트워크란? 인터넷이란? OSI 7 Layer &amp; TCP&#x2F;IP Model Layer 네트워크란?두 대 이상의 컴퓨터 들을 연결하고 서로 통신(이야기) 할수 있는 것 네트워크의 종류 PAN (Personal Area Network) : 가장 작은 규모의 네트워크 LAN (Local Area Network) : 근거리 영역 네트워크 Man (Metropolitan Area Network) : 대도시 영역 네트워크 Wan (Wide Area Network) : 광대역 네트워크 (지역과 지역, 지방과 지방, 나라와 나라, 대륙과 대륙을 연결하는 네트워크) 1. LANLocal Area Network : 근거리 통신망LAN의 토폴로지에 따라 버스형, 링형, 스타형, 계층형, 메쉬형 등으로 구분할수 있다.*토폴로지란 (Topologies) : 네트워크를 구성하는 노드와 노드간에 연결 상태에 대한 배치를 의미한다. 1-1. Bus Topology (버스형)신뢰성과 확장성이 좋으며 모든 노드 들이 버스에 T 자형으로 연결 되어 상호 Point - to - Point 형태를 가지게 됩니다. 각 노드들의 연결은 어뎁터(Adapter)를 사용하며 양 끝 단에 Terminator를 두게 됩니다.각 노드의 고장은 전체 네트워크 부분에 영향을 미치는 점을 가지며 CSMA&#x2F;CD 방식을 주로 사용, 케이블 사용량이 적기 때문에 투자 비용이 적게 드는 편입니다. *CSMA&#x2F;CD 방식이란 호스트가 채널의 상태를 감지해 충돌을 피하는 매체접근방식 CSMA(Carrier Sense Multiple Access) 호스트가 전송하기 전에 매체의 전압을 점검하여 회선이 사용되지 않는 상태임을 확인하고 전송을 시작함 1-2. Ring Topology (링형)통신제어가 간단하고 신뢰성이 높으며 장거리 네트워크에서 사용 가능 합니다.링(Ring) 형태를 이루지만 노드간 통신은 Point - to - Point 를 가지며각 노드에서 신호 재생이 가능 하기 때문에 버스 형태와 달리 거리 제약이 적으며 잡음에도 강합니다. 1-3. Star Topology (스타형&#x2F;성형)중앙 제어 방식으로 모든 기기가 Point - to - Point 방식으로 연결 되어 있으며 문제 해결이 쉽고 하나의 기기의 고장은 전체에 영향을 미치지 않지만 중앙 제어 장비가 고장이 나면 모든 시스템에 영향을 미치게 됩니다. 케이블 사용량이 많으며 비용 또한 큰 편입니다. 1-4. Mash Topology (메쉬형)네트워크 상의 모든 컴퓨터들이 연결되어진 형태로써 연결 된 기기나 노드가 고장나더라도 다른 경로를 통해 통신이 가능하며 어떠한 경우에도 네트워크가 동작한다는 장점을 가지게 됩니다.하지만, 네트워크에 연결된 기기의 수가 많을 경우 모든 기기와 연결 해야 하기 때문에 케이블 사용량이 많으며 구조 또한 복잡하여 네트워크 관리가 힘들어 진다는 단점을 가지고 있습니다. 1-5. Fully Connected 2. 인터넷이란?International Network 의 합성어 로써 TCP&#x2F;IP ( Transmission Control Protocol &#x2F; Internet Protocol ) 을 기반으로 전세계의 네트워크를 하나로 연결 하여 각각 PC가 가지고 있는 자료나 정보를 주고 받을 수 있는 광역 네트워크를 인터넷 이라고 합니다. *다른 정의 LAN 과 LAN 을 연결 하는 WAN 이 서로 다른 WAN 들과 연결 되어 하나의 네트워크를 구성한 네크워크를 칭함. 전세계의 정보를 쉽게 얻을 수 있는 정보의 바다이며, 다양한 정보 자원을 자유로운 분산과 공유를 통해 상업적인 목적 목적이 아닌 무료로 사용 할수 있어야 한다. 모든 국가 들이 네트워크 통해 연결 되어 전세계를 하나의 공동체로 구성한 네트워크를 인터넷이라 한다. 2-1. Protocol사람과 사람이 통신할때 서로 이해할 수 있는 언어, 공용된 언어를 사용해 전세계 모든 사람과 대화 할수 있다라고 하면, 컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것인데 이 것이 바로 프로토콜(Protocol) 입니다.어떤 시스템이 다른 시스템과 통신을 원활하게 수용하도록 해주는 통신 규약, 약속 프로토콜의 기능으로써 세분화와 재합성 캡슐화 연결제어 오류제어 흐름제어 동기화 순서 결정 주소 설정 다중화 전송 서비스 순서 결정세분화와 재합성 프로토콜은 특성에 따라 여러가지 형태로 분류할수 있으며 각각 형태를 구분 지어 본다면 직접&#x2F;간접 프로토콜 단일체&#x2F;구조적 프로토콜 대칭&#x2F;비대칭 프로토콜 네트워크 용어에서 나오는 P 는 Protocol 의 약자가 대부분이며 대표적으로 인터넷을 할 때 사용되는 프로토콜은 TCP&#x2F;IP 가 있습니다.TCP&#x2F;IP 는 Transmission Control Protocol &#x2F; Internet Protocol 의 약자로써 컴퓨터와 컴퓨터가 통신 회선 등으로 연결 하기 위한 통신 규약입니다.그외 HTTP, ARP, ICMP, SNMP, SMTP, POP, FTP, TFTP, DHCP 등이 프로토콜의 종류입니다. 참고링크 http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1%ED%8E%B8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%ACNetwork-%EB%9E%80?category=702276 네트워크 쉽게 이해하기-전편 프로토콜 기능","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"02. Network","slug":"01-Web/02-Network","permalink":"http://feel5ny.github.io/categories/01-Web/02-Network/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"},{"name":"network","slug":"network","permalink":"http://feel5ny.github.io/tags/network/"}]},{"title":"Database basic","slug":"DB_01","date":"2017-12-19T09:23:55.000Z","updated":"2024-11-23T12:15:09.861Z","comments":true,"path":"2017/12/19/DB_01/","permalink":"http://feel5ny.github.io/2017/12/19/DB_01/","excerpt":"","text":"목차 RDBMS DDL, DML Aggregate, Group Function SQL ERD Table 생성 1. RDBMSRelational Database Management System F.커드씨가 도입한 관계형 모델을 기반으로 데이터베이스를 관리하는 방식이다. RDBMS의 종류로는 Oracle, Mysql 등이 널리 사용되고있다. Relational을 표현하기 위하여 ERD(Entity-Relationship Diagram)으로 테이블을 표현한다. 2. DDL, DMLDDL (Data Definition Language)Table 자체를 구성하는대 사용한다. 1. Create : db 스키마 객체를 생성123456CREATE TABLE book ( bookno NUMBER(5), /* 데이터타입을 설정해 주는 것이다. 숫자 5자리까지 */ title VARCHAR2(50), /* 문자열 50자까지 설정 */ author VARCHAR2(10), /* 문자열 10자리까지 설정 */ pubdate DATE /* 날짜 데이터타입 */) 2. Data Type VARCHAR2(size) : 가변길이 문자열 (최대 4000byte) CHAR(size) : 고정길이 문자열 (최대 2000byte) NUMBER(p,s) : 가변길이 숫자. 전체 p자리 중 소수점 이하 s자리 p : 38 s : -84 ~ 127 21 byte DATE : 고정길이 날짜 + 시간 (7byte) 3. Alter : 변경 테이블 칼럼 추가ALTER Table Student ADD (name VARCHAR(50)); 테이블 칼럼 수정ALTER Table Student MODIFY (name VARCHAR(50)); 테이블 칼럼 삭제ALTER Table Student DROP name; 4. Drop : db 스키마 제거 db가 날라갈 수 있는 위험한 명령어! DROP Table Student 5. Truncate: 스키마는 유지하면서 자료만 버림 TRUNCATE Table Student 6. Rename : 이름 변경 RENAME Student TO employee 7. Comment : 테이블에 설명 추가 8. Constraint : 테이블에 제약조건 생성Table의 특정규약을 설정한다 즉 제약조건이다. NOT NULL UNIQUE CHECK PRIMARY KEY &#x3D;&gt; PRIMARY KEY는 NOT NULL + UNIQUE하다. PK는 한테이블당 한개만 존재 인덱스 자동생성 여러 컬럼을 하나의 PK로 설정 가능12345CREATE TABLE book ( ssn1 NUMBER(6), ssn2 NUMBER(7), PRIMARY KEY (ssn1, ssn2)) FOREIGN KEY &#x3D;&gt; 주의 PRIMARY KEY에게만 FOREIGN KEY 가능 ON DELETE SET NULL : 해당하는 FK를 NULL로 바꾼다. ON DELETE CASCADE : 해당하는 FK를 가진 참조행도 삭제 DML (Data Manipulation Language)Insert, Delete, Select,Update Table 내부의 data를 바꿀때 사용한다. 1. Insert테이블 Data 추가INSERT INTO 테이블이름 (col1, col2) VALUES(“val1”, “val2”); 2. Delete테이블 Data 추가DELETE FROM 테이블이름 Where id = 1; 3. Update테이블 Data 추가UPDATE 테이블이름 SET 변경내용 Where id = 1; 3. Aggregate, Group FunctionAggregate Function1. AVG평균 구하기SELECT AVG(salary) FROM Student; Group BySELECT 부서명, AVG(salary) FROM 직장; =&gt; 오류 발생&#x3D;&gt; SELECT 부서명, AVG(salary) FROM 직장 GROUP BY 부서명 Having 2. SUM12SELECT SUM(col_name) FROM table_name;SELECT SUM(salary) FROM Student; COUNT MAX MIN 4. SQLSQL(Structured Query Language): 구조화된 질의 언어 가장 기본적인 문법 Select(Table의 원하는 col을 선택하다) From (어떠한 Table에서) Where (특정 조건) Student 테이블을 전부다 가져오고싶다.Select*From Student; =&gt; *는 전부를 나타낸다. Student 테이블중에서 name(col)을 가져오고싶다.Select name From Student; Student 테이블중에서 name(col)이 Joy 가져오고싶다.Select name From Student Where name=Joy; Join둘 이상의 테이블을 합쳐서 하나의 테이블로 만든다. Cross Join (Cartasian Product) 모든 가능한 쌍이 나타난다. Inner Join 조건을 만족하는 tuple만 나타난다.12SELECT name, jobname FROM Student Inner Join JobON Student.id = Job.student_id; Outer Join 조건을 만족하지 않는 tuple도 나타난다. &#x3D;&gt; null로 표기Left Outer Join &#x3D;&gt; join table의 왼쪽 table 값중 null인 것도 가져온다.Right Outer Join &#x3D;&gt; join table의 오른쪽 table 값중 null인 것도 가져온다.Full Outer Join &#x3D;&gt; 양쪽 table 값중 null인 것도 가져온다.12SELECT name, jobname FROM Student Left Outer Join Job ON Student.id = Job.student_id; 12SELECT name, jobname FROM Student Right Outer Join JobON Student.id = Job.student_id; 12SELECT name, jobname FROM Student Full Outer Join JobON Student.id = Job.student_id; Natural Join 조건을 만족하는 tuple들의 동일한 col이 합쳐져서 나타난다. Self Join 자기 자신과 Join 5. ERDEntity-Relationship DiagrammySql에서 자동으로 그려준다. auto increment","categories":[{"name":"02_!Web","slug":"02-Web","permalink":"http://feel5ny.github.io/categories/02-Web/"},{"name":"DB","slug":"02-Web/DB","permalink":"http://feel5ny.github.io/categories/02-Web/DB/"}],"tags":[{"name":"database","slug":"database","permalink":"http://feel5ny.github.io/tags/database/"}]},{"title":"소팅 알고리즘","slug":"CS_02","date":"2017-12-10T09:23:55.000Z","updated":"2024-11-23T12:10:59.665Z","comments":true,"path":"2017/12/10/CS_02/","permalink":"http://feel5ny.github.io/2017/12/10/CS_02/","excerpt":"","text":"아직 정리 덜 됨. 정렬할 데이터가 특수한 형태가 아니라면 standard 정렬 알고리즘을 쓰는것이 가장 좋지만, 정렬알고리즘에도 여러가지가 있고 각각의 정렬방법마다 빅오 노테이션이 다르다. 목차 버블 정렬 bubble sort 선택 정렬 Selection sort 삽입 정렬 Insertion sort 병합 정렬 Merge sort 퀵 정렬 Quick sort 1. 버블정렬(Bubble sort)버블정렬은 가장 쉬운 정렬 알고리즘이지만 시간복잡도가 좋은 퍼포먼스를 내지 못해서 실제로는 잘 사용되지 않는다.시간복잡도는 O(n²)이며 공간복잡도는 하나의 배열만 사용하여 정렬을 진행하기 때문에 O(n)이다.자신과 다음의 요소를 비교하여 인덱스를 정한다. 2. 선택정렬(Selection sort)선택정렬은 시간복잡도가 O(n²)으로 버블정렬과 정렬하는 알고리즘이 버블정렬과 유사하다.한번 순회를 하면서 가장 큰 수를 찾아서 배열의 마지막 위치와 교환한다. 3. 삽입정렬(Insertion Sort)삽입정렬은 1부터 n까지 Index를 설정하여 현재위치보다 아래쪽을 순회하며 현재위치의 값을 현재위치보다 아래쪽으로 순회하며 알맞은 위치에 넣어주는 정렬알고리즘이다.삽입정렬은 이미 정렬이 되어있다면 O(n)의 시간복잡도를 가지게된다. 정렬이 되어있는 경우라면 한번 순회하며 체크만 하기 때문이며 Big-O 시간복잡도는 O(n²)이다. 4.병합정렬 (Merge sort) 재귀의 이해가 있어야한다. 병합정렬은 정렬할 리스트를 반으로 쪼개나가며 좌측과 우측 리스트를 계속하여 분할해 나간 후 각 리스트내에서 정렬 후 병합(merge) 정렬 후 병합하는 과정을 통해 정렬하는 알고리즘이다.병합정렬은 가장 많이 쓰이는 정렬 알고리즘 중 하나 이며 시간복잡도는 최소 O(nlogn)을 보장하게 된다. Divide Conquer Combine 12345678910111213141516171819202122232425262728293031323334353637383940// 4. 합병정렬 // 퀵정렬과 마찬가지로 분할 정복 알고리즘중 하나이다./*console.log(MergeSort([234, 45634, 23, 41, 2345, 34, 23, 1, 4, 3, 6, 234, 4536, 55, 234, 23, 456, 45, 234, 1, 856, 9, 67, 56, 7]))*/function MergeSort(arr) &#123; const len = arr.length; if (len == 1) &#123; return arr; &#125; const middle = Math.floor(len / 2); const left = arr.slice(0, middle); const right = arr.slice(middle, len); function merge(left, right) &#123; const result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) &#123; result.push(left.shift()); &#125; while (right.length) &#123; result.push(right.shift()); &#125; return result; &#125; return merge(MergeSort(left), MergeSort(right));&#125; ### Divide & Conquer 전략 - 주어진 문제를 작은 문제들로 분할하고 - 작은 문제에서 해를 구한 후 - 구한 해를 이용해서 주어진 문제의 해를 구하는 방법 특징 주어진 문제를 동일한 종류의 작은 문제로 분할 문제 분할 과정이 **재귀적**으로 처리됨 Fractal같은 문제라고 생각하면 된다. 구성 Divide문제를 크기가 작은 동일한 종류의 sub problems로 분할 Conquer재귀적으로 subproblems 시간복잡도 구성요소 문제를 분할하는 시간 분할된 문제 수 * 분할된 문제의 시간 복잡도 분할된 문제의 결과를 combine하는 시간 sequence : 연속된 데이터의 집단 MERGE-SORT는 combine하는 함수이다. 배열 요소가 홀수일 경우 어떻게 반을 나눌까.?크게 고려하지 않아도 되지만, 타입캐스팅 방법처럼 계산 후 앞부분이 하나를 더 가져갈지를 판단한다. 타입캐스팅 타입을 바꿔주는. 5. 퀵정렬(Quick sort)퀵정렬은 real-world 데이터에서 빠르다고 알려져 있어 가장 많이 쓰는 정렬알고리즘이다.퀵정렬은 pivot을 선정하여 pivot을 기준으로 좌측과 우측으로 pivot보다 작은값은 왼쪽 pivot보다 큰값은 오른쪽으로 재배치를 하고 계속하여 분할하여 정렬하는 알고리즘이다.최악의 경우에는 O(n²)의 비교를 수행하지만 일반적으로 O(nlogn)의 시간복잡도를 가진다. 읽어볼 글 quick sort는 항상 빠를까? + quick sort에서 nlogn은 어떤 원리에서 나온 걸까? + 참고링크 https://medium.com/@fiv3star/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sorting-algorism-%EC%A0%95%EB%A6%AC-8ca307269dc7 http://asfirstalways.tistory.com/338","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Algorithm","slug":"01-Web/zz-Algorithm","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Algorithm/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"}]},{"title":"클린코드를 위한 리팩토링","slug":"Refactoring","date":"2017-12-09T11:12:34.000Z","updated":"2024-11-23T13:46:05.174Z","comments":true,"path":"2017/12/09/Refactoring/","permalink":"http://feel5ny.github.io/2017/12/09/Refactoring/","excerpt":"","text":"코드의 구린내 +구린게 있으면 그 부분을 바로 잡으세요.리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링 기법을 적용하는 방법만큼 중요하다. 1. 중복코드구린내의 제왕 중복코드.똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선한 클래스의 두 메서드 안에 같은 코드가 들어있는경우 -&gt; 메서드 추출 기법을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서 드를 두 곳에서 호출수퍼클래스의 두 하위 클래스에 같은 코드가 들어 있는 경우 -&gt; 메서드 추출 기법을 적용해서 중복을 없앤 후 메서드 상향 기법을 적용하면 된다.위 상황에 코드가 똑같지 않고 비슷하다면 메서드 추출기법을 적용해서 같은 부분과 다른 부분을 분리해야 한다. 그런 다음 경우에 따라 템플릿 메서드 형성 기법을 적용해야 할 수도있다.두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해서 알고리즘 전환 기법을 적용하면 된다.중복 코드가 메서드 가운데에 있다면 주변 메서드 추출을 적용하면된다.서로 상관 없는 두 클래스 안에 중복코드가 있을 때 -&gt; 한 클래스 안의 중복 코드를 클래스 추출 이나 모듈 추출 을 적용해 제 3의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다. 또는 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른클래스에서 그 메서드를 호출하거나 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법이 있다. 2. 장황한 메서드최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.짧은 메서드를 이해하기 쉽게하려면 메서드 명을 잘 정해야한다. 메섣의 기능을 한눈에 알 수 있는 메서드명을 사용하면 그 메서드안의 코드를 분석하지 않아도된다.메서드 호출이 원래 코드보다 길어지는 한이 있어도, 메서드 명은 그 코드의 의도를 잘 반영하는 것으로 정해야한다.메서드명은 기능 수행 방식이 아니라 목적(즉, 기능자체)을 나타내는 이름으로 정한다.메서드 추출기법을 적용한다.코드를 여러 덩어리로 분리하려면?주석을 찾는 것 -&gt; 기능 설명이 주석으로 처리된 코드 구간을 메서드로 만들면 된다. (긴 메서드에서 기능 설명이 주석으로 되어있는 부분)조건문과 루프도 역시 메서드로 추출 3. 방대한 클래스기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어있다. 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련 4. 과다한 매개변수매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편, 더많은 데이터가 필요해질 때마다 계속 수정해야 한다즉 매개변수는 객체를 넘기도록 한다. 객체를 넘김으로써 위 문제들이 해결 5. 수정의 산발수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다.하나의 클래스를 여러 개의 변형 객체로 분리하는것이 좋다. 그러면 각 객체는 한 종류의 수정에 의해서만 변경된다. 6. 기능의 산재하나의 수정으로 여러 클래스가 바뀌게 되는 문제수정할 부분들을 전부 하나의 클래스 안에 넣어줘야 한다. 7 .잘못된 소속메서드가 자신이 속해있는 클래스보다 다른 클래스에서 더 호출이 이루어질 경우 해당 메서드를 더 접근이 많은 클래스로 옮겨줘야 한다. 8. 데이터 뭉치두 클래스에 들어 있는 인스턴스 변수나 여러 메서드 시그너처(메서드명과 인수들 목록을 메서드 시그너처 라고 부릅니다.)에 들어있는 매개변수 처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려있는 경우이렇게 몰려있는 데이터 뭉치는 객체로 만들어야한다. 9. 강박적 기본 타입 사용관련된 데이터를 묶지 못하고 흩어놓게 되면, 각각의 데이터에 대한 정보를 외부에 공개해야한다.함수를 만들때도 각각의 데이터를 파라미터로 넘겨주어야 하기에 파라미터의 갯수가 늘어나게 된다.기본형만 사용할 바에는 객체를 만들어서(구조화)해서 사용해라이때는 각각의 관련된 데이터를 하나의 구조체로 묶어 주어야한다. 10. switch 문switch 문의 단점은 반드시 중복이 생긴다는 점이다. 동일한 switch가 다른 곳에서 또 쓰일가능성이 크다switch 문에 새 코드행을 추가하려면 그렇게 여기저기에 존재하는 switch 문을 전부 찾아서 수정해야한다.이 문제를 해결할수 있는 방법은 다형성 즉 재정의를 이용하는 것이다.switch 문을 메서드 추출로 빼낸 후 메서드 이동을 실시해서 그 메서드를 재정의해야 할 클래스에 옮겨 넣으면 된다. 11. 평행 상속 계층한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위 클래스도 만들어야 한다.중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속계층의 인스턴스를 참조하게 만들면 된다. 12. 직무유기 클래스하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다.비용만큼의 기능을 수행하지 못하는 비효율적인 클래스는 삭제해야한다. 13. 막연한 범용 코드메서드나 클래스가 오직 테스트 케이스에만 사용된다면 구린내를 풍기는 유력한 용의자로 막연한 범용코드를 지목할 수 있다. 이러한 메서드나 클래스를 발견하면 그것과 그것을 실행하는 테스트 케이스는 삭제하자. 14. 임시 필드객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다.이러한 떠돌이 해당 변수들을 사용하는 class를 생성한다 15. 메시지 체인메시지 체인?클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고 …. 연쇄적으로 요청이 발생하는 문제점 16. 과잉 중개 메서드어떤 클래스의 인터페이스를 보니 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있을경우 17. 지나친 관여클래스 끼리 관계가 지나치게 밀접한 나머지 서로의 private를 알아내느라 과도한 시간낭비서로 지나지게 친밀한 클래스는 메서드 이동과 필드 이동으로 떼어 낸다. 18. 인터페이스가 다른 대용 클래스기능은 같은데 시그너처가 다른 메서드에는 메서드명 변경을 실시해야 한다. 19. 미흡한 라이브러리 클래스라이브러리 클래스에 넣어야 할 메서드가 두 개 뿐이라면 외래 클래스에 메서드 추가 기법을, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기 법을 사용 20. 데이터 클래스데이터 클래스(domain)는 필드 캡슐화기법을 실시해야한다변경되지 않아야 하는 필드에는 쓰기 메서드 제거를 적용 21. 방치된 상속물하위클래스가 부모클래스에게 상속받은 메서드나 데이터가 하위클래스에서 더이상 쓰이지 않거나 필요 없게 되었을때.위 문제의 원인은 잘못된 계층구조새 대등 클래스를 작서하고 메서드 하향과 필드하향을 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣는다. 22. 불필요한 주석주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어보자.주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다.어떤 코드를 넣은 이유를 메모해 놓을 경우에도 주석을 넣는 것이 적절하다. 레거시 코드를 받았을 때 좋은 코드로 바꾸는 방법 + 레거시 코드의 양이 방대할 경우 부분별로 리팩토링을 진행해야 한다. 이 때, 유의할 점은 정확한 목표를 가져야 한다는 것이다. 대부분의 개발자는 성능 개선에만 초점을 두는데, 이는 또 다른 레거시 코드를 만들어 낼 수 있다. 레거시 코드를 변경하는 목적은 변경 자체가 아니라 변경시키는 행위이다. 따라서 각각의 작업 끝에는 항상 테스트 코드가 있어야 한다. 이 점을 항상 유념하며 리팩토링을 진행해야 한다. 1. 변경지점 식별변경시킬 지점을 알기 위해서는 대상 프로그램의 전체적인 아키텍처를 보아야한다. 노트&#x2F;스케치나 스크래치 리팩토링 기법과 같은 방법을 통해 변경해야 할 지점을 식별하자. 2. 테스트 지점 찾기리팩토링이 필요한 부분을 찾았다면 이제 어느 부분에 테스트 루틴을 작성할 것인지 결정해야 한다. 이를 위한 가장 간단한 판단 기준은 모든 메소드에 대해 테스트를 수행하는 것이다. 또한, 각 메소드들이 의존관계를 이루는 묶음끼리도 테스트가 필요한데, 이를 위해 의존관계를 최소화시키는 것이 중요하다. 3. 의존관계 깨기코드에서의 의존관계는 다른 클래스나 인터페이스에 방향성을 가지고 의지하는 코드를 의미한다. 예를 들어 A 클래스에서 B 클래스에 있는 메서드를 호출하는 상황을 가정해 보자. 이때 A 클래스가 변경되었다고 해서 B 클래스까지 변경될 필요는 없다. 이를 A 클래스가 B 클래스에 의존하고 있다고 말한다. 이러한 의존관계는 상황별 &amp; 종류별로 매우 다양하며 이를 해소하기 위한 방법도 각양각색이다. 기본적으로 의존관계란 코드의 유지 보수성을 떨어트리기 때문에, 의존관계를 최소화시키는 것이 중요하다. 각 상황별 의존관계 해소 방법을 알고 싶다면, 책으로 출간된 마이클 패더스의 Working Effectively with Legacy Code를 읽어보기 바란다. 4. 테스트 루틴 작성테스트 루틴을 작성할 때에는 코드의 동작을 이해하는 데 필요하다고 느끼는 만큼의 사례를 작성해야 한다. 기능을 추출하거나 이동시키려 한다면 사례별로 동작들의 존재 여부와 연결을 검증할 수 있는 테스트 루틴을 작성한다. 이동시키고자 하는 코드를 수행하는지와 그 코드가 적절히 연결되었는지를 검증한 후에 변환을 수행하도록 한다. 5. 변경 후 리팩토링전체적으로 볼 때 리팩토링은 덩치가 큰 메소드를 작은 단위로 쪼개는 것이다. 이렇게 된다면 코드를 좀 더 이해하기 쉽게 작성할 수 있다. 또한, 재사용성을 높일 수 있으며 시스템 안의 다른 영역들에 있는 로직과의 중복을 제거할 수 있다.","categories":[{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"}],"tags":[{"name":"refactoring","slug":"refactoring","permalink":"http://feel5ny.github.io/tags/refactoring/"},{"name":"TDD","slug":"TDD","permalink":"http://feel5ny.github.io/tags/TDD/"}]},{"title":"알고리즘과 시간 복잡도","slug":"CS_01","date":"2017-12-09T09:23:55.000Z","updated":"2024-11-23T12:10:59.665Z","comments":true,"path":"2017/12/09/CS_01/","permalink":"http://feel5ny.github.io/2017/12/09/CS_01/","excerpt":"","text":"목차 알고리즘 시간 복잡도 Big O 표기법 Asymptotic Complexity 점근적 분석 재귀함수 합 구하기 피보나치 수열 좋은 알고리즘의 필요 요건과, 알고리즘의 실행 속도를 평가하는 방법을 알아본다. 1. 알고리즘우리는 finite amount of space and time에 집중해야한다.알고리즘은 유한한 자원을 가진 환경에서 주어진 문제를 푸는 동작의 모임이다.적은 시간과 적은 자원(공간)을 이용해 문제를 해결하는 알고리즘이 좋은 알고리즘이다. + 웹 브라우저에서 사용할 수 있는 메모리는 일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적다. 적은 메모리만 할당받는 주된 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 운영체제를 다운시키는 일을 방지하기 위함이다.메모리 제한은 변수 할당 뿐만 아니라 호출스택, 스레드에서 실행할 수 있는 문장수에도 영향을 미친다.즉! 가능한 최소한의 메모리만 사용해야 페이지의 성능을 올릴 수 있다. 예제_Facebook 친구 2명이 가진 공통 친구 리스트를 만드는 가장 빠르 방법은?n명의 페이스북 친구를 가진 A와 m명의 페이스북 친구를 가진 B의 공통 친구의 수는 단순하게 생각한다면 n*m 800명, 400명이라면 320,000번의 비교로 찾을 수 있다. 시간복잡도를 배우고, 연산횟수를 줄이는 방법을 생각해보자. 2. 시간복잡도 +시간복잡도란 알고리즘이 문제를 해결하기 위한 **시간(연산)의 횟수**를 말한다.computational complexity that measures or estimates the timetaken for running an algorism.Time complexity is commonly estimated by counting the number of elementary operations performed by the algorism, supposing that an elementary operation takes a fixed amount of time to perform. 알고리즘을 평가하는데 있어 수행시간과 메모리 사용량을 평가기준으로 두는데수행시간에 해당하는 것이 시간 복잡도 Time Complexity,메모리 사용량에 해당하는 것이 공간 복잡도 Space Complexity이다. 연산 횟수를 카운팅 할때 3가지 경우가 있다. 최선의 경우 Best Case 최악의 경우 Worst Case 평균적인 경우 Average Case 평균적인 경우가 가장 이상적으로 보이겠지만 알고리즘이 복잡해 질수록 평균적인 경우는 구하기가 매우 어려워 진다. 그러므로 최악의 경우로 알고리즘의 성능을 파악한다. 2-1. Program Step에서 Elementary Operation이란? 프로그램의 진행 정도를 나타내는 기본 단위이다. 대입연산 덧셈, 뺄셈, 곱셈, 나눗셈 비교구문 함수호출 즉, 알고리즘의 실행 순서를 따라가며 Elementary Operation이 일어나는 수를 측정한다. 2-2. 어떻게 카운팅할까. 전역변수를 이용하여 Elementary Operation을 카운팅한다. 각 실행문 별로 Step수와 실행 횟수를 분석한다. 2-2-1. 전역변수를 이용하여 Elementary Operation을 카운팅12345678910111213let count = 0;function sum(list, n) &#123; let tempSum = 0; // 대입연산 for (let i = 0; i &lt; n; i++) &#123; count++; // loop 한번 돌 때마다 tempSum += list[i]; count++; // 대입연산 &#125; count++; // for loop 끝날 때 한번 count++; // return 수행 return tempSum;&#125; 2-2-2. 각 실행문 별로 Step수와 실행 횟수를 분석한다. 주어진 프로그램 2개의 성능 비교 및 분석 프로그램 P1의 성능 : C1 * n^2 + C2 * n 프로그램 P2의 성능 : C3 * n C1, C2, C3에 따라서 대소 비교 결과가 다름.어떤 C1, C2, C3에 대해서도 C1 * n^2 &gt; C3 * n을 만족하는 n은 존재함. n이 작으면 프로그램 P1의 성능이 더 좋을 수도 있다.n이 충분히 크면 항상 프로그램 P2의 성능이 좋다. (P1에는 n이 제곱이기 때문에) 작은 경우 모두 성능이 좋으므로 문제될 것은 없다.따라서 n이 큰 경우의 처리가 중요하다. 3. Big O 표기법Big O가 중요한 이유를 알기 위해서는 Asymptotic Complexity에 대해 알야아한다.알고리즘의 성능평가는 시간복잡도와 공간복잡도를 계산하고, 적 표기법으로 나타내면 된다. 위 예와 같이 T(n)으로 표현한 함수의 최고차항의 차수가 빅오가 된다.빅오의 순서는 아래와 같고 커질수록 좋지 않다.보통 O(n^2)이상의 복잡도를 가지는 알고리즘은 좋지 않다. 4. Asymptotic Complexity입력의 크기가 충분히 클 때의 시간복잡도와 공간복잡도를 분석하는 것. 프로그램 성능이 Asymptotic(점진적인) Complexity 프로그램의 입력 크기 등 성능을 결정하는 주요 특성 값이 매우 클 때의 프로그램의 성능. 프로그램의 실행 속도가 어떤 경향을 가지는지를 평가한다고 생각하면 된다. ex. 입력의 크기가 n이고 n이 매우 큰 경우 프로그램 성능 평가의 매우 중요한 기준. 4-1. 점근적 분석의 필요성어떠한 문제 해결을 위한 알고리즘의 성능분석을 할 때, 주어지는 데이터의 형태나 실험을 수행하는 환경, 또는 실험에 사용한 시스템의 성능등 다양한 요소에 의해 공평한 결과가 나오기 힘들고 비교 결과가 항상 일정하지 않을 수 있다. 이를 효과적으로 해결하는 방법이 점근적 분석법이다. 점근적 분석법은 각 알고리즘이 주어진 데이터의 크기를 기준으로 수행시간 혹은 사용공간이 얼마나 되는지를 객관적으로 비교할 수 있는 기준을 제시해 준다.O(빅오), Ω(오메가), Θ(세타)등이 있다. 일반적으로 빅오와 세타표기가 많이 사용된다. 4-2. 빅오 표기법 O Notation 점근적 상한선(Asymptotic upper bound) 주어진 알고리즘이 아무리 나빠도 비교하는 함수와 같거나 좋다. 정의 : O(g(n)) &#x3D; {f(n) : there exist positive constants c and n0 such that 0≤f(n)≤cg(n) for all n≥n0} n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 cg(n)보다 작거나 같다는 의미이다. 그래프가 아래에 있을 수록 수행시간이 짧은 것이므로 성능이 좋은 것이다. 4-3. 오메가 표기법 Ω Notation 점근적 하한선(Asymptotic lower bound) 주어진 알고리즘이 아무리 좋아도 비교하는 함수와 같거나 나쁘다. 정의 : Ω(g(n)) &#x3D; {f(n) : there exist positive constants c and n0 such that 0≤cg(n)≤f(n) for all n≥n0} n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 cg(n)보다 크거나 같다는 의미이다. 4-4. 세타 표기법 Θ Notation 점근선 상한선과 점근적 하한선의 교집합(Asymptotic tighter bound) 주어진 알고리즘이 아무리 좋아지거나 나빠지더라도 비교하는 함수의 범위안에 있다. 정의 : Θ(g(n)) &#x3D; {f(n) : there exist positive constants c1, c2 and n0 such that 0≤c1g(n)≤f(n)≤c2g(n) for all n≥n0} n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 c1g(n)보다 크거나 같거나 c2g(n)보다 작거나 같다는 의미이다 cf. 의사코드란? pseudo-code +의사(疑似: 비교할 의, 비슷할 사 | Pseudo: 가짜의- ) 코드는 컴퓨터 프로그램이나 알고리즘이 수행해야할 내용을 우리가 사용하는 언어 (한국어 또는 영어 등)로 간략히 서술해 놓은 것을 말합니다. 왜 의사코드를 사용해야 하나요? 의사코드는 코딩 입력을 시작하기 전, 사고를 좀더 명확히 정립하게 만들어주어 프로그램을 설계하는데 도움이 됩니다. 실제 코드 입력을 처음 시작할 때가 제일 힘듭니다! 단순히 소스코드를 입력하는 것보다 함수(function) 프로그램을 만들 때 많은 시간을 낭비할 수 있습니다. 약 10분 정도 각 풀이법의 장점과 단점을 주도면밀하게 살펴보면서 의사코드 작성한다면, 이후 디버그를 수정하고 코드를 재분해 하는데 걸리는 시간을 단축할 수 있습니다. 모델링이라고 생각해보자. 참고링크 http://ledgku.tistory.com/33 http://bigocheatsheet.com/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Algorithm","slug":"01-Web/zz-Algorithm","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Algorithm/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"}]},{"title":"단위 테스트는 왜 해야할까","slug":"TDD_01","date":"2017-12-08T09:23:55.000Z","updated":"2024-11-23T12:25:27.642Z","comments":true,"path":"2017/12/08/TDD_01/","permalink":"http://feel5ny.github.io/2017/12/08/TDD_01/","excerpt":"","text":"목차1. 단위테스트. 다들 중요하다고 하는데 왜 중요할까?3. 결국 클린코드를 위한 길2. TDD : Test Driven Development4. 실습1. 단위테스트. 다들 중요하다고 하는데 왜 중요할까? +단위테스트는 모듈이나 어플리케이션 안에 있는 개별적인 코드 단위가 예상대로 작동하는지 확인하는 반복적인 행위이다. 프로젝트에 단위 테스트를 적용하는 데에는 “내 코드가 제대로 동작하는지 확인하는 것”이라는 명백한 이유 외에도 몇 가지 장점이 있다. 단위 테스트는 코드가 “어떻게!”작성하는지 생각하는데 도움을 준다. 게다가 “무엇”을 해야하는지에 있어서 구현 선택을 검토하는데 해가 되지 않고, 그 선택들이 적절한지 아닌지 알아낸다. 주된 효과로는 단위 테스트를 추가하는 것은 애플리케이션의 유닛(함수&#x2F;메소드)를 더 작게 만든다. 많은 일을 하는 테스팅 코드는 어렵다.’‘많은 일을 하는 디버깅 코드는 어렵다.’이 두 가지 문제의 해결법은 많은 일을 하지 않도록 코드를 작성하는 것이다. 각각의 함수를 단 한가지만의 일을 하도록 작성해야 한다. 이렇게 하면 단위 테스트로 쉽게 테스트할 수 있다. (하나의 함수에 대해 많은 단위 테스트가 필요하지 않는다.)내 동료가 메소드를 더 작게 분리해야 하는지에 대해 판단할 때 사용하는 문구가 있다. 만약 코드의 역할을 다른 프로그래머에게 설명할 때 ‘and’라는 단어를 사용했다면 그 메소드는 적어도 하나 이상의 부분으로 나눠야 한다는 것이다. stackoverflow 단위 테스트의 다른 장점은 문제를 빨리 발견하고 변화를 쉽게하며 통합을 간단하게 하고 설계를 개선할 수 있다는 것이다. 여기까지 읽고 나니, 테스트코드를 짜는 것은, 설계도를 만들면서 프로그래밍을 한다고 생각해도 될듯하다. 스케치를하는 느낌! 아키텍처를 짜면서 프로그래밍을 할 수 있다. 단위테스트의 시작은 어렵다. “hot to start unit testing”를 구글에 검색하면 113,000,000의 결과가 나올정도로. 단위테스트를 시작하는 가장 쉬운 방법은 버그를 고치는 것입니다. 그 방법은 아래와 같다. 버그를 찾는다. 버그를 고쳤을 때 통과할만한 테스트를 작성한다. 테스트를 통과할 때까지 코드를 수정한다. 2. 결국 클린코드를 위한 길요구사항이 수시로 변경되고 프로젝트 일정이 눈에 보이기 시작하면 테스트 코드 없이 바로 로직 구현을 하는 경우가 태반이라고 했다. 물론 신속히 개발할 수 있지만, 나중에 유지 보수 때 문제가 발생한다고 한다. 유지보수라고 하지만 새로운 기능을 요구할 때도 있다. 기존 로직에 영향을 주지 않고 코드를 작성해야 하는데 테스트 코드 없이 구현하다 보면 사이드 이펙트가 여기 저기서 터진다. 결국 유지보수기간에 코드에 대한 테스트 코드를 다시 작성하는 사태.. 클린코드가 우선순위에서 밀려나서는 안되는 3가지 이유 +1. 유지보수하기 좋은 코드프로그래머 작업 중 가장 많은 시간을 투자하는 일이 유지보수이다. 유지보수하기 좋은 코드를 구현하는 것은 서비스의 성패를 좌우하는 중요한 요소이다. 유지보수하기 좋은 코드를 구현하는 핵심은 클린 코드 구현에 있다. 2. 변화에 대응하는 핵심 능력운영 중 필연적으로 발생하기 마련인 기능 추가, 버그 수정, 레거시 코드 리뷰(이전 개발자들의 유산과도 같은 코드) 및 수정 작업과 같은 변화 자체에 확장성있게 대응하려면 클린 코드에 대한 이해와 작성 능력이 필수. 변화를 피할 수 없으면 제대로 대응하자. 3. 프로젝트 협업 능력 향상읽기 좋은 클린 코드를 작성함으로서 오는 장점은 개인에게만 있지 않다. 특히 1인 개발이 아닌, 여러 개발자가 함께 참여하는 프로젝트일수록 확장성 있는 코드 작성 능력을 가진 개발자의 기여도는 높을 수 밖에 없다. cf. 레거시 코드란 Legacy code 테스트가 불가능하거나 어려운 코드 클린코드를 위한 리팩토링 3. TDD : Test Driven Development + 우선 개발자는 바라는 향상 또는 새로운 함수를 정읳하는 자동화된 테스트 케이스를 작성(초기적 결함을 점검하는) 케이스를 통과하기 위한 최소한의 양의 코드를 생성 새 코드를 표준에 맞도록 리팩토링 일반적으로 RED, GREEN, REFACTOR 세단계를 거쳐 이루어진다. RED : 실패하는 테스트 GREEN : 테스트에 통과하도록 코드를 작성 REFACTOR : 불필요한 코드를 삭제장점 : 유지보수가 가능한 코드를 작성할수 있고, 버그가 생겨날 여지도 줄고, 높은 가독성을 추구할 수 있다. 참고한 글에서는 심리적인 안정감을 준다고 한다. 테스트 없이 개발하면 그물망 없는 막타워를 뛰어 내리는 심정이라면서.. 코드 한줄한줄이 부담스럽다고 한다.생각해보면 이전 프로젝트에서는 테스트코드 없이 작업에 들어갔었고, 기능구현은 됐으나, 내가 보기 싫은 정도의 무자비한 코드들이 나왔다. 그러다보니 리팩토링조차 하지 못하는 상황.. 그런 의미에서 클린코드를 위한 작업이라고 생각하면, 좋을 듯하다. BDD (Behaviour Driven Development)BDD는 행동 베이스이다.엔드 유저의 행동을 시나리오로 가져야합니다.가령 로그인을 예로 BDD를 하려면, 셀레늄으로 실제 브라우저에서 렌더링된 아이디와 패스워드를 입력폼에 넣고 로그인 버튼까지 누르는걸 시뮬레이트해야한다. Given, When, Then 12345Scenario: User uses wrong password Given a username dkfksl; And a password kdfksj; When the user logs in with username and password Then the login form should be shown again 특정 값이 주어지고 (Given) 어떤 이벤트가 발생했을 때 (When) 그에 대한 결과를 보장해야한다 (Then) 4. 실습 react 테스트때는 Enzyme과 묶어서 Mocha 사용할 예정.Typescript사용, type definition으로는 mocha, node, express 셋팅, 의존모듈 : mocha, shoudld, supertest, typeScript 실습을 위해 필요한 것과 알야아할 용어 mocha should.js (assert 대체) supertest sinon mock mocha Mocha is a feature-rich JavaScript test framework running on Node.js and in the browser, making asynchronous testing simple and fun. Mocha tests run serially, allowing for flexible and accurate reporting, while mapping uncaught exceptions to the correct test cases. mocha는 node와 브라우저 모두에 적용할 수 있고, TDD, BDD, QUnit, export 스타일 모두 적용할 수 있는 프레임웍이다. assertion문 또한, 취향(?)에 따라 선택하여 적용할 수 있다.assertion문 expect, should, assert … should + 테스트 코드를 검증할 때 사용하는 써드파티 라이브러리 가독성이 높은 테스트 코드를 만들 수 있게해주는 장점! assert는 nodejs 공식 모듈, should 써드파티 모듈 assert란 실행 결과를 비교하기위해 사용하는 내장 모듈. 노드에서 제공하는 assert라는 라이브러리가 있지만, 노드측에서 발표를 했다! 노드 assert 이외의 서드파티 라이브러리를 사용하라..!! 123res.body.should.be.a.Object(); // res.body는 Object 형태이어야한다. should.be.ares.body.should.have.property(&#x27;result&#x27;); // res.body는 result라는 property를 갖고(have) 있어야 한다. res.body.result.should.have.equal(&#x27;Hello Get TDD&#x27;) // res.body.result는 &#x27;Hello Get TDD&#x27;라는 문자열과 같은 값을 갖고 있어야 한다. superTest + mocha가 하나의 함수를 테스트했다면, 통합테스트(api 기능 테스트)에서 사용하는 라이브러리 api 서버라면 내부적으로 express 구동 -&gt; 요청보낸 뒤 결과 검증까지함(시나리오 코드 작성)1234567891011121314151617const supertest = require(&#x27;supertest&#x27;);require(&#x27;should&#x27;);const server: any = supertest.agent(&#x27;http://localhost:3000&#x27;)describe(&#x27;테스트 시작&#x27;, () =&gt; &#123; it(&#x27;GET&#x27;, done =&gt; &#123; server.get(&#x27;/&#x27;).expect(&quot;Content-type&quot;, /json/).expect(200) .end((err, res) =&gt; &#123; if (err) throw err; res.body.should.be.a.Object(); res.body.should.have.property(&#x27;result&#x27;); res.body.result.should.have.equal(&#x27;Hello Get TDD&#x27;) done(); &#125;) &#125;); 서버에서 구현하는 API는 단순히 메모리상의 데이터를 다루는 것만 있는 것은 아닙니다. 사용자 계정 정보 등 영구적으로 저장할 데이터는 데이터베이스에 저장하게 되는데, 서버에 이 정보를 데이터베이스에서 조회한 뒤 API로 응답하는 경우가 빈번합니다.그럼 유닛 테스트를 위해 데이터베이스에 직접 자료를 넣어야 할까요? 그렇게 할 수도 있겠지만 시간이 많이 걸립니다. 왜냐하면 테스트를 위해 데이테베이스 컨넥션을 생성한 뒤 데이터를 입력하고 조회하는 시간이 상당하기 때문입니다. 게다가 이러한 API가 많아질수록 전체 테스트 시간은 늘어나게 됩니다.그래서 목(Mock)을 사용해야 합니다. 데이터베이스 역할을 흉내낼 수 있는 가상의 것을 만들수 있습니다. sinon +Sinon.js는 주로 테스트 대상이 의존하는 모듈과 자원의 대역의 용도로 사용한다. 특정 테스트 프레임워크를 의존하지 않기 때문에 QUnit 이외의 테스트 프레임워크와도 함께 사용할 수 있다. Sinon이라는 이름은 트로이 전쟁에서 활양한 스파이의 이름에서 유래했다.복잡한 비동기나 동시 다발적인 이벤트 그리고 애니메이션등 작성하기 어려운 테스트 타입을 Spy, Stub, Mock, FakeTiner, FakeServer 등으로 대체하여 테스트하기 쉽게 만들어 준다. MOCK작업을 할 수 있게 하는 라이브러리라고 생각하면된다.MOCK : 데이터 베이스 역할을 흉내내는 가상의 것 Mock이란?실제 객체를 만들기엔 비용과 시간이 많이 들거나 의존성이 길게 걸쳐져 있어 제대로 구현하기 어려울 경우, 가짜 객체를 만들어 사용한다. JavaScript는 비동기 상황을 테스트해야하기 때문에, 실제로 테스트 코드를 짜는 것은 굉장히 까다로운 작업이 될수 있다. 이러한 것을 해결하기 위한 하나의 방법으로 stub, mock object를 만드는 방법이 있다. Mock 객체는 언제 필요한가? 테스트 작성을 위한 환경 구축이 어려운 경우 환경 구축을 위한 작업 시간이 많이 필요한 경우에 Mock객체를 사용한다. (데이터베이스, 웹서버, 웹애플리케이션서버, FTP서버, 등) 특정 모듈을 갖고 있지 않아서 테스트 환경을 구축하지 못할 때 또는 타 부서와의 협의나 정책이 필요한 경우에 사용한다. 테스트가 특정 경우나 순간에 의존적인 경우 테스트 시간이 오래 걸리는 경우 개인 PC의 성능이나 서버의 성능문제로 오래 걸릴수 있는 경우 시간을 단축하기 위해 사용한다. cf. 테스트 러너 (karma)JavaScript는 브라우저 환경에 따라, 테스트 결과가 달라지기 때문에, 실제 브라우저에서 테스트를 꼭! 해야만한다. 테스트 러너는 여러 환경에서 동일 테스트를 호출 할 수 있다. 참고링크 http://www.incodom.kr/Mock http://webframeworks.kr/tutorials/expressjs/expressjs_test_code/ https://mochajs.org/ http://jinbroing.tistory.com/148 https://hyunseob.github.io/2016/05/09/assert-nodejs-test-module/ https://suhyeon.github.io/2017/12/10/TDD-1/ http://seokjun.kr/node-js-tdd/ http://blog.jeonghwan.net/mocha/ http://meetup.toast.com/posts/126 https://sungjk.github.io/2017/03/03/testing-react-application.html http://woogri.tistory.com/entry/BDD-BDD-%EB%84%88%EB%8A%94-%EC%96%B4%EB%94%94%EC%84%9C-%EC%98%A8%EA%B1%B0%EB%8B%88","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"04. Test","slug":"03-DevOps/04-Test","permalink":"http://feel5ny.github.io/categories/03-DevOps/04-Test/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://feel5ny.github.io/tags/TDD/"},{"name":"mocha","slug":"mocha","permalink":"http://feel5ny.github.io/tags/mocha/"}]},{"title":"6/ 함수표현식의 다른 용도","slug":"JS_06","date":"2017-12-07T12:20:19.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2017/12/07/JS_06/","permalink":"http://feel5ny.github.io/2017/12/07/JS_06/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차1. 함수와 재귀2. 클로저 2-1. 클로저 사용 (반복문) 2-2. 클로저의 메모리 누수 2-3. 클로저를 이용한 고유 변수(private variable : 객체 외부에서 접근할 수 없는 변수) &#x3D; 은닉화 1. 함수의 재귀함수의 재귀 부분은 함수Part 포스팅의 callee의 예시를 보면서 설명했었다. 추가로 스트릭트 모드일 경우에 arguments.callee에 접근할 수 없으므로 이를 보완하는 방법을 알아본다. 이름 붙은 함수 표현식을 써서 같은 결과를 낼 수 있게 한다.1234567const factorial = (function f(num)&#123; // f()를 생성하여 factorial에 할당. if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;) f라는 이름은 함수를 다른 변수에 할당하더라도 그대로 유지되므로 재귀 호출은 정확히 실행됨. 2. 클로저클로저란 다른 함수의 스코프에 있는 변수에 접근 가능한 함수이다.(내부함수가 외부함수의 스코프에 접근가능). 즉, 내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다.생성될 당시의 환경을 기억하는 함수를 말한다. 클로저를 잘 이해하기 위해서는 스코프 체인이 어떻게 생성되고 사용되는지 자세히 알아야 한다. 함수에서 변수에 접근할 때마다 스코프 체인에서 해당 이름의 변수를 검색한다. 함수 실행이 끝나면 로컬 활성화 객체는 파괴되고 메모리에는 전역 스코프만 남는다. 하지만 클로저는 외부함수가 실행을 마쳐도 활성화 객체는 내부함수가 파괴될 때가지 메모리에 남는다. 123456789101112131415161718function createComparisonFunction(propertyName)&#123; return function(object1, object2)&#123; const value1 = object1[propertyName] const value2 = object1[propertyName] if(value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;const compare = createComparisonFunction(&quot;name&quot;)const result = compare(&#123;name: &quot;Nicholas&quot;&#125;, &#123;name:&quot;Greg&quot;&#125;)compare = null; // 함수파괴 - GC이 메모리 회수가능 내부 함수가 반환되어 다른 컨텍스트에서 실행되는 동안에도 `propertyName`에 접근하 수 있다. 이런 일이 가능한 것은 내부 함수의 스코프 체인에 `createComparisonFunction()`의 스코프가 포함되기 때문이다. 외부함수가 실행을 마치고 익명함수를 반환하면 익명함수의 스코프체인은 외부함수의 활성화객체AO와 전역변수객체GO를 포함하도록 초기화된다. 이 때문에 익명 함수는 외부 함수의 번수 전체에 접근할 수 있다. 아직 익명함수의 스코프 체인에서 활성객체를 참조하기 때문에 외부 함수가 실행을 마쳤는데도 활성객체는 파괴디지 않는다. 즉 활성화객체는 익명함수가 파괴될 때까지 메모리에 남는다. 중간지점..개념정리자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우,내부함수가 외부함수의 스코프에 접근할 수 있고,외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며내부함수에 의해서 소멸하게 되는 특성을 클로저라고 부른다. 외부함수의 지역변수를 Free variable(자유변수)이라고 부르는데, 클로저라는 이름은 자유변수에 함수가 닫혀있다(Closed)라는 의미로, 자유변수에 엮여있는 함수라는 뜻이다. 외부함수가 이미 반환되었어도 외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우, 계속 유지된다. (내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제변수에 접근한다.) 클로저는 외부함수의 스코프를 보관해야하므로 다른 함수에 비해 메모리를 많이 요구한다. 클로저를 과용하면 메모리 문제가 생길 수 있으니, 반드시 필요할 때만 사용하길 권장한다. 2-1. 클로저 사용 (반복문)함수 안에 함수를 정의하고 내부에 정의한 함수를 노출시키면, 클로저를 사용할 수 있다. 함수를 노출시키기 위해서는 함수를 반환하거나 다른 함수로 전달하면 됩니다. 123456789function createFunctions()&#123; var result = []; for (var i=0; i&lt;10; i++)&#123; result[i] = function()&#123; return i; &#125; &#125; return result;&#125; result 배열에 들어가는 모든 함수가 스코프체인에 createFunctions()의 활성화객체를 포함하므로, 이들은 모두 같은 변수, i를 참조한다. 때문에 마지막에 할당된 i가 저장이 되는것이다. 이는 for루프의 초기문에 사용된 var키워드 변수의 스코프가 전역이기 때문에 발생하는 현상이므로, ES6의 let키워드를 이용하여 블록레벨 스코프 개념을 만들면 원하는 결과값이 나오긴한다. 하지만.. 우선 let이 없다는 상황에서 클로저를 사용하여 원하는 결과값을 반환해보자. 1234567891011function createFunctions()&#123; var result = []; for (var i=0; i&lt;10; i++)&#123; result[i] = (function(num)&#123; return function()&#123; return num; &#125; &#125;)(i); &#125; return result;&#125; 1. 즉시실행함수이기 때문에 함수가 실행되면서 내부함수가 반환된다. - 즉시실행함수는 한번만 호출시 처음 한번만 실행된다. 2. num에 i를 매개변수로 넘기기 때문에(복사) result에 들어가는 익명함수에는 자유변수 num이 생겼다고 보면되다. 3. 배열에 들어가는 함수는 즉시실행함수 매개변수로 i를 받는다. i는 num에 매개변수로 **복사**가되고, num은 해당 함수의 자유변수가 된다. 반환된 내부함수는 자유변수 num에 엮여있는 함수 클로저가 된다. 때문에 외부함수에서 매개변수로 받는 i값에 따라 고유한 num과 클로저를 갖게 된다. 2-2. 클로저의 메모리 누수클로저는 외부함수의 활성화객체 참조를 계속 유지하기 때문에 참조카운트가 줄지 않는다. (가비지컬렉션이 잡지 치우지 못한다.) 필요하다면 클로저를 갖고 있는 변수에 null을 할당하여 참조를 끊어야한다. 2-3. 클로저를 통한 은닉화 (고유변수) 참고링크 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode http://poiemaweb.com/js-closure","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"5/ 객체 지향 프로그래밍 (1)","slug":"JS_05_1","date":"2017-12-04T05:53:22.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2017/12/04/JS_05_1/","permalink":"http://feel5ny.github.io/2017/12/04/JS_05_1/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요.이 주제는 조금 더 공부를 해야할 듯 하다. 목차1. 프로퍼티 타입 - 데이터 프로퍼티 - 접근자 프로퍼티2. 다중 프로퍼티 정의3. 프로퍼티 속성 읽기객체지향언어는 일반적으로 클래스를 통해 같은 프로퍼티와 메서드를 가지는 객체르 여러 개 만든다는 특징이 있다. ECMAScript에는 클래스라는 개념이 없으며 이에 따라 ECMAScript의 객체는 다른 클래스 기반 언어와 다르다. (ES6에는 class라는 개념이 도입되었다.) ECMAScript에서 객체는 순서가 없는 값의 배열이다. 각 프로퍼티와 메서드는 이름으로 구별하며 값에 대응한다. 객체는 이름-값 쌍의 그룹이며 각 값은 데이터나 함수가 될 수 있다. 1. 프로퍼티 타입객체 리터럴 방식으로 객체를 생성할 때 프로퍼티와 메서드를 생성할 수 있다. 이러한 프로퍼티는 모두 자바스크립트에서 프로퍼티의 행동을 정의하는 특징에 따라 생성된다.이들 속성이 자바스크립트 엔진 내부에서 구현하는 것으로 정의했고, 이들 송성을 자바스크립트에서 직접적으로 접근할 수 있는 방법은 없다.이들 속성은 [[Enumerable]]처럼 속성 이름을 대괄호로 감싸서 내부 속성임을 나타낸다. 데이터 프로퍼티와 접근자 프로퍼티 두가지 타입이 있다. 1-1. 데이터 프로퍼티데이터 값에 대한 단 하나의 위치를 포함하여 이 위치에서 값을 읽고 쓴다.(무슨말이지?) [[Configurable]]프로퍼티가 delete를 통해 삭제하거나, 속성을 바꾸거나 접근자 프로퍼티로 변활할 수 있음을 나타낸다.객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true [[Enumerable]]for-in루프에서 해당 프로퍼티를 반환함을 나타낸다.기본은 true [[Writable]]프로퍼티 값을 바꿀 수 있음을 나타낸다.기본은 true [[Value]]프로퍼티의 실제 데이터 값을 포함한다. 프로퍼티의 값을 읽는 위치이고, 새로운 값을 쓰는 위치.기본값은 undefined 프로퍼티를 선언만 하고 값을 할당하지 않으면 undefined 123const person =&#123; name: &quot;Nicholas&quot;&#125; 여기서 “Nicholas”가 [[Value]] 데이터 프로퍼티에 저장된다는 말이다. 기본 프로퍼티 속성을 바꾸기 위해서는?Object.defineProperty()메서드를 사용하면 된다. Object.defineProperty() 처럼 강력한 옵션을 사용할 일이 드물겠지만, 자바스크립트 객체를 잘 이해하려면 알고 있으면 좋다. 전반적인 자바스크립트의 문법을 변화시키고 코드에 대한 해석을 기존처럼 할 수 없는 컨텍스트를 제공한다.1Object.defineProperty(프로퍼티를 추가하거나 수정할 객체, 프로퍼티 이름, 서술자 객체) 서술자 객체가 뭐지? descriptor 객체해당 속성에 대한 특성을 의미.내부 속성 이름과 같다. 서술자 객체에는 configurable, enumerable, writable, value 4가지 프로퍼티가 있다.123456789const person = &#123;&#125;;Object.defineProperyt(person, &quot;name&quot;, &#123; writable: false, // readOnly 형식으로 바꿨다고 생각하자. value: &quot;Nicholas&quot;&#125;)console.log(person.name) // &quot;Nicholas&quot;person.name = &quot;Greg&quot;;console.log(person.name) // &quot;Nicholas&quot;1-2. 접근자 프로퍼티 (accessor 함수)데이터 값이 들어있지 않고, getter함수와 setter함수로 구성된다. (옵셔널)접근자 프로퍼티를 읽을 때는 getter함수가 호출 유효한 값을 반환할 책임은 이 함수에 있다. 접근자 프로퍼티의 4가지 속성 [[Configurable]] 프로퍼티가 delete를 통해 삭제하거나, 속성을 바꾸거나 접근자 프로퍼티로 변활할 수 있음을 나타낸다. 기본은 true [[Enumerable]] for-in루프에서 해당 프로퍼티를 반환함을 나타낸다. 기본은 true 12345678910111213141516 var person = &#123; &#x27;first-name&#x27;: &#x27;Joy&#x27;, &#x27;last-name&#x27;: &#x27;Kim&#x27;, gender: &#x27;female&#x27;&#125;;// prop에 객체의 프로퍼티 이름이 반환된다. 단, 순서는 보장되지 않는다.for (var prop in person) &#123; console.log(prop + &#x27;: &#x27; + person[prop]);&#125;/*first-name: Joylast-name: Kimgender: female*/ [[Get]] 프로퍼티를 읽을 때 호출할 함수. 기본은 undefined [[Set]] 프로퍼티를 바꿀 때 호출할 함수. 기본은 undefined 1234567891011121314151617181920const book = &#123; _year: 2004, // 밑줄(_)은 이 프로퍼티는 객체의 메서드를 통해서만 접근할 것이고 객체 외부에서는 접근하지 않겠다는 의도를 나타낼 때 흔히 쓰는 표기법 (private와 같은 개념) edition: 1&#125;Object.defineProperty(book, &quot;year&quot;, &#123; get: function()&#123; return this._year &#125;, set: function(newValue)&#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue -2004; &#125; &#125;&#125;)book.year = 2005;alert(book.edition) //2 setter의 경우는 프로퍼티의 값을 바꿨을 때 해당 프로퍼티만 바뀌는 게 아니라 부수적인 절차가 필요한 경우에 사용한다. getter만 셋팅할 경우 읽기전용setter만 셋팅될 경우 undefined 2. 다중 프로퍼티 정의여러개의 프로퍼티를 동시에 수정해야할 경우 Object.defineProperties()configurable의 기본값은 true이지만, defineProperties나 defineProperty은 공통적으로 호출만 되면 true로 재지정하지 않는 이상 false가 된다. 3. 프로퍼티 속성 읽기1Object.getOwnPropertyDescriptor(읽어올 프로퍼티가 포함된 객체, 서술자를 가져올 프로퍼티 이름) 원하는 프로퍼티의 서술자 프로퍼티를 읽을 수 있다.모든 객체에서 사용가능하며, DOM이나 BOM 객체에서도 가능하다. 12345678910111213141516171819202122232425262728293031323334const book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;)var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);console.log(descriptor.value) // 2004console.log(descriptor.configurable) // falseconsole.log(typeof descriptor.get) // undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);console.log(descriptor.value) // undefinedconsole.log(descriptor.configurable) // falseconsole.log(typeof descriptor.get) // &quot;function&quot; 참고링크 http://www.bsidesoft.com/?p=1878#%25ec%25a0%2595%25ec%25a0%2581%25ec%258b%259c%25ec%25a0%2590%25ea%25b3%25bc-%25ec%258b%25a4%25ed%2596%2589%25ec%258b%259c%25ec%25a0%2590 http://poiemaweb.com/js-object","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"4/ 참조타입_Function 타입 (2)","slug":"JS_04_2","date":"2017-12-03T11:11:53.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2017/12/03/JS_04_2/","permalink":"http://feel5ny.github.io/2017/12/03/JS_04_2/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차 함수의 내부 구조 함수 프로퍼티와 메서드 함수의 다양한 형태 3-1. 즉시실행함수 3-2. 내부함수 3-3. 콜백함수 1. 함수의 내부 구조함수 내부에는 객체들이 있다. 요약- arguments 함수에 전달된 파라미터를 모두 포함하는 유사배열객체- this 함수의 호출패턴에 따라 값이 달라진다.- caller 해당 함수를 호출한 함수를 참조하는 값을 갖고있다. 전역함수에서는 null. 재귀함수를 사용할 때 사용가능.- length arguments의 배열 길이. (파라미터의 갯수)- name 함수의 이름- __proto__ 모든 객체가 갖고 있는 프로퍼티. [[Prototype]] 이며, 브라우저마다 다르게 명시한다. 해당 객체의 프로토타입을 가리키는 참조값을 갖고있다.- prototype 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.- apply 함수를 호출하면서 해당함수의 this를 호출한 함수로 넘기는 역할을 한다.- call apply와 같은 개념이며, apply와 다른 점은 parmeter를 각각 넘기는 스타일이다.- bind bind() 메소드는 호출될 때 그 this 키워드를 제공된 값으로 설정하고 새로운 함수가 호출될 때 제공되는 주어진 순서의 선행 인수가 있는 새로운 함수를 생성한다.1-1. arguments순회가능한(iterable) 유사배열객체이며, 함수에 전달된 파라미터를 모두 포함한다.arguments 프로퍼티는 arguments 객체를 값으로 가지며, 함수 내부에서 지역변수처럼 사용된다. 즉, 외부에서는 호출할 수 없다. arguments 객체에는callee, length, Symbol 프로퍼티가 존재한다.callee 프로퍼티는 arguments 객체의 소유자인 함수를&#x2F; 가리키는 포인터이다. 1234567function factorial(num)&#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125; 12345678// 함수 이름에 의존하는 약점을 callee로 보완function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125; 1-2. this1-3. callercaller 프로퍼티에는 해당 함수를 호출한 함수에 대한 참조를 저장하며, 전역 스코프에서 호출했다면 null이 저장된다. 2. 함수 프로퍼티와 메서드함수에서 사용된 this는 실행된 객체를 가리키거나 상위 컨텍스트인 window를 가리킨다.this를 조작해서 다를 객체를 지정하려면? apply나 call을 사용하면 된다. 2-1. apply 메서드소유자인 함수를 호출하면서 this를 파라미터로 넘기는데, 결론적으로는 함수 내부에서 this객체의 값을 바꾸는 것이나 마찬가지이다. 매개변수로는 소유자함수에 넘길 this와 매개변수 배열을 (Array의 인스턴스 혹은 arguments)를 받는다. 123456789101112function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments) // arguments 객체를 넘김&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]) // 배열을 넘김&#125;alert(callSum1(10,10)) //20alert(callSum2(10,10)) //20 2-2. callapply와 같은데, 두번째 파라미터를 array형태가 아니라, 각각 나열해야한다. 1234567function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2) // arguments 객체를 넘김&#125;alert(callSum(10,10)) //20 2-3. bind새 함수 인스턴스를 만드는데 그 this는 bind()에 전달된 값이다. 123456789window.color= &quot;red&quot;;var o = &#123; color: &quot;white&quot; &#125;function sayColor()&#123; alert(this.color)&#125;var objectSayColor = sayColor.bind(o)objectSayColor() //white 2-4. __proto__ 프로퍼티ECMAScript spec에서는 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다라고 되어있다. [[Prototype]]와 __proto__는 같은 개념이다. 2-5. prototype프로퍼티함수 객체만이 갖고 있는 프로퍼티로, 자바스크립트 객체지향의 근간이다. __proto__와 다르다. 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다. 함수가 생성될 때 만들어지며 constructor 프로퍼티를 가지는 객체를 가리킨다. 이 constructor 프로퍼티는 함수 객체 자신을 가리킨다. 3. 함수의 다양한 형태3-1. 즉시호출함수표현식 IIFE, (Immediately Invoke Function Expression)함수의 정의와 동시에 실행되는 함수를 즉시호출함수라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다. react에서 componentwillmount의 개념 즉시실행함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 충돌을 방지할 수 있어 이를 위한 목적으로 사용되기도 한다. 12345678910111213// 기명 즉시실행함수(named immediately-invoked function expression)(function myFunction() &#123; var a = 3; var b = 5; return a * b;&#125;());// 익명 즉시실행함수(immediately-invoked function expression)(function () &#123; var a = 3; var b = 5; return a * b;&#125;()); 3-2. 내부함수함수 내부에 정의된 함수를 내부함수라 한다.내부함수는 부모함수의 변수에 접근할 수 있지만, 부모함수는 자식함수의 변수에 접근할 수 없다. 3-3. 콜백함수콜백함수는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다. 보통 이벤트 핸들러 처리때, 비동기식 처리모델에 사용된다. 옵저버(Observer) 디자인 패턴에서 나온 개념이다. 123setTimeout(function () &#123; console.log(&#x27;1초 후 출력된다.&#x27;);&#125;, 1000); 비동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다. 콜백함수는 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다.콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다. (참고) 그런데 왜 이름이 callback 일까?설명1 -선언된 함수를 이용하는 것을 호출 (call) 한다고 표현 한다. 콜백 함수는 운영체제(혹은 웹)에 의해 호출되는 응용 프로그램의 함수라 할 수 있다. 호출되는 방향이 정상적인 호출과 달리 반대된다는 의미에서 콜백이라고 한다. 정상적인 함수 호출 방법과는 다르게 운영체제 ( 시스템 ) 측에서 이벤트를 발생시켜서 이에 대한 처리를 해달라고 요청해 오는 과정이 있기 때문에 이와 같은 이름이 붙여졌다고 할 수 있다. 설명2 -콜백함수란 API 의 반대개념이라고 볼 수 있습니다.또한 말그대로 콜백! CallBack &gt; 반대로 부른다고 해석할 수 있지요.우리는 작성하는 일반 코드내에서보통 API나 SDK에서 제공해주는 함수(Function)들을 호출(Call)하여 사용하곤 한다.이런 방식의 경우, 어떤 이벤트를 제어하기 위해서는 별도의 쓰레드를 생성하여 무한루프로 실시간 검사하는 꽤나 무겁고 살짝 무식한 프로그램들을 만들어야한다. 보통 이럴때, 사용하는 것이 콜백(CallBack) 함수.물론 시스템상 CallBack함수를 만들어 등록하는 방식이 제공되어야 한다.Windows 프로그램상에서 On??Event()를 통해 등록하는 방식이나, 안드로이드 상에서 Listener를 등록하는 방식이 이와 같다.콜백함수라는 말 그대로 일반 Call의 반대 방향을 말한다.통상적으로 쓰듯이 우리가 시스템상의 함수를 Call하는 것이 아니라, 시스템에서 우리가 만들고 등록한 함수를 Call하는 방식. 참고링크 http://poiemaweb.com/js-function shinlucky’s Archive","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"4/ 참조타입_Function 타입 (1)","slug":"JS_04_1","date":"2017-12-02T02:20:12.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2017/12/02/JS_04_1/","permalink":"http://feel5ny.github.io/2017/12/02/JS_04_1/","excerpt":"","text":"‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 목차0. Function 타입1. 함수 선언 vs 함수 표현식2. 값처럼 쓰는 함수(일급객체)3. 함수의 내부 구조3. 함수 프로퍼티와 메서드 4,5번은 Function 2편에서 1. Function 타입함수는 객체이다. 모든 함수는 Function타입의 인스턴스이며, 프로퍼티와 메서드가 있다.함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다. 함수 정의 함수 선언식 123function sum (num1, num2) &#123; return num1 + num2&#125; 함수 표현식 Function expression 123const sum = function(num1, num2)&#123; return num1 + num2&#125; 일급객체라는 함수의 특징 때문에 함수 리터럴 방식으로 선언 후 변수에 할당할 수 있다. 할당된 함수를 가리키는 참조값을 저장하게 된다. 이렇게 생성된 함수는 function 키워드 다음에 함수 이름이 없으므로 익명 함수로 간주한다. 익명함수(anonymous function) &#x3D; 람다함수(lambda) name 프로퍼티는 빈 문자열이다. 함수표현식으로 재귀, 클로저, 고유변수 등을 설명할 수 있다. Function 생성자 사용 1const sum = new Function(&#x27;num1&#x27;,&#x27;num2&#x27;,&#x27;return num1 + num2&#x27;) 함수 리터럴 방식 당연히 권장하지 않는다. ECMAScript 생성자에 전달할 문자열을 다시 평가해야 하므로 성능에 영향이 있다. 괄호를 쓰지않는 sum괄호를 쓰지 않고 함수 이름만 쓰면 함수를 실행하지 않고 함수를 가리키는 포인터에 접근(만)하는 것이다. 2. 함수 선언 vs 함수 표현식자바스크립트 엔진이 실행 컨텍스트에 데이터를 불러올 때 중요한 차이가 하나 있다.함수 선언은 어떤 코드도 실행하기 전에 이미 모든 실행 컨텍스트에서 접근하고 실행할 수 있지만함수 표현식은 코드 실행이 해당 줄까지 진행하기 전에는 사용할 수 없다. 실행 컨텍스트와 같이 생각해보자!자바스크립트 엔진은 코드를 평가할 때 제일 먼저 함수 선언을 찾은 다음 이들을 맨 위로 올린다 (함수 호이스팅). 함수 표현식은 변수에 함수가 할당된 개념이기 때문에, 해당 변수에 값(함수)이 들어오기 전까지는 undefined로만 선언되어있는 상태이다.(변수 호이스팅) 1234alert(sum(10,10));const sum = function(num1, num2)&#123; return num1 + num2;&#125; 즉, 위 코드를 보면 에러가 나는데, sum은 컨텍스트에 있지만 매개변수를 넘길 수 있는 형태가 아니기 때문에(2번째 줄 오기 전까지는 undefined) 해당 코드까지 실행하기 전에는 unexpected identifier 에러를 낸다.(예기치 못한 식별자 &#x3D; sum(10,10)을 보고 함수형태의 식별자 sum을 기대하고 찾았는데, 함수형태가 아니라서) 함수 표현식만 사용하자고 권고한다 : 참고JavaScript : The Good Parts의 저자이며 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수표현식만을 사용할 것을 권고하고 있다. 함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 1. 코드의 구조를 엉성하게 만들 수 있다고 지적한다. 또한 함수선언식으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 2. 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다. 3. 값처럼 쓰는 함수 (일급객체)자바스크립트 함수는 일급 객체이다. 일급객체란 생성(인스턴스 생성가능), 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다.일급객체일 경우 아래와 같은 특징을 갖는다. 1. 무명의 [리터럴](https://feel5ny.github.io/2017/11/17/Typescript_04/#literal)로 표현이 가능하다. 2. 변수나 자료구조 (객체, 배열...)에 저장할 수 있다. 3. 함수의 파라미터로 전달할 수 있다. 4. 반환값(return value)으로 사용할 수 있다. (내부함수) 함수와 다른 객체를 구분 짓는 특징은 호출할 수 있다는 것이다. 함수가 다른 함수를 반환하는 상황예시1_callSomeFunction123456789101112// sample example// callSomeFuncion은 범용함수이다. 범용함수란 더 많은 상황에서 더 잘 적용할 수 있는 함수를 말한다.function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument) // 반환값으로 사용됨&#125;function add10(num)&#123; return num + 10;&#125;const result1 = callSomeFunction(add10, 19);alert(result); //20 예시2_sort의 createComparisonFunction함수 해당 객체의 프로퍼티 이름을 확인하여 순서를 배치하는 함수를 반환하는 비교함수이다. 개체는 해당 속성 중 하나의 값을 기준으로 정렬 할 수 있습니다.123456789101112131415161718192021// sortfunction createComparisonFunction(propertyName)&#123; return function (object1, object2)&#123; // return 연산자 뒤에 내부함수 let value1 = object1[propertyName] let value2 = object2[propertyName] if (value1 &lt; value2)&#123; return -1; // value1이 앞에 옴 &#125; else if (value1 &gt; value2)&#123; return 1; // value1이 뒤에 옴 &#125; else &#123; return 0; &#125; &#125;&#125;const data = [&#123;name: &#x27;Joy&#x27;, age: 27&#125;, &#123;name:&#x27;Clara&#x27;, age:28&#125;]data.sort(createComparisonFunction(&#x27;name&#x27;))console.log(data[0].name) // Claradata.sort(createComparisonFunction(&#x27;age&#x27;))console.log(data[0].age) // 27 sort(compareFunction)compareFunction이 제공되지 않으면 요소를 문자열(toString)로 변환하고 유니 코드 코드 포인트 순서로 문자열을 비교하여 정렬됩니다. 예를 들어 “바나나”는 “체리”앞에옵니다. 숫자 정렬에서는 9가 80보다 앞에 오지만 숫자는 문자열로 변환되기 때문에 “80”은 유니 코드 순서에서 “9”앞에옵니다. 문자열 대신 숫자일 경우 value1과 value2를 빼는방법으로 색인을 반환한다. 1234567const numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);// [1, 2, 3, 4, 5] 참고링크 http://poiemaweb.com/js-function","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"3/ 실행 컨텍스트와 스코프","slug":"JS_03","date":"2017-12-01T01:13:55.000Z","updated":"2024-11-23T12:13:00.744Z","comments":true,"path":"2017/12/01/JS_03/","permalink":"http://feel5ny.github.io/2017/12/01/JS_03/","excerpt":"","text":"프론트엔드 개발자를 위한 자바스크립트 프로그래밍 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 1. 실행 컨텍스트실행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다. ECMAScript 스펙에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 즉, 실행 컨텍스트는 실행 가능한 코드가 실행되는 환경이라고 말할 수 있다.실행 가능한 코드란 전역코드 : 전역 영역에 존재하는 코드 함수코드 : 함수 내에 존재하는 코드 Eval코드 : Eval 함수로 실행되는 코드 일반적으로는 전역코드와 함수코드. 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보를 알고 있어야 한다. 변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티 함수 선언 함수 표현식은 호이스팅이 안되는 이유. (함수 표현식은 변수에 할당되는 방식이기 때문에) 변수의 유효범위 (Scope) this 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 2. 실행 컨텍스트의 3가지 객체객체의 형태를 가지며 아래의 3가지 프로퍼티를 소유한다. Variable object Scope chain thisValue 2-1. Variable object (VO 변수객체)변수나 함수의 실행 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는지를 규정합니다. 각 실행 컨텍스트에는 변수객체(variable object:VO)가 연결되어 있으며, 해당 컨텍스트에서 정의된 모든 변수와 함수는 이 객체에 존재한다. 코드로는 접근할 수 없다. 변수 parameter arguments parameter, 매개변수 : 함수 원형 작성시 사용되는 변수를 인자 (이름보다는 타입이 중요) argument, 실행인자 : 코딩 중 함수 호출시 사용되는 변수 또는 실제 값을 인수 함수 선언 (함수 표현식은 제외) Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 갖는데, 이 값은 다른 객체를 가리킨다.전역 컨텍스트와 함수 컨텍스트가 가리키는 객체는 다르다. 함수에만 파라미터가 존재한다. 전역 컨텍스트인 경우Variable Object는 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object&#x2F;GO)를 가리킨다. 전역변수와 전역함수는 전역 객체의 프로퍼티이다. 전역 컨텍스트란 가장 바깥쪽에 존재하는 실행 컨텍스트이다. ECMAScript를 구현한 환경에 따라 이 컨텍스트를 부르는 이름이 다르다. 웹 () 전역컨텍스트 : window 전역변수와 전역함수는 모두 window의 프로퍼티 및 메서드로 생성된다. 전역컨텍스트는 애플리케이션이 종료될 때, 웹페이지를 나가거나 브라우저를 닫을 때까지 유지된다. 함수 컨텍스트인 경우Variable Object는 Activation Object(AO&#x2F;활성객체)를 가리키며 arguments object가 추가된다.arguments object 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체이다.(이전 글에서 함수의 매개변수로 값이 전달될 때 arguments object에 들어간다고 했다. 전달한 값이 argument라고 생각하면 된다. arguments object: 함수 호출 시 전달된 인수들의 정보를 담고 있는 유사배열객체.) 실행컨텍스트 스택123456789101112var x = &#x27;xxx&#x27;;function foo () &#123; var y = &#x27;yyy&#x27;; function bar () &#123; var z = &#x27;zzz&#x27;; console.log(x + y + z); &#125; bar();&#125;foo(); 1. 컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다. 2. 전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다. 3. 함수를 호출하면 해당 함수의 실행 컨택스트가 생성되며 직전에 실행된 코드블럭의 실행 컨텍스트 위에 쌓인다. 4. 함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다. ECMAScript 프로그램은 모두 이런 식으로 실행된다. 3. 스코프 체인 SC스코프 체인은 일종의 리스트로서 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있는 개념이다.즉, 현재 실행컨텍스트의 활성객체(AO)를 선두로하여 순차적으로 상위 컨텍스트의 AO를 가리키며 마지막 리스트는 전역 객체를 가리킨다. 스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것. 함수가 중첩 상태일 때 하위함수 내에서 상위함수의 유효범위까지 참조할 수 있는데 이것는 스코프 체인을 검색하였기 때문이다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인에 포함된다. 함수 실행중에 변수를 만나면 그 변수를 우선 현재 Scope, 즉 Activation Object에서 검색해보고, 만약 검색에 실패하면 스코프 체인에 담겨진 순서대로 그 검색을 이어가게 되는 것이다. 이것이 스코프 체인이라고 불리는 이유이다. 이와 같이 순차적으로 스코프 체인에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 Reference 에러를 발생시킨다.스코프 체인은 [[scope]] 프로퍼티로 참조할 수 있다. 4. this valuethis 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정되는데, 이는 Function 글에서 자세히 다루겠다. 5. 실행 컨텍스트의 생성과정12345678910111213var x = &#x27;xxx&#x27;;`function foo () &#123; var y = &#x27;yyy&#x27;; function bar () &#123; var z = &#x27;zzz&#x27;; console.log(x + y + z); &#125; bar();&#125;foo(); 전역 코드에 진입컨트롤이 실행 컨텍스트에 진입하기 이전에 유일한 전역 객체(Global Object)가 생성된다. 초기 상태의 전역 객체에는 빌트인 객체(Math, String, Array 등)와 BOM, DOM이 설정되어 있다. 참고링크 http://poiemaweb.com/js-execution-context http://nerissa.tistory.com/entry/Parameter%EC%99%80-Argument%EC%9D%98-%EC%B0%A8%EC%9D%B4 http://poiemaweb.com/js-function","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"2/ 메모리 관리와 가비지 콜렉션","slug":"JS_02","date":"2017-11-30T09:23:55.000Z","updated":"2024-11-23T12:13:00.739Z","comments":true,"path":"2017/11/30/JS_02/","permalink":"http://feel5ny.github.io/2017/11/30/JS_02/","excerpt":"","text":"프론트엔드 개발자를 위한 자바스크립트 프로그래밍 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 요약가비지 콜렉션은 더 이상 사용하지 않는 메모리를 회수하는 역할을 한다. 메모리를 회수하기 전 사용하지 않는 변수를 체킹해야 하는데 이때 표시하고 지우기 방법과 참조 카운팅이 있다. 표시하고 지우기 방법은 처음 컨텍스트의 모든 변수에 마킹을 한 후, 값이 할당되어있거나 참조되어있는 변수의 마킹을 지운다. 지웠음에도 마킹이 남아있는 변수를 회수하는 방식이다. 참조 카운팅은 참조 카운트가 0인 변수를 회수하는 방식인데 순환참조의 카운팅 한계가 있기 때문에 주로 표시하고 지우기 방법을 사용한다. 가비지 콜렉터 사이클이 도는 것은 상당한 비용이 발생한다. 메모리 누수 관리를 위해서는 사용하지 않는 변수나 객체는 모두 null로 재할당하여 가비지 컬렉터가 다음 사이클 때 회수하도록 하는 방법, 크롬 개발자도구의 퍼포먼스 탭에서 확인하는 방법 등이 있다. 1. 가비지 콜렉션자바스크립트는 인터프리터 언어이다.(인터프리터 언어란 목적 파일 산출과정이 없이 실행과 동시에 줄 단위로 번역이 된고, 저용량 소스에 적합하다. 코드가 실행되는 시점이 런타임이다. 인터프리터와 컴파일러의 차이점) 고급 언어 인터프리터는 가비지 콜렉터 라는 소프트웨어를 가지고 있다.가비지 컬렉터(Garbage Collector)란 메모리 할당을 추적하고 할당된 메모리가 더 이상 필요 없어졌을 때 해체하는 작업이다. 이 프로세스는 주기적으로 실행되는데 코드 실행 중에 특정 시점에서 메모리를 회수하도록 지정할 수도 있다. C나 C++같은 언어에서는 메모리 추적이 매우 중요하기 때문에 메모리 관리가 힘들지만, 자바스크립트는 필요한 메모리를 자동으로 할당하고 더 이상 사용하지 않는 메모리는 자동으로 회수하므로 개발자가 직접 메모리를 관리하지 않아도 된다. 가비지 컬렉터는 항상 필요없어진 메모리만을 해제하지만, 모든 필요없어진 메모리를 해제하는 건 아니다. 즉, ‘더 이상 필요없는 모든 메모리’가 아니라 ‘더 이상 필요 없는 몇몇 메모리’를 찾아낸다. 이는 가비지 콜렉션 알고리즘의 한계점이 있기 때문이다. 2. GC가 회수해야할 메모리 식별은 어떻게 하나요?무튼, 어떤 변수가 더 이상 사용되지 않는지, 사용될 가능성이 있는 변수는 무엇인지 추적해야 메모리 회수 대상을 정할 수 있다. 식별 기준은 2가지이다. 표시하고 지우기 Mark and Sweep 참조 카운팅 Reference counting 2.1 표시하고 지우기 Mark and Sweep가장 널리 쓰이는 컬렉션 방법이다.변수가 특정 컨텍스트 안에서 사용할 것으로 정의되면 그 변수는 그 컨텍스트 안에 있는 것으로 표시된다. 표시한는 구체적인 방법은 알 필요는 없다.. GC가 작동하면 메모리에 저장된 변수 전체를 표시한다. 컨텍스트에 있는 변수, 컨텍스트에 있는 변수가 참조하는 변수의 표시를 지운다. 표시가 지워지지 않는 변수를 삭제한다. 가비지 컬렉터는 ‘메모리 청소’를 실행해 표시가 남아 있는 값을 모두 파괴하고 메모리를 회수한다. 2.2 참조 카운팅 Reference counting각 값이 얼마나 많이 참조 되었는지 추적한다. 변수를 선언하고 참조 값이 할당되면 참조 카운트는 1이다. 다른 변수가 같은 값을 참조하면 참조 카운트가 늘어난다. 마찬가지로 해당 값을 참조하는 변수에 다른 값을 할당하면 원래 값의 참조 카운트가 줄어든다. 값의 참조 카운트가 0이 되면 해당 값에 접근할 방법이 없으며, 메모리를 회수해도 안전하다. 다음 가비지 컬렉터를 실행할 때 참조 카운트가 0인 값에서 사용하던 메모리를 회수한다. 순환 참조 문제이 알고리즘은 두 object가 서로를 참조하면 문제가 발생한다. 1234567function problem()&#123; let objectA = new Object(); // objectA : reference count 1 let objectB = new Object(); // objectB : reference count 2 objectA.someOtherObject = objectB; // objectA : 2 objectB.anotherObject = objectA; // objectB : 2&#125; 위의 코드를 보면 새로운 객체가 생성되면서 참조 카운트가 1이되고,서로 참조하게 되면서 참조카운트가 2가 된다.이 상태에서 스코프를 벗어나게 되면, 해당 변수는 사용되지 않는데, 벗어났음에도 카운트가 0이 아니기 때문에 GC가 컬렉션을 하지 않게 된다. 이는 곧 메모리 낭비로 이어진다.이때는 강제로 null을 항당해서 참조했던 값으로의 연결을 끊어줘야한다. 그래서 대부분의 브라우저에서는 표시하고 지우기 방법을 쓴다. 3. 가비지 콜렉터와 성능문제GC는 주기적으로 실행되며 메모리 내에 할당된 변수가 많다면 상당한 비용이 드는 작업이므로 GC를 실행하는 타이밍이 중요하다. 익스플로러는 가비지 컬렉터를 너무 자주 실행하여 성능 문제를 일으키는 것으로 악명이 놓다. 4. 자바스크립트로 프로그래밍시 내가 할 수 있는 메모리 관리웹 브라우저에서 사용할 수 있는 메모리는 일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적다. 적은 메모리만 할당받는 주된 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 운영체제를 다운시키는 일을 방지하기 위함이다.메모리 제한은 변수 할당 뿐만 아니라 호출스택, 스레드에서 실행할 수 있는 문장수에도 영향을 미친다.즉! 가능한 최소한의 메모리만 사용해야 페이지의 성능을 올릴 수 있다. 필요 없어진 데이터에는 null을 할당하여 참조를 제거(dereference)하는 편이 좋다. 이론상은 그렇지만, 실제로는 많이 사용하지 않는다. 참조를 하고 있는지에 대해서 개발자가 판단하기가 어렵기 때문에 오히려 전체 흐름을 망가뜨리는 행위가 될 수 있다. 우리도 모르게 어디선가 side effect가 발생할 수도있고, 복잡성이 증가한다.(면접 때 면접관님께서 정정해주셨다!)수동으로 참조 제거해야 할 대상은 주로 전역변수 및 전역 객체의 프로퍼티이다.(지역변수는 컨텍스트를 빠져나가는 순간 자동으로 참조가 제거된다.) 참조 제거의 요점은 값의 컨텍스트를 없애서 다음에 가비지콜렉션을 실행할 때 해당 메모리를 회수하도록 하는 것이다. 사용하지 않은 객체, 변수는 모두 null 로 초기화 이벤트 핸들러를 바인딩 했다면, 모두 언바인딩 DOM 을 동적으로 생성했다면, 불필요한 객체, 속성(값)을 DOM 에 삽입하지 말자. 크롬 개발자도구의 Performace탭에서 timeline확인해보자. (번외 (참고 글)) V8_Efficient Garbage CollectionV8은 객체가 사용하다가 더 이상 필요 없게 된 메모리를 가비지 콜렉션(garbage collection)이라고 알려진 작업을 통해서 다시 찾아온다. 빠른 객체 할당을 보장하고, 가비지 콜렉션으로 인한 프로그램 정지 시간을 단축시키며, 메모리 파편화를 제거하기 위해서 stop-the-world 방식의 세대적이고, 정확한 가비지 콜렉터(garbage collector)를 채택하고 있다. 이것은 다음을 의미한다. 가비지 콜렉션 사이클을 수행할 때 프로그램 실행을 멈춘다. 가비지 콜렉션 사이클 중 대부분의 시간을 객체의 힙(heap)의 영역을 처리하는데 사용함으로써 어플리케이션 멈춤 현상을 최소화 한다. 모든 객체가 포인터가 메모리의 어디에 있는지 항상 정확히 알고 있다. 이를 통해 객체를 포인터로 잘못 식별하여 메모리 누수를 일으키는 문제를 피할 수 있다. V8에서 객체의 heap은 2개의 부분으로 나누어져 있다. 새로 객체가 생성되는 영역과 가비지 콜렉션 사이클이 진행되는 동안에 살아남은 객체가 있는 영역. 객체가 가비지 콜렉션으로 들어가면 V8은 객체의 포인터를 갱신한다. 변수를 생성하는 것 자체가 메모리를 사용하는 것인데, 이를 회수하고 관리하는 가비지컬렉션이 있다는 것에 흥미로웠다.메모리 누수를 막아서 최소한의 메모리 사용으로 페이지 성능을 향상하는 것이 목적이지만, 사이클이 너무 많이 실행되면 이것 또한 자원낭비.변수의 할당의 최소화하고, 코드 재사용성을 높이고, 전역변수나 전역객체의 프로퍼티가 존재한다면 마지막에 null을 할당해보자. 참고링크 https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management http://huns.me/development/452 https://v8project.blogspot.kr/2015/08/getting-garbage-collection-for-free.html http://hapina.tistory.com/112","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"1/ 변수, 원시 값과 참조 값","slug":"JS_01","date":"2017-11-29T09:23:55.000Z","updated":"2024-11-23T12:13:00.738Z","comments":true,"path":"2017/11/29/JS_01/","permalink":"http://feel5ny.github.io/2017/11/29/JS_01/","excerpt":"","text":"프론트엔드 개발자를 위한 자바스크립트 프로그래밍 책을 참고하여 정리합니다. 오류가 있다면 언제든지 댓글 남겨주세요. 까묵지말자Call-by-value, Call-by-reference 1. 변수란?변수는 위치(주소)를 기억하는 저장소이다. (포인터의 개념)위치란 메모리 상의 주소(address)를 의미한다. 즉, 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자이다. 변수를 통해 메모리에 값을 저장하기 위해서는 우선 필요한 저장 단위(byte)를 알아야한다. 이는 값의 종류에 따라 값을 저장하기 위해 확보해야할 메모리의 크기가 다르기 때문이다. 이때 값의 종류 즉, 데이터의 종류를 자료형이라고 한다. C-family언어는 정적타이핑 언어로 변수 선언 시 변수에 저장할 값의 종류에 따라 사전에 자료형을 지정하여야 한다. 변수를 선언하는 것부터가 메모리를 사용하는 것이기 때문에 변수사용을 최소한으로 하여, 페이지의 성능을 유지해야한다. 동적 타입 Dynamic typedjacascript는 동적 타이핑 언어로(느슨한 타입: loosely typed) 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자동으로 자료형이 결정(Type Inference: 타입 추론)된다. 따라서 같은 변수에 여러 자료형의 값을 대입할 수 있다. 타입스크립트는 이런 동적 타이핑 언어의 단점을 보안하기 위해서 타입을 명시해주는 특징을 갖고 있다. 변수는 값을 저장(할당), 참조하기 위해 사용된다. 한번 쓰고 버리는 값이 아닌 유지할 필요가 있는 경우, 변수를 사용한다. 2. 원시 값과 참조 값원시 값과 참조값 두가지 타입의 데이터를 저장할 수 있는데,원시 값은 단순한 데이터이며참조 값은 여러 값으로 구성되는 객체를 가리킨다.변수에 값이 할당되면 자바스크립트 엔진이 해당 값이 원시 데이터인지 참조인지 판단한다. 참조 값은 메모리에 저장된 객체이다. 다른 언어와 달리 자바스크립트는 메모리 위치에 직접 접근하는 것을 허용하지 않고, 객체의 메모리 공간을 직접 조작하는 일은 불가능하다. 참조로 접근한다객체를 조작할 때는 객체 자체가 아니라 해당 객체에 대한 참조를 조작하는 것이다. 이런 이유로 객체를 가리키는 값은 ‘참조로 접근한다’고 한다. 3. 동적 프로퍼티참조 값을 다룰 때는 언제든 프로퍼티와 메서드를 추가하거나 바꾸고 삭제 할 수 있다.원시 값에는 프로퍼티가 없지만 추가하려 해도 에러가 생기진 않는다.동적으로 프로퍼티를 추가할 수 있는 값은 참조 값 뿐이다. 12345678let person = new Object()person.name = &#x27;Clara&#x27;alert(person.name)let name = &#x27;Clara&#x27;name.age = 27alert(name.age) // undefined 4. 값 복사원시 값원시 값은 다른 변수로 복사할 때는 현재 저장된 값을 새로 생성한 다음 새로운 변수에 복사한다. 복사된 값과 원래 값은 완전히 분리되어 있다. 참조 값참조 값을 변수에서 다른 변수로 복사가되면 그 값이 객체 자체가 아니라 힙에 저장된 객체를 가리키는 포인터라는 점이다. 복사 후에는 두 변수는 정확히 같은 객체를 가리킨다. 따라서 한쪽을 조작하면 다른 쪽에도 반영된다.스택메모리 공간은 함수호출 시마다 생성되고,힙메모리 공간은 객체 생성 시 생성됨. 5. 매개변수 전달함수 매개변수는 모두 값으로 전달된다. 함수 외부에 있는 값은 함수 내부의 매개변수에 복사된다. 변수는 값으로도, 참조로도 접근할 수 있지만 매개변수는 오직 값으로만 전달된다. 메모리 공간을 확보하며 매개변수에 할당된다. Call-by-value (값에 의한 호출) 매개변수를 값 형태로 넘기면 해당 값은 지역 변수에 복사된다. arguments 객체에 들어가게 된다. Call-by-reference (참조에 의한 호출) 함수에 `값`을 전달했기 때문에 함수 내부에서 매개변수의 값이 바뀌었음에도 불구하고 원래 객체에 대한 참조를 그대로 유지한 것이다. = 즉 객체가 넘어갈때는 참조 형태로 전달되는 것이 아니라 **값으로 넘어간다.** (== 포인터가 넘어간다) 함수 내부에서 obj를 덮어쓰면 obj는 지역객체를 가리키는 포인터가 되고, 이 지역 객체(obj.name)는 함수 실행이 끝나면 파괴된다. 6. 타입판별typeof 1typeof 변수명 instanceof123변수명 instanceof Object // 이 변수는 Object의 인스턴스인가? // 결과값은 boolean참고링크 http://poiemaweb.com/js-data-type-variable","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"}]},{"title":"React에 typeScript 셋팅하기","slug":"Typescript_13","date":"2017-11-28T11:13:22.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2017/11/28/Typescript_13/","permalink":"http://feel5ny.github.io/2017/11/28/Typescript_13/","excerpt":"","text":"실습은 tic-tac-toc이라는 js 프로젝트를 마이그레이션 하면서 typescript를 연습해본다.raect+typescript는 이웅재님의 강의 참고하였습니다.역시 이론과 실습이 결합할 때가 제일 재밌다! 처음 프로젝트를 생성할 때 부터 타입스크립 버전으로 셋팅하는것이 제일 깔끔하다. 1. create-react-app ts-test --scripts-version=react-scripts-ts create-react-app + 프로젝트 이름 + --scripts-version=react-scripts-ts 추가 react에서 사용하는 PropTypes를 사용하지 않아도 된다. PropTypes컴포넌트 에서 원하는 props 의 Type 과 전달 된 props 의 Type 이 일치하지 않을 때 콘솔에서 오류 메시지가 나타나게 하고 싶을 땐, 컴포넌트 클래스의 propTypes 객체를 설정하면 됩니다. 또한, 이를 통하여 필수 props 를 지정할 수 있습니다. 즉, props 를 지정하지 않으면 콘솔에 오류 메시지가 나타납니다. 1234567891011121314151617181920// Content.jsimport React from &#x27;react&#x27;; class Content extends React.Component &#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;&#123; this.props.title &#125;&lt;/h2&gt; &lt;p&gt; &#123; this.props.body &#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;Content.propTypes = &#123; title: React.PropTypes.string, body: React.PropTypes.string.isRequired // isRequired는 필수의 의미이다.&#125;;export default Content; 2. state와 props는 interface로 처리를 해야한다.class에서 입출력되는 타입을 검토하기 위해서 배열의 요소가 객체일 경우 123456789101112131415161718192021interface GameState &#123; history: Array&lt;&#123; squares: Array&lt;string&gt; &#125;&gt; // Array 요소가 객체일 경우 이렇게 타입을 지정해준다. stepNumber: number xIsNext: boolean&#125;export default class Game extends React.Component&lt;GameProps, GameState&gt; &#123; constructor() &#123; super() this.state = &#123; history: [ &#123; squares: Array(9).fill(null), &#125;, ], stepNumber: 0, xIsNext: true, &#125; &#125; ...&#125; return에 대한 출력값을 타입으로 명시할때 JSX.Elementreturn 내부가 JSX문법이므로 JSX.Element로 명시하였다. 123456789101112131415export default class Game extends React.Component&lt;GameProps, GameState&gt; &#123; render(): JSX.Element &#123; return ( &lt;div className=&quot;game&quot;&gt; &lt;div className=&quot;game-board&quot;&gt; &lt;Board squares=&#123;current.squares&#125; onClick=&#123;i =&gt; this.handleClick(i)&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;game-info&quot;&gt; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;moves&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 참고링크 https://velopert.com/921","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"11/ Type Inference","slug":"Typescript_12","date":"2017-11-27T04:11:43.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2017/11/27/Typescript_12/","permalink":"http://feel5ny.github.io/2017/11/27/Typescript_12/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 1. 타입추론 기본적으로 타입을 명시적으로 쓰지 않을 때 추론하는 방법에 대한 규칙 명시적으로 쓰는 것은 타입 추론이 아니라 코드를 읽기 좋게 하는 지름길 let 은 기본적으로 우리가 아는 기본 자료형으로 추론 const 는 리터럴 타입으로 추론 오브젝트 타입을 타입을 쓰지 않으면, 프로퍼티는 let 처럼 추론 const person &#x3D; {name: ‘Mark’, age: 35}; 면 person &#x3D;&gt; {name: string; age: number;} 로 추론 대부분은 추론이 쉽다. 단순 변수 structuring, destructuring array, 함수의 리턴에서는 원하는데로 얻기가 힘들다. 2. 배열 타입 추론1234567891011121314151617const array1 = [];const array2 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];const array3 = [&#x27;a&#x27;, 1, false]; // 타입이 다를 경우 union타입으로 추론된다. class Animal &#123; name: string;&#125;class Dog extends Animal &#123; dog: string;&#125;class Cat extends Animal &#123; cat: string;&#125;const array4 = [new Dog(), new Cat()] 3. 리턴 타입 추론1234567function hello(message: string | number) &#123; if (message === &#x27;world&#x27;) &#123; return &#x27;world&#x27;; &#125; else &#123; return 0; &#125;&#125; 리터럴타입의 ‘world’이거나 0이 나온다. 4. 유니온 타입과 타입 가드타입가드 Type guard어떤 Scope에서 타입을 보증하는 런타임 체크를 수행하는 몇 가지 표현식이다. 타입 가드를 정의하기 위해서, 리턴 타입이 Type predicate인 함수를 정의 할 필요가 있다. Type predicate1parameterName is Type 1234567891011121314151617181920212223interface Person &#123; name: string; age: number;&#125;interface Car &#123; brand: string; wheel: number;&#125;function isPerson(arg: any): arg is Person &#123; return arg.name !== undefined;&#125;function hello(arg: Person | Car) &#123; if (isPerson(arg)) &#123; console.log(arg.name); // console.log(arg.brand); &#125; else &#123; // console.log(arg.name); console.log(arg.brand); &#125;&#125; 참고링크 https://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"10/ Decorator","slug":"Typescript_11","date":"2017-11-26T12:11:09.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2017/11/26/Typescript_11/","permalink":"http://feel5ny.github.io/2017/11/26/Typescript_11/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 요약아직 잘 이해가 안간다. &#128565; 1. Decorator 종류 Class Decorator Method Decorator Property Decorator Parameter Decorator 각자 Decorator의 시그니처가 다르다. Decorator?- 함수 표현식에 해당한다.- @와 같이 써서 표현식 뒤에 오는 대상에 더욱 기능적으로 추가하거나 하는 일들을 할 수 있다.- 함수를 선언한 뒤 @키워드를 이용해 선언된 함수를 Decorator로 사용할 수 있다. 1-1. Decorator 코드 작성 준비yarn add typeScript -D여기서 D는 dev와 같은 명령어다. 2. Decorator2-1. Class Decorator 2-1-1. Class Decorator Basic여기서 helloFactory 는 팩토리 패턴 123456789101112131415161718192021function hello(constructorFn: Function) &#123; console.log(constructorFn);&#125;function helloFactory(show: boolean) &#123; if (show) &#123; return hello; &#125; else &#123; return null; &#125;&#125;// @hello@helloFactory(true)class Person &#123; constructor() &#123; console.log(&#x27;new Person()&#x27;); &#125;&#125;new Person(); 2-1-2. Class Decorator Advanced123456789101112131415function addHello(constructorFn: Function) &#123; constructorFn.prototype.hello = function() &#123; console.log(&#x27;hello&#x27;); &#125;&#125;@addHelloclass Person &#123; constructor() &#123; console.log(&#x27;new Person()&#x27;); &#125;&#125;const person = new Person();(&lt;any&gt;person).hello(); 2-2. Method Decorator12345678910111213141516171819202122232425262728function editable(canBeEdit: boolean) &#123; return function(target: any, propName: string, description: PropertyDescriptor) &#123; console.log(canBeEdit); console.log(target); console.log(propName); console.log(description); description.writable = canBeEdit; &#125;&#125;class Person &#123; constructor() &#123; console.log(&#x27;new Person()&#x27;); &#125; @editable(true) hello() &#123; console.log(&#x27;hello&#x27;); &#125;&#125;const person = new Person();person.hello();person.hello = function() &#123; console.log(&#x27;world&#x27;);&#125;person.hello(); 2-3. Property Decorator12345678910111213141516171819202122232425262728function writable(canBeWrite: boolean) &#123; return function(target: any, propName: string): any &#123; console.log(canBeWrite); console.log(target); console.log(propName); return &#123; writable: canBeWrite &#125; &#125;&#125;class Person &#123; @writable(false) name: string = &#x27;Mark&#x27;; constructor() &#123; console.log(&#x27;new Person()&#x27;); &#125;&#125;const person = new Person();console.log(person.name);/*undefined*/ 2-4. Prameter Decorator12345678910111213141516171819202122232425262728function printInfo(target: any, methodName: string, paramIndex: number) &#123; console.log(target); console.log(methodName); console.log(paramIndex);&#125;class Person &#123; private _name: string; private _age: number; constructor(name: string, @printInfo age: number) &#123; this._name = name; this._age = age; &#125; hello(@printInfo message: string) &#123; console.log(message); &#125;&#125;/*Person &#123; hello: [Function] &#125;hello0[Function: Person]undefined1 참고링크 http://poiemaweb.com/es6-class https://javarouka.github.io/blog/2016/09/30/decorator-exploring/ http://blog-kr.zoyi.co/channel-frontend-decorator/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"9/ itertor","slug":"Typescript_10","date":"2017-11-25T11:13:22.000Z","updated":"2024-11-23T12:10:16.997Z","comments":true,"path":"2017/11/25/Typescript_10/","permalink":"http://feel5ny.github.io/2017/11/25/Typescript_10/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 요약아직 잘 이해가 안간다. &#128565; 1. for…of es3for(var i = 0; i&lt;array.length; i++) es5array.forEach : return으로 순회를 탈출할 수 없다. es6for..offor(const item of array)원칙적으로는 배열에서만 사용이 가능하다. for-of 루프는 이터러블 객체를 순회한다. for-of 루프는 이터레이터의 next() 메소드를 호출하고 next() 메소드가 반환하는 객체의 done 프로퍼티가 true가 될 때까지 루핑한다. 2. for..in일반적일때는 사용하지 않는 것으로. (엔진에 따라 다르다.) 배열을 순회할 때는 사용하지 않을 것 index 가 number 가 아니라 string 으로 나온다. 배열의 프로퍼티를 순회할 수도 있다. prototype 체인의 프로퍼티를 순회할 수도 있다. 루프가 무작위로 순회할 수도 있다. for..of 를 쓸 것 객체를 순회할 때 for (const prop of Object.keys(obj)) 도 사용할 수 있다. 12345678910111213141516171819202122232425262728293031323334const array = [&#x27;first&#x27;, &#x27;second&#x27;];const obj = &#123; name: &#x27;Mark&#x27;, age: 35&#125;;// 배열에 for..of 이용for (const item of array) &#123; console.log(typeof item + &#x27;, &#x27; + item);&#125;// 배열에 for..in 이용// item 이 string 타입의 숫자for (const item in array) &#123; console.log(typeof item + &#x27;, &#x27; + item);&#125;// 객체에 for..of 이용 =&gt; 오류/*for (const item of obj) &#123; console.log(typeof item + &#x27;, &#x27; + item);&#125;*/// 객체에 for..in 이용for (const item in obj) &#123; console.log(typeof item + &#x27;, &#x27; + item);&#125;// 객체의 keys 들에 for..of 이용for (const item of Object.keys(obj)) &#123; console.log(typeof item + &#x27;, &#x27; + item);&#125; target 이 es3 인데도 forEach 는 트랜스파일이 되지 않았음.https://github.com/Microsoft/TypeScript/issues/2410 1234567891011const array = [&#x27;first&#x27;, &#x27;second&#x27;];// tsarray.forEach((item) =&gt; &#123; console.log(item);&#125;);// jsarray.forEach(function (item) &#123; console.log(item);&#125;); 3. Symbol.iterator이터러블(iterable)iterate &#x3D; 반복하다이터러블은 순회 가능한 자료 구조이다. Symbol.iterator를 프로퍼티 key로 사용한 메소드를 구현하는 것에 의해 순회 가능한 자료 구조인 이터러블이 된다. 이터레이터Symbol.iterator를 프로퍼티 key로 사용한 메소드는 이터레이터로 반환한다. 이터레이터는 순회 가능한 자료 구조인 이터러블의 요소를 탐색하기 위한 포인터로서 next() 메소드를 갖는 객체이다. next() 메소드는 value, done 프로퍼티를 갖는 객체를 반환하며 이 메소드를 통해 이터러블 객체를 순회할 수 있다. ES6에서 제공하는 built-in iterable은 아래와 같다. Array Array.prototype[Symbol.iterator] String String.prototype[Symbol.iterator] Map Map.prototype[Symbol.iterator] Set Set.prototype[Symbol.iterator] DOM data structures NodeList.prototype[Symbol.iterator] HTMLCollection.prototype[Symbol.iterator] 프로퍼티이며, 함수가 구현되어있으면, iterable 이라고 한다. Array, Map, Set, String, Int32Array, Uint32Array, etc. 에는 내장된 구현체가 있으므로 이터러블 하다. 그냥 객체는 이터러블하지 않다. 이터레이터를 통해 이터러블한 객체의 Symbol.iterator 함수를 호출한다. target : es3 or es5 Array 에만 for..of 사용 가능 일반 객체에 사용하면 오류 target : es6 Symbol.iterator 함수를 구현하면 어떤 객체에도 for..of 사용 가능 12345678910111213141516171819// lib.es6.d.tsinterface IteratorResult&lt;T&gt; &#123; done: boolean; value: T;&#125;interface Iterator&lt;T&gt; &#123; next(value?: any): IteratorResult&lt;T&gt;; // next가 필수로 있어야한다. return?(value?: any): IteratorResult&lt;T&gt;; throw?(e?: any): IteratorResult&lt;T&gt;;&#125;interface Iterable&lt;T&gt; &#123; [Symbol.iterator](): Iterator&lt;T&gt;;&#125;interface IterableIterator&lt;T&gt; extends Iterator&lt;T&gt; &#123; [Symbol.iterator](): IterableIterator&lt;T&gt;;&#125; 5. CustomIterable객체는 이터러블이 아니다. 하지만 이터레이션 프로토콜을 준수하여 이터러블 객체를 만들수 있다. Symbol.iterator를 key로 사용한 메소드는 next() 함수를 프로퍼티로 가지는 객체를 반환하여야 한다. 그리고 next() 함수는 done과 value 프로퍼티를 가지는 객체를 반환한다. for-of는 done 프로퍼티가 true가 될 때까지 반복하며 done 프로퍼티가 true가 되면 반복을 중지한다. 12345678910111213141516171819202122class CustomIterable implements Iterable&lt;string&gt; &#123; private _array: Array&lt;string&gt; = [&#x27;first&#x27;, &#x27;second&#x27;]; [Symbol.iterator]() &#123; var nextIndex = 0; return &#123; next: () =&gt; &#123; return &#123; value: this._array[nextIndex++], done: nextIndex &gt; this._array.length &#125; &#125; &#125; &#125;&#125;const cIterable = new CustomIterable();for (const item of cIterable) &#123; console.log(item);&#125; 참고링크 http://poiemaweb.com/es6-iteration-for-of","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"8/ Generic","slug":"Typescript_09","date":"2017-11-24T06:42:10.000Z","updated":"2024-11-23T12:10:17.013Z","comments":true,"path":"2017/11/24/Typescript_09/","permalink":"http://feel5ny.github.io/2017/11/24/Typescript_09/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 요약제네릭은 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다. 정적 타입 언어에서도 이렇게 특정 타입을 위해 만들어진 함수 혹은 클래스를 보다 범용적으로 재사용하기 위한 요구가 있기 때문에 제네릭이라는 프로그래밍 기법이 생긴 게 아닐까한다. 1. any &#x3D;&gt; genericany의 사용을 지양하고자 타입을 인자로 넘긴다. 탬플릿을 만드는 개념. 인자값과 출력값의 타입을 같게 탬플릿을 만들어준다. 제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다. 한번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다. T는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 타입 파라미터(Type parameter)라 한다. T는 Type의 약자로 반드시 T를 사용하여야 하는 것은 아니다. 함수에도 제네릭을 사용할 수 있다. 제네릭을 사용하면 하나의 타입만이 아닌 다양한 타입의 매개변수와 리턴값을 사용할 수 있다. 123function helloGeneric&lt;T&gt;(message: T): T&#123; return message;&#125; 1234567891011121314151617181920212223function helloString(message: string): string &#123; return message;&#125;function helloNumber(message: number): number &#123; return message;&#125;// 더 많은 반복된 함수들 ...function hello(message: any): any &#123; return message;&#125;function helloGeneric&lt;T&gt;(message: T): T &#123; return message;&#125;console.log(hello(&#x27;Mark&#x27;).length);console.log(hello(35).length); // hello 의 리턴이 any 이기 때문에 타입 헬퍼가 제대로 되지 않음console.log(helloGeneric(35).toString()); // console.log(helloGeneric&lt;number&gt;(35).toString());// helloGeneric 을 사용하면 정상적으로 사용가능 2. basic generic Generic 타입을 쓰지 않으면, T 로 추론 Generic 타입을 쓰면, T 를 확인 123456789101112function helloGeneric&lt;T&gt;(message: T): T &#123; return message;&#125;function hello&lt;T&gt;(message: T): T &#123; return message;&#125;console.log(hello&lt;string&gt;(&#x27;Hello&#x27;));let age = hello(35);hello&lt;number&gt;(&#x27;35&#x27;); 3. Generic Arrayhello 함수의 제네릭 타입을 [] 를 이용하여 배열로 사용할 수 있음 12345function hello&lt;T&gt;(messages: T[]): T &#123; return messages[0];&#125;console.log(hello&lt;string&gt;([&#x27;Hello&#x27;, &#x27;World&#x27;])); 4. Generic Type구현체에 return T 를 설정하지 않아도, return false 시 오류가 나지 않는다? 때에 따라서 적합하지 않을 수 있다. 12345678type HelloGeneric = &lt;T&gt;(message: T) =&gt; T;const hello: HelloGeneric = &lt;T&gt;(message: T): T =&gt; &#123; return message;&#125;console.log(hello&lt;string&gt;(&#x27;Hello&#x27;).length); 5. Generic Class명시적으로 제네릭 타입을 설정하면 오류 function에서 generic을 사용할 때의 오류와 같다. 123456789101112class Person&lt;T&gt; &#123; private _name: T; private _age: number; constructor(name: T) &#123; this._name = name; &#125;&#125;new Person(&#x27;Mark&#x27;);// new Person&lt;string&gt;(35); 6. Generic with extendsT 가 string 또는 number 를 상속받기 때문에 boolean 은 안된다. 12345678910111213class Person&lt;T extends string | number&gt; &#123; // union type private _name: T; private _age: T; constructor(name: T) &#123; this._name = name; &#125;&#125;new Person(&#x27;Mark&#x27;);new Person(35);// new Person(true); 7. Generic with multiple types1234567891011class Person&lt;T, K&gt; &#123; private _name: T; private _age: K; constructor(name: T, age: K) &#123; this._name = name; this._age = age; &#125;&#125;new Person(&#x27;Mark&#x27;, 35); 8. type lookup systemkeyof 키워드를 알아야한다. 12type Test = keyof Person;// 리터럴 타입의 유니온 타입이 나온다. &quot;name&quot; | &quot;age&quot; 객체와 key값을 인자로 받아서 perperty의 타입값을 알아내는 함수를 만들었다고 치자.함수에서 컴파일 타입을 검증할 수 있는 시스템이 필요하다. &#x3D;&gt; type lookup system getProperty: Generic과 type alias를 결합하여 사용하여 type을 찾아낼 수 있는 시스템을 만든다. setProperty: Generic과 type alias를 결합하여 사용하여 type을 찾아내고, 타입을 다시 재정의 하는 함수 1234function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123; return obj[key];&#125; 1234567891011121314151617181920212223interface Person &#123; name: string; age: number;&#125;const person: Person = &#123; name: &#x27;Mark&#x27;, age: 35&#125;;function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123; return obj[key];&#125;function setProperty&lt;T, K extends keyof T&gt;(obj: T, key: K, value: T[K]): void &#123; obj[key] = value;&#125;console.log(getProperty(person, &#x27;name&#x27;));// console.log(getProperty(person, fullname));setProperty(person, &#x27;name&#x27;, &#x27;Anna&#x27;);console.log(getProperty(person, &#x27;name&#x27;));// setProperty(person, &#x27;name&#x27;, 24); 참고링크 http://poiemaweb.com/typeScript-generic https://www.youtube.com/watch?v=3-nJyzJATq8 https://hyunseob.github.io/2017/01/14/typeScript-generic/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"08 days/ 협업규칙 정하기, 초기 셋팅, 퍼블리싱","slug":"dada_02week","date":"2017-11-24T01:10:04.000Z","updated":"2024-11-23T12:12:54.695Z","comments":true,"path":"2017/11/24/dada_02week/","permalink":"http://feel5ny.github.io/2017/11/24/dada_02week/","excerpt":"","text":"Daily scrum(김나영) +Github + 목차(2017.10.01 ~ 2017.10.09) 프로젝트 매니징을 위한 셋팅 깃헙 셋팅 깃헙 프로젝트 탭으로 매니징 테스크 관련 규칙 정하기 프로젝트 초기 셋팅 의존모듈 셋팅 CSS 프레임워크 선택 CSS styling 방법 퍼블리싱 &#128153; (feat.추석) 1. 프로젝트 매니징을 위한 셋팅깃헙 셋팅 깃헙 레포에는 백엔드, 프론트엔드 폴더를 초반에 나누어서 진행하였다. troubleShoot위험 상황을 피하는 차원에서 백엔드와 프론트엔드는 레포를 따로 생성하는게 좋다고 하셨음. 처음 시작 시에는 master브랜치에서 브랜치를 각자 생성하여 진행, 풀리케스트 없이 바로 바로 merge하며 진행. (지금 생각하니 헉;) 퍼블리싱 이후에는 master는 절대적으로 배포용으로만 사용하기로 정함. (브랜치 rock 설정) develop-backend, develop-frontend 브랜치를 main브랜치로 정함. 퍼블리싱 단계에서는 각자 이름-페이지이름으로 브랜치를 생성하기로 정하였다. > 퍼블리싱 끝나고 merge 후 troubleShoot위의 이미지는 1주일만에 merge한 상황. merge는 자주자주 하는게 좋다. 깃헙 프로젝트 탭 프로젝트 탭은 총 5가지로 구성하였다. 1. 규칙 2. 할 일 3. 진행 중인 작업 4. 마친 작업 규칙의 경우 예전에 참여했던 프로젝트의 규칙을 light하게 가져왔다. 규칙은 아래와 같이 가볍게 정했다! 급한 이슈의 경우 라벨 붙이기 카드당 assign 필수 작성 규칙 [페이지명] 작업 설명 EX. [Diary] 식단 추가 작업 페이지가 구분 되지 않는 경우는 [Global]로 한다. EX. [Global] 페이지 라우팅 카드 하나당 1개의 작업만 등록한다. 테스크의 경우 매주 진행했던 오프라인 회의 때 코드리뷰 이후 할일 카드를 같이 생성하기로 정했다. Tip 깃헙 프로젝트에서 카드를 이슈로 만들면, 이슈탭에도 자동 등록 가능하다. 해당 이슈의 커밋이 진행 될 경우, 커밋 메세지에 이슈 number와 명령어를 추가하면 이슈가 자동으로 close나 등등의 작업이 자동화되면서, 이슈에도 log가 남는다. Close: close, closes, closed, fix, fixes, fixed, resolve, resolves, resolved Reopen: reopen, reopens, reopened Issue slack notation을 걸어놓지 않아서 이메일로 확인해야했다. 카드를 close로 옮겨야하는 번거로움이 있었다.(지라같은 툴은 옮기지 이슈가 닫히면 자동으로 옮기짐) 2. 프로젝트 초기 셋팅1. create-react-app 2. 폴더 구조 셋팅 components/ global하게 사용되는 container 컴포넌트 pages/ container component와 presentational component를 함께 두었다. 3. CSS 프레임워크 선택 + Semantic-UI-React 서비스 컨셉과 유사한 디자인을 갖고 있고 여러 종류의 컴포넌트들이 있어서 사용. 4. css styling 방법4-1. 첫번째 이슈_디자인 커스텀 시맨틱 프레임워크를 사용해도, 디자인 시안이 있었기 때문에 약간의 커스텀이 필요했다. 이미 셋팅되어있는 컴포넌트를 커스텀을 해야했기 때문에 css로는 적용이 불가능했다. 인라인으로 적용해야 덮어씌어졌음. !important로 되어있는 css를 제외하고는 inline 형식으로 작성하기로 결정 4-2. 두번째 이슈_스타일드 컴포넌트? 인라인 스타일핫한 스타일드 컴포넌트를 쓸까 인라인 스타일로 작업을 할까 고민했었다. 지금 생각해보면 과감하게 쓸껄…이라고 생각이 든다. 러닝커브가 있을 듯 하여 인라인 스타일로 작업하게 되었다. Issue인라인스타일로 작업하다보니 :hover, :before, :after과 같은 셀렉터를 사용하지 못했고, css를 부분 부분 섞어 쓰게 되었다. 스타일드 컴포넌트는 이를 해결해주는데.. 그냥 쓸껄! 5. 의존모듈 셋팅디자인 시안을 보면, 필요한 서드파티는 일기탭의 에디터 그래프 차트 5-1. 일기탭 에디터 개인적으로 summernote를 좋아하는데, 리액트 친화적이지 않아서 포기 리액트 친화적인 모듈을 찾다가 페이스북에서 만든 draft.js를 사용하기로 결정. 나중에 설명하겠지만, 에디터는 post로 보내기 전에 html 형식으로 export했어야 했고, 이 부분에서 많은 난관에 봉착했었다. draft-js-export-html로 해결 5-2. 그래프 차트 react d3를 사용하려고 했으나, 디자인 시안과 비슷하지 않다는 점, 커스텀이 어려운 점이 있었다. 두번째 찾은 차트는 Uber에서 나온 react-vis 리액트 친화적. 세번째 찾은 차트는 rechart react와 d3로 만들어졌고, UI가 서비스 컨셉과 잘 어울려서 선택하게 됨. 이또한 나중에 설명하겠지만, 그래프에 데이터를 넣는 구조와 서버에서 날라오는 데이터 구조가 많이 달랐기 때문에 프론트에서 다시 셋팅하는 작업이 필요했음. 3. 퍼블리싱 &#128153;프론트엔드는 2명이었다. 각자 하고싶은 페이지를 맡아서 진행했다. 퍼블리싱은 항상 즐겁다! &#128582; 퍼블리싱하면서 발생한 이슈만 정리하겠다. + 간단 라우팅 작업 react-router-dom 의존모듈 주 사용 API BrowserRouter Route Link Switch (로그인 이후 바꾸주는 역할, 404페이지 라우팅) withRouter (중첩 라우팅할 때 사용) App.js에 셋팅 path / /diary tab용 router파일 따로 셋팅 /diary/food /diary/fitness /diary/review /report /weight /search/:sc /recipe/:id","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Retrospective","slug":"Personal-🙆/Retrospective","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Retrospective/"}],"tags":[{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"publishing","slug":"publishing","permalink":"http://feel5ny.github.io/tags/publishing/"}]},{"title":"7-1/ class 연습","slug":"Typescript_08-1","date":"2017-11-23T03:11:23.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2017/11/23/Typescript_08-1/","permalink":"http://feel5ny.github.io/2017/11/23/Typescript_08-1/","excerpt":"","text":"연습문제 1아래 자바스크립트를 타입스크립트로 바꾸시오 123456789101112131415161718function Car(name) &#123; this.name = name; this.speed = 0; this.honk = function() &#123; console.log(&quot;부우우웅&quot;); &#125;; this.accelerate = function(speed) &#123; this.speed = this.speed + speed; &#125;&#125;var car = new Car(&quot;BENZ&quot;);car.honk();console.log(car.speed);car.accelerate(10);console.log(car.speed); 1차 123456789101112131415161718class Car &#123; constructor(public name: string) &#123; &#125; public speed: number = 0 public honk(): void &#123; console.log(&#x27;부우우웅&#x27;) &#125; public accelerate(speed) &#123; this.speed = this.speed + speed; &#125; &#125;const car = new Car(&quot;BENZ&quot;);car.honk();console.log(car.speed);car.accelerate(10);console.log(car.speed); 2차 12345678910111213141516171819202122class Car &#123; constructor(private name: string) &#123; &#125; private _speed: number = 0 public honk(): void &#123; console.log(&#x27;부우우웅&#x27;) &#125; public accelerate(speed) &#123; this._speed = this.speed + speed; &#125; get speed(): number &#123; return this._speed; &#125;&#125;const car = new Car(&quot;BENZ&quot;);car.honk();console.log(car.speed);car.accelerate(10);console.log(car.speed); 3차 123456789101112131415161718192021222324252627interface ICar &#123; honk(): void; accelerate(speed: number): void &#125;class Car &#123; constructor(private name: string) &#123; &#125; private _speed: number = 0 public honk(): void &#123; console.log(&#x27;부우우웅&#x27;) &#125; public accelerate(speed) &#123; this._speed = this._speed + speed; &#125; get speed(): number &#123; return this._speed; &#125;&#125;const car = new Car(&quot;BENZ&quot;);car.honk();console.log(car.speed);car.accelerate(10);console.log(car.speed);","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"7/ class(2)","slug":"Typescript_08","date":"2017-11-22T01:32:11.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2017/11/22/Typescript_08/","permalink":"http://feel5ny.github.io/2017/11/22/Typescript_08/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 요약class에서 선언된 멤버변수와 멤버함수를 외부에서 접근이 가능하게 하는 방법, 재선언할 수 있도록 컨트롤하는 방법을 배웁니다. 생성자에도 private화하여 class 내부에서만 선언이 가능하도록 하며, 이는 singleTon 패턴을 정확하게 배치 가능할 수 있게 합니다. readonly 키워드를 붙여서 getter의 역할만 가능하도록 할 수 있습니다. 1. class getter, setterget, set을 하는 중에 무언가를 해주기 위해서 사용한다. get과 set 사이에 추가적인 작업이 있을 때 사용한다. _ 를 변수명 앞에 붙이고, 내부에서만 사용한다. getter를 함수처럼 설정하면, 프로퍼티처럼 꺼내쓸수있다. 마찬가지로 setter 를 함수처럼 설정하면, 추가 작업을 하고 셋팅할 수 있다. 강사님은 getter setter가 혼란을 줄 수 있는 경우가 있어서 사용하지 않고, 대신 메서드를 같은 역할을 하는 메서드를 만드는데 메서드의 이름을 getName, setName으로 짓는다고 하셨따. 12345678910111213141516171819202122232425class Person &#123; private _name: string; private _age: number; constructor(name: string, age: number) &#123; this._name = name; this._age = age; &#125; get name() &#123; return this._name; &#125; set name(name: string) &#123; // 작업 this._name = `$&#123;name&#125; Lee`; &#125;&#125;const person: Person = new Person(&#x27;Mark&#x27;, 35);console.log(person.name);person.name = &#x27;Woongjae&#x27;;console.log(person.name); gettergetter는 어떤 멤버 변수에 접근할 때마다 멤버 변수의 값을 조작하는 행위가 필요할 때 사용한다. 사용 방법은 아래와 같다. settersetter는 어떤 멤버 변수에 값을 할당할 때마다 멤버 변수의 값을 조작하는 행위가 필요할 때 사용한다. 사용 방법은 아래와 같다. 2. class 멤버변수객체지향의 class와 거의 유사하다. static property와 static method가 있다. static 키워드를 붙힌 프로퍼티는 클래스.프로퍼티로 사용한다. static 프로퍼티에 private, protected 를 붙히면 똑같이 동작한다. public static은 외부에서 변경이 가능하다. default는 public이다. 12345678910111213141516171819class Person &#123; public static CITY = &quot;&quot;; private static lastName: string = &#x27;Lee&#x27;; private _name: string; private _age: number; constructor(name: string, age: number) &#123; this._name = name; this._age = age; &#125; public print() &#123; console.log(`$&#123;this._name&#125; $&#123;Person.lastName&#125; in $&#123;Person.CITY&#125;.`); &#125;&#125;const person: Person = new Person(&#x27;Mark&#x27;, 35);Person.CITY = &#x27;Seoul&#x27;;person.print(); // Mark Lee in Seoul. 3. class 멤버함수1234567class Person &#123; public static Talk(): void &#123; console.log(&#x27;안녕하세요.&#x27;); &#125;&#125;Person.Talk(); // 안녕하세요. public static은 의미가 있다.private static 메소드와 프로퍼티는 무슨 의미가 있나?대부분 한 ts파일에 한 class를 사용하고, 모듈을 다른곳에서 쓰기위해서 export import를 쓴다. private static? 사용시 class의 private static과 ts파일 안의 제일 상단에 있는 const 변수와 어떤 차이가 있나? 라고 할때 애매하다. private이라 애매한 것. 4. class private static property or method12345678910111213141516171819202122232425class Person &#123; private static PROPERTY = &#x27;프라이빗 프로퍼티&#x27;; private static METHOD() &#123; console.log(&#x27;프라이빗 메서드&#x27;); &#125; constructor() &#123; console.log(Person.PROPERTY); Person.METHOD(); &#125;&#125;//////////////////////////////////////////////const PROPERTY = &#x27;모듈 내 변수&#x27;;function METHOD() &#123; console.log(&#x27;모듈 내 함수&#x27;);&#125;export class Person &#123; constructor() &#123; console.log(PROPERTY); METHOD(); &#125;&#125; 5. Abstract Class &#128566; abstract 키워드가 사용된 클래스는 new 로 생성할 수 없다. abstract 키워드가 사용된 클래스를 상속하면 abstract 키워드가 붙은 함수를 구현해야 한다. 1234567891011121314abstract class APerson &#123; protected _name: string = &#x27;Mark&#x27;; abstract setName(name: string): void; &#125;class Person extends APerson &#123; setName(name: string): void &#123; this._name = name; &#125;&#125;// const person = new APerson(); // (X)const person = new Person(); 6. private constructor 생성자 함수 앞에 접근제어자인 private 을 붙일 수 있다. 외부에서 생성이 불가능하다. 내부에서 생성하는 방법을 써야하고, 그러다보니 싱글톤 패턴을 정확하게 배치해서 사용할 수 있게 되었다. 1234567class Preference &#123; private constructor() &#123; &#125;&#125;// const p: Preference = new Preference(); (X) 7. singleTon &#128580;자바스크립트의 함수는 new로 생성자를 사용할 때마다 새로이 생성된 객체를 리턴합니다. 하지만 특수한 상황에서는 하나의 함수에서 생성되는 객체가 오직 한개만을 가져야 할 때가 있다. 그럴 경우 사용되는 디자인 패턴이 Singleton Pattern 싱글턴 패턴 : 객체리터럴이 싱글턴 패턴의 대표적. 모듈패턴을 변형한 디자인 패턴 처음 namespace를 만들 때 사용한다. 게임을 실행할 때 게임은 한번만 켜져야 하기 때문에 싱글턴이 적절. private 생성자를 이용해서 내부에서만 인스턴스 생성이 가능하도록 함. pubilc static 메서드를 통해 private static 인스턴스 레퍼런스를 획득한다. Lazy Loading (Initialization) : 최초 실행시가 아니라, 사용시에 할당을 함 1234567891011121314151617class Preference &#123; public static getInstance() &#123; // 유일 객체가 정의되지 않았다면 객체를 생성. if (Preference.instance === null) &#123; Preference.instance = new Preference(); &#125; return Preference.instance; &#125; private static instance: Preference = null; private constructor() &#123; &#125;&#125;const p: Preference = Preference.getInstance(); 8. readonlyprivate인데 get, set중 get만 있는 상황과 같다. private readonly 로 선언된 경우, 생성자에서는 할당이 가능하다. private readonly 로 선언된 경우, 생성자 이외에서는 할당이 불가능하다. public readonly 로 선언된 경우, 클래스 외부에서는 다른값을 할당할 수 없다. 마치 getter 만 있는 경우와 같다. 12345678910111213141516class Person &#123; private readonly _name: string = null; public readonly age: number = 35; constructor(name: string) &#123; this._name = name; &#125; public setName(name: string) &#123; // this._name = name; (X) &#125;&#125;const p: Person = new Person(&#x27;Mark&#x27;);console.log(p.age);// p.age = 36; // (X) 참고링크 http://poiemaweb.com/es6-class http://blog.javarouka.me/2012/02/javascripts-pattern-1-singeton-patterrn.html http://karl27.tistory.com/10","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"6/ class(1)","slug":"Typescript_07","date":"2017-11-21T01:32:11.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2017/11/21/Typescript_07/","permalink":"http://feel5ny.github.io/2017/11/21/Typescript_07/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. TL;DR타입스크립트에서 주로 사용되는 class의 기초에 대해서 배웁니다. es6에 도입된 class와, public, private, protected 키워드로 class에 접근제어하는 방법을 배우고, class간의 상속 개념을 배웁니다. 1. class 기초 생성자 함수(constructor)가 없으면, 디폴트 생성자가 불린다. 클래스의 프로퍼티 혹은 멤버 변수가 정의되어 있지만, 값을 대입하지 않으면 undefined 이다. &#x3D;&gt; 오브젝트에 프로퍼티가 아예 존재하지 않는다. 접근제어자 (Access Modifier)는 public이 디폴트이다. 1234567891011121314class Person &#123; // name과 age는 프로퍼티 // class 바디에는 메소드와 프로퍼티만 포함할 수 있다. name: string = null; age: number = null; constructor(name:string) &#123; this.name = name; // constructor 내부에서 선언한 멤버변수는 this에 바인딩되어 있으므로 언제나 public이다. &#125; // 퍼블릭&#125;// class에서 default가 public이다.const person = new Person(&#x27;Clara&#x27;);// 인스턴스를 생성할 때 new 연산자와 함께 호출한 것이 바로 constructor이며 constructor의 파라미터에 전달한 값은 멤버 변수에 할당한다.console.log(person.name)console.log(person.age) // undefined 2. class property constructor이외에 프로퍼티들을 포함시킬 수 있다. 프로퍼티에도 값을 할당할 수 있다. 호출시 프로퍼티에 다시 값을 할당하게 되면, 마지막에 할당된 값이 출력된다. 12345678910111213141516class Person &#123; name: string = &#x27;Clara&#x27;; age: number = 27; constructor() &#123; console.log(this.name === null); // false console.log(this.name === undefined); // true &#125;&#125;const person: Person = new Person();person.name = &#x27;nayoung&#x27;;person.age = 35;console.log(person); // Person &#123;name: &#x27;nayoung&#x27;, age: 35&#125;// Person의 프로퍼티가 불린 후에 person.name에 다시 할당된 값이 불리어지므로 결론적으로는 &#x27;nayoung&#x27;이 출력된다. 3. class Access Modifierprivate 절대적으로 접근이 불가능하다. private 으로 설정된 프로퍼티는 dot(.)으로 접근할 수 없다. 클래스 내부에서는 private 프로퍼티를 사용할 수 있다. private이 붙은 변수나 함수는 _ 를 이름앞에 붙이는데, 이는 문법이 아니라 널리 쓰이는 코딩 컨벤션이다. 앞에 밑줄과 변수명을 쓰면 private이라는 코딩컨벤션 중 하나였다. 12345678910111213class Person &#123; public name: string; private _age: number; constructor(age: number) &#123; this._age = age; &#125;&#125;const person: Person = new Person(35);person.name = &#x27;Mark&#x27;;// person._age (X)console.log(person); // Person &#123;name: &#x27;Mark&#x27;, _age: 35&#125; protected부모자식간의 관계에서 상속을 받은 class는(자식) 부모에는 접근 가능하다. 부모에서 private 으로 설정된 프로퍼티는 상속을 받은 자식에서도 접근할 수 없다. 부모에서 protected 로 설정된 프로퍼티는 상속을 받은 자식에서 접근이 가능하다. 상속을 받은 자식 클래스에서 부모 클래스에 this 를 통해 접근하려면, 생성자에서 super(); 를 통해 초기화 해야한다. super란? super키워드는 부모 클래스의 프로퍼티를 참조할 때 또는 부모 클래스의 constructor를 호출할 때 사용한다. 1234567891011121314151617class Parent &#123; private privateProp: string; protected protectedProp: string; constructor() &#123; &#125;&#125;class Child extends Parent &#123; constructor() &#123; super(); // 아래의 멤버변수와 순서가 바뀌어도 에러가 난다! this.protectedProp = &#x27;protected&#x27;; // this.privateProp = &#x27;private&#x27;; // (X) &#125;&#125; 4. class default constructor 디폴트 생성자는 프로그래머가 만든 생성자가 없을 때 사용할 수 있다. 사용자가 만든 생성자가 하나라도 있으면, 디폴트 생성자는 사라진다.1234567891011class Person &#123; public name: string; private _age: number; constructor(age: number) &#123; this._age = age; &#125;&#125;const person: Person = new Person(); 5. class &amp; method 클래스 내부에 작성된 메서드는 public 이 디폴트 arrow function 으로 작성 가능 private 을 이용하면 클래스 외부에서 접근 불가 123456789101112131415161718192021class Person &#123; constructor(private _name: string, private _age: number) &#123; &#125; print(): void &#123; console.log(`이름은 $&#123;this._name&#125; 이고, 나이는 $&#123;this._age&#125; 살 입니다.`); &#125; printName = (): void =&gt; &#123; // arrow function console.log(`이름은 $&#123;this._name&#125; 입니다.`); &#125; private printAge(): void &#123; console.log(`나이는 $&#123;this._age&#125; 살 입니다.`); &#125;&#125;const person: Person = new Person(&#x27;Mark&#x27;, 35);person.print(); // 이름은 Mark 이고, 나이는 35 살 입니다.person.printName(); // 이름은 Mark 입니다.// person.printAge(); // (X) 6. class extends 상속은 extends 키워드를 이용한다. 자식 클래스에서 디폴트 생성자는 부모의 생성자와 입력 형태가 같다. 123456789101112131415161718192021222324class Parent &#123; constructor(protected _name: string, protected _age: number) &#123; &#125; print(): void &#123; console.log(`이름은 $&#123;this._name&#125; 이고, 나이는 $&#123;this._age&#125; 살 입니다.`); &#125; printName = (): void =&gt; &#123; console.log(`이름은 $&#123;this._name&#125; 입니다.`); &#125; private printAge(): void &#123; console.log(`나이는 $&#123;this._age&#125; 살 입니다.`); &#125;&#125;class Child extends Parent &#123; _name = &#x27;Mark Jr.&#x27;; // 나중에 할당된 값이 출력된다. &#125;// const p: Child = new Child(); // (X)const p: Child = new Child(&#x27;&#x27;, 5);p.print(); // 이름은 Mark Jr. 이고, 나이는 5 살 입니다. 생성자를 정의하고, this 를 사용하려면, super 를 통해 부모의 생성자를 호출해줘야 한다. super를 호출할때는 부모 생성자의 입력 타입이 같아야 한다. super를 호출하는 것은 클래스 외부에서 호출하는 것과 같다. protected 함수를 호출해서 그 안의 private 을 출력하는 것에 주의한다.12345678910111213141516171819202122232425262728class Parent &#123; constructor(protected _name: string, private _age: number) &#123; &#125; print(): void &#123; console.log(`이름은 $&#123;this._name&#125; 이고, 나이는 $&#123;this._age&#125; 살 입니다.`); &#125; protected printName = (): void =&gt; &#123; console.log(`이름은 $&#123;this._name&#125; 입니다.`); &#125; protected printAge(): void &#123; console.log(`나이는 $&#123;this._age&#125; 살 입니다.`); &#125;&#125;class Child extends Parent &#123; constructor(age: number) &#123; super(&#x27;Mark Jr.&#x27;, age); this.printName(); this.printAge(); &#125;&#125;const p: Child = new Child(1);// 이름은 Son 입니다.// 나이는 1 살 입니다. 참고링크 http://poiemaweb.com/es6-class","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"03 days/ 기획 및 프로토타입, 그리고 디자인","slug":"dada_01week","date":"2017-11-21T01:10:04.000Z","updated":"2024-11-23T11:40:31.101Z","comments":true,"path":"2017/11/21/dada_01week/","permalink":"http://feel5ny.github.io/2017/11/21/dada_01week/","excerpt":"","text":"Daily scrum +Github + 개발부분부터 보길 원하신다면 다음 포스팅부터 읽으셔도 됩니다. 정말 3일만에 끝내신건가요?개발 공부를 하고 있던 만큼, 개발 이외의 시간들은 최대한 단축하고 싶었다. 우리 모두 비슷한 마음이었고, 다행히 이 부분의 스케줄을 잘 조정할 수 있었다. 사실 기획 스탭은 굉장히 중요한 시간이라는건 안다.. 한달이라는 기간이 주어졌기 때문에 선택과 집중을 해야하는 상황에서 우리는 개발기간을 선택했다. 다행히 각 스탭별로 능력을 갖고 있던 팀원들이 모였기 때문에, 이 부분에 대한 커뮤니케이션은 잘 진행되었고, 모두가 물어보는 그 3일만에 개발에 들어갈 수 있었다.(여기서 말한 3일은 아이데이션 기간은 제외한 기간이다.) 목차 아이데이션 와이어프레임 및 스토리보드 프로토타입 디자인 1. 아이데이션아이디어 논의 회의는 3일 중에.. 끝낸건 아니다ㅎ 그래도 2번의 회의 끝에 확정하게 되었다.9월 7일 팀빌딩을 마치고, 25일 첫 팀프로젝트 오리엔테이션 전까지 2번의 회의를 진행했다. 1차회의 서비스 주제의 경우, 요리에 관심이 많던 팀원의 의견에서부터 시작했다. 요리로 키워드가 좁혀지고, 요리로 끊임없는 마인드맵을 그리다가, 첫 회의때는 주제는 결정하지 못했다.그리고 첫 회의 때인만큼, 각자 하고 해보고싶은 테크에 대해서도 같이 얘기해보았는데, 그중 Google Cloud Platform (이하 GCP)의 **Vision api**를 사용하자는 의견이 나왔다. 간단하게 얘기하자면 사진을 분석하여 어떤 물체가 있는 사진인지 단어를 여러가지 던져주는 api이다. 사실 이외에도 여러 의견들이 나왔었다. 일랙트론, 얼굴인식 api, 등등.. 1차회의의 결론은 요리로 좁혀졌다는 것. 2차회의 1차회의가 끝난 후 2차회의 전까지 집에서 이것저것 생각 해보았다. 요리와 사진을 접목시켜서 나올 수 있는 서비스가 무엇일까. 요리를 사진 찍어서 올릴 상황은 언제인거지.그러다 문득 네이버 블로그 이웃은 다이어트 컨설팅을 하는 언니가 떠올랐다. 그분이 주로 컨설팅 하는 방식은 컨설팅 받은 사람이 칼로리 계산과 영양소를 잘 조절해서 건강한 식사를 해 줄 수 있도록 도와주는 방식인데, 이때 사용하는 방법은 그 사람의 SNS에 무조건 식단 사진을 올리고 칼로리, 영상소를 기록하게 한다. 컨설턴트는 그 내용을 확인하고 1:1로 상담을 진행한다. 오케이. 무조건 사진을 올려야한다는 조건과 음식이라는 조건이 일치했고, 2차 회의 때 제시해보았다. 저번 회의때 요리라는 키워드 때문에 레시피 서비스도 얘기했었는데, 레퍼런스를 찾다가 로푸드 레시피를 제공하는 해외사이트를 공유한적이 있었다. 그때의 레퍼런스와 건강함을 추구하는 몇몇 팀원들 덕분에 ㅎㅎ 식단 다이어리 서비스로 확정.바로 러프한 아키텍처를 구상하고 회의를 마무리했다. 2. 와이어프레임 및 스토리보드 팀프로젝트 오리엔테이션 및 3차회의 4차 회의 기획안 발표 팀 프로젝트 오리엔테이션 3차회의팀 오리엔테이션때는 여러 재밌는 시간을 가졌는데, 프로젝트 시작 전 생각할 수 있는 위험요소를 공유하고, 어떻게 해결할지에 대해서 공유하는 시간을 가졌다. 지금 보니.. 귀여운 리스크들이네. Risk 각자의 욕심을 내세우는 커뮤니케이션 문제로 팀원 간의 관계 악화 충분한 테스트를 거치지 못해 최종 결과물이 오작동하거나 오류 발생 환경적 문제 : 소스 손실, 장비 고장 Solution 충분한 대화, 타협되지 않을 경우 각자 해당 부분을 담당 테스트 기간을 무조건 확보한다. 백업을 자주 한다. 간단 오리엔테이션과 전체 진행 일정을 들은 후, 팀 회의 시간을 갖게 되었다. 이날은 저번에 짠 아키텍처를 시각화하고, 구체적으로 어떻게 컨셉을 잡을지와 UI구성, 서비스 네이밍, 등을 정했다. 이번 회의때는 몇몇 이슈들이 있었는데 저번 회의가 끝나고, 각자 머리 속으로 구성한 부분이 조금씩 달랐다는 점이었다. 이 날은 그런 생각의 차이를 조정하는 시간을 가졌다.그리고 건강한 다이어트를 위한 식단 다이어리 서비스, DA DA 가 확정 되었다. 스토리보드 작업 (소요기간: 1일)와이어프레임 ( PDF version + &#x2F; Web version + ) Information Architecture 구조도 화면별 스토리보드 시나리오 3. 프로토타입 +프로토타입은 Invision, Sketch를 사용했다. 스토리보드를 참고하여 간단 목업스타일로 시안 작업을 진행했고, 인터렉션은 invision에서 작업, 전체 느낌과 컨셉을 확인하는 시간을 가졌다. 4. 디자인 +디자인은 간단하게 키워드를 잡고 진행했다. 심플 + 모던 + 산뜻최대한 음식을 먹고싶은 욕구를 억제했으면 좋겠다는 생각이 들어서 붉은 계열의 색상은 피했다. 식욕억제를 목적으로 블루계열 색상으로 key color를 잡았고, 블랙과 키칼리가 비슷한 비율로 사용되었기 때문에 강약조절이 필요했고, 키칼라에 좀더 힘을 주려기 위해 그라데이션을 사용하였다.프로토타입에서 목업작업을 잘 해놓았기 때문에 그래픽 작업에서는 수월하게 진행할 수 있었다. 역시 기초작업이 제일 중요. 최종 디자인 사안 이후 zeplin을 사용해서 팀원 전체와 공유하였다. 다음편! &gt;","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Retrospective","slug":"Personal-🙆/Retrospective","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Retrospective/"}],"tags":[{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"plan","slug":"plan","permalink":"http://feel5ny.github.io/tags/plan/"},{"name":"design","slug":"design","permalink":"http://feel5ny.github.io/tags/design/"},{"name":"prototype","slug":"prototype","permalink":"http://feel5ny.github.io/tags/prototype/"}]},{"title":"5/ interface","slug":"Typescript_06","date":"2017-11-20T13:10:56.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2017/11/20/Typescript_06/","permalink":"http://feel5ny.github.io/2017/11/20/Typescript_06/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. TL;DRinteface에 대해서 배웁니다. interface 내부에서 타입선언 후 변수에서 사용하며, 함수에서는 implements 키워드를 사용하여 interface를 상속받아 사용합니다. property를 ?를 사용하여 옵셔널하게 사용가능하며(안써도 되는 프로퍼티를 명시할 수 있음) interface 끼리 상속이 가능합니다. interface 자체를 함수화하여 사용가능하며, 내부에서는 출력값과 입력값의 타입을 명시합니다. indexable type으로도 옵셔널한 프로퍼티를 만들 수 있습니다. 1. interface 기초123456const person: &#123; name: string, age: number &#125; = &#123; name: &#x27;Mark&#x27;, age: 32&#125;// person이라는 오브젝트를 설명하고 있는 타입은 리터럴 타입인데,매번 리터럴방식으로 타입을 선언할것인가?// 아니오.. &gt; interface로 부르자. 12345678910interface Person &#123; name: string, age: number,&#125;const person: Person = &#123; name: &#x27;Mark&#x27;, age: 32&#125;// interface는 컴파일 이후에는 나타나지 않는다. 타입을 미리 interface에서 명시 한 후에 해당 interface를 넣어서 타입을 명시한다. 1234567function hello(입력값:입력값타입): 출력타입 &#123; ~&#125;const hello = (p:Person): void =&gt; &#123; console.log(p.name)&#125; 12345678910interface Person &#123; name: string, age: number,&#125;// 입력과 출력을 정확히 명시하지 않으면, // 추론을 하게 되는데 이는 문제가 될 수 있다.function hello(p: Person): void &#123; console.log(`안녕하세요. $&#123;p.name&#125; 입니다.`);&#125; 2. interface optional property2-1. 있어도 되고 없어도 되는 proerty를 설정 할 수 있다.123456789interface Person &#123; name: string, age: number,&#125;const person: Person = &#123; name: &#x27;Mark&#x27;, // age를 정의하지 않았기 때문에 person에 빨간줄이 생긴다.&#125; 123interface Person &#123; age? : number // &lt;= age 뒤에 ?를 붙이면 된다.&#125; 123456789interface Person &#123; name: string, age?: number, // 옵셔널한 프로퍼티 주는 방법&#125;const person: Person = &#123; name: &#x27;Mark&#x27;, // age는 optional한 property이기 때문에 없어도 오류가 나지 않는다.&#125; 2-2. indexable typeindexable type으로 optional한 타입을 사용 가능하다. 1234567891011121314151617// 1. array같은 타입이고// 2. 사전같은 타입이다.interface Person &#123; name: string; [index: string]: string; // person의 property명으로 인덱스가 어떤 타입이었는지에 따라서 // property.string 형태의 어떤 indexable type이 들어가면 나머지는 다 string으로 표현할 수 있다. // 사전같은 의미이다.&#125;const person: Person = &#123; name: &#x27;Clara&#x27;,&#125;person.anybody = &quot;Clara&quot;person[1] = &#x27;hi&#x27; // 배열형태로도 넣을 수 있다. person.anybody = &quot;Clara&quot; 이렇게 객체에 .을 붙인 후 프로퍼티로 타입을 옵셔널하게 줄 수 있기 때문에 optional type으로 사용이 가능하다는 뜻이다. (없어도 에러가 나지 않는다.) index는 string이거나 number만 가능하다. 1234567891011121314151617181920212223interface StringArray &#123; [index: number]: string;&#125;const sa: StringArray = &#123;&#125;; // 옵셔널하다, 안써도 에러가 안난다.sa[100] = &#x27;백&#x27;;interface StringDictionary &#123; [index: string]: string;&#125;const sd: StringDictionary = &#123;&#125;; // 옵셔널하다sd.hundred = &#x27;백&#x27;;interface StringArrayDictionary &#123; [index: number]: string; [index: string]: string;&#125;const sad: StringArrayDictionary = &#123;&#125;;// 당연히 옵셔널하다.sad[100] = &#x27;백&#x27;;sad.hundred = &#x27;백&#x27;; 123456789101112131415161718interface StringDictionary &#123; [index: string]: string; name: string;&#125;const sd: StringDictionary = &#123; name: &#x27;이름&#x27; // 필수&#125;;sd.any = &#x27;any&#x27;; // 어떤 프로퍼티도 가능////////////////////////////////////////////////interface StringDictionaryNo &#123; [index: string]: string; // name: number; // (X) 인덱서블 타입이 string 값을 가지기 때문에 number 를 필수로 끌어오면 에러&#125; 3. function in interfaceinterface 내부에 함수를 넣을 수 있다. 출력값의 타입을 명시해야한다.12345678910111213141516171819interface Person &#123; name: string; hello(): void; world(): string; nayoung(): string;&#125;const person: Person = &#123; name: &#x27;Mark&#x27;, hello: function (): void &#123; //void일 경우는 써도 되고 안 써도된다. &#125;, world(): string &#123; return &#x27;World&#x27; &#125;, nayoung: (): number =&gt; &#123; // ES6 문법 합수 사용시 return 1 &#125;&#125; 4. implements interface &#128580;interface를 상속받아서 class에서 사용가능하다. class 선언문의 implements 뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현하여야 한다. 12345678910111213141516171819202122interface IPerson &#123; name: string; hello(): void;&#125;// class 만들기. IPeron을 상속받았다.class Person implements IPerson &#123; // IPerson을 다 써줘야한다. name: string = null; constructor(name: string) &#123; // IPerson의 name을 this.name으로 받는다. this.name = name; &#125; hello(): void &#123; console.log(`안녕하세요. $&#123;this.name&#125; 입니다.`) &#125; public hi(): void &#123; console.log(`$&#123;this.name&#125;`) &#125;&#125;const person: IPerson = new Person(&#x27;Mark&#x27;);person.hello() 5. extends interface상속받는 인터페이스를 만들 수 있다. interface끼리 상속이 가능하다.12345678910111213interface Person &#123; name: string; age?: number;&#125;interface Korean extends Person &#123; city: string;&#125;const k: Korean = &#123; name: &#x27;이웅재&#x27;, city: &#x27;서울&#x27;&#125;; 6. function interface함수형 인터페이스이다. 함수의 타입 체크는 할당할 때가 아니라 사용할 때 한다는 점을 명심 function의 입출력을 바로 명시하지 않는다. 12345678910111213interface HelloPerson &#123; // (name: string, age: number): void; (name: string, age?: number): void;&#125;// helloPerson의 타입이 HelloPersonlet helloPerson: HelloPerson = function (name: string) &#123; // name:string을 넣지 않아도 에러가 안난다. =&gt; 호출할 때 에러가 난다. console.log(`안녕하세요! $&#123;name&#125; 입니다.`);&#125;;helloPerson(&#x27;Mark&#x27;); // 안녕하세요! Mark 입니다.helloPerson(); // 에러가 난다. 참고링크 http://poiemaweb.com/typeScript-interface","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"4/ 타입추론, Type assertions, Type alias","slug":"Typescript_05","date":"2017-11-18T06:13:11.000Z","updated":"2024-11-23T12:10:16.997Z","comments":true,"path":"2017/11/18/Typescript_05/","permalink":"http://feel5ny.github.io/2017/11/18/Typescript_05/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 목표이 포스팅과 interface 포스팅에서는 타입을 명시하는 방법을 배웁니다. 타입을 명시하지 않아도 추론이 가능하며, 강제 타입선언, 별명을 붙여가며 타입을 선언하는 방식 등을 배웁니다. 1. let과 const의 타입 추론123456let a: string = &#x27;진호&#x27;;let b = &#x27;승민&#x27;;const c: string = &#x27;나영&#x27;;const d = &#x27;슬기&#x27; // 리터럴 타입 const는 프리미티브 타입은 다른 값으로 못 바꾸고, 레퍼런스타입은 다른 레퍼런스타입을 가리키지 못하게 하는 것인데, 타입스크립트에서는 리터럴 타입이라고 하는 것으로 타입까지 강제해버린다. 즉 const에서 타입없이 선언될 경우 타입 추론에 의해서 할단된 값이 타입으로 된다. (리터럴 타입)ex. 위에서 const d = &#39;슬기&#39;에서 d는 const d:&#39;슬기&#39;라고 뜨고, 슬기라는 리터럴 타입으로 된다. 재할당 redeclare let은 재할당(redeclare)이 가능하다. const는 레퍼런스 타입은 레퍼런스 값이 바뀌는 것을 허용하지 않고, 속안의 프로퍼티 바꾸는 것은 허용된다. 프리미티브 타입은 재할당이 아예 불가능. 보통은 const를 사용하며, let을 쓰면서 명시적으로도 값이 바껴지는 변수라고도 표시한다. 2. Type assertions (assertions:’단언’) 형 변환과는 다르다.형 변환은 : 실제 데이터 구조를 바꾼다. &#39;타입이 이것이다&#39;라고 컴파일러에게 알려주는 것을 의미한다.예_넓은 범위의 타입이 (union타입) 어떤 상황에서 고정이 되어야할 경우, 타입 어셜션으로 타입을 강제해 준다. 방법은 2가지가 있다. 변수 as 강제할 타입 &lt;강제할타입&gt;변수 123456789let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;let strLength: number = (someValue as string).length;/*1. 주로 넓은 타입에서 좁은 타입으로 강제하는 경우가 많다.2. jsx 에서는 as 를 쓴다.*/ 3. Type alias (alias:’별명’)타입에 별명을 붙인다고 생각하면 된다. 타입이 생기는 것이 아니라, 따로 이름을 붙여주는 것이다. interface가 유사하지만 interface처럼 쓸수 없는 경우가 있다. Primitive나 Union Type, Tuple 같은 타입에서 쓴다.보통 Primitive 타입은 .. 많이 안쓴다. (number나 string을 구지..) 만들어진 타입의 refer로 사용하는 것이지 &#96;타입을 만드는 것은 아니다. type + 별칭 12345678// Aliaing Primitivetype MyStringType = string;const str = &#x27;world&#x27;;let myStr: MyStringType = &#x27;hello&#x27;;myStr = str;// string에 &#x27;world&#x27;라는 별명을 주었다.// 별 의미가 없다.. 123456789101112131415// Aliaing Union Typelet person: string | number = 0;person = &#x27;Mark&#x27;;type StringOrNumber = string | number;// StringOrNumber이라는 타입별칭을 붙였다. // 별칭 붙일 때는 앞에 type + 별칭let another: StringOrNumber = 0;another = &#x27;Anna&#x27;;/*1. 유니온 타입은 A 도 가능하고 B 도 가능한 타입2. 길게 쓰는걸 짧게*/ 12345678// Aliaing Tuplelet person: [string, number] = [&#x27;Mark&#x27;, 35];type PersonTuple = [string, number];let another: PersonTuple = [&#x27;Anna&#x27;, 24];/*1. 튜플 타입에 별칭을 줘서 여러군데서 사용할 수 있게 한다.*/ 3-1. Type alias와 Interface와 차이점보통은 interface와 class등을 자주 사용하기 때문에 alias 쓰는 타이밍이 초반에는 많이 없다. interface를 사용하다가 굳이 사용할 필요가 없는 순간에 alias를 쓰면 된다. 오류 메세지타입스크립트가 컴파일을 시도할때 오류가 나올때, Alias라는 이름으로 알려주지 않고 타입 자체로 알려준다. 12345678910111213type Alias = &#123; num: number &#125;interface Interface &#123; num: number;&#125;declare function aliased(arg: Alias): Alias;declare function interfaced(arg: Interface): Interface;/*1. type alias 는 object literal type 로2. interface 는 interface 로*/ 상속을 받을 수는 있지만 상속을 할 수는 없다. 당연한건 type alias 끼리는 extends, implements 불가 interface extends type alias 가능 class A implements type alias 가능&#x3D; A라는 클래스는 type alias 인터페이스를 구현할 수 있다. class A extends type alias 블가 (interface 도 마찬가지)&#x3D; A라는 클래스는 type alias를 상속받지 못한다. 마치 interface 처럼 동작한다. 클래스 선언문의 implements 뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현하여야 한다. 123456789101112131415161718192021222324252627282930type PersonAlias = &#123; name: string; age: number;&#125;; // type aliasinterface IPerson extends PersonAlias &#123;&#125; // 가능let ip: IPerson = &#123; name: &#x27;Mark&#x27;, age: 35&#125;;class PersonImpl implements PersonAlias &#123; name: string; age: number; hello() &#123; console.log(&#x27;안녕하세요&#x27;); &#125;&#125; // PersonImpl라는 클래스는 PersonAlias라는 인터페이스를 구현하겠다.let pi: PersonImpl = new PersonImpl();pi.hello();class PersonChild extends PersonAlias &#123;&#125; // 불가능 extends와 implements의 차이class A extends B 라고 하면A는 B라는 클래스를 상속 받아서 +a 시키겠다는 뜻.class A implements C 라고 하면A는 C라는 인터페이스를 구현하겠다~ 라는 뜻입니다. 참고링크 http://gdthink.blogspot.kr/2006/06/extends%EC%99%80-implements%EC%9D%98-%EC%B0%A8%EC%9D%B4.html http://poiemaweb.com/typeScript-interface","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"3/ Typescript_기본 데이터 타입","slug":"Typescript_04","date":"2017-11-17T03:33:40.000Z","updated":"2024-11-23T12:10:17.029Z","comments":true,"path":"2017/11/17/Typescript_04/","permalink":"http://feel5ny.github.io/2017/11/17/Typescript_04/","excerpt":"","text":"기본 데이터 타입 🌱타입스크립트에서 기본 자료형을 잘! 숙지해야 한다. 타입스크립트는 타입을 새로 만들면서 짜는 방식인데, 특정한 골격을 갖출 때 결국 남는건 기본 자료형들이 남는다. 이때 기본 자료형이 정확히 어떤 것들이 있는지 인지하고 있어야, 그 기본 자료형들을 잘 조합해서 내가 사용할 인터페이스를 만들어 낼 수 있고, 타입을 만들 수 있다. 자바스크립트의 기본자료형을 모두 포함한다. 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다 . 0. literal 값 자체가 변하지 않는 값을 의미합니다 . 상수와 다른 것은 상수는 가리키는 포인터가 고정이라는 것이고, 리터럴은 그 자체가 값이자 그릇입니다 . “리터럴 상수는 5, 1.23 과 같은 숫자나, ‘This is a string’ 혹은 “It’s a string!” 과 같은 문자열 등을 말합니다. 이것들이 리터럴 상수라고 불리우는 이유는 이것들이 프로그램 내에 직접 문자 형태로 (literally) 지정되는 값들 이기 때문입니다. 이러한 값들은 한번 지정되면 변하지 않습니다 . 예를 들면 숫자 2는 언제나 자기 자신이 2 라는 숫자임을 나타내며 어떤 다른 의미도 갖지 않습니다 . 이들은 한번 지정되면 그 값을 변경할 수 없기 때문에 상수입니다 . 그 중에서도 특별히 이러한 값들을 리터럴 상수라고 부릅니다. @kangpual 1. 기본 자료형 Primitive Type object 와 reference 형태가 아닌 실제 값을 저장하는 자료형입니다 . 프리미티브 형의 내장 함수를 사용 가능한것은 자바스크립트 처리 방식 덕분 동작 자체는 마치 객체인 것처럼 처리된다 . 메모리를 아끼기 위해서 123let name = &#x27;Nayoung&#x27;name.toString() 1-1. boolean 가장 기본적인 데이터 타입 단순한 true 혹은 false값 입니다 . JavaScript &#x2F; TypeScript 에서 ‘boolean’ 이라고 부른다 . 소문자 boolean 과 대문자 Boolean 소문자 boolean 은 프리미티브 타입의 불린 , 대문자 Boolean 은 레퍼 오브젝트의 생성자 class 인데 , 자바스크립트에서는 두 가지의 차이가 크게 없지만, 타입스크립트에서는 차이가 있다 . 타입스크립트에서는 소문자를 권장한다. Type &#39;boolean&#39; is assignable to type &#39;Boolean&#39;. Type ‘Boolean’ is not assignable to type ‘boolean’. ‘boolean’ is a primitive, but ‘Boolean’ is a wrapper object. Prefer using ‘boolean’ when possible. 1234567891011let isDone: boolean = falsetypeof isDone === &#x27;boolean&#x27; // true// Type &#x27;boolean&#x27; is assignable to type &#x27;Boolean&#x27;.let isOk: Boolean = true// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.// &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object.// Prefer using &#x27;boolean&#x27; when possible.let isNotOk: boolean = new Boolean(true) 1-2. number JavaScript 와 같이, TypeScript 의 모든 숫자는 부동 소수점 값 입니다. TypeScript 는 16진수 및 10진수 리터럴 외에도, ECMAScript 2015에 도입된 2진수및 8진수를 지원합니다. 1234let decimal: number = 6 // 10진수 리터럴let hex: number = 0xf00d // 16진수 리터럴let binary: number = 0b1010 // 2진수 리터럴let octal: number = 0o744 // 8진수 리터럴 1-3. string Template String을 자주 쓴다 . 다른 언어에서와 마찬가지로 텍스트 형식을 참조하기 위해 string형식을 사용한다. 자바스크립트와 마찬가지로, 타입스크립트는 문자열 데이터를 둘러싸기 위해 큰 따옴표나 작은따옴표를 사용한다. 12let name: string = &#x27;mark&#x27;name = &#x27;anna&#x27; 1-4. Template String 주로 사용한다. 행에 걸쳐 있거나, 표현식을 넣을 수 있는 문자열 이 문자열은 backtick (&#x3D; backquote &#96;&#96;&#96;) 기호에 둘러쌓여 있습니다. 포함된 표현식은 $&#123; expr &#125;와 같은 형태로 사용합니다. 123456789101112131415let fullName: string = `Bob Bobbington`let age: number = 37let sentence: string = `Hello, my name is $&#123;fullName&#125;.I&#x27;ll be $&#123;age + 1&#125; years old next month.`// template string 을 사용하지 않을 경우let sentence: string = &#x27;Hello, my name is &#x27; + fullName + &#x27;.\\n\\n&#x27; + &quot;I&#x27;ll be &quot; + (age + 1) + &#x27; years old next month.&#x27; 1-5. Undefined &amp; null TypeScript에서 ‘undefined’와 ‘null’은 실제로 각각 ‘undefined’와 ‘null’이라는 고유한 타입을 가집니다. ‘void’ 와 마찬가지로, undefined 와 null 은 그 자체로는 쓸모가 없습니다. 둘다 소문자만 존재합니다. 1234// 이 변수들에 할당할 수 있는 것들은 거의 없다.let u: undefined = undefinedlet n: null = null 위 처럼 사용하기 보다는 return에서 주로 사용 1-5-1. undefined &amp; null are subtypes of all other types 기본 설정이 그렇습니다. 대입이 가능하다는 것이다. number에 null 또는 undefined 를 할당할 수 있다는 의미입니다. 하지만, 컴파일 옵션에서 --strictNullChecks사용하면, null과 undefined 는 void 나 자기 자신들에게만 할당할 수 있습니다. 이 경우, null과 undefined를 할당할 수 있게 하려면, union type 을 이용해야합니다. (union type: 두개의 타입을 합치는 것.) 123456789101112131415161718// 대입 가능let name: string = nulllet age: number = undefined// strictNullChecks =&gt; true// 보통 위의 옵션을 true로 하진 않는다..// 위의 옵션이 추가되면 자기 자신이나 void에게만 할당 가능, 다른 타입에는 할당하지 못함.// let name: null = null; // (O)// Type &#x27;null&#x27; is not assignable to type &#x27;string&#x27;.let name: string = null // (X)// null =&gt; null || void, undefined =&gt; undefined || void// Type &#x27;null&#x27; is not assignable to type &#x27;undefined&#x27;.let u: undefined = null // (X)let v: void = undefined // (O)let union: string | null | undefined = &#x27;str&#x27; 1-5-2. null in JavaScript null 이라는 값으로 할당된 것을 null 이라고 합니다. 무언가가 있는데, 사용할 준비가 덜 된 상태. (undefined 는 무언가가 아예 준비가 안된 상태) null 이라는 타입은 null 이라는 값만 가질 수 있습니다. 런타임에서 typeof 연산자를 이용해서 알아내면 , object 입니다. 1234let n: null = nullconsole.log(n) // nullconsole.log(typeof n) // object 1-5-3. undefined in JavaScript 값을 할당하지 않은 변수는 undefined 라는 값을 가집니다. 무언가가 아예 준비가 안된 상태 object 의 property 가 없을 때도 undefined 입니다. 런타임에서 typeof 연산자를 이용해서 알아내면 , undefined 입니다. 1234let u: undefined = undefinedconsole.log(u) // undefinedconsole.log(typeof u) // undefined 2. 참조타입 (javaScript) 2-1. Array 원래 자바스크립트에서 array는 객체입니다. 사용방법 2가지 &#9996; Array&lt;타입&gt; (내부적으로 제네릭을 이용한 것이다.) 타입 [] 123let list: number[] = [1, 2, 3]let list: Array&lt;number&gt; = [1, 2, 3] 2-2. Symbol 🙄 ECMAScript 2015의 Symbol 입니다. 프리미티브 타입의 값을 담아서 사용합니다. 고유하고 수정불가능한 값으로 만들어줍니다. 그래서 주로 접근을 제어하는데 쓰는 경우가 많았습니다. 1234567let sym = Symbol()let obj = &#123; [sym]: &#x27;value&#x27;,&#125;console.log(obj[sym]) // &quot;value&quot; 3. 타입스크립트에서 추가로 제공하는 타입 3-1. Void 타입이 없는 상태입니다. any 와 반대의 의미를 가집니다. Void 는 대문자가 없습니다. 소문자입니다. 주로 함수의 리턴이 없을 때 사용합니다. 그 외에는 사용할 일이 거의 없습니다. 12345function returnVoid(message): void &#123; console.log(message)&#125;returnVoid(&#x27;리턴이 없다&#x27;) 3-2. Any 어떤 타입이어도 상관없는 타입입니다. 이걸 최대한 쓰지 않는게 핵심입니다. 왜냐면 컴파일 타임에 타입 체크가 정상적으로 이뤄지지 않기 때문입니다. 그래서 컴파일 옵션 중에는 any 를 쓰면 오류를 뱉도록 하는 옵션도 있습니다. noImplicitAny 12345function returnAny(message): any &#123; console.log(message)&#125;returnVoid(&#x27;리턴은 아무거나&#x27;) 3-3. Never 리턴에 주로 사용된다. 아래의 3 가지 정도가 대부분 1234567891011121314// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message)&#125;// Inferred return type is neverfunction fail() &#123; return error(&#x27;Something failed&#x27;)&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; 3-4. Tuple 배열인데 타입이 한가지가 아닌 경우 마찬가지로 객체입니다. 꺼내 사용할때 주의가 필요합니다. 배열을 Destructuting 하면 타입이 제대로 얻어집니다. 12345678910111213141516// Declare a tuple typelet x: [string, number]// Initialize itx = [&#x27;hello&#x27;, 10] // OK// Initialize it incorrectlyx = [10, &#x27;hello&#x27;] // Errorx[3] = &#x27;world&#x27; // OK, &#x27;string&#x27; can be assigned to &#x27;string | number&#x27;console.log(x[5].toString()) // OK, &#x27;string&#x27; and &#x27;number&#x27; both have &#x27;toString&#x27;x[6] = true // Error, &#x27;boolean&#x27; isn&#x27;t &#x27;string | number&#x27;const person: [string, number] = [&#x27;mark&#x27;, 35]const [name, age] = person 3-5. Enum C 에서 보던것과 같습니다. 아래 예제만 이해하면 사용 준비 끝 Enum 의 결과값은 string 형이다. Da,Da 할때 아침 &#x2F; 점심 &#x2F; 저녁 &#x2F; 간식을 Enum 타입으로 받았는데 , 이때 문자열이였기 때문에 *1을 해줬었다 . 1234567891011enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green;enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green;enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2]; // 결과값은 string으로 해야한다. 참고링크 http://jaroinside.tistory.com/10 http://poiemaweb.com/typeScript-vscode http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"2016년 A월 B일","slug":"algorithm_02","date":"2017-11-16T04:42:33.000Z","updated":"2024-11-23T12:10:59.665Z","comments":true,"path":"2017/11/16/algorithm_02/","permalink":"http://feel5ny.github.io/2017/11/16/algorithm_02/","excerpt":"","text":"2016년 A월 B일2016년 1월 1일은 금요일입니다. 2016년 A월 B일은 무슨 요일일까요? 두 수 A,B를 입력받아 A월 B일이 무슨 요일인지 출력하는 getDayName 함수를 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각SUN,MON,TUE,WED,THU,FRI,SAT를 출력해주면 됩니다. 예를 들어 A&#x3D;5, B&#x3D;24가 입력된다면 5월 24일은 화요일이므로 TUE를 반환하면 됩니다. 1. 처음 생각한 로직 월마다 일 수가 다르다.a월이 1,3,5,7,10,12 &gt; 31일a월이 4,6,8,9,11 &gt; 30일a월이 2 &gt; 28일 일별로 요일이 다르다.const day = [&quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;]7일 day[0]6일 day[6] 전체 일수가 x라면x일을 7로 나눈후 나머지값 arr[x%7]x의 값은 ? 전체 일수를 배열과 연결하자.31일 + 1 &#x3D; 32 &#x2F;&#x2F; 배열에서 금요일부터 32번 후의 값1월 02월 31일 + b3월 31일 + 29일 + b4월 31일 + 29일 + 31일 + b5월 31일 + 29일 + 31일 + 30일 + b6월 31일 + 29일 + 31일 + 30일 + 31일 &#x3D; 31일 * 3 + 30일 * 2 - 17월 31일 * 3 + 30일 * 3 -18월 31일 * 4 + 30일 * 3 -19월 31일 * 5 + 30일 * 3 -110월 31일 * 5 + 30일 * 4 -111월 31일 * 6 + 30일 * 4 -112월 31일 * 6 + 30일 * 5 -1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function getDayName(a, b) &#123; let answer = &quot;&quot;; let month = a; let date = 0; let inputDate = b; let week = 0; const day = [&quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;] switch (month) &#123; case 1: date = 0 break; case 2: date = 31 break; case 3: date = 31 + 28 break; case 4: date = 31 * 2 + 29 break; case 5: date = 31 * 2 + 30 * 2 - 1 break; case 6: date = 31 * 3 + 30 * 2 - 1 break; case 7: date = 31 * 3 + 30 * 3 - 1 break; case 8: date = 31 * 4 + 30 * 3 - 1 break; case 9: date = 31 * 5 + 30 * 3 - 1 break; case 10: date = 31 * 5 + 30 * 4 - 1 break; case 11: date = 31 * 6 + 30 * 4 - 1 break; case 12: date = 31 * 6 + 30 * 5 - 1 break; &#125; date = date + inputDate return day[date % 7];&#125;//아래 코드는 테스트를 위한 코드입니다.console.log(getDayName(5, 24)); 2. case 문이 너무 비효율적이다. &gt; 반복문으로 바꾸자123456789101112function getDayName(a, b) &#123; let answer = [&quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;,]; let month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; let sum = 0; for (let i = 0; i &lt; a - 1; i++) &#123; sum += month[i]; &#125; sum += b; return answer[(sum % 7)];&#125; 3. Date 메소드를 사용해보자.메소드 사용 123456function getDayName(a, b) &#123; let arr = [&#x27;SUN&#x27;, &#x27;MON&#x27;, &#x27;TUE&#x27;, &#x27;WED&#x27;, &#x27;THU&#x27;, &#x27;FRI&#x27;, &#x27;SAT&#x27;]; let date = new Date(`2016,$&#123;a&#125;,$&#123;b&#125;`); let day = date.getDay() return arr[day];&#125; 템플릿 리터럴을 사용하지 않으면 값이 이상하게 나온다. 이유 1234new Date();new Date(value);new Date(dateString);new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); ** dateString*날짜를 표현하는 문자열값. 문자열은 parse 메소드에 의해 인식가능한 형식이어야 한다. ** year, month, date*날짜의 각 부분을 표현하는 정수값. 월(month)부분은 0부터 11까지의 값을 가지며, 0이 1월을, 11이 12월을 가리킨다. 때문에 템플릿 리터럴로 넣게 되면 문자열이 되어서 그대로 파싱하지만, 숫자일 경우 배열의 인덱스값으로 인지하여서 월의 시작숫자가 0이게 된다.즉, let date &#x3D; new Date(2016,a-1,b) 이렇게 넣어야 한다. 참고링크 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Algorithm","slug":"01-Web/zz-Algorithm","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Algorithm/"}],"tags":[{"name":"algorism","slug":"algorism","permalink":"http://feel5ny.github.io/tags/algorism/"}]},{"title":"2/ Typescript_tsconfig.json 프로퍼티의 종류","slug":"Typescript_03","date":"2017-11-15T10:30:01.000Z","updated":"2024-11-23T12:10:16.974Z","comments":true,"path":"2017/11/15/Typescript_03/","permalink":"http://feel5ny.github.io/2017/11/15/Typescript_03/","excerpt":"","text":"타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 컴파일러 옵션실제 프로젝트에서는 컴파일러 옵션을 그렇게 많이 셋팅하진 않는다 . 옵션을 셋팅할 수 있는 전체 스펙은 이 링크로 가면 확인가능하다 . 1. 최상위 프로퍼티 tsconfig.json 파일에서 제일 상위에 정의되어있는 컴파일 옵션들 compileOnSave extends compileOptions ( 초기에는 compileOptions 요소가 많이 존재한다 .) files include exclude 2. compileOnSave파일 변경 후 저장하면 바로 컴파일을 해준다 . 에디터마다 안될 수도 있다. true &#x2F; false (default false) true 이면 저장하면 바로 컴파일됨 최상단에 설정해야 한다. 누가 ?? Visual Studio 2015 with TypeScript 1.8.4 이상 atom-typeScript 플러그인 3. extends보통 많이 사용하지 않는다 . 사용 예를 들면 , 클라이언트 타입스크립트와 서버사이드 타입스크립트가 있을 때, 설정이 비슷하다면 어떤 파일을 만든 후, 상속을 받아서 작은 부분만 바꿔서 쓰는 경우 사용 가능하다. 파일 (상대) 경로명 : string TypeScript 2.1 New Spec 12345678910111213141516 // in config/base.json&#123; &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: true, &quot;strictNullChecks&quot;: true &#125;&#125;// in tsconfig.json&#123; &quot;extends&quot;: &quot;./configs/base&quot;, &quot;files&quot;: [ &quot;main.ts&quot;, &quot;supplemental.ts&quot; ]&#125; 4. files, include, exclude 셋다 설정이 없으면 , 전부다 컴파일 files 상대 혹은 절대 경로의 리스트 배열. 파일별 부분 컴파일이 된다. exclude 보다 쎕니다. (exclude가 해놓아도 files 에 있으면 컴파일 실행된다는 뜻) 특정 폴더를 exclude가 있어도 컴파일 된다. include, exclude glob 패턴 (마치 .gitignore) include exclude 보다 약하다. 같은걸 사용하면 , .ts &#x2F; .tsx &#x2F; .d.ts 만 include (allowJS) exclude 설정 안하면 4가지 (node_modules, bower_components, - jspm_packages, )를 default 로 제외한다 . 은 항상 제외합니다 . (include 에 있어도 ) 5.@types (중요 !)TypeScript 2.0 부터 사용 가능해진 내장 type definition 시스템 이전 버전에서는 사용하지 못한다. 아무 설정을 안하면 ? node_modules&#x2F;@types 라는 모든 경로를 찾아서 사용 typeRoots 를 사용하면 ? 배열 안에 들어있는 경로들 아래서만 가져옵니다 . types 를 사용하면 ? 패키지 이름입니다. 배열 안의 모듈 혹은 ./node_modules/@types/ 안의 모듈 이름에서 찾아옵니다 . [] 빈 배열을 넣는다는건 이 시스템을 이용하지 않겠다는 것입니다 . 블루베리 플젝에서는 types 를 사용한다 . typeRoots 와 types 를 같이 사용하지 않습니다 . 1234567891011121314151617181920212223// compiileOptions : type&#123; &quot;type&quot;: &quot;object&quot;, &quot;description&quot;: &quot;Instructs the TypeScript compiler how to compile .ts files.&quot;, &quot;properties&quot;: &#123; &quot;typeRoots&quot;: &#123; &quot;description&quot;: &quot;Specify list of directories for type definition files to be included. Requires TypeScript version 2.0 or later.&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125;, &quot;types&quot;: &#123; &quot;description&quot;: &quot;Type declaration files to be included in compilation. Requires TypeScript version 2.0 or later.&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125;&#125; 6. compileOptions6-1. target과 lib1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; &quot;type&quot;: &quot;object&quot;, &quot;description&quot;: &quot;Instructs the TypeScript compiler how to compile .ts files.&quot;, &quot;properties&quot;: &#123; &quot;target&quot;: &#123; &quot;description&quot;: &quot;Specify ECMAScript target version. Permitted values are &#x27;es3&#x27;, &#x27;es5&#x27;, &#x27;es2015&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27; or &#x27;esnext&#x27;.&quot;, &quot;type&quot;: &quot;string&quot;, &quot;default&quot;: &quot;es3&quot;, &quot;anyOf&quot;: [ &#123; &quot;enum&quot;: [ &quot;es3&quot;, &quot;es5&quot;, &quot;es2015&quot;, &quot;es2016&quot;, &quot;es2017&quot;, &quot;esnext&quot; // 확정은 아니지만 곧 확정될 것 같은 문법들을 모아둔 ] &#125;, &#123; &quot;pattern&quot;: &quot;^([eE][sS]([356]|(201[567])|[nN][eE][xX][tT]))$&quot; &#125; ] &#125;, &quot;lib&quot;: &#123; &quot;description&quot;: &quot;Specify library file to be included in the compilation. Requires TypeScript version 2.0 or later.&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [ &quot;es5&quot;, &quot;es6&quot;, &quot;es2015&quot;, &quot;es7&quot;, &quot;es2016&quot;, &quot;es2017&quot;, &quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;, &quot;webworker&quot;, &quot;scripthost&quot;, &quot;es2015.core&quot;, &quot;es2015.collection&quot;, &quot;es2015.generator&quot;, &quot;es2015.iterable&quot;, &quot;es2015.promise&quot;, &quot;es2015.proxy&quot;, &quot;es2015.reflect&quot;, &quot;es2015.symbol&quot;, &quot;es2015.symbol.wellknown&quot;, &quot;es2016.array.include&quot;, &quot;es2017.object&quot;, &quot;es2017.sharedmemory&quot;, &quot;esnext.asynciterable&quot; ] &#125; &#125;, &quot;noLib&quot;: &#123; &quot;description&quot;: &quot;Do not include the default library file (lib.d.ts).&quot;, &quot;type&quot;: &quot;boolean&quot; &#125; &#125;&#125; target 빌드의 결과물을 어떤 버전으로 할 것이냐 지정을 안하면 es3 입니다. lib 기본 type definition 라이브러리를 어떤 것을 사용할 것이냐 잘 정의하지 않으면 빨간줄이 계속 생긴다 . lib 를 지정하지 않을 때 , target 이 ‘es3’ 이고, 디폴트로 lib.d.ts 를 사용합니다. target 이 ‘es5’ 이면 , 디폴트로 dom, es5, scripthost 를 사용합니다 . target 이 ‘es6’ 이면, 디폴트로 dom, es6, dom.iterable, scripthost 를 사용합니다. es5 이후에는 문법별 쪼개서도 설정 가능하다 . ​lib 를 지정하면 그 lib 배열로만 라이브러리를 사용하니다. ​ 빈 [] &#x3D;&gt; ‘no definition found 어쩌구’ 혹은 &quot;noLib&quot; : true로 바꾸면 된다. ( 거의 안쓸듯 ) 6-2. compileOptions: outDir, outFile 파일을 다 모아서 하나의 컴파일된 하나의 파일로 모으고 싶을 때 outFile을 사용 소스디렉토리에 그대로 똑같이 구조를 컴파일된 상태로 옮길 때 outDir 를 사용 많이 사용한다 . 12345678910111213141516171819&#123; &quot;type&quot;: &quot;object&quot;, &quot;description&quot;: &quot;Instructs the TypeScript compiler how to compile .ts files.&quot;, &quot;properties&quot;: &#123; &quot;outFile&quot;: &#123; &quot;description&quot;: &quot;Concatenate and emit output to single file.&quot;, &quot;type&quot;: &quot;string&quot; &#125;, &quot;outDir&quot;: &#123; &quot;description&quot;: &quot;Redirect output structure to the directory.&quot;, &quot;type&quot;: &quot;string&quot; &#125;, &quot;rootDir&quot;: &#123; &quot;description&quot;: &quot;Specifies the root directory of input files. Use to control the output directory structure with --outDir.&quot;, &quot;type&quot;: &quot;string&quot; &#125; &#125;&#125; 6-3. compileOptions: modulemodule 결과물을 어떻게 무엇을 쓸것인가에 대한 것이다 . 컴파일 된 모듈의 결과물을 어떤 모듈 시스템으로 할지를 결정 target 이 ‘es6’ 이면 es6 가 디폴트이고 , target 이 ‘es6’ 가 아니면 commonjs 가 디폴트 입니다 . AMD 나 System 와 사용하려면, outFile 이 지정되어야 합니다 . ES6 나 ES2015 를 사용하려면, target 이 es5 이하여야 합니다. moduleResolution ts 소스에서 모듈을 사용하는 방식을 지정해야 합니다 . classic 아니면 node 입니다 . commonJS 일때만 node 라고 생각하시면 됩니다. paths 와 baseUrl 상대경로 방식이 아닌 baseUrl 로 꼭지점과 paths 안의 키&#x2F; 밸류로 모듈을 가져가는방식입니다 . rootDirs 배열 안에서 상대 경로를 찾는 방식입니다. 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;type&quot;: &quot;object&quot;, &quot;description&quot;: &quot;Instructs the TypeScript compiler how to compile .ts files.&quot;, &quot;properties&quot;: &#123; &quot;module&quot;: &#123; &quot;description&quot;: &quot;Specify module code generation: &#x27;none&#x27;, &#x27;CommonJS&#x27;, &#x27;Amd&#x27;, &#x27;System&#x27;, &#x27;UMD&#x27;, or &#x27;es2015&#x27;.&quot;, &quot;enum&quot;: [&quot;commonjs&quot;, &quot;amd&quot;, &quot;umd&quot;, &quot;system&quot;, &quot;es6&quot;, &quot;es2015&quot;, &quot;none&quot;] &#125;, &quot;moduleResolution&quot;: &#123; &quot;description&quot;: &quot;Specifies module resolution strategy: &#x27;node&#x27; (Node) or &#x27;classic&#x27; (TypeScript pre 1.6) .&quot;, &quot;type&quot;: &quot;string&quot;, &quot;pattern&quot;: &quot;^(([Nn]ode)|([Cc]lassic))$&quot;, &quot;default&quot;: &quot;classic&quot; &#125;, &quot;baseUrl&quot;: &#123; &quot;description&quot;: &quot;Base directory to resolve non-relative module names.&quot;, &quot;type&quot;: &quot;string&quot; &#125;, &quot;paths&quot;: &#123; &quot;description&quot;: &quot;Specify path mapping to be computed relative to baseUrl option.&quot;, &quot;type&quot;: &quot;object&quot; &#125;, &quot;rootDirs&quot;: &#123; &quot;description&quot;: &quot;Specify list of root directories to be used when resolving modules.&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125;&#125; 현재 플젝 tsconfig.json처음보는 옵션들이 있어서 정리해보았다 . 참고 : 타입스크립트 공식 페이지 allowSyntheticDefaultImports: true Allow default imports from modules with no default export. This does notaffect code emit, just typechecking. 리엑트에서 컴포넌트를 import 할 때 주로 쓰는 import Something from &#39;./Something&#39;을 사용할 수 있다 . noImplicitAny: false Raise error on expressions and declarations with an implied any type. 암시적으로 선언되었는데 any 로 추론되면 에러를 알려줍니다 . false이면 무시됨. preserveConstEnums: true Do not erase const enum declarations in generated code. See const enums documentation for more details. enum 변수선언을 유지한다는 것 같은데 정확히 잘 모르겠다. allowJs : false include 에 있는 파일 경로들에 존재하는 모든 .ts, .tsx파일들이 컴파일되는데 ,allowJs를 true 로 하면 .js와 .jsx 파일도 컴파일 대상이 된다 . sourceMap : true Generates corresponding .map file. 트랜스파일을 거치는 많은 모듈들이 디버깅을 위해서 기본적으로 source map 출력을 지원한다 . noImplicitReturns : true Report error when not all code paths in function return a value. 제대로 리턴 다 안되면 에러 -&gt; 오류에 대해 강력하게 체크한다는 뜻입니다. noUnusedParameters : true Report errors on unused parameters. 사용하지 않는 파라미터가 있으면 에러를 알려줍니다. noUnusedLocals : true Report errors on unused locals. 사용 안하는 로컬 변수가 있으면 에러를 알려줍니다 . 참고링크 http://jaroinside.tistory.com/10 http://poiemaweb.com/typeScript-vscode http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"overview","slug":"dada_06week","date":"2017-11-14T01:10:04.000Z","updated":"2024-11-23T11:40:36.526Z","comments":true,"path":"2017/11/14/dada_06week/","permalink":"http://feel5ny.github.io/2017/11/14/dada_06week/","excerpt":"","text":"식단 다이어리 서비스, DA,DA프론트엔드 스쿨을 마지막 달에는 그동안 배운 기술을 토대로 프로젝트를 필수적으로 진행해야 했다. node.js 스쿨과 함께 5명으로 이루어진 우리 조는 33일간의 대장정을 끝으로, 알바퍼전의 웹서비스가 배포할 수 있게 되었다. 블로그에서는 프론트엔드 중심으로 이번 프로젝트에 대한 개인적인 후기와 더불어 전반적인 진행과정, 이슈에 대해서 5가지 챕터로 포스팅하려고 한다. chapter 1 : 기획 및 프로토타입 및 디자인chapter 2 : 퍼블리싱chapter 3 : 핵심기능 개발chapter 4 : 리팩토링 및 테스트chapter 5 : 추가개발 및 배포 이번 프로젝트를 통해서 크게 3가지를 얻을 수 있었다. 비동기통신 redux 자유로운 사용 react 라이프사이클과 한계 프로젝트 이후 느낀점 Rest API우리 프로젝트에서는 다루는 데이터의 양이 많았었다. 매일 하루 3끼 식단, 운동, 일기, 등등. 이 데이터들을 rest API를 사용해서 rest하게 통신했지만, 해당 액션마다 필요한 데이터 + 필요 없는 데이터까지 가져오는 경우가 많았다. 이를 방지하기위해서는 백엔드에 엔드포인트를 요청해야했고, 여러면에서 낭비되는 리소스가 많이 발생함.GraphQL과 Rest Api를 같이 써보자. 다른 상태관리 라이브러리redux의 사용은 props로 액션을 주고받는 면에서는 혁신이다. 당연히. 그치만 많은 액션을 다루고, 관리하는 면에서 이건 액션으로 처리해야해. 라고 말하는 순간 귀찮음이 도지게 된다. 아 그럼 또 액션을 놓고 리듀서에 놓고 payload의 타입을 잘 지정해서 넣어주어야겠구나. 이런 불편함을 해소하고자 mobX를 사용하나 싶었다. 다음에 사용해보기 타입 이슈타입에 대한 이슈가 종종 있었다. 특히 이건 도대체 무슨에러인거지? 하면서 삽질할 때가 보통 타입때문에 생긴 에러들이었다. 객체형태로 들어오는지, 어떤 타입으로 타입을 내려주는지 등등을 console.log로 찍는건 한계가 있었고, PropsType으로 설정하는 것도 흠. github : https://github.com/huusz/Da-Da DA,DA : https://dada.downmix.net (카카오 아이디로 로그인)","categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Retrospective","slug":"Personal-🙆/Retrospective","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Retrospective/"}],"tags":[{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"DADA","slug":"DADA","permalink":"http://feel5ny.github.io/tags/DADA/"}]},{"title":"야근지수 (미제)","slug":"algorithm_01","date":"2017-11-13T08:10:04.000Z","updated":"2024-11-23T12:10:59.665Z","comments":true,"path":"2017/11/13/algorithm_01/","permalink":"http://feel5ny.github.io/2017/11/13/algorithm_01/","excerpt":"","text":"야근 지수회사원인 수민이는 많은 일이 쌓여 있습니다. 수민이는 야근을 최소화하기 위해 남은 일의 작업량을 숫자로 메기고, 일에 대한 야근 지수를 줄이기로 결정했습니다. 야근 지수는 남은 일의 작업량을 제곱하여 더한 값을 의미합니다. 수민이는 1시간 동안 남은 일 중 하나를 골라 작업량 1만큼 처리할 수 있습니다. 수민이의 퇴근까지 남은 N 시간과 각 일에 대한 작업량이 있을 때, noOvertime 함수를 제작하여 수민이의 야근 지수를 최소화 한 결과를 출력해 주세요. 예를 들어, N&#x3D;4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 일을 한 결과는 [2, 2, 2]가 되고 야근 지수는 22 + 22 + 22 &#x3D; 12가 되어 12를 반환해 줍니다. 처음 생각한 로직 해당 배열의 전체 합 - N값 1번의 값을 배열의 길이로 나눈다. 나머지가 0인 경우와, 0이 아닌 경우가 생긴다. 나머지가 0인 경우, 해당 몫의 제곱근에 length값을 곱한다. (끝) 나머지가 0이 아닌경우, 몫이 소수점이 나온는데, 이는 내림하여 소수점 자리수들을 버리고 (floor) 해당 값과 배열의 인자를 비교하여, 해당 값보다 작은 인자의 경우 바로 제곱근화 하고, 나머지 값은 해당 몫으로 제곱하여 더한다. (이 부분이 잘못되었음) 3번의 첫번째 나머지가 0인 경우는 테스트가 통과하는데 2번째 경우는 로직이 잘못됨 통과하고 싶다","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Algorithm","slug":"01-Web/zz-Algorithm","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Algorithm/"}],"tags":[{"name":"algorism","slug":"algorism","permalink":"http://feel5ny.github.io/tags/algorism/"}]},{"title":"1/ Typescript_환경 셋팅","slug":"Typescript_02","date":"2017-11-10T01:52:01.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2017/11/10/Typescript_02/","permalink":"http://feel5ny.github.io/2017/11/10/Typescript_02/","excerpt":"","text":"개발환경 구축 및 컴파일러 셋팅앞선 글에서 컴파일러와 트랜스파일러 인터프리터의 차이점을 알아보았다. 트랜스파일러와 컴파일러의 차이가 있다고는 했지만, 앞으로의 글에서는 컴파일러라고 통일해서 쓰려고 한다 . 타입스크립트는 컴파일드 언어라고 했지만 , 실제적으로 어떻게 환경을 셋팅하고 작업해야하는지 알아보자 . 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다. (짱짱)오류가 있다면 언제든지 댓글 부탁드립니다. 실행환경 컴파일러 셋팅, 에디터 간단하게 실습 컴파일러 옵션 목표타입스크립트를 사용하기 위해서 첫번째 실행환경을 셋팅하고 , 컴파일러 셋팅(npm으로 설치), 에디터에서 환경셋팅(tslint, 등등) 을 하고 , 간단하게 실습으로 컴파일 테스팅해본다. 기본 테스트가 완료되면 컴파일러 옵션을 어떻게 추가해야하는지 알아본다 . 1. 실행환경런타임 환경 1-1. node.js 자바스크립트 런타임 환경으로 node.js를 사용한다. 컴파일러를 설치하기 위해서 필요하다. 타입스크립트에서 컴파일러 프로그램을 제공하는 것이 npm 모듈로 있기 때문에 .. node.js없이 VScode에서도 셋팅이 가능하긴하다 . (2번에서 확인!) 버전을 바꾸고 싶을 때는 nvm (node.js version manager) 사용 ~ 1-2. browser 결과를 보는 곳.. 그냥 있는거 쓰자 . 2. (타입스크립트) 컴파일러 셋팅 , 에디터타입스크립트를 셋팅해 보자. 셋팅 방법에는 npm 과 VScode plugin으로 설치하는 방법이 있는데 , npm으로 설치해보았다 . 2-1. npm으로 설치하기1npm i typeScript -g 설치 후 node_modules 폴더의 bin파일에 tsc 파일이 생성되는 것을 볼 수 있다 ..bin 내부에 있는 파일들은 스크립트에서 경로 없이 파일 이름으로만 바로 실행시킬수 있다. 12345node_modules/.bin/tsc 파일이름// 원래는 이렇게tsc source.ts// 경로 생략 가능, 뒷부분은 컴파일 할 파일 이름 2-2. Visual Studio Code 내장 플러그인 사용하기타입스크립트로 만들어졌기 때문에 타입스크립트에 대한 지원이 강력 ! ts파일을 선택 후 하단 bar를 보면 Typescript라는 단어와 버전이 보인다. 버전을 누르면 옵션창이 보이게 되는데, 이는 VS Code에 내장되어있는 컴파일러 리스트 중 선택하라는 옵션창이다. 내장된 컴파일러 버전은 VS Code 가 업데이트 되면서 자동으로 올라가며, 컴파일러 버전과 VS Code 의 버전은 상관 관계가 있다. 내장된 컴파일러를 선택할수 있고, 직접 설치한 컴파일러를 선택할 수도 있다. 2-3. tslint 설치eslint와 같이 코딩 컨벤션을 맞추기 위한 프로그램이다 . 12npm i typeScript tslint (로컬)tslint --init tslint.json파일이 생성되고, 프로젝트에 맞게 코딩 컨벤션을 셋팅할 수 있다 .https://palantir.github.io/tslint/ 에디터에서 tslint 플러그인 설치 cmd + p &gt; 옵션창 ext install tslint 그냥 확장프로그램에 가서 tslint 검색 후 다운로드 받아도된다. VScode : https://marketplace.visualstudio.com/items?itemName=eg2.tslint 3. 간단하게 실습3-1. 특정 프로젝트 폴더에서 타입스크립트 컴파일러 설정에 맞춰 컴파일tsconfig.json 파일에서 옵션을 추가하여 컴파일시 여러 조건을 걸 수 있다. tsconfig 파일 초기셋팅 1tsc --init tsconfig.json 파일이 생성이 된다. 처음 생성시 디폴트로 되어있는 tsconfig.json파일 12345678910&#123; &quot;compilerOptions&quot;: &#123; /* Basic Options */ &quot;target&quot;: &quot;es5&quot; /* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;. */, &quot;module&quot;: &quot;commonjs&quot; /* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */, &quot;strict&quot;: true /* Enable all strict type-checking options. */ &#125;&#125; target : 컴파일된 결과물을 es5 버전으로 맞추겠다는 것 module : 컴파일된 결과물이 어떤 모듈로 사용할 것인지? 옵션에 대한 자세한 설명은 4번에서 설명! 3-2. watch 모드1tsc -w 변경되면 감지해서 새로 컴파일 해주는 것 . 보통은 gulp 를 사용한다 . 3-3. 프로젝트 파일 내에서만 설치할 경우 ( 로컬)셋팅 방법 12345npm init -ynpm i typeScript // 프로젝트 이름(폴더이름)이 동일하면 안된다.package.json &gt; &quot;scripts&quot;에 &quot;transpile&quot; : &quot;tsc&quot; 추가.// tsc파일이 .bin폴더 내부에 있는데, npm에서는 .bin내부의 파일들은 전체 상대 경로를 적지 않아도 접근가능하다.npm run transpile typescirpt 를 글로벌로 설치할 경우 tsc 파일이름.ts 명령어만으로 컴파일이 가능하다. 로컬로만 설치할 경우 , 위의 방법처럼 따로 스크립트에 추가 후에 명령어를 사용하면된다. cli 명령어로 명렁어를 다 걸어둘 수 있지만 json 파일을 만들어서 설정을 정리하며서 쓴다 . 참고링크 https://marketplace.visualstudio.com/items?itemName=eg2.tslint https://palantir.github.io/tslint/","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"0/ TypeScript?","slug":"Typescript_01","date":"2017-11-08T09:23:55.000Z","updated":"2024-11-23T12:10:16.973Z","comments":true,"path":"2017/11/08/Typescript_01/","permalink":"http://feel5ny.github.io/2017/11/08/Typescript_01/","excerpt":"","text":"자바스크립트 말고 타입스크립트 ?최근 프로젝트를 진행하면서나도 모르는 사이에 타입이 자주 바뀌는 자바스크립트의 불편함을 느끼곤 했었다. 애초에 값을 할당할 때 타입 체킹은 그 순간에 내 머릿속에서만 생각만 하지, 그 이후는 케어하지 못하게 되었다. 나중에 에러가 발생하면, 삽질 후에 원인이 타입 때문이라는 것을 알게 되고.. 이는 생각보다 빈번하게 일어났다. 콘솔에서 타입 에러를 잡지않고 렌더링이 될 때가 있기 때문에 타입으로 발생한 버그를 잡을 때는 시간이 더 걸린다.( 왜 에러가 나는 거여? 물론 리액트는 타입도 종종 잡아준다 . 무튼 시간 아까워! ) 버그 잡는 게 중요하긴 한데 , 타입이 원인이라는 것은 뭔가 어처구니없는 실수라는 생각도 들었다 .. 그러다 문득! 예전에 타입 버그가 날 때마다 타입스크립트를 배우면 이런 버그는 애초에 만나지 않을 겁니다! 라고 자주 얘기하셨던 선생님이 종종 생각났고 .. 게다가 지금 여러 프로젝트에서 타입스크립트을 도입하고도 있고, 얼마 후에 앵귤러도 시작하고자 해서 .. 겸사겸사 동기부여가 여러 군데에서 생겼기 때문에!! 시작!! 타입스크립트 정리 글은 이웅재님의 강의와 강의록을 참고하여 작성하였습니다 . (짱짱) 오류가 있다면 언제든지 댓글 부탁드립니다 . 타입스크립트는 무엇인가 컴파일러? 트랜스파일러? 인터프리터 ? 정적타입 언어 vs 동적타입 언어 1. 타입스크립트는 무엇인가.타입스크립트는 프로그래밍 언어 중 하나이다 . 자바스크립트가 인터프리터 기반의 언어로써, 실행과 동시에 렌더링이 되는데 , 타입스크립트는 인터프리터 방식이 아닌 컴파일 후에 실행되는 Compiled Language이다 . 별도의 빌드 과정이 필요 ! 전통적인 컴파일 언어와는 다른데 , (C언어 , 자바 …) 때문에 Compile 말고, Transpile이라는 용어를 사용하기도 한다 . 혹은 meta programming이라고 한다. 2. 컴파일러? 트랜스파일러? 인터프리터 ?간단하게 3가지를 비교해보면 아래 그림과 같다. transpiler 하나의 언어를 다른 형태의 언어로 변환해 주는 기능을 부각시키는 표현으로 compiler라는 표현보다 transpiler라는 표현을 쓴다. ( 번역이라는 말과 합쳐진 듯 하다 .) ex. TypeScript, Babel compiler 한 번 컴파일 하게 되면, 별도 생성된 목적 파일을 통해 빠르게 실행할 수 있다. 대용량 소스에 적합 컴파일이 필요 O 컴파일러가 필요 O 컴파일 하는 시점 O &#x3D;&gt; 컴파일 타임 컴파일된 결과물을 실행 컴파일된 결과물을 실행하는 시점 ex. C, Go, C#, JAVA, … interpreter 목적 파일 산출 과정이 없이 실행과 동시에 줄 단위로 번역이 된다. 저용량 소스에 적합 컴파일이 필요 X 컴파일러가 필요 X 컴파일하는 시점 X 코드 자체를 실행 코드를 실행하는 시점 o &#x3D; 런타임 ex. javaScript *Tranditional Compiled Language 컴파일 언어라고 한다. C, C++, Go, C#, Java, … 프로그래머가 작성한 Source Code 를 기계어로 변환하는 과정을 Compile이라고한다. 기계어로 변환된 결과물을 Object Code (목적 코드 )라 한다. Compile 하는 프로그램을 Compiler 라고 한다 . Compile 하는 동안을 Compile Time 이라고 한다 . 컴파일된 코드는 프로세서에 따라 다르다. 소스 코드에서는 OS 에 따라 라이브러리가 다르다 . 컴파일된 코드는 작은 크기에 최적화된다. 일반적으로 실행시 기계어로 바꾸는 방식 (인터프리터 언어) 보다 빠르다 . 실행시 기계어로 바꿔주는 연산이 필요없기 때문이다 . 3. 정적타입 언어 vs 동적타입 언어 정적 타입 언어 : 미리 타입을 지정해놓고 시작 자바스크립트에서 정적타입언어만 갖고오자라고 한 것이 TypeScript 동적 타입 언어가 갖고 있는 단점을 커버하자 .하는 목적이다 . test coverage를 올리면 상관없긴하다 . ex. TypeScript 동적 타입 언어 : 타입을 정하지 않는다. 타입 자체가 변화하는 것을 막지않는다. ex. JavaScript *The End of Dynamic Languages vs Have Static Languages Won? 최근 나타나는 신생언어들은 대부분 정적 타입을 지원한다. (Typed Racket, TypedClojure, TypeScript, Typed Lua, Python with type hints) 정적 언어로 작성된 코드의 버그는 해당 코드를 실행하기 전까지는 찾을 수 없다. 동적 언어의 경우 대부분 대충 디자인되어있다 . JavaScript의 경우에는 2 주만에개발된 언어이다보니 컴파일러와 힌들리- 밀너 타입추론 시스템과 같은 CS 지식으로무장한 사람들이 디자인한 언어와 비교하는건 무리다. Closure 같은 경우에도 이제는 대부분의 언어에서 지원하게 되면서 functional 과imperative 프로그래밍이 융합되듯이, 동적 언어와 정적 언어도 그렇게 되지 않을까? Crystal Programming Language 의 경우 루비를 기반으로 하는 정적&#x2F; 동적 언어가 합쳐진 언어이다. 참고링크 http://www.notforme.kr/archives/1541 http://www.geekhours.com/2017/03/08/difference-compiling-transpiling/ https://ruslanspivak.com/lsbasi-part1/ http://blog.sejongin.kr/44 http://hieroglyph.tistory.com/4 https://okky.kr/article/304342","categories":[{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"}]},{"title":"Hexo 설치","slug":"aboutHEXO","date":"2017-09-10T11:46:25.000Z","updated":"2024-11-23T12:25:51.932Z","comments":true,"path":"2017/09/10/aboutHEXO/","permalink":"http://feel5ny.github.io/2017/09/10/aboutHEXO/","excerpt":"","text":"intro 무언가를 배울때 하루하루의 기록을 남기는 것은 자기계발의 첫 스타트라고 생각합니다. 머리속에 있는 것을 그대로 옮기는 작업은, 정리하며 내것으로 만들기에도 좋고, 그때그때의 생각을 기록하는 용으로도 좋기 때문입니다. 그래서 우리는 일기를 쓰고, 일지를 쓰고, 이렇게 블로그도 만들며 기록합니다. 특히나 개발은 많은 개념을 숙지하면서 공부해야하기 때문에 블로깅 자체가 공부가 됩니다. 이왕 node.js까지 배우고 있으니, jekyll이 아닌, hexo를 사용해서 블로그를 만들었습니다. ## 0. Github 간단 소개 깃에 대해서 잘 알고 있다면 1번으로 넘어가도 됩니다. ### 0-1. 원격저장소 [Git](https://backlogtool.com/git-tutorial/kr/intro/intro1_1.html)이란 소스코드를 효과적으로 관리하기 위해 개발된 '분산형 버전 관리 시스템'입니다. git은 저장소에서 관리를 하는데, 내 컴퓨터에 있는 저장소를 `로컬저장소`라고 하고, 웹 상에 있는 저장소를 `원격저장소`라고 합니다. 우리가 흔히 알고 있는 원격저장소를 제공하는 서비스에는 **깃헙, 비트버킷, 깃랩**등이 있습니다다. 헥소를 이용한 블로그 개설을 위해서는 **깃헙**을 사용해야합니다. ### 0-2. 원격저장소 Github이 제공하는 정적웹사이트, Github Pages Github에서 제공하는 Static Website, Github Pages가 있다. 깃헙 저장소에 리소스를 `push`만 해도(push란 저장소에 리소스를 넣을때 사용하는 명령어) 간단하게 웹사이트를 만들 수 있다. 즉, 다른 호스팅 서비스의 도움없이, 원격저장소에 올리기만해도 호스팅이 가능하다. ### 0-3. 호스팅을 편리하게 만들어주는 generator, Jekyll & HEXO 사실, hexo나 jekyll이 없이도, html,css,javascript를 통해서도 호스팅이 가능하나, 블로그 구성상 글을 등록하고, 리스트를 보여주며, 댓글을 달 수 있는, 블로그가 갖고 있는 기능을 편라히게 사용하기 위해서 hexo나 jekyll과 같은 generator를 사용해야 한다. Static Website generator는 마크다운을(.md 파일)로 편집 후 html로 변환할 수 있도록 돕는다. generator에는 jekyll과 HEXO가 있는데, jekyll은 ruby기반, HEXO는 node.js기반이다. 그럼 generator을 셋팅하기 전, 내 컴퓨터에 디렉토리(폴더)를 생성하고, 원격저장소(github)에 연결을 시켜보자. ## 1. Github Pages로 정적 페이지 호스팅하기 Github Pages를 사용하기 위해 Github의 원격저장소에 리소스를 올려야한다는 사실을 잊지말자. 아래 그림의 저장소들이 필요하다. ### 1-1. 로컬에 저장소 생성하기 내 컴퓨터 원하는 장소에 폴더를 생성한다. terminal없이도 생성해도 된다. 아래는 terminal을 이용한 생성방법 1234&lt;!-- 바탕화면에 생성한다는 가정 (글쓴이는 운영체제가 mac입니다.) --&gt;$ cd Desktop$ mkdir github-blog 바탕화면에 github-blog라는 이름의 폴더가 생성이 되었다. ### 1-2. 원격 저장소 생성하기 (Github Repository) github pages를 통해 손쉽게 `USERNAME.github.io`를 통해 정적 페이지를 호스팅 할 수 있다. > 번외 > gh-pages 브랜치를 생성하면, 각 repository마다 `USERNAME.github.io/레포이름`으로 호스팅이 가능하다. 지금부터 말하는 USERNAME은, 당신의 아이디이다. 깃헙주소 뒷부분 /이후 붙는 유저네임을 붙이면된다. 아래 순서로 깃 저장소를 생성한다. New Repository &gt; 이름은 꼭 USERNAME.github.io로 적용한다. Public선택. 원격저장소 생성 완료 ### 1-3. 원격 저장소와 로컬 저장소 연결하기 내 컴퓨터에 저장소를 만들고, 원격에도 만들었으니, 연결을 해야한다. 연결하는 방법은 간단하다. 지금은 터미널을 열고 명령어를 입력해야하는 타이밍이다. 1번에서 만들었던 디렉토리로 이동한다. 해당 디렉토리에서 원격저장소의 git을 clone한다. clone 뒤에 생성한 원격저장소의 주소를 입력하는데, 이는 remote가 동시에 일어나므로, 따로 remote 명령어를 입력안해도 된다. 연결 테스트겸, READMD.md 파일을 생성한다. 생성된 README.md파일을 푸시한다. (commit &gt; push) 위의 순서를 코드로 옮기면. 12345678910111213141516&lt;!-- 1. 해당 디렉토리로 이동 --&gt;cd Desktopcd github-blog&lt;!-- 2. git clone --&gt;git clone https://github.com/feel5ny/TEST.github.io.gitcd test.github.io&lt;!-- 3. README.md파일 생성 --&gt;echo README.md&lt;!-- 4. 원격저장소에 올리기 --&gt;git add --allgit commit -m &quot;first commit&quot;git push -u origin master step 1이 끝났다! 그리고 벌써 호스팅이 완료되었다.USERNAME.github.io에 가보자. –아직 블로그의 형태를 띄지 않았다. 위에서 말했던 generator를 이용하여 블로그의 구조를 짤 예정인데, 우리는 HEXO를 이용할 것이다. ## 2. Hexo 설치하기 Hexo는 node.js기반이기 때문에 npm을 통해 쉽게 설치가 가능하다. 다양한 plugin과 테마를 지원하고 있다. 2-1. Hexo 설치 전 준비Hexo는 말했다 싶이 node.js 기반이기 때문에 node.js가 로컬에 기본적으로 설치되어있어야 한다. node.js는 공식 사이트에서 설치가 가능하다. stable버전을 추천한다. 2-2. Hexo npm 설치하기Node.js를 설치 한 후에 아래 CLI를 순서대로 입력하여 npm을 설치한다. 1234npm install hexo-cli -ghexo init blogcd blognpm install node.js를 설치하면 npm을 사용할 수 있는데, 패키지 중에 hexo-cli를 설치한다. blog파일을 생성하여 hexo를 초기화한다. blog 디렉토리로 이동후, npm install을 사용하여, blog에 필요한 파일들을 자동으로 설치한다. 2-3. 설정파일 업데이트위의 순서가 끝나면, root 디렉토리에 _config.yml이라는 설정파일이 생성된다. (yml파일은 사람이 쉽게 읽을 수 있는 데이터 직력화 양식으로,…more) 해당 파일에 블로그 정보를 수정한다. 나머지 정보는 hexo 공식 문서에서. Site 정보블로그 정보를 수정할 수 있다. 1234title: 제목(html head에 들어가는 title태그에 들어가는 제목과 같다.)subtitle: description:author: Nayoung Kim URL 정보블로그 URL 정보를 설정할 수 있다. 1234url: https://USERNAME.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: Github 정보배포를 위해서 저장소 주소를 추가한다. 1234# Deploymentdeploy: type: git repo: https://github.com/feel5ny/TEST.github.io.git 테마별로 구성을 수정하는 스타일이 다르다. 테마 적용하기 파트에서 anatol 레이아웃 수정방법을 설명하겠다. ### 2-4. 로컬에서 테스트하기 1hexo server blog 디렉토리에 위치되어있는 상태에서 서버를 구동한다. blog에 위치되어있지 않으면 서버구동이 안된다. 서버 구동이 완료되면 4000번 포트로 접속이 가능하다. - 02. HTTP://localhost:4000 테스트시 구동이 잘 안될 경우, 서버를 껐다가 다시 실행해 보면된다. 서버를 끄는 방법은 터미널에서 ctrl+c를 두번 입력하면 된다. ## 3. Github에 배포하기 로컬에서 테스트를 완료하면 USERNAME.github.io 주소로 배포해보자. 3-1. hexo 설정을 통해 정적 리소스를 생성하기1hexo generate 위 명령어를 입력하면, github에 올라갈 리소스만 정리되어 따로 폴더가 생성된다. 3-2. 배포하기1hexo deploy 위 명령어를 입력하면 배고가 완료된다. generate와 deploy를 한번에 진행하고 싶은 경우 아래 명령어를 입력한다. 1hexo deploy --generate 약자로 hexo d g를 사용해도 됩니다. 3-3. 배포가 잘 안될 경우12hexo cleanhexo deploy --generate","categories":[{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"06. Deploy","slug":"03-DevOps/06-Deploy","permalink":"http://feel5ny.github.io/categories/03-DevOps/06-Deploy/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://feel5ny.github.io/tags/hexo/"},{"name":"node.js","slug":"node-js","permalink":"http://feel5ny.github.io/tags/node-js/"}]}],"categories":[{"name":"Personal 🙆","slug":"Personal-🙆","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/"},{"name":"Reflection","slug":"Personal-🙆/Reflection","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Reflection/"},{"name":"00_Clean_Code","slug":"00-Clean-Code","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/"},{"name":"Refactoring","slug":"00-Clean-Code/Refactoring","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Refactoring/"},{"name":"03_DevOps","slug":"03-DevOps","permalink":"http://feel5ny.github.io/categories/03-DevOps/"},{"name":"06. Deploy","slug":"03-DevOps/06-Deploy","permalink":"http://feel5ny.github.io/categories/03-DevOps/06-Deploy/"},{"name":"01_Web","slug":"01-Web","permalink":"http://feel5ny.github.io/categories/01-Web/"},{"name":"03. Html","slug":"01-Web/03-Html","permalink":"http://feel5ny.github.io/categories/01-Web/03-Html/"},{"name":"05. Release","slug":"03-DevOps/05-Release","permalink":"http://feel5ny.github.io/categories/03-DevOps/05-Release/"},{"name":"00. UX 💅","slug":"01-Web/00-UX-💅","permalink":"http://feel5ny.github.io/categories/01-Web/00-UX-%F0%9F%92%85/"},{"name":"04_AARRR","slug":"04-AARRR","permalink":"http://feel5ny.github.io/categories/04-AARRR/"},{"name":"00. Analyze","slug":"04-AARRR/00-Analyze","permalink":"http://feel5ny.github.io/categories/04-AARRR/00-Analyze/"},{"name":"02. HTTP","slug":"01-Web/02-HTTP","permalink":"http://feel5ny.github.io/categories/01-Web/02-HTTP/"},{"name":"zz. Workshop","slug":"01-Web/zz-Workshop","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Workshop/"},{"name":"Acquisition","slug":"04-AARRR/Acquisition","permalink":"http://feel5ny.github.io/categories/04-AARRR/Acquisition/"},{"name":"03. CSS","slug":"01-Web/03-CSS","permalink":"http://feel5ny.github.io/categories/01-Web/03-CSS/"},{"name":"03. JavaScript","slug":"01-Web/03-JavaScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-JavaScript/"},{"name":"02. Code","slug":"03-DevOps/02-Code","permalink":"http://feel5ny.github.io/categories/03-DevOps/02-Code/"},{"name":"03. TypeScript","slug":"01-Web/03-TypeScript","permalink":"http://feel5ny.github.io/categories/01-Web/03-TypeScript/"},{"name":"03. Library","slug":"01-Web/03-Library","permalink":"http://feel5ny.github.io/categories/01-Web/03-Library/"},{"name":"Principle","slug":"00-Clean-Code/Principle","permalink":"http://feel5ny.github.io/categories/00-Clean-Code/Principle/"},{"name":"01. Browser","slug":"01-Web/01-Browser","permalink":"http://feel5ny.github.io/categories/01-Web/01-Browser/"},{"name":"03. Motion","slug":"01-Web/03-Motion","permalink":"http://feel5ny.github.io/categories/01-Web/03-Motion/"},{"name":"02. Network","slug":"01-Web/02-Network","permalink":"http://feel5ny.github.io/categories/01-Web/02-Network/"},{"name":"02_!Web","slug":"02-Web","permalink":"http://feel5ny.github.io/categories/02-Web/"},{"name":"DB","slug":"02-Web/DB","permalink":"http://feel5ny.github.io/categories/02-Web/DB/"},{"name":"zz. Algorithm","slug":"01-Web/zz-Algorithm","permalink":"http://feel5ny.github.io/categories/01-Web/zz-Algorithm/"},{"name":"04. Test","slug":"03-DevOps/04-Test","permalink":"http://feel5ny.github.io/categories/03-DevOps/04-Test/"},{"name":"Retrospective","slug":"Personal-🙆/Retrospective","permalink":"http://feel5ny.github.io/categories/Personal-%F0%9F%99%86/Retrospective/"}],"tags":[{"name":"book review","slug":"book-review","permalink":"http://feel5ny.github.io/tags/book-review/"},{"name":"deep work","slug":"deep-work","permalink":"http://feel5ny.github.io/tags/deep-work/"},{"name":"programmer","slug":"programmer","permalink":"http://feel5ny.github.io/tags/programmer/"},{"name":"cognitive","slug":"cognitive","permalink":"http://feel5ny.github.io/tags/cognitive/"},{"name":"docker","slug":"docker","permalink":"http://feel5ny.github.io/tags/docker/"},{"name":"docker_volume","slug":"docker-volume","permalink":"http://feel5ny.github.io/tags/docker-volume/"},{"name":"docker_network","slug":"docker-network","permalink":"http://feel5ny.github.io/tags/docker-network/"},{"name":"docker_log","slug":"docker-log","permalink":"http://feel5ny.github.io/tags/docker-log/"},{"name":"Docker","slug":"Docker","permalink":"http://feel5ny.github.io/tags/Docker/"},{"name":"Joy","slug":"Joy","permalink":"http://feel5ny.github.io/tags/Joy/"},{"name":"blog","slug":"blog","permalink":"http://feel5ny.github.io/tags/blog/"},{"name":"svg","slug":"svg","permalink":"http://feel5ny.github.io/tags/svg/"},{"name":"rounded rect","slug":"rounded-rect","permalink":"http://feel5ny.github.io/tags/rounded-rect/"},{"name":"progress bar","slug":"progress-bar","permalink":"http://feel5ny.github.io/tags/progress-bar/"},{"name":"animation","slug":"animation","permalink":"http://feel5ny.github.io/tags/animation/"},{"name":"version","slug":"version","permalink":"http://feel5ny.github.io/tags/version/"},{"name":"standard-version","slug":"standard-version","permalink":"http://feel5ny.github.io/tags/standard-version/"},{"name":"CHANGLOG","slug":"CHANGLOG","permalink":"http://feel5ny.github.io/tags/CHANGLOG/"},{"name":"SemVr","slug":"SemVr","permalink":"http://feel5ny.github.io/tags/SemVr/"},{"name":"commitlint","slug":"commitlint","permalink":"http://feel5ny.github.io/tags/commitlint/"},{"name":"conventional-commit","slug":"conventional-commit","permalink":"http://feel5ny.github.io/tags/conventional-commit/"},{"name":"UX","slug":"UX","permalink":"http://feel5ny.github.io/tags/UX/"},{"name":"Frontend","slug":"Frontend","permalink":"http://feel5ny.github.io/tags/Frontend/"},{"name":"UX Law","slug":"UX-Law","permalink":"http://feel5ny.github.io/tags/UX-Law/"},{"name":"Fitts Law","slug":"Fitts-Law","permalink":"http://feel5ny.github.io/tags/Fitts-Law/"},{"name":"Touch Target","slug":"Touch-Target","permalink":"http://feel5ny.github.io/tags/Touch-Target/"},{"name":"Accessibility","slug":"Accessibility","permalink":"http://feel5ny.github.io/tags/Accessibility/"},{"name":"Reflection","slug":"Reflection","permalink":"http://feel5ny.github.io/tags/Reflection/"},{"name":"maketing","slug":"maketing","permalink":"http://feel5ny.github.io/tags/maketing/"},{"name":"LTV","slug":"LTV","permalink":"http://feel5ny.github.io/tags/LTV/"},{"name":"customer","slug":"customer","permalink":"http://feel5ny.github.io/tags/customer/"},{"name":"refactoring","slug":"refactoring","permalink":"http://feel5ny.github.io/tags/refactoring/"},{"name":"http","slug":"http","permalink":"http://feel5ny.github.io/tags/http/"},{"name":"release","slug":"release","permalink":"http://feel5ny.github.io/tags/release/"},{"name":"hosting","slug":"hosting","permalink":"http://feel5ny.github.io/tags/hosting/"},{"name":"vary","slug":"vary","permalink":"http://feel5ny.github.io/tags/vary/"},{"name":"Accept header","slug":"Accept-header","permalink":"http://feel5ny.github.io/tags/Accept-header/"},{"name":"variant","slug":"variant","permalink":"http://feel5ny.github.io/tags/variant/"},{"name":"transcoding","slug":"transcoding","permalink":"http://feel5ny.github.io/tags/transcoding/"},{"name":"internationalization","slug":"internationalization","permalink":"http://feel5ny.github.io/tags/internationalization/"},{"name":"instance","slug":"instance","permalink":"http://feel5ny.github.io/tags/instance/"},{"name":"Range","slug":"Range","permalink":"http://feel5ny.github.io/tags/Range/"},{"name":"encoding","slug":"encoding","permalink":"http://feel5ny.github.io/tags/encoding/"},{"name":"entity","slug":"entity","permalink":"http://feel5ny.github.io/tags/entity/"},{"name":"study","slug":"study","permalink":"http://feel5ny.github.io/tags/study/"},{"name":"https","slug":"https","permalink":"http://feel5ny.github.io/tags/https/"},{"name":"openSSL","slug":"openSSL","permalink":"http://feel5ny.github.io/tags/openSSL/"},{"name":"sslHandShake","slug":"sslHandShake","permalink":"http://feel5ny.github.io/tags/sslHandShake/"},{"name":"ca","slug":"ca","permalink":"http://feel5ny.github.io/tags/ca/"},{"name":"cryptography","slug":"cryptography","permalink":"http://feel5ny.github.io/tags/cryptography/"},{"name":"X.509","slug":"X-509","permalink":"http://feel5ny.github.io/tags/X-509/"},{"name":"web","slug":"web","permalink":"http://feel5ny.github.io/tags/web/"},{"name":"digest","slug":"digest","permalink":"http://feel5ny.github.io/tags/digest/"},{"name":"authorization","slug":"authorization","permalink":"http://feel5ny.github.io/tags/authorization/"},{"name":"authentication","slug":"authentication","permalink":"http://feel5ny.github.io/tags/authentication/"},{"name":"cookie","slug":"cookie","permalink":"http://feel5ny.github.io/tags/cookie/"},{"name":"Identification","slug":"Identification","permalink":"http://feel5ny.github.io/tags/Identification/"},{"name":"javaScript","slug":"javaScript","permalink":"http://feel5ny.github.io/tags/javaScript/"},{"name":"codeSpitz","slug":"codeSpitz","permalink":"http://feel5ny.github.io/tags/codeSpitz/"},{"name":"concurrency","slug":"concurrency","permalink":"http://feel5ny.github.io/tags/concurrency/"},{"name":"Parallelism","slug":"Parallelism","permalink":"http://feel5ny.github.io/tags/Parallelism/"},{"name":"robot","slug":"robot","permalink":"http://feel5ny.github.io/tags/robot/"},{"name":"cache","slug":"cache","permalink":"http://feel5ny.github.io/tags/cache/"},{"name":"app","slug":"app","permalink":"http://feel5ny.github.io/tags/app/"},{"name":"link","slug":"link","permalink":"http://feel5ny.github.io/tags/link/"},{"name":"url","slug":"url","permalink":"http://feel5ny.github.io/tags/url/"},{"name":"proxy","slug":"proxy","permalink":"http://feel5ny.github.io/tags/proxy/"},{"name":"css","slug":"css","permalink":"http://feel5ny.github.io/tags/css/"},{"name":"unicode","slug":"unicode","permalink":"http://feel5ny.github.io/tags/unicode/"},{"name":"font","slug":"font","permalink":"http://feel5ny.github.io/tags/font/"},{"name":"웹서버","slug":"웹서버","permalink":"http://feel5ny.github.io/tags/%EC%9B%B9%EC%84%9C%EB%B2%84/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://feel5ny.github.io/tags/TCP-IP/"},{"name":"connection","slug":"connection","permalink":"http://feel5ny.github.io/tags/connection/"},{"name":"message","slug":"message","permalink":"http://feel5ny.github.io/tags/message/"},{"name":"header","slug":"header","permalink":"http://feel5ny.github.io/tags/header/"},{"name":"status code","slug":"status-code","permalink":"http://feel5ny.github.io/tags/status-code/"},{"name":"method","slug":"method","permalink":"http://feel5ny.github.io/tags/method/"},{"name":"URL","slug":"URL","permalink":"http://feel5ny.github.io/tags/URL/"},{"name":"OOP","slug":"OOP","permalink":"http://feel5ny.github.io/tags/OOP/"},{"name":"symbol","slug":"symbol","permalink":"http://feel5ny.github.io/tags/symbol/"},{"name":"generator","slug":"generator","permalink":"http://feel5ny.github.io/tags/generator/"},{"name":"yield","slug":"yield","permalink":"http://feel5ny.github.io/tags/yield/"},{"name":"loop","slug":"loop","permalink":"http://feel5ny.github.io/tags/loop/"},{"name":"iterator","slug":"iterator","permalink":"http://feel5ny.github.io/tags/iterator/"},{"name":"flow control","slug":"flow-control","permalink":"http://feel5ny.github.io/tags/flow-control/"},{"name":"git","slug":"git","permalink":"http://feel5ny.github.io/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://feel5ny.github.io/tags/submodule/"},{"name":"programming","slug":"programming","permalink":"http://feel5ny.github.io/tags/programming/"},{"name":"typeScript","slug":"typeScript","permalink":"http://feel5ny.github.io/tags/typeScript/"},{"name":"async","slug":"async","permalink":"http://feel5ny.github.io/tags/async/"},{"name":"redux","slug":"redux","permalink":"http://feel5ny.github.io/tags/redux/"},{"name":"observable","slug":"observable","permalink":"http://feel5ny.github.io/tags/observable/"},{"name":"react","slug":"react","permalink":"http://feel5ny.github.io/tags/react/"},{"name":"rxjs","slug":"rxjs","permalink":"http://feel5ny.github.io/tags/rxjs/"},{"name":"글쓰기","slug":"글쓰기","permalink":"http://feel5ny.github.io/tags/%EA%B8%80%EC%93%B0%EA%B8%B0/"},{"name":"closure","slug":"closure","permalink":"http://feel5ny.github.io/tags/closure/"},{"name":"principle","slug":"principle","permalink":"http://feel5ny.github.io/tags/principle/"},{"name":"File API","slug":"File-API","permalink":"http://feel5ny.github.io/tags/File-API/"},{"name":"EXIF","slug":"EXIF","permalink":"http://feel5ny.github.io/tags/EXIF/"},{"name":"cleanCode","slug":"cleanCode","permalink":"http://feel5ny.github.io/tags/cleanCode/"},{"name":"Web","slug":"Web","permalink":"http://feel5ny.github.io/tags/Web/"},{"name":"browser","slug":"browser","permalink":"http://feel5ny.github.io/tags/browser/"},{"name":"canvas","slug":"canvas","permalink":"http://feel5ny.github.io/tags/canvas/"},{"name":"media-query","slug":"media-query","permalink":"http://feel5ny.github.io/tags/media-query/"},{"name":"mobile","slug":"mobile","permalink":"http://feel5ny.github.io/tags/mobile/"},{"name":"log","slug":"log","permalink":"http://feel5ny.github.io/tags/log/"},{"name":"angular","slug":"angular","permalink":"http://feel5ny.github.io/tags/angular/"},{"name":"prettier","slug":"prettier","permalink":"http://feel5ny.github.io/tags/prettier/"},{"name":"formatter","slug":"formatter","permalink":"http://feel5ny.github.io/tags/formatter/"},{"name":"lottie","slug":"lottie","permalink":"http://feel5ny.github.io/tags/lottie/"},{"name":"bodymovin","slug":"bodymovin","permalink":"http://feel5ny.github.io/tags/bodymovin/"},{"name":"CS","slug":"CS","permalink":"http://feel5ny.github.io/tags/CS/"},{"name":"network","slug":"network","permalink":"http://feel5ny.github.io/tags/network/"},{"name":"database","slug":"database","permalink":"http://feel5ny.github.io/tags/database/"},{"name":"TDD","slug":"TDD","permalink":"http://feel5ny.github.io/tags/TDD/"},{"name":"mocha","slug":"mocha","permalink":"http://feel5ny.github.io/tags/mocha/"},{"name":"publishing","slug":"publishing","permalink":"http://feel5ny.github.io/tags/publishing/"},{"name":"plan","slug":"plan","permalink":"http://feel5ny.github.io/tags/plan/"},{"name":"design","slug":"design","permalink":"http://feel5ny.github.io/tags/design/"},{"name":"prototype","slug":"prototype","permalink":"http://feel5ny.github.io/tags/prototype/"},{"name":"algorism","slug":"algorism","permalink":"http://feel5ny.github.io/tags/algorism/"},{"name":"DADA","slug":"DADA","permalink":"http://feel5ny.github.io/tags/DADA/"},{"name":"hexo","slug":"hexo","permalink":"http://feel5ny.github.io/tags/hexo/"},{"name":"node.js","slug":"node-js","permalink":"http://feel5ny.github.io/tags/node-js/"}]}
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>필오의 개발일지</title>
  
  <subtitle>Frontend developer &amp; love UX, Interaction</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://feel5ny.github.io/"/>
  <updated>2018-08-26T14:02:36.413Z</updated>
  <id>http://feel5ny.github.io/</id>
  
  <author>
    <name>Joy Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4/ 함수와 프로토타입 체이닝 (2)</title>
    <link href="http://feel5ny.github.io/2018/08/25/JS_16/"/>
    <id>http://feel5ny.github.io/2018/08/25/JS_16/</id>
    <published>2018-08-25T12:20:19.000Z</published>
    <updated>2018-08-26T14:02:36.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.</p></blockquote><hr><p><a name="4"></a></p><h1 id="4-함수-호출과-this"><a href="#4-함수-호출과-this" class="headerlink" title="4. 함수 호출과 this"></a>4. 함수 호출과 this</h1><ul><li>함수호출시 암묵적으로 arguments 객체와 this인자가 전달된다.</li></ul><p><a name="4-1"></a></p><h2 id="4-1-arguments-객체"><a href="#4-1-arguments-객체" class="headerlink" title="4.1 arguments 객체"></a>4.1 arguments 객체</h2><ul><li><span class="mint">유사배열 <strong>객체</strong></span></li><li>정의된 함수의 인자보다 적게 함수를 호출할 경우 넘겨지지 않은 인자는 <strong>undefined</strong></li><li>함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다. arguments 객체가 그 역할을 한다. </li><li>함수가 호출될 당시의 인자들에 배열 형태로 접근할 수 있다.</li></ul><p><img src="/images/2018/32/arguments.png"></p><ul><li>함수 호출할 때 넘겨진 인자 (배열형태)</li><li>length : 인자갯수</li><li>callee : 현재 실행 중인 함수의 참조값</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>); <span class="comment">// 45</span></span><br></pre></td></tr></table></figure><p><a name="4-2"></a></p><h2 id="4-2-호출패턴과-this-바인딩"><a href="#4-2-호출패턴과-this-바인딩" class="headerlink" title="4.2 호출패턴과 this 바인딩"></a>4.2 호출패턴과 this 바인딩</h2><p>함수가 호출되는 방식<span class="mint">(호출패턴)</span>에 따라 this가 다른 객체를 참조한다.(this 바인딩)</p><ul><li>객체의 메서드 호출할 때 this바인딩</li><li>함수 호출할 때 this바인딩</li><li>생성자 함수를 호출할 때 this 바인딩</li><li></li></ul><h3 id="4-2-1-객체의-메서드-호출할-때-this바인딩"><a href="#4-2-1-객체의-메서드-호출할-때-this바인딩" class="headerlink" title="4.2.1 객체의 메서드 호출할 때 this바인딩"></a>4.2.1 객체의 메서드 호출할 때 this바인딩</h3><p><span class="mint"><strong>자신을 호출한 객체</strong>에 바인딩된다!</span><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// sayName은 function()&#123;console.log(this.nmae)&#125;을 가리킴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> otherObject = &#123;</span><br><span class="line">  name: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">otherObject.sayName = myObject.sayName;</span><br><span class="line"><span class="comment">// myObject.sayName의 참조값을 할당함.</span></span><br><span class="line"><span class="comment">// otherObject.sayName은 생성과 동시에 function()&#123;console.log(this.nmae)&#125;을 가리킴</span></span><br><span class="line"><span class="comment">// this는 자신을 호출한 객체에 바인딩되므로, 결과값이 다름</span></span><br><span class="line">myObject.sayName(); <span class="comment">// foo</span></span><br><span class="line">otherObject.sayName(); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure></p><h3 id="4-2-2-함수-호출할-때-this바인딩"><a href="#4-2-2-함수-호출할-때-this바인딩" class="headerlink" title="4.2.2 함수 호출할 때 this바인딩"></a>4.2.2 함수 호출할 때 this바인딩</h3><p>자바스크립트의 모든 전역 변수는 전역 객체의 프로퍼티들이다.<br>(브라우저는 window, node는 global)</p><ul><li>함수 내부에서의 this는 전역 객체를 가리킨다.</li><li>내부 함수에서도 this는 전역 객체를 가리킨다. </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  func1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'func1()'</span> + <span class="keyword">this</span>.value); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value += <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'func2()'</span> + <span class="keyword">this</span>.value); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">      func3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'func3()'</span> + <span class="keyword">this</span>.value); <span class="comment">// 102</span></span><br><span class="line">      &#125;</span><br><span class="line">      func3();</span><br><span class="line">    &#125;</span><br><span class="line">    func2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func1();</span><br></pre></td></tr></table></figure><p><img src="/images/2018/32/02.jpeg"></p><p><span class="mint">부모함수의 this를 내부 함수가 접근 가능한 <strong>다른변수에 저장하는 방법이 사용된다.</strong></span></p><ul><li>보통 관례상 this값을 저장하는 변수의 이름을 <strong>that</strong>이라고 짓는다. </li><li>명시적으로 bind를 사용할 수도 있다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  func1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.value += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'func1()'</span> + <span class="keyword">this</span>.value); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _func2 = func2.bind(<span class="keyword">this</span>)</span><br><span class="line">    func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      that.value += <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'func2()'</span> + that.value); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">      func3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.value += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'func3()'</span> + that.value); <span class="comment">// 102</span></span><br><span class="line">      &#125;</span><br><span class="line">      func3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// const _func2 = func2.bind(this)</span></span><br><span class="line">    <span class="comment">// _func2();</span></span><br><span class="line">    func2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func1();</span><br></pre></td></tr></table></figure><p><img src="/images/2018/32/03.jpeg"></p><h3 id="4-2-3-생성자-함수를-호출할-때-this-바인딩"><a href="#4-2-3-생성자-함수를-호출할-때-this-바인딩" class="headerlink" title="4.2.3 생성자 함수를 호출할 때 this 바인딩"></a>4.2.3 생성자 함수를 호출할 때 this 바인딩</h3><p>객체를 생성하는 방법</p><ul><li>객체 리터럴 방식</li><li>Object() 생성자 함수</li><li>생성자 함수 이용</li></ul><p><strong>기존 함수에 new 연산자를 붙여서 호출</strong>하면 해당 함수는 생성자 함수로 동작한다.<br>일반 함수에 new를 붙여 호출하면 원치 않는 생성자 함수처럼 동작할 수 있다.<br>특정함수가 생성자 함수로 정의되어 있음을 알리려고 <strong>함수 이름의 첫 문자를 대문자로 쓴다.</strong></p><p>생성자 함수에서의 this는 함수호출방식의 this 바인딩과 다르게 동작한다.<br>이를 이해하기 위해 생성자 함수의 동작방식을 이해하면 된다!</p><h4 id="1-생성자-함수가-동작하는-방식"><a href="#1-생성자-함수가-동작하는-방식" class="headerlink" title="1. 생성자 함수가 동작하는 방식"></a>1. 생성자 함수가 동작하는 방식</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure><blockquote><p>위 의 예시를 토대로 설명</p></blockquote><ol><li>빈 객체 생성 및 this 바인딩</li></ol><ul><li>빈 객체가 생성된다.</li><li>new Person()을 통해서<ul><li>빈 객체는 this로 바인딩된다. 즉, 생성자 함수 내의 this는 빈 객체를 가리킨다.</li><li>빈 객체에는 기본적으로 [[Prototype]]이 생성된다.</li><li>이 <code>__proto__</code>는<br><span class="mint">자신을 생성한 <strong>생성자 함수</strong><code>Person()</code>의 prototype 프로퍼티가 가리키는 객체를 </span><br>자신의 프로토타입 객체로 설정한다.</li></ul></li></ul><ol><li>this를 통한 프로퍼티 생성<ul><li>함수코드 내부에서 this를 통해 foo에 동적으로 프로퍼티나 메서드를 생성할 수 있다.</li></ul></li><li>생성된 객체 리턴<ul><li></li></ul></li></ol><p><img src="/images/2018/32/01.png"></p><h4 id="2-객체-리터럴-방식과-생성자-함수를-통한-객체-생성-방식의-차이"><a href="#2-객체-리터럴-방식과-생성자-함수를-통한-객체-생성-방식의-차이" class="headerlink" title="2. 객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이"></a>2. 객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  age: <span class="number">35</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> Person(<span class="string">'bar'</span>, <span class="number">33</span>);</span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">new</span> Person(<span class="string">'baz'</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/2018/32/04.png" width="500"></p><h4 id="3-생성자-함수를-new를-붙이지-않고-호출할-경우"><a href="#3-생성자-함수를-new를-붙이지-않고-호출할-경우" class="headerlink" title="3. 생성자 함수를 new를 붙이지 않고 호출할 경우"></a>3. 생성자 함수를 new를 붙이지 않고 호출할 경우</h4><ul><li>객체 생성을 목적으로 작성한 생성자 함수를<br>new 없이 호출하거나 일반함수를 new를 붙여서 호출할 경우 오류 발생</li><li>일반 함수 호출과 생성자 함수를 호출할 때 this 바인딩 방식이 다르기 때문</li></ul><ul><li>일반함수의 경우 <span class="mint">this =&gt; <strong>window</strong></span><br>생성자함수의 경우 <span class="mint">this =&gt; <strong>새로 생성되는 빈 객체</strong></span></li></ul><p>대문자 표기 네이밍 규칙을 권장하나 휴먼에러가 발생 할 수 있기 때문에 다음과 같은 분기문이 있는 코드 패턴을 사용하기도 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 강제로 인스턴스 생성하기</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> A(arg);</span><br><span class="line">  <span class="keyword">this</span>.value = arg? arg : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-4-call과-apply-메서드를-이용한-명시적인-this-바인딩"><a href="#4-2-4-call과-apply-메서드를-이용한-명시적인-this-바인딩" class="headerlink" title="4.2.4 call과 apply 메서드를 이용한 명시적인 this 바인딩"></a>4.2.4 call과 apply 메서드를 이용한 명시적인 this 바인딩</h3><p>내부적인 this 바인딩 이외에도<br>this를 특정 객체에 명시적으로 바인딩 시키는 방법</p><ul><li>apply()</li><li>call()<blockquote><p>함수의 부모 객체인 Function.prototype 객체의 메서드들이다.</p></blockquote></li></ul><p><strong>apply()메서드를 호출하는 주체가 <span class="mint">함수</span>고,<br>apply() 메서드도 this를 특정 객체에 바인딩할 뿐<br>결국 본질적인 기능은 <span class="mint">함수호출</span>이라는 것이다.</strong></p><ul><li>Person()이라는 함수가 있고, Person.apply() 이렇게 호출한다면 이것의 기본적인 기능은 Person() 함수를 호출하는 것이다. </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function.apply(thisArg, argArray)</span><br><span class="line">function.call(thisArg, argItem1, argItem2, argItem3, ...)</span><br></pre></td></tr></table></figure><p><span class="mint"><code>function</code>을 호출하라, 이때 <strong>this</strong>는 <code>thisArg</code>에 바인딩해라.</span></p><ul><li>thisArg : apply를 호출한 함수 내부에서 사용한 this에 바인딩할 <strong>객체</strong></li><li>argArray: 인자배열</li><li>call : call은 인자를 각각 넘긴다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.apply(foo, [<span class="string">'foo'</span>, <span class="number">30</span>, <span class="string">'main'</span>]);</span><br><span class="line"><span class="comment">// Person 메서드를 호출해라, 이때 this는 foo객체에 바인딩해라.</span></span><br><span class="line"><span class="comment">// 명시적인 바인딩</span></span><br></pre></td></tr></table></figure><p>유사배열 객체에서 사용하는 경우<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="built_in">arguments</span>); <span class="comment">// __proto__는 Object</span></span><br><span class="line">  <span class="comment">// arguments.shift() // 에러</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.dir(args); <span class="comment">// __proto__는 Array</span></span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>Array.prototype.slice를 호출하라, 이때 Array.prototype.slice의 this는 arguments 객체로 바인딩하라.</p><p><a name="4-3"></a></p><h2 id="4-3-함수리턴"><a href="#4-3-함수리턴" class="headerlink" title="4.3 함수리턴"></a>4.3 함수리턴</h2><h3 id="일반-함수나-메서드는-리턴값을-지정하지-않을-경우-undefined-값이-리턴된다"><a href="#일반-함수나-메서드는-리턴값을-지정하지-않을-경우-undefined-값이-리턴된다" class="headerlink" title="일반 함수나 메서드는 리턴값을 지정하지 않을 경우, undefined 값이 리턴된다."></a>일반 함수나 메서드는 리턴값을 지정하지 않을 경우, undefined 값이 리턴된다.</h3><h3 id="생성자-함수에서-리턴값을-지정하지-않을-경우-생성된-객체가-리턴된다"><a href="#생성자-함수에서-리턴값을-지정하지-않을-경우-생성된-객체가-리턴된다" class="headerlink" title="생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴된다."></a>생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴된다.</h3><ul><li>생성자 함수에서 별도의 리턴값을 지정하지 않을 경우 this로 바인딩 된 새로 생성된 객체가 리턴된다.</li><li>때문에 <strong>생성자 함수에서는 일반적으로 리턴값을 지정하지 않는다.</strong></li><li>생성자 함수가 명시적으로 객체를 리턴할 경우 새로운 객체를 생성하더라도, 명시적으로 넘긴 객체나 배열이 리턴된다.</li><li>불린, 숫자, 문자열을 리턴할 경우 무시된다.</li></ul><hr><p><a name="5"></a></p><h1 id="5-프로토타입-체이닝"><a href="#5-프로토타입-체이닝" class="headerlink" title="5. 프로토타입 체이닝"></a>5. 프로토타입 체이닝</h1><p><a name="5-1"></a></p><h2 id="5-1-프로토타입의-두가지-의미"><a href="#5-1-프로토타입의-두가지-의미" class="headerlink" title="5.1 프로토타입의 두가지 의미"></a>5.1 프로토타입의 두가지 의미</h2><p>자바스크립트는 <strong>프로토타입기반의 객체지향 프로그래밍을 지원</strong><br>자바스크립트의 모든 객체는 자신의 부모인 프로토타입 객체를 가리키는 참조 링크 형태로 숨겨진 프로퍼티가 있다.<br>implicit prototype link : <span class="mint">[[Prototype]]</span></p><ul><li>prototype객체와 [[Prototype]]링크는 다른 개념이다.</li></ul><p><a name="5-2"></a></p><h2 id="5-2-객체-리터럴-방식으로-생성된-객체의-프로토타입-체이닝"><a href="#5-2-객체-리터럴-방식으로-생성된-객체의-프로토타입-체이닝" class="headerlink" title="5.2 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝"></a>5.2 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝</h2><p><strong>프로토타입 체이닝</strong><br>자바스크립트에서 특정 객체의 <strong>프로퍼티나 메서드에 접근</strong>하려고 할 때,<br>해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면<br><strong>[[Prototype]]링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것</strong></p><p><a name="5-3"></a></p><h2 id="5-3-생성자-함수로-생성된-객체의-프로토타입-체이닝"><a href="#5-3-생성자-함수로-생성된-객체의-프로토타입-체이닝" class="headerlink" title="5.3 생성자 함수로 생성된 객체의 프로토타입 체이닝"></a>5.3 생성자 함수로 생성된 객체의 프로토타입 체이닝</h2><p>객체 리터럴 방식과 약간 다른 프로토타입 체이닝이 이뤄지지만 아래의 기본 원칙은 지킨다.</p><blockquote><p>자바스크립트에서 모든 객체는 자신을 생성한 생성자함수의 prototype 프로퍼티가 가리키는 객체를<br>  자신의 프로토타입객체(부모객체)로 취급한다.</p></blockquote><p><a name="5-4"></a></p><h2 id="5-4-프로토타입-체이닝의-종점"><a href="#5-4-프로토타입-체이닝의-종점" class="headerlink" title="5.4 프로토타입 체이닝의 종점"></a>5.4 프로토타입 체이닝의 종점</h2><p><span class="mint">Object.prototype</span>이 프로토타입 체이닝의 종점이다.</p><p><a name="5-5"></a></p><h2 id="5-5-기본-데이터-타입-확장"><a href="#5-5-기본-데이터-타입-확장" class="headerlink" title="5.5 기본 데이터 타입 확장"></a>5.5 기본 데이터 타입 확장</h2><p>자바스크립트는 Object.prtototype, String,prototype 등과 같이<br><strong>표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다.</strong></p><blockquote><p>공용적으로 사용하는 메서드의 경우 prototype에 선언하긔<br>angular에서 pipe의 성격으로 사용하는 함수들을 prototype에 넣어도 됨</p></blockquote><p><a name="5-6"></a></p><h2 id="5-6-프로토타입도-자바스크립트-객체다"><a href="#5-6-프로토타입도-자바스크립트-객체다" class="headerlink" title="5.6 프로토타입도 자바스크립트 객체다"></a>5.6 프로토타입도 자바스크립트 객체다</h2><p>프로토타입 객체 역시 자바스크립트 객체이므로, 일반 객체처럼 동적으로 프로퍼티를 추가/삭제하는 것이 가능하다.</p><p><a name="5-7"></a></p><h2 id="5-7-프로토타입-메서드와-this-바인딩"><a href="#5-7-프로토타입-메서드와-this-바인딩" class="headerlink" title="5.7 프로토타입 메서드와 this 바인딩"></a>5.7 프로토타입 메서드와 this 바인딩</h2><p>메서드 호출패턴에서의 this는 <strong>그 메서드를 호출한 객체에 바인딩된다.</strong><br>프로토타입 객체도 이 this바인딩 규칙이 적용된다.</p><p><a name="5-8"></a></p><h2 id="5-8-디폴트-프로토타입은-다른-객체로-변경이-가능하다"><a href="#5-8-디폴트-프로토타입은-다른-객체로-변경이-가능하다" class="headerlink" title="5.8 디폴트 프로토타입은 다른 객체로 변경이 가능하다"></a>5.8 디폴트 프로토타입은 다른 객체로 변경이 가능하다</h2><ul><li>이 특징을 이요해서 객체지향의 상속을 구현한다.</li></ul><p><a name="5-9"></a></p><h2 id="5-9-객체의-프로퍼티-읽기나-메서드를-실행할-때만-프로토타입-체이닝이-동작한다"><a href="#5-9-객체의-프로퍼티-읽기나-메서드를-실행할-때만-프로토타입-체이닝이-동작한다" class="headerlink" title="5.9 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다."></a>5.9 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다.</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-함수-호출과-this&quot;&gt;&lt;a href=&quot;#4-함수-호출과-t
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>4/ 함수와 프로토타입 체이닝 (1)</title>
    <link href="http://feel5ny.github.io/2018/08/25/JS_15/"/>
    <id>http://feel5ny.github.io/2018/08/25/JS_15/</id>
    <published>2018-08-25T12:20:19.000Z</published>
    <updated>2018-08-27T14:09:36.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.</p></blockquote><hr><p><a name="1"></a></p><h1 id="1-함수-정의"><a href="#1-함수-정의" class="headerlink" title="1. 함수 정의"></a>1. 함수 정의</h1><p><a name="1-1"></a></p><h2 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="1-2"></a></p><h2 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>add는 함수 변수</li><li>add는 함수의 참조값을 가진다.</li><li>함수이름이 없는 함수를 <strong>익명함수</strong>라고 부른다. anonymous function<ul><li><strong>익명 함수를 이용한 함수 표현식 방법(익명함수 표현식)</strong></li><li>익명함수의 호출은 호출연산자 <code>()</code>를 붙여서 기술한다.</li></ul></li></ul><h3 id="기명함수-표현식"><a href="#기명함수-표현식" class="headerlink" title="기명함수 표현식"></a>기명함수 표현식</h3><ul><li><p>함수 이름이 포함된 함수 표현식</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add 변수가 sum 함수를 참조한다. </span></span><br><span class="line"><span class="comment">// 때문에 외부에서 sum함수에 접근할 수 없고, add변수를 통해 접근가능하다.</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li><li><p>함수를 재귀적으로 호출하거나, 디버거에서 함수를 구분할 때 사용</p></li><li><p><span class="mint">함수 선언문은 <strong>자바스크립트 엔진</strong>에 의해서 <strong>함수 표현식</strong> 형태로 변경되기 때문에 호출가능하다.</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 함수는 자바스크립트 엔진에 의해서 아래와 같은 형태로 변환되다.</span></span><br><span class="line"><span class="keyword">var</span> add =<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 팩토리얼 함수</span></span><br><span class="line"><span class="keyword">var</span> factorialVar = <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorialVar(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">factorial(<span class="number">3</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>관습적으로 <span class="mint">함수 표현식 뒤에는 세미콜론을 붙인다.</span><br><a name="1-3"></a></p><h2 id="Function-생성자-함수"><a href="#Function-생성자-함수" class="headerlink" title="Function() 생성자 함수"></a>Function() 생성자 함수</h2><p>함수도 일반 객체처럼 값으로 취급된다. (일급객체)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x + y'</span>);</span><br></pre></td></tr></table></figure></li><li><p>자주 사용되지 않는다.<br><a name="1-4"></a></p><h2 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h2></li><li>함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로, 코드의 구조를 엉성하게 만들 수 있다.</li><li>함수 표현식을 권장한다.<br><span class="mint">이를 자세히 알기 위해서는 <strong>실행컨택스트</strong>를 이해하면 된다.</span></li><li>자바스크립트의 변수 생성과 초기화의 작업이 분리되서 진행되기 때문이다.</li></ul><hr><p><a name="2"></a></p><h1 id="2-함수-객체-함수도-객체다"><a href="#2-함수-객체-함수도-객체다" class="headerlink" title="2. 함수 객체: 함수도 객체다."></a>2. 함수 객체: 함수도 객체다.</h1><p><a name="2-1"></a></p><h2 id="2-1-자바스크립트에서는-함수도-객체다"><a href="#2-1-자바스크립트에서는-함수도-객체다" class="headerlink" title="2.1 자바스크립트에서는 함수도 객체다."></a>2.1 자바스크립트에서는 함수도 객체다.</h2><p>함수 자체가 <span class="mint">일반 객체처럼 프로퍼티들을 가질 수 있다.</span><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.result = add(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">add.status = <span class="string">'OK'</span>;</span><br></pre></td></tr></table></figure></p><p><a name="2-2"></a></p><h2 id="2-2-자바스크립트에서-함수는-값으로-취급된다-일급객체"><a href="#2-2-자바스크립트에서-함수는-값으로-취급된다-일급객체" class="headerlink" title="2.2 자바스크립트에서 함수는 값으로 취급된다. (일급객체)"></a>2.2 자바스크립트에서 함수는 값으로 취급된다. (일급객체)</h2><p>자바스크립트에서 함수는 <span class="mint">일급객체</span>이다.</p><ul><li>변수나 배열 요소, 객체의 프로퍼티 등에 할당 가능</li><li>함수의 인자로 전달가능</li><li>함수의 리턴값으로 리턴 가능</li><li>리터럴에 의해 성성</li><li>동적으로 프로퍼티를 생성 및 할당 가능</li></ul><p>이 특징때문에 함수형 프로그래밍이 가능하다.<br>자바스크립트의 함수를 제대로 이해하려면<br>함수가 일급 객체이며<br>이는 곧 함수가 일반 객체처럼 <span class="mint">값</span>으로 취급된다는 것을 이해해야한다.</p><h3 id="2-2-1-변수나-프로퍼티의-값으로-할당"><a href="#2-2-1-변수나-프로퍼티의-값으로-할당" class="headerlink" title="2.2.1 변수나 프로퍼티의 값으로 할당"></a>2.2.1 변수나 프로퍼티의 값으로 할당</h3><ul><li>변수나 <span class="mint">프로퍼티의 값</span>으로 할당될 수 있다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">100</span>;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar()); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.baz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">200</span>;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.baz()) <span class="comment">// 200;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  obj = &#123;</span></span><br><span class="line"><span class="comment">    baz: function()&#123;reutrn 200&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-함수-인자로-전달"><a href="#2-2-2-함수-인자로-전달" class="headerlink" title="2.2.2 함수 인자로 전달."></a>2.2.2 함수 인자로 전달.</h3><h3 id="2-2-3-리턴값으로-활용"><a href="#2-2-3-리턴값으로-활용" class="headerlink" title="2.2.3 리턴값으로 활용."></a>2.2.3 리턴값으로 활용.</h3><blockquote><p>클로저</p></blockquote><p><a name="2-3"></a></p><h2 id="2-3-함수-객체의-기본-프로퍼티"><a href="#2-3-함수-객체의-기본-프로퍼티" class="headerlink" title="2.3 함수 객체의 기본 프로퍼티"></a>2.3 함수 객체의 기본 프로퍼티</h2><p><span class="mint">함수 객체만의 표준 프로퍼티</span>가 정의되어 있다.<br><img src="/images/2018/31/add.png"></p><h3 id="ECMA5-스크립트-명세서에는-모든-함수가-length와-prototype프로퍼티를-가져야-한다도-기술되어있다"><a href="#ECMA5-스크립트-명세서에는-모든-함수가-length와-prototype프로퍼티를-가져야-한다도-기술되어있다" class="headerlink" title="ECMA5 스크립트 명세서에는 모든 함수가 length와 prototype프로퍼티를 가져야 한다도 기술되어있다."></a>ECMA5 스크립트 명세서에는 <span class="mint">모든 함수가 length와 prototype프로퍼티를 가져야 한다도 기술되어있다.</span></h3><p>length, prototype 이외의 프로퍼티는 ECMA 표준이 아니다.</p><ul><li>arguments</li><li>caller</li><li>name</li><li><code>__proto__</code></li></ul><ol><li>name<ul><li>함수의 이름</li><li>익명함수라면 빈배열</li></ul></li><li>caller<ul><li>자신을 호출한 함수를 나타낸다.</li></ul></li><li>arguments<ul><li>파라미터값을 모아둔 유사배열객체이다.</li></ul></li><li><code>__proto__</code></li></ol><h3 id="Function-prototype객체의-프로토타입-객체는"><a href="#Function-prototype객체의-프로토타입-객체는" class="headerlink" title="Function.prototype객체의 프로토타입 객체는?"></a><span class="mint">Function.prototype객체</span>의 프로토타입 객체는?</h3><blockquote><p>대박 처음에 프로토타입 공부할 때 한참 헷갈렸던 부분</p></blockquote><ul><li>모든 함수들의 부모 객체는 <strong>Function Prototype</strong>객체라고 했다.</li><li>ECMAScript 명세서에서는 Function.prototype은 <strong>함수</strong>라고 정의하고 있다.</li><li>Function.prototype 함수 객체도 결국 함수이니까,<br>Function.prototype객체, 즉 자기 자신을 부모가 갖는 것인가??</li></ul><p>ECMAScript 명세서에서는 <strong>예외적으로</strong> Function.prototype 함수 객체의 부모는 Object.prototype 객체라고 설명하고 있다.</p><p>Function.prototype 객체가 표준으로 가지는 프로퍼티나 메서드.</p><ul><li><code>constructor</code> 프로퍼티</li><li><code>toString()</code> 메서드 (Object.prototype에도 존재한다.)</li><li><code>apply(thisArg, argArray)</code> 메서드</li><li><code>call(thisArg, [, arg1 [,arg2,]])</code> 메서드</li><li><code>bind(thisArg, [, arg1 [,arg2,]])</code> 메서드</li></ul><h3 id="2-3-1-length"><a href="#2-3-1-length" class="headerlink" title="2.3.1 length"></a>2.3.1 length</h3><p>인자의 개수를 나타내고 있다.</p><h3 id="2-3-2-prototype-프로퍼티"><a href="#2-3-2-prototype-프로퍼티" class="headerlink" title="2.3.2 prototype 프로퍼티"></a>2.3.2 prototype 프로퍼티</h3><p>모든 함수는 객체로서 <strong>prototype 프로퍼티</strong>를 갖고 있다.</p><ul><li>함수 객체만 가지고 있는 프로퍼티이다.</li><li>내부 프로퍼티인 <code>__proto__</code>와 혼동되면 안된다.</li><li><code>__proto__</code>는 부모 역할을 하는 프로토타입 객체를 가리킨다.</li><li>prototype 프로퍼티는 이 함수가 생성자로 사용될 때,<br>이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킨다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>, <span class="string">'male'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(Person);</span><br><span class="line"><span class="built_in">console</span>.dir(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__ === Person.prototype);                <span class="comment">// ① true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">// ② true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person);           <span class="comment">// ③ true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype);           <span class="comment">// ④ true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// ⑤ true</span></span><br></pre></td></tr></table></figure><p><img src="/images/2018/31/01.png"></p><blockquote><p>(이미지출처 : <a href="https://poiemaweb.com/js-prototype" target="_blank" rel="noopener">https://poiemaweb.com/js-prototype</a>)</p></blockquote><hr><p><a name="3"></a></p><h1 id="3-함수의-다양한-형태"><a href="#3-함수의-다양한-형태" class="headerlink" title="3. 함수의 다양한 형태"></a>3. 함수의 다양한 형태</h1><p><a name="3-1"></a></p><h2 id="3-1-콜백함수"><a href="#3-1-콜백함수" class="headerlink" title="3.1 콜백함수"></a>3.1 콜백함수</h2><p>함수 표현식에서 함수이름은 꼭 붙이지 않아도 되는 선택사항이다. (익명함수)<br><span class="mint">익명함수의 대표적인 용도가 <strong>콜백함수.</strong></span></p><p>콜백함수는 코드를 통해 명시적으로 호출하는 함수가 아니라,<br>개발자는 단지 함수를 등록하기만 하고,<br><strong>어떤 이벤트가 발생하거나 <u>특정 시점</u>에 도달했을 때<br>시스템에서 호출되는 함수를 말한다.</strong></p><p>또한, 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백함수가 될 수 있다.</p><ul><li>대표적인 콜백함수는 이벤트 핸들러 처리.<ul><li>DOM 이벤트가 발생할 경우, 이벤트 핸들러를 발생시킨다.</li></ul></li></ul><p><a name="3-2"></a></p><h2 id="3-2-즉시실행함수"><a href="#3-2-즉시실행함수" class="headerlink" title="3.2 즉시실행함수"></a>3.2 즉시실행함수</h2><p>= 함수를 정의함과 동시에 바로 실행하는 함수<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h3 id="사용하는-곳"><a href="#사용하는-곳" class="headerlink" title="사용하는 곳"></a>사용하는 곳</h3><ol><li>초기화 코드<ul><li>같은 함수를 다시 호출할 수 없다.</li><li><span class="mint">최초 <strong>한번</strong>의 실행만을 필요로 하는 <strong>초기화 코드</strong> 부분</span> 등에 사용한다.</li></ul></li><li><p>자바스크립트 라이브러리나 프레임워크 소스들 (like Jquery)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(fucntion(<span class="built_in">window</span>, <span class="literal">undefined</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><ul><li>변수 스코프를 위해서 사용한다. 함수 코드 내부에서만 유효할 수 있도록</li><li>라이브러리 내의 변수들은 함수 외부에서 접근할 수 없다.</li></ul></li></ol><p><a name="3-3"></a></p><h2 id="3-3-내부-함수"><a href="#3-3-내부-함수" class="headerlink" title="3.3 내부 함수"></a>3.3 내부 함수</h2><p>함수 코드 내부에서 함수 정의</p><ul><li><p>공용으로 쓰이지 않고 정말 내부에서만 쓰일때</p><blockquote><p>예_ html을 만드는 함수에서 받은 data에서 특정 추가작업을 해야하고, 공용함수로 쓰이지 않을 경우</p></blockquote></li><li><p>내부함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다.</p></li><li>내부 함수는 일반적으로 자신이 정의된 부모함수내부에서만 호출 가능하다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">300</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 내부에서 참조가 시작하므로, 내부에서 참조가능했다면 부모스코프까지 가지 않는다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  child();</span><br><span class="line">&#125;</span><br><span class="line">parent(); <span class="comment">// 100 300</span></span><br><span class="line">child(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/2018/31/inner_function.jpeg" width="500"></p><ul><li>하지만, 함수 외부에서도 특정 함수 스코프 안에 선언된 내부 함수 호출이 가능하다. <span class="mint">(클로저)</span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = parent(); <span class="comment">// inner에 child 함수변수가 리턴된다. </span></span><br><span class="line">inner(); <span class="comment">// 클로저</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/2018/31/closure.jpeg" width="500"></p><hr><p><a name="3-4"></a></p><h2 id="3-4-함수를-리턴하는-함수"><a href="#3-4-함수를-리턴하는-함수" class="headerlink" title="3.4 함수를 리턴하는 함수"></a>3.4 함수를 리턴하는 함수</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-함수-정의&quot;&gt;&lt;a href=&quot;#1-함수-정의&quot; class=&quot;
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>3/ 자바스크립트 데이터 타입과 연산자</title>
    <link href="http://feel5ny.github.io/2018/08/23/JS_14/"/>
    <id>http://feel5ny.github.io/2018/08/23/JS_14/</id>
    <published>2018-08-23T12:20:19.000Z</published>
    <updated>2018-08-23T15:18:50.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.</p></blockquote><hr><p>목차 </p><ol><li>객체 프로퍼티 읽기/쓰기/갱신<ul><li>객체 프로퍼티에 접근하는 방법</li><li><code>for in</code>문 객체 프로퍼티 출럭</li><li>객체 <strong>프로퍼티</strong> 삭제 <code>delete</code></li></ul></li><li>배열과 객체<ul><li>배열과 객체의 유사점과 차이점</li><li>배열의 프로퍼티 동적생성</li><li>유사배열<strong>객체</strong></li></ul></li></ol><hr><h3 id="1-객체-프로퍼티-읽기-쓰기-갱신"><a href="#1-객체-프로퍼티-읽기-쓰기-갱신" class="headerlink" title="1. 객체 프로퍼티 읽기/쓰기/갱신"></a>1. 객체 프로퍼티 읽기/쓰기/갱신</h3><h4 id="1-1-객체-프로퍼티에-접근하는-방법"><a href="#1-1-객체-프로퍼티에-접근하는-방법" class="headerlink" title="1-1. 객체 프로퍼티에 접근하는 방법"></a>1-1. 객체 프로퍼티에 접근하는 방법</h4><ul><li>대괄호 표기법</li><li><p>마침표 표기법</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  major: <span class="string">'computer science'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 프로퍼티 읽기</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.name) <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="string">'name'</span>]) <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 프로퍼티 갱신</span></span><br><span class="line">foo.major = <span class="string">'electronics engineering'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.major);</span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="string">'major'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 프로퍼티 동적 생성</span></span><br><span class="line">foo.age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 대괄호 표기법만을 사용해야 할 경우</span></span><br><span class="line">foo[<span class="string">'full-name'</span>] = <span class="string">'foo bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="string">'full-name'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(foo.full-name);</span><br><span class="line"><span class="built_in">console</span>.log(foo.full);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure></li><li><p><strong>대괄호 표기법만 사용해야하는 경우</strong> </p><ul><li>접근하려는 프로퍼티가 표현식이거나 예약어 일 경우.</li></ul></li></ul><h4 id="1-2-for-in문-객체-프로퍼티-출럭"><a href="#1-2-for-in문-객체-프로퍼티-출럭" class="headerlink" title="1-2. for in문 객체 프로퍼티 출럭"></a>1-2. <code>for in</code>문 객체 프로퍼티 출럭</h4><p>  for in 문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.</p><blockquote><p>키 값을 출력할 수 있음</p></blockquote>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  major: <span class="string">'computer science'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prop;</span><br><span class="line"><span class="keyword">for</span>(prop <span class="keyword">in</span> foo)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop, foo[prop]); </span><br><span class="line">  <span class="comment">// name foo</span></span><br><span class="line">  <span class="comment">// age 30</span></span><br><span class="line">  <span class="comment">// major 'computer science'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-객체-프로퍼티-삭제-delete"><a href="#1-3-객체-프로퍼티-삭제-delete" class="headerlink" title="1-3. 객체 프로퍼티 삭제 delete"></a>1-3. 객체 <strong>프로퍼티</strong> 삭제 <code>delete</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> foo.major</span><br><span class="line"><span class="built_in">console</span>.log(foo.major) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-배열과-객체"><a href="#2-배열과-객체" class="headerlink" title="2. 배열과 객체"></a>2. 배열과 객체</h3><h4 id="2-1-배열과-객체의-유사점과-차이점"><a href="#2-1-배열과-객체의-유사점과-차이점" class="headerlink" title="2-1. 배열과 객체의 유사점과 차이점"></a>2-1. 배열과 객체의 유사점과 차이점</h4><p>  자바스크립트에서 배열 역시 객체인데, 배열과 일반객체와는 약간 차이가 있다.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//colorsArray 배열</span></span><br><span class="line"><span class="keyword">const</span> colorsArray = [<span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colorsArray[<span class="number">0</span>]); <span class="comment">// orange</span></span><br><span class="line"><span class="built_in">console</span>.log(colorsArray[<span class="number">1</span>]); <span class="comment">// yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(colorsArray[<span class="number">2</span>]); <span class="comment">// green</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// colorsObj 객체</span></span><br><span class="line"><span class="keyword">const</span> colorsObj = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'yellow'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'green'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colorsObj[<span class="number">0</span>]); <span class="comment">// orange</span></span><br><span class="line"><span class="built_in">console</span>.log(colorsObj[<span class="number">1</span>]); <span class="comment">// yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(colorsObj[<span class="number">2</span>]); <span class="comment">// green</span></span><br></pre></td></tr></table></figure><ul><li>대괄호 안에는 접근하려는 프로퍼티의 속성을 <strong>문자열 형태</strong>로 적어야 한다.<br>하지만 자바스크립트 엔진이 [] 연산자 내에 숫자가 사용될 경우,<br>해당 숫자를 자동으로 문자열 형태로 바꿔준다.<br>-</li></ul><h4 id="2-2-배열의-프로퍼티-동적-생성"><a href="#2-2-배열의-프로퍼티-동적-생성" class="headerlink" title="2-2. 배열의 프로퍼티 동적 생성"></a>2-2. 배열의 프로퍼티 동적 생성</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>];</span><br><span class="line">arr.color = <span class="string">'blue'</span>;</span><br><span class="line">arr.name = <span class="string">'number_array'</span>;</span><br></pre></td></tr></table></figure><p>  <img src="/images/2018/30/01.png"></p><blockquote><p>신기하다!!</p></blockquote><h4 id="2-3-유사배열객체-array-like-objects"><a href="#2-3-유사배열객체-array-like-objects" class="headerlink" title="2-3. 유사배열객체 array like objects"></a>2-3. 유사배열<strong>객체</strong> array like objects</h4><p>일반 객체에 length라는 프로퍼티가 있으면 어떻게 될까?<br>자바스크립트에서는 length라는 프로퍼티를 갖고 있는 객체를 <strong>유사배열객체</strong>라고 한다. </p><ul><li><code>apply()</code>메서드를 사용하여 객체지만 표준 배열 메서드를 활용하는 것이 가능하다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'bar'</span>];</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'foo'</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr.push(<span class="string">'baz'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['bar', 'baz']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(obj, [<span class="string">'baz'</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;📒 인사이드 자바스크립트 중 메모해야할 부분만 적었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;객체 프로퍼티 읽기/쓰기/갱신&lt;ul&gt;
&lt;li&gt;객체 프로퍼티에 접근하는 방법&lt;/li&gt;

      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>1부/ chap03. RxJs가 해결하려고 했던 문제(3)_로직 오류</title>
    <link href="http://feel5ny.github.io/2018/08/15/Async_03/"/>
    <id>http://feel5ny.github.io/2018/08/15/Async_03/</id>
    <published>2018-08-15T11:12:34.000Z</published>
    <updated>2018-08-16T15:14:07.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[📕 퀵스타트 Rxjs]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>웹 어플리케이션의 로직</li><li>로직의 복잡성 그리고 오류</li><li>자바스크립트의 솔루션</li></ol><hr><hr><hr><h2 id="1-웹-어플리케이션의-로직"><a href="#1-웹-어플리케이션의-로직" class="headerlink" title="1. 웹 어플리케이션의 로직"></a>1. 웹 어플리케이션의 로직</h2><p>데이터를 추출하고 변환하는 작업을 빈번하게 하고 있다.</p><ul><li>반복문 사용, 분기문 사용, 변수 사용</li></ul><hr><h2 id="2-로직의-복잡성-그리고-오류"><a href="#2-로직의-복잡성-그리고-오류" class="headerlink" title="2. 로직의 복잡성 그리고 오류"></a>2. 로직의 복잡성 그리고 오류</h2><p>반복문, 분기문, 변수는 우리 코드를 복잡하게 만든다.<br>반복문 : 가독성을 떨어뜨림<br>분기문 : 확인해야 할 프로그램의 흐름을 여러 개로 만듦<br>변수 : 누군가에 의해 변경 될 수 있다.<br>=&gt; 오류 발생 빈도를 높인다.</p><h3 id="2-1-반복문과-분기문"><a href="#2-1-반복문과-분기문" class="headerlink" title="2.1 반복문과 분기문"></a>2.1 반복문과 분기문</h3><p>로직의 복잡성을 줄이는 방법 : 기능을 쪼개기 (관심사 분리)<br>기능을 추상화</p><h3 id="2-3-변수는-오류의-시작"><a href="#2-3-변수는-오류의-시작" class="headerlink" title="2.3 변수는 오류의 시작"></a>2.3 변수는 오류의 시작</h3><p>변수의 사용은 오류를 발생시킬 수 잇는 확률을 높인다는 것.</p><hr><h2 id="3-자바스크립트의-솔루션"><a href="#3-자바스크립트의-솔루션" class="headerlink" title="3. 자바스크립트의 솔루션"></a>3. 자바스크립트의 솔루션</h2><p>함수형 프로그래밍의 특성을 가진 자바스크립트 함수를 이용하면<br>실제 로직과 상관없는 반복분, 분기문을 분리할 수 있다.</p><blockquote><p>자바스크립트는 일급객체!</p><ul><li>함수를 변수 혹은 데이터 구조에 저장할 수 있다.</li><li>파라미터로 함수를 전달 할 수 있다.</li><li>반환값으로 사용할 수 있다. </li></ul></blockquote><h3 id="3-1-로직의-분리"><a href="#3-1-로직의-분리" class="headerlink" title="3.1 로직의 분리"></a>3.1 로직의 분리</h3><p>고차함수 Higher-order function</p><ul><li>다른 함수를 인자로 받거나 그 결과로 함수를 반환하는 함수</li><li>고차 함수는 변경되는 주요 부분을 함수로 제공함으로써 동일한 패턴 내에 존재하는 문제를 손수비게 해결할 수 있는 고급 프로그래밍 기법이다.</li><li>고차 함수를 이용하면 함수의 합성, 변형과 같은 작업을 손쉽게 할 수 있다.<br>더불어 커링(리액트 dispatch), 메모이제이션과 같은 기법도 사용할 수 있다. </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> html = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> user <span class="keyword">of</span> people.results) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/male|female/</span>.test(user.gender)) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = logic(user.height, user.mass, user.gender);</span><br><span class="line">      <span class="built_in">Object</span>.assign(user,result);</span><br><span class="line">      html.push(makeHtml(user));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> html.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> people.results</span><br><span class="line">      .filter(<span class="function"><span class="params">user</span> =&gt;</span> /male|femail/.test(user.gender))</span><br><span class="line">      .map(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">Object</span>.assign(user, logic(user.height, user.mass, user.gender)))</span><br><span class="line">      .reduce(<span class="function">(<span class="params">acc,user</span>)=&gt;</span> &#123; </span><br><span class="line">        acc.push(makeHtml(user))</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">      &#125;, []).join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>개선된 process에서는 반복문, 분기문, 변수가 존재하지 않는다.<br>핵심로직은 분리되었고<br>코드의 흐름은 단일화 되었다.<br>변수를 사용하지 않음으로써 오류 발생 빈도도 크게 줄었다.</p><hr><h2 id="4-rxjs는-어떻게-개선하였나"><a href="#4-rxjs는-어떻게-개선하였나" class="headerlink" title="4. rxjs는 어떻게 개선하였나?"></a>4. rxjs는 어떻게 개선하였나?</h2><h3 id="4-1-rxjs가-제공하는-오퍼레이터"><a href="#4-1-rxjs가-제공하는-오퍼레이터" class="headerlink" title="4.1 rxjs가 제공하는 오퍼레이터"></a>4.1 rxjs가 제공하는 오퍼레이터</h3><p><a href="http://reactivex.io/rxjs/manual/index.html" target="_blank" rel="noopener">http://reactivex.io/rxjs/manual/index.html</a><br>rxjs에서 제공하는 오퍼레이터를 이용하면 observable을 생성할 수도 있고,<br>전달된 데이터를 변환하거나 필요한 데이터만을 추출할 수도 있다.</p><h3 id="4-2-불변-객체-observable"><a href="#4-2-불변-객체-observable" class="headerlink" title="4.2 불변 객체 observable"></a>4.2 불변 객체 observable</h3><p>ES5 Array의 고차함수들이 반환값으로 새로운 Array 객체를 반환하여 각각에 영향을 미치지 않도록 하는 것과 같이,<br>rxjs의 오퍼레이터는 항상 <strong>새로운 observable</strong>을 반환함으로써 array의 고차 함수와 같이 <strong>불변 객체</strong>(immutable object)를 반환한다.</p><p>차이점 : Array의 리턴 객체는 새로운 레퍼런스 객체지만,observable과 달리 객체 자체가 불변객체는 아니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> mappedArr = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr === mappedArr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><ul><li>Array의 경우 새로운 Array 객체 생성 작업만 함</li><li>Observable은 새로운 Observable을 만들고,<br>그 Observable이 오퍼레이터를 호출한 원래의 Observable을 내부적으로 구독한다!!<ul><li>링크드 리스트 형태로 기존 Observable 객체와 새롭게 만든 Observable 객체를 오퍼레이터로 연결한다.</li></ul></li></ul><h3 id="∴-rxjs의-오퍼레이터로-생성된-Observable은-항상-불변-객체를-반환한다-오퍼레이터의-인자로-순수함수를-받음으로써-함수형-프로그래밍에서-추구하는-부원인과-부작용을-제거한다"><a href="#∴-rxjs의-오퍼레이터로-생성된-Observable은-항상-불변-객체를-반환한다-오퍼레이터의-인자로-순수함수를-받음으로써-함수형-프로그래밍에서-추구하는-부원인과-부작용을-제거한다" class="headerlink" title="∴ rxjs의 오퍼레이터로 생성된 Observable은 항상 불변 객체를 반환한다. 오퍼레이터의 인자로 순수함수를 받음으로써, 함수형 프로그래밍에서 추구하는 부원인과 부작용을 제거한다."></a>∴ rxjs의 오퍼레이터로 생성된 Observable은 항상 불변 객체를 반환한다. 오퍼레이터의 인자로 순수함수를 받음으로써, 함수형 프로그래밍에서 추구하는 부원인과 부작용을 제거한다.</h3><hr><p>참고링크<br><a href="http://reactivex.io/rxjs/manual/index.html" target="_blank" rel="noopener">http://reactivex.io/rxjs/manual/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[📕 퀵스타트 Rxjs]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="async" scheme="http://feel5ny.github.io/tags/async/"/>
    
      <category term="rxjs" scheme="http://feel5ny.github.io/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>2부/ chap01. RxJs란 무엇인가?</title>
    <link href="http://feel5ny.github.io/2018/08/15/Async_04/"/>
    <id>http://feel5ny.github.io/2018/08/15/Async_04/</id>
    <published>2018-08-15T11:12:34.000Z</published>
    <updated>2018-08-16T15:14:23.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[📕 퀵스타트 Rxjs]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>RxJS란?</li><li>RxJS 시작하기<br>2.1 RxJS 첫번째 예제<br>2.2 RxJS 첫번째 예제 개선하기<br>2.3 RxJS 두번째 예제</li><li>RxJS 4대 천왕<br>3.1 Observable<br>3.2 오퍼레이터<br>3.3 Observer<br>3.4 Subscription</li><li>RxJS 개발 방법</li></ol><hr><hr><hr><h2 id="1-RxJS란"><a href="#1-RxJS란" class="headerlink" title="1. RxJS란?"></a>1. RxJS란?</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[📕 퀵스타트 Rxjs]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="async" scheme="http://feel5ny.github.io/tags/async/"/>
    
      <category term="rxjs" scheme="http://feel5ny.github.io/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>1부/ chap02. RxJs가 해결하려고 했던 문제(2)_상태 전파 문제</title>
    <link href="http://feel5ny.github.io/2018/08/15/Async_02/"/>
    <id>http://feel5ny.github.io/2018/08/15/Async_02/</id>
    <published>2018-08-15T05:12:34.000Z</published>
    <updated>2018-08-16T15:14:05.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[📕 퀵스타트 Rxjs]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>웹 어플리케이션의 상태</li><li>웹 어플리케이션의 상태 변화로 인한 문제점</li><li>우리가 이미 알고 있는 솔류션</li><li>흔한 예</li><li>적용하기</li><li>rxjs는 무엇을 해결하고자 했는가?</li><li>rxjs는 어떻게 개선하였나?</li><li>observable은 리액티브하다.</li></ol><hr><hr><hr><h1 id="상태-전파-오류"><a href="#상태-전파-오류" class="headerlink" title="상태 전파 오류"></a>상태 전파 오류</h1><p>상태 전파. state propagation</p><h2 id="1-웹-어플리케이션의-상태"><a href="#1-웹-어플리케이션의-상태" class="headerlink" title="1. 웹 어플리케이션의 상태"></a>1. 웹 어플리케이션의 상태</h2><p>각각의 상태 머신들은 각자의 상태를 가지고 있고, 상태 머신들은 각자의 역할에 따라 서로 유기적으로 연결되어 있다.<br>모듈간의 의존성.<br>예_ 사용자정보(상태)를 System 클래스가 check()함수에서 사용하고 있는 예제</p><ul><li>변경에 대한 전파가 원활하게 이루어지지 않는다.</li></ul><hr><h2 id="3-우리가-이미-알고-있는-솔류션"><a href="#3-우리가-이미-알고-있는-솔류션" class="headerlink" title="3. 우리가 이미 알고 있는 솔류션"></a>3. 우리가 이미 알고 있는 솔류션</h2><h3 id="3-1-Loosely-Coupling"><a href="#3-1-Loosely-Coupling" class="headerlink" title="3.1 Loosely Coupling"></a>3.1 Loosely Coupling</h3><ul><li>옵저버 패턴에서는 상태가 변경될 대상을 Subject라고 한다.<br>그리고, 그 상태 변화를 관찰하는 대상을 Observer라고 한다.</li><li>subject와 observer는 서로 <strong>느슨하게 연결되어 있다.</strong><ul><li>여기서 <strong>느슨하게(Loosely Coupling)</strong>의 의미는 Subject와 Observer가 서로 상호작용을 하지만 <strong>서로 잘 모른다라는 뜻!!</strong></li><li>subject가 observer에 대해서 아는건 <strong>observer가 특정 인터페이스를 구현한다는 것 뿐.</strong></li><li>subject와 observer는 서로 <strong>독립적</strong>ㄴ으로 사용할 수 있으며, observer가 바뀌더라도 서로에게 영향을 미치지 않는다.</li></ul></li></ul><h3 id="3-2-자동-상태-전파"><a href="#3-2-자동-상태-전파" class="headerlink" title="3.2 자동 상태 전파"></a>3.2 자동 상태 전파</h3><p><strong>pull 시나리오</strong></p><ul><li>기존 방식과 같이 데이터를 얻고자 하는 대상이<br>데이터를 직접 가져오는 방식은<br><strong>매번 요청을 하여 변경사항을 확인해야만 한다.</strong></li></ul><p><strong>push 시나리오</strong></p><ul><li>하지만 옵서버 패턴은 이와 다르게<br>의존 관계의 대상(Subject)으로 부터<br><strong>데이터를 제공받는 방식</strong>이다.</li></ul><p>push 방식으로 구성된 옵서버패턴은<br>subject의 상태가 변경되었을 경우<br>관찰하는 observer에게 자동으로 알려준다.(subscribe)</p><p>subject와 observer가 <code>1:n</code>의 상황에서는 더욱 효과적이다.<br><strong>다수의 observer를 subject에 등록하기만 하면</strong><br>subject의 변경사항이 등록된 다수의 observer에게 자동으로 전달된다.</p><h3 id="3-3-인터페이스의-단일화"><a href="#3-3-인터페이스의-단일화" class="headerlink" title="3.3 인터페이스의 단일화"></a>3.3 인터페이스의 단일화</h3><p>옵저버 패턴은 Observer.update만 존재하기 때문에 Subject에서는 옵저버 인터페이스에 대한 별도의 비용이 존재하지 않는다.</p><hr><h2 id="4-옵저버-패턴의-흔한-예"><a href="#4-옵저버-패턴의-흔한-예" class="headerlink" title="4. 옵저버 패턴의 흔한 예"></a>4. <span style="color:blue">옵저버 패턴</span>의 흔한 예</h2><p>뉴스를 발행하는 신문사와 이를 구독하는 고객</p><p>뉴스를 발행하는 신문사 = subject<br>고객 = observer</p><p>신문사는 고객을 등록하고 신문이 발행될 때 각각의 고객에게 신문이 발행되었다고 알려준다.(notify)</p><p>신문이 발행되면<br>어떤 고객은 뉴스를 스크랩하거나,<br>어떤 고객은 뉴스를 읽기 시작한다.</p><hr><h2 id="6-RxJS는-무엇을-해결하고자-했는가"><a href="#6-RxJS는-무엇을-해결하고자-했는가" class="headerlink" title="6. RxJS는 무엇을 해결하고자 했는가?"></a>6. RxJS는 무엇을 해결하고자 했는가?</h2><p>rxjs도 상태 변화에 대한 문제를 옵저버 패턴을 기반으로 해결하려고 하였다.</p><h3 id="6-1-상태-변화는-언제-종료되는가"><a href="#6-1-상태-변화는-언제-종료되는가" class="headerlink" title="6.1 상태 변화는 언제 종료되는가?"></a>6.1 상태 변화는 언제 종료되는가?</h3><p>옵저버 패턴에는 종료 flag가 없기 때문에 별도의 규칙을 정해야한다.</p><blockquote><p><span class="pink">rxjs</span>에서는 complete</p></blockquote><h3 id="6-2-상태-변화에서-에러가-발생하면"><a href="#6-2-상태-변화에서-에러가-발생하면" class="headerlink" title="6.2 상태 변화에서 에러가 발생하면?"></a>6.2 상태 변화에서 에러가 발생하면?</h3><p>옵저버 패턴은 에러 발생여부를 observer들에게 전달할 방법은 딱히 없다.</p><blockquote><p><span class="pink">rxjs</span>에서는 error</p></blockquote><h3 id="6-3-observer에-의해-subject의-상태가-변경되는-경우"><a href="#6-3-observer에-의해-subject의-상태가-변경되는-경우" class="headerlink" title="6.3 observer에 의해 subject의 상태가 변경되는 경우?"></a>6.3 observer에 의해 subject의 상태가 변경되는 경우?</h3><p>코드의 복잡도를 증가시키는 경우가 많다.</p><blockquote><p><span class="pink">rxjs</span>에서는 옵저버블은 오직 read-only</p></blockquote><hr><h2 id="7-rxjs는-어떻게-개선하였나"><a href="#7-rxjs는-어떻게-개선하였나" class="headerlink" title="7. rxjs는 어떻게 개선하였나?"></a>7. rxjs는 어떻게 개선하였나?</h2><p>rxjs에서 전달되는 데이터는 모두 observable형태로 변환된다.<br>observable은 구독과정(subscribe)후부터 데이터를 전달받기 시작한다.</p><blockquote><p>rxjs의 observable<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;fromEvent&#125; = rxjs;</span><br><span class="line"><span class="keyword">const</span> clikc$ = fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</span><br><span class="line">clikc$.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">click$.subscribe(&#123;</span><br><span class="line">  next: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>observer pattern<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newsPaper = <span class="keyword">new</span> Subject();</span><br><span class="line">newPaper.add(&#123;</span><br><span class="line">  update: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>subject와 observer</strong></p><blockquote><p>상태가 변경되는 아이 : subject, observable</p></blockquote><p>rxjs의 observable ≒ 옵서버 패턴의 Subject</p><blockquote><p>변경된 상태를 알아야 하는 아이 : observer</p></blockquote><p><span class="mint">옵서버 패턴</span>의 observer는 <strong>add</strong>라는 메소드를 통해 subject에게 전달된다.<br><span class="pink">rxjs</span>의 observer는 함수와 객체 둘 다 가능하며 <strong>subscribe</strong>라는 메소드를 통해 subject에게 전달된다.</p><p>rxjs가 기존 옵저버 패턴의 아쉬웠던 점을 개선하고자 했기 때문이다.</p><h4 id="cf-Rxjs의-Observable과-Subject"><a href="#cf-Rxjs의-Observable과-Subject" class="headerlink" title="cf_Rxjs의 Observable과 Subject"></a>cf_Rxjs의 Observable과 Subject</h4><p>Rxjs에는 observable도 있고 subject도 있다.</p><p>rxjs의 subject는 기능적으로 정확히 옵저버패턴의 subject와 일치한다.<br>rxjs의 subject는 다수의 observer에게 <strong>공통의 데이터</strong>를 전달하고, update와 같은 메소드가 존재하여 데이터 변경도 가능하다.</p><p>rxjs의 observable은 기능적으로 옵저버 패턴의 subject와는 엄격히 다르다.<br>observable은 하나의 observer에게 독립적인 데이터를 전달한다.</p><h3 id="7-1-인터페이스의-확장"><a href="#7-1-인터페이스의-확장" class="headerlink" title="7.1 인터페이스의 확장"></a>7.1 인터페이스의 확장</h3><ol><li><p><span class="mint">update</span> =&gt; <span class="pink">next</span><br>데이터의 연속적인 변화를 observer에서 표현할 수 있도록 기존 update메서드를 next로 바꾸었다.</p><blockquote><p>개인적으로는 update가 더 명시적이다 ..ㅜ</p></blockquote></li><li><p>종료시점, 에러시점<br>옵저버 패턴에는 없던 종료시점, 에러시점을 개선,<br>종료는 compleate<br>에러는 error</p></li></ol><p><img src="/images/2018/24/04.jpeg" width="500px"></p><blockquote><p>rxjs</p></blockquote><p><img src="/images/2018/24/03.jpeg" width="500px"></p><blockquote><p>옵저버패턴</p></blockquote><h4 id="왜-객체가-아닌-함수를-사용하는-것인가"><a href="#왜-객체가-아닌-함수를-사용하는-것인가" class="headerlink" title="왜 객체가 아닌 함수를 사용하는 것인가?"></a>왜 객체가 아닌 함수를 사용하는 것인가?</h4><p>observable.subscribe는 객체, 함수 모든 형태로 전달 받을 수는 있다.<br>subscribe는 특별한 경우를 제외하고는 가급적 함수 형태를 사용한다.</p><p>객체는 상태를 가질 수 없기 때문이다.<br>객체가 상태를 가진다는 의미 =&gt; <strong>또다른 상태 머신</strong>이 될 수 있다는 의미.<br>반면 함수는 상태가 존재하지 않는 <strong>기능만을 담당하기 때문에</strong> 상태에 관한 문제에서는 보다 자유롭다.</p><h3 id="7-2-옵저버블은-Read-only"><a href="#7-2-옵저버블은-Read-only" class="headerlink" title="7.2 옵저버블은 Read-only"></a>7.2 옵저버블은 Read-only</h3><p>observable은 subscribe를 통해 데이터를 전달할 대상에게 데이터를 전달할 수는 있지만,<br>반대로 observer에게 데이터를 전달받을 수 없다.</p><ul><li>데이터 흐름을 단순화함으로 복잡도를 낮추고 오류 발생 빈도를 줄인다.</li></ul><hr><h2 id="8-Observable은-리액티브하다"><a href="#8-Observable은-리액티브하다" class="headerlink" title="8. Observable은 리액티브하다."></a>8. Observable은 리액티브하다.</h2><p>데이터가 발생하게 되면 옵저버에게 자동으로 빠르게 변경된 데이터를 전달한다.<br>이를 보고 리액티브하다고 이야기한다.</p><h4 id="리액티브-프로그래밍이란"><a href="#리액티브-프로그래밍이란" class="headerlink" title="리액티브 프로그래밍이란?"></a>리액티브 프로그래밍이란?</h4><p>데이터 흐름과 상태 변화 전파에 중점을 둔 프로그램 패러다임이다.<br>사용되는 프로그래밍 언어에서<br><strong>데이터 흐름</strong>을 쉽게 표현할 수 있어야 하며<br>기본 실행 모델이 변경 사항을 데이터 흐름을 통해 <strong>자동으로 전파</strong>한다는 것을 의미한다.</p><blockquote><p>예: 엑셀</p></blockquote><p>이런 고민의 해결책이 <span class="mint">옵저버 패턴</span>이고,<br><span class="pink">rxjs</span>는 이런 옵저버 패턴을 개선하여 애플리케이션에서 발생하는 모든 데이터를 리액티브하게 전달할 수 있게 해준다.</p><h3 id="∴-rxjs는-리액티브-프로그래밍을-지향하는-라이브러리이다"><a href="#∴-rxjs는-리액티브-프로그래밍을-지향하는-라이브러리이다" class="headerlink" title="∴ rxjs는 리액티브 프로그래밍을 지향하는 라이브러리이다"></a>∴ rxjs는 리액티브 프로그래밍을 지향하는 라이브러리이다</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[📕 퀵스타트 Rxjs]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="async" scheme="http://feel5ny.github.io/tags/async/"/>
    
      <category term="rxjs" scheme="http://feel5ny.github.io/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>1부/ chap01. RxJs가 해결하려고 했던 문제(1)_입력데이터의 오류</title>
    <link href="http://feel5ny.github.io/2018/08/15/Async_01/"/>
    <id>http://feel5ny.github.io/2018/08/15/Async_01/</id>
    <published>2018-08-15T02:12:34.000Z</published>
    <updated>2018-08-16T15:13:57.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[📕 퀵스타트 Rxjs]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>웹 어플리케이션의 입력 데이터</li><li>입력 데이터의 <strong>전달 시점</strong>이 다양하다. - 동기/비동기</li><li>동기와 비동기를 함께 사용할 수 밖에 없는가?</li><li>rxjs는 어떻게 개선하였나? <ul><li>Observable</li><li>모든 데이터는 Observable 인스턴스로 만들 수 있다.</li></ul></li></ol><hr><hr><hr><h2 id="1-웹-어플리케이션의-입력-데이터"><a href="#1-웹-어플리케이션의-입력-데이터" class="headerlink" title="1. 웹 어플리케이션의 입력 데이터"></a>1. 웹 어플리케이션의 입력 데이터</h2><p>게시판을 예로 생각.<br>목록화면 : 서버에 저장된 글을 보여주는<br>상세화면 : 게시글의 내용을 보여주는 상세화면</p><ul><li>서버로부터 저장된 글에 대한 정보를 받아서 </li><li>화면과 관련 UI작업을 한다.</li><li>게시글 등록/수정하는 편집화면</li><li>수정이 끝나면 서버에 저장</li></ul><ol><li>게시글 / 서버 -&gt; 브라우저 / <strong>비동기</strong> / ajax통신으로 json데이터를 받는다.</li><li>게시글 / 브라우저 -&gt; 브라우저 UI객체 / <strong>동기</strong> / json 데이터를 ui에 반영한다.</li><li>사용자가 입력한 내용 / 사용자 -&gt; 브라우저 UI 객체 / <strong>비동기</strong> / <code>&lt;textarea&gt;</code>를 통해 사용자 입력을 받는다.</li><li>사용자가 입력한 내용 / 브라우저 UI객체 -&gt; 브라우저 -&gt; 서버 / <strong>동기, 비동기</strong> / <code>&lt;textarea&gt;</code>에 있는 데이터를 json객체로 저장 후, 서버로 ajax요청을 한다.</li></ol><hr><h2 id="2-입력-데이터의-전달-시점이-다양하다"><a href="#2-입력-데이터의-전달-시점이-다양하다" class="headerlink" title="2. 입력 데이터의 전달 시점이 다양하다."></a>2. 입력 데이터의 전달 시점이 다양하다.</h2><h3 id="동기-synchronous"><a href="#동기-synchronous" class="headerlink" title="동기 synchronous"></a>동기 synchronous</h3><p>: 작업이 들어온 순서에 맞게 차근차근 하나씩 진행되는 것을 의미한다.</p><ul><li>장점 : 개발이 쉬움</li><li>단점 : 속도가 느려짐.</li><li>웹 브라우저는 단일 UI 스레이드 이므로 해당 작업이 끝날때까지 브라우저는 대기해야한다.</li></ul><h3 id="비동기-asynchronous"><a href="#비동기-asynchronous" class="headerlink" title="비동기 asynchronous"></a>비동기 asynchronous</h3><p>: 작업이 들어온 순서에 상관없이 산발적으로 작업이 진행된다.</p><ul><li>별도의 이벤트나 콜백함수를 통해 결과를 전달하는 방식</li><li>장점 : 효율적인 작업 진행</li><li>개발은 복잡해지고 오류 확률이 높아질 우려가 있다.</li></ul><hr><h2 id="3-동기와-비동기를-함께-사용할-수-밖에-없는가"><a href="#3-동기와-비동기를-함께-사용할-수-밖에-없는가" class="headerlink" title="3. 동기와 비동기를 함께 사용할 수 밖에 없는가?"></a>3. 동기와 비동기를 함께 사용할 수 밖에 없는가?</h2><ul><li>동기 방식은 프로세스를 독점하기 때문에 효율적인 작업이 불가능.</li><li>비동기 방식은 효율적으로 작업할 수 있지만 <span style="color:blue"><strong>호출순서를 보장하기 어렵다.</strong><span></span></span></li><li>웹 브라우저는 단일 스레드 기반이기때문에 성능상 문제가 발생한다.</li></ul><hr><h2 id="4-rxjs는-어떻게-개선하였나"><a href="#4-rxjs는-어떻게-개선하였나" class="headerlink" title="4. rxjs는 어떻게 개선하였나?"></a>4. rxjs는 어떻게 개선하였나?</h2><p>입력데이터에 대한 구조적 문제를 개선하고자 하였다.<br>rxjs는 동기와 비동기의 차이점을 <strong>시간</strong>이라는 개념을 도입함으로써 해결하려고 했다.</p><p><img src="/images/2018/24/01.png" width="300px" style="margin-left: 0;"></p><blockquote><p>비동기</p></blockquote><p><img src="/images/2018/24/02.png" width="300px" style="margin-left: 0;"></p><blockquote><p>동기</p></blockquote><p>동기와 비동기는 시간의 축으로 봤을 때는 같은 형태이다.<br>=&gt; <strong>시간을 인덱스로 둔 컬렉션으로 생각할 수 있다.</strong><br>=&gt; Rxjs는 이를 <strong>스트림</strong>이라고 표현한다.<br>=&gt; Rxjs는 이런 스트림($)을 표현하는 Observable 클래스를 제공한다.</p><h3 id="4-1-Observable"><a href="#4-1-Observable" class="headerlink" title="4.1 Observable"></a>4.1 Observable</h3><p><strong>시간을 인덱스로 둔 컬렉션을 추상화한 클래스이다.</strong><br>동기나 비동기 동작 방식으로 전달된 데이터를 하나의 컬렉션으로 바라볼 수 있게 해준다.<br>개발자는 데이터가 어떤 형태로 전달되는지에 대해 더이상 고민할 필요가 없어진다.<br>Observable을 통해 데이터를 전달받기만 하면된다.</p><blockquote><p>동기던 비동기던 옵저버블로 데이터를 받긔</p></blockquote><h3 id="4-2-모든-데이터는-Observable-인스턴스로-만들-수-있다"><a href="#4-2-모든-데이터는-Observable-인스턴스로-만들-수-있다" class="headerlink" title="4.2 모든 데이터는 Observable 인스턴스로 만들 수 있다."></a>4.2 모든 데이터는 Observable 인스턴스로 만들 수 있다.</h3><ul><li>키보드를 눌러서 입력된 데이터</li><li>마우스를 이동하거나 클릭해서 입력된 데이터</li><li>ajax/fetch 요청을 통해 얻은 데이터</li><li>web socket을 통해 전달된 데이터</li><li>messages를 통해 전달된 데이터<br>…</li></ul><p>rxjs는 observable을 만들기 위해 rxjs 네임스페이스에 다양한 함수를 제공한다.(오퍼레이터)<br>이벤트를 observable로 만들때 <code>fromEvent</code>를 사용한다.<br>단일데이터를 연속으로 전달하는 경우는 <code>of</code></p><p><strong>Observable 객체의 변수명은 관용적으로 접미사로 $를 붙인다.</strong><br>Observable 객체는 스트림(stream)이다. 따라서 Stream을 뜻하는 S와 유사한 $를 Stream의 약어로 사용한다.</p><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[📕 퀵스타트 Rxjs]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="async" scheme="http://feel5ny.github.io/tags/async/"/>
    
      <category term="rxjs" scheme="http://feel5ny.github.io/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>chap02.원칙 - 프로그래밍의 가이드라인</title>
    <link href="http://feel5ny.github.io/2018/08/12/principle_02/"/>
    <id>http://feel5ny.github.io/2018/08/12/principle_02/</id>
    <published>2018-08-12T03:12:34.000Z</published>
    <updated>2018-08-15T14:45:24.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[프로그래밍의 정석]</strong>을 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li><a href="#first">KISS</a>   :: Keep It Simple, Stupid<ul><li>오컴의 면도날</li></ul></li><li><a href="#second">DRY</a>   :: Don’t Repeat Yourself</li><li><a href="#third">YAGNI</a>  :: You Aren’t Going to Need it</li><li><a href="#forth">PIE</a>    :: Program Intently and Expressively (의도를 표현해서 프로그래밍하라)</li><li><a href="#fifth">SLAP</a>   :: Single Level of Abstraction Principle (추상화 수준의 통일)</li><li><a href="#sixth">OCP</a>    :: Open-Closed Principle (개방-폐쇄의 원칙) </li></ol><hr><h4 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h4><hr><p><a id="first"></a></p><h2 id="1-KISS-Keep-It-Simple-Stupid"><a href="#1-KISS-Keep-It-Simple-Stupid" class="headerlink" title="1. KISS _Keep It Simple, Stupid"></a>1. KISS _Keep It Simple, Stupid</h2><h3 id="코드는-단순하게-유지한다"><a href="#코드는-단순하게-유지한다" class="headerlink" title="*코드는 단순하게 유지한다."></a>*코드는 단순하게 유지한다.</h3><h3 id="why-아무생각-없이-수정하게-되면-코드는-무질서로-향한다"><a href="#why-아무생각-없이-수정하게-되면-코드는-무질서로-향한다" class="headerlink" title="*why_아무생각 없이 수정하게 되면 코드는 무질서로 향한다."></a>*why_아무생각 없이 수정하게 되면 코드는 무질서로 향한다.</h3><p>함수의 경우 관심사 분리를 목표로 간결하게 유지한다.</p><ul><li>단순한 코드는 읽기 쉽고 수정이 용이하다.</li><li>의사소통 유지비용을 절약할 수 있다.</li></ul><h3 id="how-코드에-불필요한-것을-하지-않는다"><a href="#how-코드에-불필요한-것을-하지-않는다" class="headerlink" title="*how_코드에 불필요한 것을 하지 않는다."></a>*how_코드에 불필요한 것을 하지 않는다.</h3><p><u style="color:blue"><strong>단순함</strong>을 프로그래밍의 <strong>나침반</strong>으로 삼자.</u></p><p>아래 상황을 경계하자.</p><ol><li>새롭게 배운 기술을 사용하고 싶다.</li><li>장래의 필요에 대비하고 싶다.<br>지금 필요할게 아니면 지금 작성할 것이 아니다.</li><li>멋대로 요구사항을 추가한다.<br>요구사항을 결정하는 쪽은 사용자다. 프로그래머가 요구사항을 결정해서는 안된다.<blockquote><p>케바케일듯</p></blockquote></li></ol><h3 id="Less-is-more-단순한-것이-더-아름답다"><a href="#Less-is-more-단순한-것이-더-아름답다" class="headerlink" title="*Less is more 단순한 것이 더 아름답다."></a>*Less is more 단순한 것이 더 아름답다.</h3><p>지금 작성하는 코드가 정말로 필요한지를 항상 자문자답해야한다.</p><h3 id="오컴의-면도날"><a href="#오컴의-면도날" class="headerlink" title="*오컴의 면도날"></a>*오컴의 면도날</h3><p>어떤 상황을 설명하는 데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식.<br><u>= 뭔가에 관해 여러 가지 설명이 가능하다면 <strong>가장 단순한 방식이 옳다.</strong></u></p><hr><p><a id="second"></a></p><h2 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h2><h3 id="코드-복사는-금물"><a href="#코드-복사는-금물" class="headerlink" title="*코드 복사는 금물"></a>*코드 복사는 금물</h3><ul><li>로직 한 덩어리를 다른 부분에 복붙<ul><li>같은 로직이 여러 군데로 흩어진다.</li></ul></li><li>같은 조건을 다루는 제어문 블록이 여러군데 중복</li><li>같은 의미의 값(상수, 정수..)</li></ul><h3 id="why-코드를-개선할-수-없다"><a href="#why-코드를-개선할-수-없다" class="headerlink" title="*why_코드를 개선할 수 없다"></a>*why_코드를 개선할 수 없다</h3><ol><li><strong>코드를 읽는 작업이 어려워진다.</strong><br>양적으로 많아지고 질적으로 복잡해진다.</li><li><strong>코드를 수정하는 작업이 어려워진다.</strong><br>신중하게 수정하지 않으면 <strong>수정에 누락이 생길 위험성</strong>이 있다.<br>미세한 차이가 있다면 코드를 더욱 깊게 읽어야한다.</li><li><strong>테스트가 없다.</strong><br>열심히 수정하더라도 테스트가 없는 상태에서는 새로운 오류가 발생할 위험이 커진다.</li></ol><h3 id="how-코드를-추상화한다"><a href="#how-코드를-추상화한다" class="headerlink" title="*how_코드를 추상화한다."></a>*how_코드를 추상화한다.</h3><p>코드를 추상화함으로써 중복을 제거하자.<br>코드 로직을 추상화하려면<br><u style="color:blue">처리하는 코드를 묶고 이름을 붙여 함수화, 모듈화한다.</u></p><h4 id="추상화의-장점"><a href="#추상화의-장점" class="headerlink" title="추상화의 장점"></a>추상화의 장점</h4><ul><li>코드의 양이 줄어 읽는 양을 줄일 수 있다.</li><li>이름을 붙였으므로 코드가 읽기 쉽다.</li><li>같은 코드를 한군데 집약했기 때문에 코드 수정이 용이, 품질을 담보하기 쉽다.</li><li>추상화한 부분은 재사용하기 쉬워진다.</li></ul><h3 id="DRY의-적용범위"><a href="#DRY의-적용범위" class="headerlink" title="*DRY의 적용범위"></a>*DRY의 적용범위</h3><h4 id="구체적으로-반복되는-작업은-자동화"><a href="#구체적으로-반복되는-작업은-자동화" class="headerlink" title="구체적으로 반복되는 작업은  자동화"></a>구체적으로 반복되는 작업은 <i class="fa fa-long-arrow-right"> <span style="color:blue">자동화</span></i></h4><ul><li>자동화의 대표적인 작업 <i class="fa fa-long-arrow-right"> <strong>테스트, 빌드, 배포</strong> (지속적인 통합)</i></li><li>빌드, 테스트, 배포 등을 정확하고 빈번하게 자동 실행하는 것.</li><li>장점<ul><li>반복 수작업이 없어진다.</li><li>빌드 <strong>품질</strong>이 안정된다.</li><li>빌드가 속인화하지 않는다.</li><li>문제를 조기에 발견할 수 있다.</li></ul></li></ul><h3 id="DRY와-프로그래밍-기술"><a href="#DRY와-프로그래밍-기술" class="headerlink" title="*DRY와 프로그래밍 기술"></a>*DRY와 프로그래밍 기술</h3><p>코드 중복을 제거하는 것을 목적 중 하나로 삼고 있다.</p><ul><li>구조화 프로그래밍</li><li>객체지향 프로그래밍 기술<br>: 함수나 모듈 구성을 통해 중복을 제거하기 위한 기법이 내제되어있음.</li><li><p>디자인 패턴<br>: 코드를 재사용 가능(확장가능)하게 하려고 코드 구조 패턴을 제공한다.<br>: <strong>사고의 중복</strong>이 일어나지 않게 하는 기법이라고도 할 수 있다.</p></li><li><p><strong>일반적으로 기술이나 기법은 특정 목적을 갖고 고안된다.</strong><br>: 기법을 배울 때는 방식 자체만을 모방하지말고<br>: <span style="color:blue"><strong>목적을 파악하는 것이 습득에 이르는 지름길이다.</strong><span></span></span></p></li></ul><h3 id="WET-Write-Every-Tiem-Write-EveryThing-Twice"><a href="#WET-Write-Every-Tiem-Write-EveryThing-Twice" class="headerlink" title="*WET (Write Every Tiem, Write EveryThing Twice)"></a>*WET (Write Every Tiem, Write EveryThing Twice)</h3><p>DRY가 되어 있지 않은 코드에 대해 비꼬는 표현이다.</p><h3 id="OFOP-One-Fact-in-One-Place"><a href="#OFOP-One-Fact-in-One-Place" class="headerlink" title="*OFOP (One Fact in One Place)"></a>*OFOP (One Fact in One Place)</h3><p>한 곳에는 하나의 사실<br>: 데이터베이스 논리 설계에서 테이블 설계의 핵심이 되는 원칙이다.</p><h3 id="OAOO-Once-and-Only-Once"><a href="#OAOO-Once-and-Only-Once" class="headerlink" title="*OAOO (Once and Only Once)"></a>*OAOO (Once and Only Once)</h3><p>한번만, 단 한번만<br>DRY와 유사한 의미</p><hr><p><a id="third"></a></p><h2 id="3-YAGNI-You-Are-Not-Going-to-Need-It"><a href="#3-YAGNI-You-Are-Not-Going-to-Need-It" class="headerlink" title="3. YAGNI You Are Not Going to Need It"></a>3. YAGNI You Are Not Going to Need It</h2><h3 id="코드는-필요할-때-최소한으로"><a href="#코드는-필요할-때-최소한으로" class="headerlink" title="*코드는 필요할 때 최소한으로!"></a>*코드는 필요할 때 최소한으로!</h3><h3 id="why-코드의-예측은-빗나간다"><a href="#why-코드의-예측은-빗나간다" class="headerlink" title="*why_코드의 예측은 빗나간다."></a>*why_코드의 예측은 빗나간다.</h3><p>시간이 지날수록 이렇게 사용하지도 않는 코드가 있는 것인지 영문을 알 수 없다. 오히려 방해물이 된다.</p><h3 id="코드는-지금-필요한-것만"><a href="#코드는-지금-필요한-것만" class="headerlink" title="*코드는 지금 필요한 것만"></a>*코드는 지금 필요한 것만</h3><p><strong>우선 사용할 수 있는 데 가치를 주자.</strong><br>범용성보다는 <strong>단순성</strong>이라는 가치에 기준을 두고 고른다.<br>단순한 방식이 사실 범용성이 더 높을 때가 많다.</p><hr><p><a id="forth"></a></p><h2 id="4-PIE"><a href="#4-PIE" class="headerlink" title="4. PIE"></a>4. PIE</h2><p>Program Intently and Expressively<br><strong>의도를 표현해서 프로그래밍하라</strong></p><h3 id="코드의-의도를-전한다"><a href="#코드의-의도를-전한다" class="headerlink" title="*코드의 의도를 전한다."></a>*코드의 의도를 전한다.</h3><p>블로그에 글을 쓰듯이 명확한 의도<br><i class="fa fa-long-arrow-right">사람이 읽기 위한 것이기 때문</i></p><h3 id="why-코드가-유일한-실마리"><a href="#why-코드가-유일한-실마리" class="headerlink" title="*why_코드가 유일한 실마리"></a>*why_코드가 유일한 실마리</h3><p>코드는 소프트웨어 동작을 정확하고 완벽하게 알기 위한 유일한 실마리</p><ul><li>요구사항 정의서 : 어떤 기능을 원하는지가 적혀 있을 뿐</li><li>기본 설계서 : 어떤 식의 소프트웨어로 요구사항을 실현할지 적혀있을 뿐</li><li>상세 설계서 : 어떤 식의 구조로 소프트웨어를 작서할지에 관한 예정</li></ul><p><i class="fa fa-long-arrow-right"> 코드와 가장 밀접하지만, 실시간으로 코드와 동기화되지 않는다.<br><i class="fa fa-long-arrow-right"> 결국 코드가 유일한 실마리</i></i></p><h3 id="코드는-읽기-쉬운-것이-최우선"><a href="#코드는-읽기-쉬운-것이-최우선" class="headerlink" title="*코드는 읽기 쉬운 것이 최우선"></a>*코드는 읽기 쉬운 것이 최우선</h3><p><strong>읽기 쉬움</strong>을 중시하자.<br>작성효율보다는 <strong>읽는 효율</strong>이 우선시된다.!!<br>읽기 쉽다면 나중에 실행 효율을 높이기는 간단하다.</p><blockquote><p>다른 사람이 내 코드를 볼 때 이해가 잘 되도록 노력하자.</p></blockquote><h3 id="두더지-잡기식-개발은-피한다"><a href="#두더지-잡기식-개발은-피한다" class="headerlink" title="*두더지 잡기식 개발은 피한다."></a>*두더지 잡기식 개발은 피한다.</h3><p>읽기 쉽고<br>오류가 없으며<br>품질이 좋은 코드와<br>테스트를 작성하려면 시간이 걸린다.</p><p>이는 단기적으로 손실로 보이지만, 두더지 잡기식 개발이 되지 않으므로<br><span style="color:blue">장기적으로 반드시 이익을 가져다 준다.</span></p><h3 id="주석을-작성한다"><a href="#주석을-작성한다" class="headerlink" title="*주석을 작성한다."></a>*주석을 작성한다.</h3><p>주석으로 설명하지 않아도 되는 이해하기 쉬운 코드를 지향하면서,<br>표현할 수 없는 부분에는 주석을 활용하는 식으로<br>균형잡힌 코드를 작성하도록 하자.</p><h3 id="문학적-프로그래밍"><a href="#문학적-프로그래밍" class="headerlink" title="*문학적 프로그래밍"></a>*문학적 프로그래밍</h3><p>literate programming<br>코드 자체를 문서화하는 기법<br>문서를 기술하기 위한 언어가 프로그래밍 언어와 결함되어 있다.<br>코드는 곧 문서이며, 문서는 곧 코드다.</p><blockquote><p><a href="http://nevir.github.io/groc/languages.html" target="_blank" rel="noopener">groc</a></p></blockquote><hr><p><a id="fifth"></a></p><h2 id="5-SLAP"><a href="#5-SLAP" class="headerlink" title="5. SLAP"></a>5. SLAP</h2><p>Single Level of Abstraction Principle :: 추상화 수준의 통일</p><h3 id="코드-수준을-맞춘다"><a href="#코드-수준을-맞춘다" class="headerlink" title="*코드 수준을 맞춘다."></a>*코드 수준을 맞춘다.</h3><p><strong>고수준 추상화</strong> 개념과 <strong>저수준 추상화</strong> 개념을 분리해야한다.<br>상하 2계층이 아니라 기능의 복잡도에 따라 여러 계층으로 분리한다.<br>각 계층에서는 추상화 수준을 일치시킨다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 고수준(<span class="params"></span>) </span>&#123; <span class="comment">//수준 1의 목차</span></span><br><span class="line">    중수준<span class="number">1</span>();</span><br><span class="line">    중수준<span class="number">2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 중수준1(<span class="params"></span>) </span>&#123; <span class="comment">//수준2의 목차-1</span></span><br><span class="line">    저수준<span class="number">1</span>();</span><br><span class="line">    저수준<span class="number">2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 저수준1(<span class="params"></span>) </span>&#123; <span class="comment">//본문 내용</span></span><br><span class="line">  <span class="comment">//처리</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 저수준2(<span class="params"></span>) </span>&#123; <span class="comment">//본문 내용</span></span><br><span class="line">  <span class="comment">//처리</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 중수준2(<span class="params"></span>) </span>&#123; <span class="comment">//수준2의 목차-2</span></span><br><span class="line">  저수준<span class="number">3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 저수준3(<span class="params"></span>) </span>&#123; <span class="comment">//본문 내용</span></span><br><span class="line">  <span class="comment">//처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="why-코드에-요약성과-열람성을-가져다준다"><a href="#why-코드에-요약성과-열람성을-가져다준다" class="headerlink" title="*why_코드에 요약성과 열람성을 가져다준다"></a>*why_코드에 요약성과 열람성을 가져다준다</h3><ul><li>함수의 일람 : 목차, 요약성을 지님</li><li>분할된 함수 : 작은 코드 묶음, 열람성이 좋아짐.</li></ul><h3 id="how-함수를-구조화한다"><a href="#how-함수를-구조화한다" class="headerlink" title="*how_함수를 구조화한다."></a>*how_함수를 구조화한다.</h3><p><strong>함수를 구조화하자.</strong><br>함수를 구조화하면 각 함수는 자신보다 한 단계 낮은 수준의 함수를 호출하는 처리가 중심이 된다.<br><i class="fa fa-long-arrow-right"> 다른 함수를 호출하는 코드로 구성된 함수 : 복합함수 (composed method)</i></p><p>복합함수</p><ul><li>최대한 작게 만든다.</li><li>추상화 수준이 다른 함수를 호출하지 않도록 한다.</li></ul><h3 id="SLAP의-적용범위"><a href="#SLAP의-적용범위" class="headerlink" title="*SLAP의 적용범위"></a>*SLAP의 적용범위</h3><p>함수 뿐만 아니라 모듈 등에도 적용된다.</p><ul><li>개념을 저장할 저장소는 추상클래스와 해당 상속클래스가 된다.<ul><li>추상클래스 : 무엇인가 덜 구체화 된 것</li><li>객체 : 상태와 행동을 가진 것</li><li>클래스 : 객체를 만들기 위한 틀</li><li>초기화 : 클래스를 이용하여 객체를 생성</li></ul></li><li><strong>추상 클래스</strong>에 높은 수준의 개념을 갖게 하고</li><li><strong>상속 클래스</strong>에 낮은 수준의 개념을 갖게 한다.</li></ul><h3 id="SLAP의-순서"><a href="#SLAP의-순서" class="headerlink" title="*SLAP의 순서"></a>*SLAP의 순서</h3><p>글을 쓸때는<br><strong>내용을 쓰는 것</strong>과<br><strong>내용을 이해하기 쉽게 전하기 위한 구성을 생각하는 것</strong>을 별개의 작업으로 본다.</p><ul><li>구체적인 처리를 작성하는 작업</li><li>추상화 수준을 일치시키는 작업은<br>모드를 전환해서 별개의 작업으로 수행하도록 하자.<br>그래야 작업이 쉬워지고 결과적으로 더 좋은 코드가 만들어진다.</li></ul><hr><p><a id="sixth"></a></p><h2 id="6-OCP"><a href="#6-OCP" class="headerlink" title="6. OCP"></a>6. OCP</h2><p>Open-Closed Principle : 개방-폐쇠의 원칙</p><h3 id="코드의-변경은-파급시키지-않는다"><a href="#코드의-변경은-파급시키지-않는다" class="headerlink" title="*코드의 변경은 파급시키지 않는다."></a>*코드의 변경은 파급시키지 않는다.</h3><p>코드는 확장에 대해서 열려 있고<br>수정에 대해서 닫혀 있는<br>2가지 속성을 동시게 충족하도록 설계한다.</p><ul><li>확장에 열려있다. : 코드의 동작을 확장할 수 있다</li><li>수정에 닫혀있다. : 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다는 의미</li></ul><h3 id="why-코드의-변경에-유연하게-대응한다"><a href="#why-코드의-변경에-유연하게-대응한다" class="headerlink" title="*why_코드의 변경에 유연하게 대응한다."></a>*why_코드의 변경에 유연하게 대응한다.</h3><p>변경에 대해 유연하게 대응할 수 있는 유연한 설계가 요구된다.</p><h3 id="OCP의-적용-범위"><a href="#OCP의-적용-범위" class="headerlink" title="*OCP의 적용 범위"></a>*OCP의 적용 범위</h3><p>코드의 모든 부분에 OCP를 적용하는 것은 과한 방식이다.<br>코드의 단순함을 우지할 수 없다.</p><p>변경내용을 지나치게 예측하지 말아야 한다.<br><strong style="color:blue">실제 변경이 발생하기를 기다리는 전략.</strong><br>첫번째 변경을 감수하고, 두번째부터 OCP를 적용한다.<br>기본적으로 예측 가능한 부분에는 확장성 있게 작업한다.</p><h3 id="OCP의-구현과-설계"><a href="#OCP의-구현과-설계" class="headerlink" title="*OCP의 구현과 설계"></a>*OCP의 구현과 설계</h3><p><strong>대표적인 기술 : 객체지향의</strong> <strong style="color:blue">다향성</strong></p><ul><li>다향성(polymorphism)은 특정 기능을 <strong>선언(설계)부분</strong>(=인터페이스)과 <strong>구현(동작)부분</strong>으로 분리한 후 구현부분을 다양한 방법으로 만들어 선택해서 사용할 수 있게 하는 기능.</li><li>선언부분과 구현부분은 1:N의 다향성 관계가 형성</li><li>다향성 <strong>선언</strong>부분: 인터페이스(interface)와 추상클래스(abstract class)</li><li>다향성 <strong>구현</strong>부분: 클래스(class)</li></ul><p><strong>대표적인 디자인 패턴</strong></p><ul><li>strategy pattern<ul><li>교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정한다.</li><li>애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리 시킨다.</li><li>바뀌는 부분은 따로 뽑아서 <strong>캡슐화</strong> 시킨다.</li></ul></li><li>Observer<ul><li>한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.</li></ul></li><li>template method pattern</li><li>decorater pattern</li></ul><hr><hr><p>참고링크<br>객체지향의 다향성 : <a href="http://webclub.tistory.com/406" target="_blank" rel="noopener">http://webclub.tistory.com/406</a><br>strategy pattern : <a href="http://hyeonstorage.tistory.com/146" target="_blank" rel="noopener">http://hyeonstorage.tistory.com/146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[프로그래밍의 정석]&lt;/strong&gt;을 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Programing" scheme="http://feel5ny.github.io/categories/TIL-9997/Programing/"/>
    
    
      <category term="programming" scheme="http://feel5ny.github.io/tags/programming/"/>
    
      <category term="principle" scheme="http://feel5ny.github.io/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>chap01.전제 - 프로그래밍 불변의 진실</title>
    <link href="http://feel5ny.github.io/2018/08/11/principle_01/"/>
    <id>http://feel5ny.github.io/2018/08/11/principle_01/</id>
    <published>2018-08-11T11:12:34.000Z</published>
    <updated>2018-08-15T14:45:20.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[프로그래밍의 정석]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><p>1.1 프로그래밍에 은제탄환은 없다.<br>1.2 코드는 설계서다<br>1.3 코드는 반드시 변경된다.</p><hr><h4 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h4><hr><p><a id="third"></a></p><h2 id="1-1-프로그래밍에-은제-탄환은-없다"><a href="#1-1-프로그래밍에-은제-탄환은-없다" class="headerlink" title="1.1 프로그래밍에 은제 탄환은 없다."></a>1.1 프로그래밍에 은제 탄환은 없다.</h2><h3 id="WHY-소프트웨어는-본질적으로-난해하다"><a href="#WHY-소프트웨어는-본질적으로-난해하다" class="headerlink" title="*WHY_소프트웨어는 본질적으로 난해하다."></a>*WHY_소프트웨어는 본질적으로 난해하다.</h3><ol><li><strong>복잡성</strong></li><li><strong>동조성</strong> : 실세계와 계속 동조해야한다.</li><li><strong>가변성</strong> : 소프트웨어가 사용자의 인식에 영향을 미치며 새로운 요구사항이 생긴다.</li><li><strong>비가시성</strong> : 추상화해서 단순한 도면으로 만드는 작업은 가능하나, 이때의 정보가 사상되므로 모든 정보를 표현할 수 없다.</li></ol><h3 id="HOW-역사를-배워-복잡함에-맞선다"><a href="#HOW-역사를-배워-복잡함에-맞선다" class="headerlink" title="*HOW_역사를 배워 복잡함에 맞선다."></a>*HOW_<span style="color:blue">역사를 배워 복잡함에 맞선다.</span></h3><p>소프트웨어 개발의 역사는 복잡함과 투쟁의 역사.</p><h3 id="소프트웨어의-우유적인-부분을-개선"><a href="#소프트웨어의-우유적인-부분을-개선" class="headerlink" title="*소프트웨어의 우유적인 부분을 개선"></a>*소프트웨어의 우유적인 부분을 개선</h3><ul><li>본질 : 어떤 대상에서 그것이 없으면 대상물이라고 할 수 없는 성질</li><li>비본질(우유) : 부차적이고 부수적이라는 의미로 그것이 없어도 대상물이라고 할 수 있는 성질</li></ul><ul><li>소프트웨어 개발 현장에서 필요한 기술이라고 알려진 것의 대부분은 우유적인 부분<br>빌드 환경, 프로그래밍언어, 라이브러리, 프레임워크 등등은 우유적..</li><li>우유적인 부분의 개선 중에서 큰 성과는 <strong>자동화</strong><br>(테스트, 빌드, 환경 설정 등을 자동화 <i class="fa fa-long-arrow-right"> 작업 품질 향상)</i></li><li>우유적인 부분을 <i class="fa fa-long-arrow-right"> 자동화<br><i class="fa fa-long-arrow-right"> <u>본질적인 부분에 시간을 할애하자.</u></i></i></li></ul><hr><h2 id="1-2-코드는-설계서다"><a href="#1-2-코드는-설계서다" class="headerlink" title="1.2 코드는 설계서다."></a>1.2 코드는 설계서다.</h2><h3 id="what-코드가-곧-설계서"><a href="#what-코드가-곧-설계서" class="headerlink" title="*what_코드가 곧 설계서"></a>*what_코드가 곧 설계서</h3><ul><li><p><strong>설계</strong></p><ul><li>상세설계</li><li>프로그래밍</li><li>테스트</li><li>디버깅</li></ul></li><li><p><strong>설계서</strong></p><ul><li>코드</li></ul></li><li><p><strong>공정(제조)</strong></p><ul><li>배포</li><li>컴파일러, 빌드시스템</li></ul></li></ul><h3 id="how-우수한-설계자-프로그래머-가-필요"><a href="#how-우수한-설계자-프로그래머-가-필요" class="headerlink" title="*how_우수한 설계자(프로그래머)가 필요"></a>*how_우수한 설계자(프로그래머)가 필요</h3><p>설계란 창조적이며 기예가 필요한 행위다.<br>(설계 = 기본설계 + 상세설계 + 프로그래밍 + 테스트 + 디버깅)<br>신입에게 맡길 첫 업무가 아니라 고도로 숙련된 프로그래머의 업무여야 한다.</p><h3 id="로제타-스톤"><a href="#로제타-스톤" class="headerlink" title="*로제타 스톤"></a>*로제타 스톤</h3><p><strong>장래의 유지보수 담당자에게 필요한 가이드북</strong><br>: 소프트웨어 개발 환경을 이해하기 위한 정보와<br>: 소프트웨어 아키텍처를 이해하기 위한 정보가 담겨 있다.</p><h4 id="소프트웨어-개발-환경을-이해하기-위한-정보"><a href="#소프트웨어-개발-환경을-이해하기-위한-정보" class="headerlink" title="소프트웨어 개발 환경을 이해하기 위한 정보"></a>소프트웨어 개발 환경을 이해하기 위한 정보</h4><ul><li>빌드와 테스트 프로세스를 수행하는 방법</li><li>소프트웨어를 파악할 때 함정에 빠지는 일을 방지해 준다.</li></ul><h4 id="소프트웨어-아키텍처"><a href="#소프트웨어-아키텍처" class="headerlink" title="소프트웨어 아키텍처"></a>소프트웨어 아키텍처</h4><ul><li>전체를 파악하기 위해 필요한 그림</li><li>코드로부터 파악할 수 없는 코드 전체를 부감(높은 곳에서 내려다봄)해서 본 그림을 기술한다.</li></ul><hr><h2 id="1-3-코드는-반드시-변경된다"><a href="#1-3-코드는-반드시-변경된다" class="headerlink" title="1.3 코드는 반드시 변경된다."></a>1.3 코드는 반드시 변경된다.</h2><ul><li>최초 배포만으로 요구사항을 완전히 망라한 소프트웨어를 만들어 내는 것은 불가능하다.</li><li>변경에 강한 코드를 작성한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[프로그래밍의 정석]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Programing" scheme="http://feel5ny.github.io/categories/TIL-9997/Programing/"/>
    
    
      <category term="programming" scheme="http://feel5ny.github.io/tags/programming/"/>
    
      <category term="principle" scheme="http://feel5ny.github.io/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>1부/ chap0. RxJs를 시작하기 전에</title>
    <link href="http://feel5ny.github.io/2018/08/10/Async_00/"/>
    <id>http://feel5ny.github.io/2018/08/10/Async_00/</id>
    <published>2018-08-10T11:12:34.000Z</published>
    <updated>2018-08-16T15:13:52.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[퀵스타트 Rxjs]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>웹 환경의 변화</li><li>웹 개발 복잡도 증가</li><li>웹 애플리케이션은 상태 머신이다. <a href="#third">=&gt;</a></li><li>웹 애플리케이션 오류가 발생하는 경우 <a href="#forth">=&gt;</a></li><li>RxJS는 무엇인가? 그리고 웹 어플리케이션과 무슨 관련이 있는가?</li></ol><hr><h4 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h4><p>대부분 처음 개발을 시작할 때는 <strong>요구사항</strong>을 어떻게 프로그래밍할 것인지를 고민하게 된다.<br><strong>즉, 구현 자체에만 초점을 맞추게 된다.</strong> 물론, 이는 개발에서 무엇보다 중요한 문제이다. 하지만, 시간이 자나 초급 개발자 딱지를 떼고 경험이 쌓이기 시작하면 구현보다는 <strong>소프트웨어를 얼마나 효과적으로 유지보수할 수 있는지?</strong> 또는 얼마나 많은 문제점을 설계나 테스트 코드를 통해 사전에 해결할 수 있을지를 고민하게 된다.<br>그래서 우리는 자연스레 기존 문제들을 해결하기 위해 고심했던 라이브러리나, 디자인 패턴들을 하나둘씩 적용하게 되고,<br>결국에는 이런 고민들이 녹아들어 간 프레임워크에 관심을 갖게 된다.<br>…<br><strong>결과물(프레임워크)을 잘 사용하는 것도 중요하지만 그 기술의 결과물이 어떤 고민의 산물인지 아는 것이 더 중요하다.</strong></p><hr><p><a id="third"></a></p><h2 id="3-웹-어플리케이션은-상태-머신이다"><a href="#3-웹-어플리케이션은-상태-머신이다" class="headerlink" title="3. 웹 어플리케이션은 상태 머신이다."></a>3. 웹 어플리케이션은 상태 머신이다.</h2><h3 id="상태머신이란-state-machine"><a href="#상태머신이란-state-machine" class="headerlink" title="상태머신이란? state machine"></a>상태머신이란? state machine</h3><p>주어진 시간의 상태(state)가 존재하고,<br>어떤 한 사건(input)에 의해<br>다른 상태 (state)로 변할 수 있는<br>수학적 모델을 의미힌다.</p><p><img src="/images/2018/23/01.jpg" width="400px"></p><ol><li>시스템으로 input이 발생한다.</li><li>프로그램 로직은 input과 현재 프로그램 상태에 따라 행위를 결정한다.</li><li>프로그램 로직은 결정에 따라, 프로그램 상태를 변경한다.</li><li>경우에 따라서는 프로그램 로직은 output을 생산하기도 한다.</li></ol><p>웹 어플리케이션은 이런 기능들의 집합으로 구성되어있다.<br>크게 보면 웹 어플리케이션도 하나의 큰 상태 머신인 셈.</p><hr><p><a id="forth"></a></p><h2 id="4-웹-애플리케이션-오류가-발생하는-경우"><a href="#4-웹-애플리케이션-오류가-발생하는-경우" class="headerlink" title="4. 웹 애플리케이션 오류가 발생하는 경우**"></a>4. 웹 애플리케이션 오류가 발생하는 경우**</h2><p>웹 어플리케이션을 하나의 상태 머신으로 본다면<br>정확한 <strong>입력</strong>과 <strong>로직</strong>으로 상태를 관리하는 방법이 중요하다.<br>=&gt; 이에 따라 오류의 발생 여부가 결정된다.</p><p>∴ <strong>각 구성요소의 상태를 어떻게 관리하느냐</strong>에 따라 안정적인 어플리케이션을 만들 수 있다.</p><h3 id="4-1-입력-오류"><a href="#4-1-입력-오류" class="headerlink" title="4-1. 입력 오류"></a>4-1. 입력 오류</h3><p>서버로부터 전달받은 데이터를 입력값으로 사용하는 경우</p><ol><li>서버에서 전달받은 응답 결괏값이 정상적으로 왔을 경우에만 입력값을 전달해야 한다.<ul><li>입력값을 별도로 제어해야함.</li></ul></li><li>응답 데이터의 결과가 미처 오기도 전에 데이터를 입력값으로 전달하거나 응답 중에 에러가 발생하여 비정상적인 응답 데이터를 입력값으로 전달하면 오류가 발생할 수 있다.<ul><li>오류처리 필요</li></ul></li></ol><h3 id="4-2-상태-오류"><a href="#4-2-상태-오류" class="headerlink" title="4-2. 상태 오류"></a>4-2. 상태 오류</h3><p>상태 오류가 발생하는 이유는 상태 변화를 정확하게 전달하지 못하는 경우이다.</p><ol><li><strong>구성요소 간</strong>에 의존도가 있는 경우<br>구성요소 간 의존도가 있는 경우, 구성요소의 변경 상태는 적시에 다른 구성요소에 전달되어야 한다.</li><li>두번째 <strong>호출 순서</strong>에 의존도가 있는 경우<br>구성요소 간 호출 순서에 의존도가 있는 경우, 구성요소는 <strong>순서</strong>에 맞게 호출되어야만 한다.</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[퀵스타트 Rxjs]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="async" scheme="http://feel5ny.github.io/tags/async/"/>
    
      <category term="rxjs" scheme="http://feel5ny.github.io/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>13/ Image 업로드 시 회전에 대하여 (feat. exif 메타데이터 - Orientation)</title>
    <link href="http://feel5ny.github.io/2018/08/06/JS_13/"/>
    <id>http://feel5ny.github.io/2018/08/06/JS_13/</id>
    <published>2018-08-06T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.112Z</updated>
    
    <content type="html"><![CDATA[<p>웹 브라우저에서 이미지를 업로드 할 때 type이 file인 input을 통해 이미지를 받고, file API를 사용하여 이미지를 read합니다. 이때 핸드폰을 세워서 촬영할 경우 사진 이미지가 멋대로 회전되서 read될때가 있습니다. 이를 잡기 위해서는 사진의 메타정보(exif)에 있는 orientation이라는 정보를 확인해야합니다.<br>exif가 무엇인지 간략하게 알아보고, 라이브러리를 사용하여 회전 버그를 픽스하는 방법에 대해서 정리해보았습니다.</p><hr><p>목차 </p><ol><li>exif란? <a href="https://ko.wikipedia.org/wiki/%EA%B5%90%ED%99%98_%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D" target="_blank" rel="noopener">출처</a></li><li>Javascript 로드 시 회전 픽스방법</li></ol><hr><h2 id="1-exif란"><a href="#1-exif란" class="headerlink" title="1. exif란?"></a>1. exif란?</h2><h3 id="교환-이미지-파일-형식-Exif-EXchangable-Image-File-format"><a href="#교환-이미지-파일-형식-Exif-EXchangable-Image-File-format" class="headerlink" title="교환 이미지 파일 형식 (Exif; EXchangable Image File format)"></a><strong>교환 이미지 파일 형식</strong> (Exif; EXchangable Image File format)</h3><p>디지털 카메라에서 이용되는 이미지 파일 포맷이다.<br>이 데이터는 JPEG, TIFF 6.0과 RIFF, WAV 파일 포맷에서 이용되며<br><strong><code>사진에 대한 정보를 포함하는 메타데이터</code></strong>를 추가한다.<br>Exif는 JPEG 2000, PNG나 GIF파일에서는 지원하지 않는다.</p><h3 id="EXIF의-메타데이터"><a href="#EXIF의-메타데이터" class="headerlink" title="EXIF의 메타데이터"></a>EXIF의 메타데이터</h3><p>EXIF 메타데이터는 다음 정보를 포함한다.</p><ul><li>날짜와 시간 정보</li><li>카메라 설정</li><li>저작권 정보에 대한 설명</li></ul><h3 id="지리정보-기록"><a href="#지리정보-기록" class="headerlink" title="지리정보 기록"></a>지리정보 기록</h3><p>교환 이미지 파일 형식은 <code>위치 정보</code>를 기록하는 <strong>표준</strong>을 갖고 있다.<br>기존에는 GPS 수신기를 내장한 극소수의 카메라만이 사진이 찍힌 장소의 정보를 저장할 수 있었다.<br>니콘 D300이나 니콘 D90, 파인픽스 S5 Pro, (캐논 EOS 6D 는 내부 장착)는 카메라 플래시 연결부에 별도의 GPS 수신기를 장착하여 지리 정보를 기록할 수 있다. 기록된 GPS 데이터는 컴퓨터에서 다른 디지털 사진에도 추가될 수 있다.</p><p><strong>그러나 최근에는 GPS 수신기를 장착하고 사진 촬영이 가능한 수많은 휴대폰과 태블릿PC 등이 있어<br>해당 기기로 사진 촬영을 할 경우 위치 정보를 같이 저장할 수 있는 옵션을 지원하여 위치 정보를 함께 기록하여 촬영하기 쉬워졌다.</strong></p><h3 id="Exif-이미지-정보"><a href="#Exif-이미지-정보" class="headerlink" title="Exif : 이미지 정보"></a>Exif : 이미지 정보</h3><p>Exif 데이터는 이미지 파일 자체에 끼워진다.<br>많은 그래픽 소프트웨어에서 Exif 데이터를 인식하고,<br>파일이 변경될 때에도 메타데이터를 보존한다.<br>단 구버전의 경우에는 해당되지 않는다.<br>많은 이미지 갤러리 프로그램 역시 Exif 데이터를 인식하고, 이미지 옆에 Exif 정보를 보여 준다.</p><p>Exif 메타데이터는 </p><ul><li>카메라 제조사 </li><li>카메라 모델</li><li><strong>회전 방향</strong></li><li>날짜와 시간 </li><li>색 공간</li><li>초점 거리 </li><li>플래시</li><li>ISO 속도</li><li>조리개</li><li>셔터 속도</li><li>gps<br>등의 정보를 제공한다.</li></ul><blockquote><p>포토샵이나 라이트룸에서 사진을 import한 후 info를 확인하면 사진 정보를 바로 확인할 수 있는데, 이 사진이 갖고 있는 exif데이터로 확인하는 듯 </p></blockquote><p><img src="/images/2018/22/Konqueror_Exif_data.jpg"></p><hr><hr><h2 id="2-Javascript-로드-시-회전-픽스방법"><a href="#2-Javascript-로드-시-회전-픽스방법" class="headerlink" title="2. Javascript 로드 시 회전 픽스방법"></a>2. Javascript 로드 시 회전 픽스방법</h2><p>전체 flow는 이렇습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> input file에서 image upload</span><br><span class="line"><span class="number">2.</span> File API중 FileReader를 사용하여 file의 data 확인</span><br><span class="line"><span class="number">3.</span> reader.onload 에서 Image 인스턴스 생성</span><br><span class="line"><span class="number">4.</span> read의 result값 == binary 데이터</span><br><span class="line"><span class="number">5.</span> img src에 result값 삽입</span><br><span class="line"><span class="number">6.</span> binary 데이터에서 orientation 관련 태그값 select =&gt; orientation 값 추출</span><br><span class="line"><span class="number">7.</span> orientation 값에 따라 img 회전 </span><br><span class="line"><span class="number">8.</span> canvas 생성, img를 canvas에서 다시 그림 (drawImage)</span><br><span class="line"><span class="number">9.</span> 해당 canvas의 toDataURL를 사용하여 dataUrl추출</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="exif-중-orientation-값"><a href="#exif-중-orientation-값" class="headerlink" title="exif 중 - orientation 값"></a>exif 중 - orientation 값</h3><p><img src="/images/2018/22/orientation.gif"><br>fileList =&gt; file =&gt; binary Data =&gt; exif의 주소값을 찾아서 사진 정보를 get해오기<br>(exif라는 라이브러리를 들춰보면 재밌는 것이!!많습니다.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Tiff : Tagged Image File Format</span></span><br><span class="line"><span class="keyword">var</span> TiffTags = EXIF.TiffTags = &#123;</span><br><span class="line">      <span class="number">0x0100</span> : <span class="string">"ImageWidth"</span>,</span><br><span class="line">      <span class="number">0x0101</span> : <span class="string">"ImageHeight"</span>,</span><br><span class="line">      <span class="number">0x8769</span> : <span class="string">"ExifIFDPointer"</span>,</span><br><span class="line">      <span class="number">0x8825</span> : <span class="string">"GPSInfoIFDPointer"</span>,</span><br><span class="line">      <span class="number">0xA005</span> : <span class="string">"InteroperabilityIFDPointer"</span>,</span><br><span class="line">      <span class="number">0x0102</span> : <span class="string">"BitsPerSample"</span>,</span><br><span class="line">      <span class="number">0x0103</span> : <span class="string">"Compression"</span>,</span><br><span class="line">      <span class="number">0x0106</span> : <span class="string">"PhotometricInterpretation"</span>,</span><br><span class="line">      <span class="number">0x0112</span> : <span class="string">"Orientation"</span>, &lt;==</span><br><span class="line">      <span class="number">0x0115</span> : <span class="string">"SamplesPerPixel"</span>,</span><br><span class="line">      <span class="number">0x011C</span> : <span class="string">"PlanarConfiguration"</span>,</span><br><span class="line">      <span class="number">0x0212</span> : <span class="string">"YCbCrSubSampling"</span>,</span><br><span class="line">      <span class="number">0x0213</span> : <span class="string">"YCbCrPositioning"</span>,</span><br><span class="line">      <span class="number">0x011A</span> : <span class="string">"XResolution"</span>,</span><br><span class="line">      <span class="number">0x011B</span> : <span class="string">"YResolution"</span>,</span><br><span class="line">      <span class="number">0x0128</span> : <span class="string">"ResolutionUnit"</span>,</span><br><span class="line">      <span class="number">0x0111</span> : <span class="string">"StripOffsets"</span>,</span><br><span class="line">      <span class="number">0x0116</span> : <span class="string">"RowsPerStrip"</span>,</span><br><span class="line">      <span class="number">0x0117</span> : <span class="string">"StripByteCounts"</span>,</span><br><span class="line">      <span class="number">0x0201</span> : <span class="string">"JPEGInterchangeFormat"</span>,</span><br><span class="line">      <span class="number">0x0202</span> : <span class="string">"JPEGInterchangeFormatLength"</span>,</span><br><span class="line">      <span class="number">0x012D</span> : <span class="string">"TransferFunction"</span>,</span><br><span class="line">      <span class="number">0x013E</span> : <span class="string">"WhitePoint"</span>,</span><br><span class="line">      <span class="number">0x013F</span> : <span class="string">"PrimaryChromaticities"</span>,</span><br><span class="line">      <span class="number">0x0211</span> : <span class="string">"YCbCrCoefficients"</span>,</span><br><span class="line">      <span class="number">0x0214</span> : <span class="string">"ReferenceBlackWhite"</span>,</span><br><span class="line">      <span class="number">0x0132</span> : <span class="string">"DateTime"</span>,</span><br><span class="line">      <span class="number">0x010E</span> : <span class="string">"ImageDescription"</span>,</span><br><span class="line">      <span class="number">0x010F</span> : <span class="string">"Make"</span>,</span><br><span class="line">      <span class="number">0x0110</span> : <span class="string">"Model"</span>,</span><br><span class="line">      <span class="number">0x0131</span> : <span class="string">"Software"</span>,</span><br><span class="line">      <span class="number">0x013B</span> : <span class="string">"Artist"</span>,</span><br><span class="line">      <span class="number">0x8298</span> : <span class="string">"Copyright"</span></span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>번거로운 작업이기 때문에.. 아래 라이브러리를 사용합니다.</p><ul><li><a href="https://github.com/blueimp/JavaScript-Load-Image" target="_blank" rel="noopener">load-image-orientation.js</a></li><li><a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">exif.js</a></li></ul><p>개인적으로는 <code>load-image-orientation</code>가 좋습니다 :)<br>orientation값에 따른 회전 이외에도 crop기능도 있습니다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load-image-orientation.js</span></span><br><span class="line"><span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// horizontal flip</span></span><br><span class="line">    ctx.translate(width, <span class="number">0</span>)</span><br><span class="line">    ctx.scale(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// 180° rotate left</span></span><br><span class="line">    ctx.translate(width, height)</span><br><span class="line">    ctx.rotate(<span class="built_in">Math</span>.PI)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="comment">// vertical flip</span></span><br><span class="line">    ctx.translate(<span class="number">0</span>, height)</span><br><span class="line">    ctx.scale(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="comment">// vertical flip + 90 rotate right</span></span><br><span class="line">    ctx.rotate(<span class="number">0.5</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">    ctx.scale(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="comment">// 90° rotate right</span></span><br><span class="line">    ctx.rotate(<span class="number">0.5</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">    ctx.translate(<span class="number">0</span>, -height)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="comment">// horizontal flip + 90 rotate right</span></span><br><span class="line">    ctx.rotate(<span class="number">0.5</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">    ctx.translate(width, -height)</span><br><span class="line">    ctx.scale(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="comment">// 90° rotate left</span></span><br><span class="line">    ctx.rotate(<span class="number">-0.5</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">    ctx.translate(-width, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>라이브러리 내부를 보시면, orientation 값에 따라 image를 회전하는 것을 볼 수 있습니다.</p><p>이미지 resizing 함수도 따로 작업했었는데, 이번 이슈를 통해서 찾은 load-image 라이브러리에 리사이징관련된 메서드들도 있는 것을 확인했습니다. </p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://ko.wikipedia.org/wiki/%EA%B5%90%ED%99%98_%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%EA%B5%90%ED%99%98_%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D</a></li><li><a href="https://magnushoff.com/jpeg-orientation.html" target="_blank" rel="noopener">https://magnushoff.com/jpeg-orientation.html</a></li><li><a href="http://code.flickr.net/2012/06/01/parsing-exif-client-side-using-javascript-2/" target="_blank" rel="noopener">http://code.flickr.net/2012/06/01/parsing-exif-client-side-using-javascript-2/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;웹 브라우저에서 이미지를 업로드 할 때 type이 file인 input을 통해 이미지를 받고, file API를 사용하여 이미지를 read합니다. 이때 핸드폰을 세워서 촬영할 경우 사진 이미지가 멋대로 회전되서 read될때가 있습니다. 이를 잡기
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="File API" scheme="http://feel5ny.github.io/tags/File-API/"/>
    
      <category term="EXIF" scheme="http://feel5ny.github.io/tags/EXIF/"/>
    
  </entry>
  
  <entry>
    <title>📓 읽기 좋은 코드가 좋은 코드다. || part3. 코드 재작성하기</title>
    <link href="http://feel5ny.github.io/2018/08/03/Clean_code_3/"/>
    <id>http://feel5ny.github.io/2018/08/03/Clean_code_3/</id>
    <published>2018-08-03T11:12:34.000Z</published>
    <updated>2018-08-15T14:44:30.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[읽기 좋은 코드가 좋은 코드다.]</strong>를 보고 메모할 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>상관없는 하위문제 추출하기 ⇒ 관심사 분리 <a href="#first">⇒</a></li><li>한번에 하나씩 ⇒ 관심사 분리 방법 <a href="#scond">⇒</a></li><li>생각을 코드로 만들기 <a href="#third">⇒</a></li><li>코드 분량 줄이기 <a href="#forth">⇒</a></li></ol><p><strong>서론</strong><br>좋은 코드는 무슨 일이 일어나고 있는지를 빠르게 전달해준다.<br>사용하기에도 즐겁고, 자신에게도 더 좋은 코드를 만들어야 하겠다는 욕구를 불러일으키기도 한다.</p><hr><hr><h1 id="PART-3-코드-재작성하기"><a href="#PART-3-코드-재작성하기" class="headerlink" title="PART 3 ) 코드 재작성하기"></a>PART 3 ) 코드 재작성하기</h1><p>엔지니어링은 커다란 문제를<br>작은 문제들로 쪼갠 다음,<br>각각의 문제에 대한 해결책을 구하고,<br>다시 하나의 해결책으로 맞추는 일련의 작업을 한다.<br>이러한 원리를 코드에 적용하면 코드가 더 튼튼해지며 가독성도 좋아진다.</p><ol><li><p>주어진 함수나 코드 블록을 보고, 스스로에게 질문하라<br><strong>“상위수준에서 본 이 코드의 목적은 무엇인가?”</strong></p></li><li><p>코드의 모든 줄에 질문을 던져라<br><strong>“이 코드는 직접적으로 목적을 위해서 존재하는가?</strong><br>혹은 목적을 위해서 필요하긴 하지만 <strong>목적 자체와 직접적으로 상관없는 하위문제를 해결하는가?”</strong></p></li><li><p>상당히 원래의 목적과 직접적으로 관련되지 않은 하위문제를 해결하는 코드 분량이 많으면,<br><strong>이를 추출해서 별도의 함수로 만든다.</strong></p></li></ol><hr><p><a id="first"></a></p><h2 id="10-상관없는-하위문제-추출하기-⇒-관심사-분리"><a href="#10-상관없는-하위문제-추출하기-⇒-관심사-분리" class="headerlink" title="10. 상관없는 하위문제 추출하기 ⇒ 관심사 분리"></a>10. 상관없는 하위문제 추출하기 ⇒ 관심사 분리</h2><hr><p><a id="second"></a></p><h2 id="11-한번에-하나씩-⇒-관심사-분리-방법"><a href="#11-한번에-하나씩-⇒-관심사-분리-방법" class="headerlink" title="11. 한번에 하나씩 ⇒ 관심사 분리 방법"></a>11. 한번에 하나씩 ⇒ 관심사 분리 방법</h2><p>함수는 오직 한 가지 작업만 수행해야 한다.</p><ol><li>코드가 수행하는 모든 ‘작업’을 나열한다.</li><li>이러한 작업을 분리하여 서로 다른 함수로 혹은 적어도 논리적으로 구분되는 영역에 놓을 수 잇는 코드로 만들면 됟나.</li></ol><h3 id="11-1-작업은-작을-수-있다"><a href="#11-1-작업은-작을-수-있다" class="headerlink" title="11-1. **작업은 작을 수 있다."></a>11-1. **작업은 작을 수 있다.</h3><p>  예시 ) 투표**<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vote_changed(old_vote, new_vote); <span class="comment">// 각 투표는 '추천','반대' 혹은 ''이다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vote_changed = <span class="function"><span class="keyword">function</span>(<span class="params">old_vote, new_vote</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scroe = get_score();</span><br><span class="line">  <span class="keyword">if</span>(new_vote !== old_vote)&#123;</span><br><span class="line">    <span class="keyword">if</span>(new_vote == <span class="string">'Up'</span>)&#123;</span><br><span class="line">      score += (old_vote === <span class="string">'Down'</span>? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_vote == <span class="string">'Down'</span>)&#123;</span><br><span class="line">      score -= (old_vote === <span class="string">'Up'</span> ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_vote === <span class="string">''</span>)&#123;</span><br><span class="line">      score += (old_vote === <span class="string">'Up'</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set_score(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  위 코드의 <strong>흐름</strong></p><ol><li>old_vote와 new_vote가 수치 값으로 ‘해석’된다.</li><li>점수가 변경된다.<br>투표를 수치값으로 해석한다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vote_value = <span class="function"><span class="keyword">function</span>(<span class="params">vote</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(vote === <span class="string">'Up'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vote === <span class="string">'Down'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vote_changed = <span class="function"><span class="keyword">function</span>(<span class="params">old_vote, new_vote</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> score = get_score();</span><br><span class="line">score -= vote_value(old_vote);</span><br><span class="line">socre += vote_value(new_vote);</span><br><span class="line">set_score(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-2-객체에서-값-추출하기"><a href="#11-2-객체에서-값-추출하기" class="headerlink" title="11-2. 객체에서 값 추출하기!"></a>11-2. <strong>객체에서 값 추출하기!</strong></h3><ol><li>한번에 한 가지일 원리 적용하기<ol><li>작업의 흐름을 적고 한 함수당 한가지 일만 적용되도록 한다. </li></ol></li></ol><hr><p><a id="third"></a></p><h2 id="12-생각을-코드로-만들기"><a href="#12-생각을-코드로-만들기" class="headerlink" title="12. 생각을 코드로 만들기"></a>12. 생각을 코드로 만들기</h2><ol><li>코드가 할 일을 옆의 동료에게 말하듯이 평범한 영어로 묘사하라.</li><li>설명에 들어가는 <strong>핵심적인 단어와 문구를 포착</strong>하라.</li><li>설명과 부합하는 코드를 작성하라 </li></ol><hr><p><a id="forth"></a></p><h2 id="13-코드-분량-줄이기"><a href="#13-코드-분량-줄이기" class="headerlink" title="13. 코드 분량 줄이기"></a>13. 코드 분량 줄이기</h2><ol><li>요구사항에 질문을 던지고 질문을 잘게 나누어 분석하라</li><li>상점위치 추적기</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[읽기 좋은 코드가 좋은 코드다.]&lt;/strong&gt;를 보고 메모할 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CleanCode" scheme="http://feel5ny.github.io/categories/TIL-9997/CleanCode/"/>
    
    
      <category term="cleanCode" scheme="http://feel5ny.github.io/tags/cleanCode/"/>
    
      <category term="refactoring" scheme="http://feel5ny.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>📓 읽기 좋은 코드가 좋은 코드다. || part2. 루프와 논리를 단순화하기</title>
    <link href="http://feel5ny.github.io/2018/08/02/Clean_code_2/"/>
    <id>http://feel5ny.github.io/2018/08/02/Clean_code_2/</id>
    <published>2018-08-02T11:12:34.000Z</published>
    <updated>2018-08-15T14:44:29.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[읽기 좋은 코드가 좋은 코드다.]</strong>를 보고 메모할 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>읽기 쉽게 흐름제어 만들기 <a href="#first">⇒</a></li><li>거대한 표현을 잘게 쪼개기 <a href="#second">⇒</a></li><li>변수와 가독성 <a href="#third">⇒</a></li></ol><hr><p><strong>서론</strong><br>좋은 코드는 무슨 일이 일어나고 있는지를 빠르게 전달해준다.<br>사용하기에도 즐겁고, 자신에게도 더 좋은 코드를 만들어야 하겠다는 욕구를 불러일으키기도 한다.</p><hr><h1 id="PART-2-루프와-논리를-단순화하기"><a href="#PART-2-루프와-논리를-단순화하기" class="headerlink" title="PART 2 ) 루프와 논리를 단순화하기"></a>PART 2 ) 루프와 논리를 단순화하기</h1><blockquote><p>흐름제어 control flow 논리식 logical expression 변수 등에 대해서 알아보자.</p></blockquote><p>코드가 코드를 읽는 사람에게 정신적 부담을 더 많이 부과할 수록,<br>버그는 좀처럼 눈에 보이지 않고,<br>코드 수정 작업은 더 어려워지고,<br>결국 그런 코드로 작업하는 일이 즐겁지 못하게 된다.</p><p><a id="first"></a></p><h2 id="7-읽기-쉽게-흐름제어-만들기"><a href="#7-읽기-쉽게-흐름제어-만들기" class="headerlink" title="7. 읽기 쉽게 흐름제어 만들기"></a>7. 읽기 쉽게 흐름제어 만들기</h2><p>분기문과 점프문은 어려운 대상이며, 코드를 복잡하게 만드는 원인이다.</p><h3 id="7-1-조건문에서-인수의-순서"><a href="#7-1-조건문에서-인수의-순서" class="headerlink" title="7-1. 조건문에서 인수의 순서"></a><strong>7-1. 조건문에서 인수의 순서</strong></h3><p><code>A &gt; B</code></p><ul><li>왼쪽 : 값이 더 유동적인 질문을 받는 표현</li><li>오른쪽 : 더 고정적인 값, 비교대상으로 사용되는 표현</li></ul><p>cf_ 요다표기법 (옛날에 쓰던.. <code>NULL == obj</code> )</p><h3 id="7-2-if-else-블록의-순서"><a href="#7-2-if-else-블록의-순서" class="headerlink" title="7-2. if/else 블록의 순서"></a><strong>7-2. if/else 블록의 순서</strong></h3><ul><li>부정이 아닌 <strong>긍정을 다루어라.</strong> 즉 <code>if(!debug)</code>가 아니라 <code>if(debug)</code>를 선호하자.</li><li>간단한 것을 먼저 처리하라.</li><li>더 흥미롭고, 확실한 것을 먼저 다루어라.</li></ul><h3 id="7-3-삼항-연산자로-알려진-를-이용하는-조건문-표현"><a href="#7-3-삼항-연산자로-알려진-를-이용하는-조건문-표현" class="headerlink" title="7-3. (삼항 연산자로 알려진) ?:를 이용하는 조건문 표현"></a><strong>7-3. (삼항 연산자로 알려진) <code>?:</code>를 이용하는 조건문 표현</strong></h3><ul><li>줄 수를 최소화하는 일보다 다른 사람이 코드를 읽고 이해하는 데 걸리는 시간을 최소화하는 일이 더 중요하다.</li></ul><h3 id="7-4-do-while-루프를-피하라"><a href="#7-4-do-while-루프를-피하라" class="headerlink" title="7-4. do/while 루프를 피하라"></a>7-4. do/while 루프를 피하라</h3><h3 id="7-5-함수-중간에서-반환하기"><a href="#7-5-함수-중간에서-반환하기" class="headerlink" title="7-5. 함수 중간에서 반환하기"></a>7-5. 함수 중간에서 반환하기</h3><h3 id="7-7-중첩을-최소화하기"><a href="#7-7-중첩을-최소화하기" class="headerlink" title="7-7. 중첩을 최소화하기"></a>7-7. 중첩을 최소화하기</h3><p>루프와 조건문을 비롯한 그외 분기문을 읽기 쉽게 만드는 방법을 살펴본 것이다.<br>하지만 자신의 프로그램에 존재하는 ‘흐름’을 상위수준에서 조망해볼 필요가 있다.<br>프로그램의 전체 실행 경로를 쉽게 따라갈 수 있게 만드는 게 궁극의 목표다.</p><hr><p><a id="second"></a></p><h2 id="8-거대한-표현을-잘게-쪼개기"><a href="#8-거대한-표현을-잘게-쪼개기" class="headerlink" title="8. 거대한 표현을 잘게 쪼개기"></a>8. 거대한 표현을 잘게 쪼개기</h2><p>코드의 표현이 커지면 커질수록 이해하기 더 여렵다. ⇒ 예시: 대왕오징어 식도주변의 도넛뇌</p><ol><li>설명 변수<ul><li>커다란 표현을 쪼개는 가장 쉬운 방법은 작은 <strong>하위표현을 담을 ‘추가변수</strong>‘를 만드는 것이다.<br>( 추가변수 == 설명변수 )</li></ul></li><li>요약 변수<ul><li>의미를 쉽게 파악할 수 있어 별도의 설명을 요구하지 않는 표현이라고 해도, 새로운 변수로 담아두는 방법은 여전히 유용할 수 있다.</li></ul></li><li>드모르간의 법칙 사용하기 De Morgan’s Laws<ul><li><code>if (!(file_exists &amp;&amp; !is_protected))</code></li><li><code>if (!file_exists &amp;&amp; is_protected)</code></li></ul></li><li>쇼트 서킷 논리 오용 말기<ul><li><strong>if ( a || b ) a가 참이면 b는 평가하지 않는다.</strong></li></ul></li><li><strong>예; 복잡한 논리와 씨름하기</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool Range:;OverlapsWith(Range other)&#123;</span><br><span class="line">  <span class="comment">// 'begin'dlsk 'end'가 'other'에 속하는지검사한다.</span></span><br><span class="line">  <span class="keyword">return</span> (begin &gt;= other.begin &amp;&amp; begin &lt; other.end) ||</span><br><span class="line">          (end &gt; other.begin &amp;&amp; end &lt;= other.end) ||</span><br><span class="line">          (begin &lt;= other.begin &amp;&amp; end &gt;= other.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>더 우아하게 접근하기<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool Range:;OverlapsWith(Range other)&#123;</span><br><span class="line">  <span class="keyword">if</span> (other.end &lt;= begin) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 우리가 시작하기 전에 끝난다.</span></span><br><span class="line">  <span class="keyword">if</span> (other.begin &gt;= begin) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 우리가 끝난 후에 시작한다.</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 마지막 가능성만 남았다. 즉 겹친다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>거대한 구문 나누기<br>반복되는 부분을 ⇒ 요약변수로 추출할 때 (DRY : Don’t Repeat Yourself)</p><ul><li>타이핑 실수를 피할 수 있다.</li><li>코드를 한눈에 훓어보는게 용이하도록 코드의 길이를 조이라도 더 줄여준다.</li><li>클래스명을 변경해야 할 때 한 곳만 바꾸면 된다.</li></ul></li><li><p>표현을 단순화하는 다른 창의적인 방법들</p></li></ol><hr><p><a id="third"></a></p><h2 id="9-변수와-가독성"><a href="#9-변수와-가독성" class="headerlink" title="9. 변수와 가독성"></a>9. 변수와 가독성</h2><p>변수를 엉터리로 사용하면 코드를 이해하기가 얼마나 어려워지는지 살펴본다.</p><ul><li>변수의 수가 많을수록 기억하고 다루기 더 어려워진다.</li><li>변수의 범위가 넓어질수록 기억하고 다루는 시간이 더 길어진다.</li><li>변수 값이 자주 바뀔수록 현재 값을 기억하고 다루기가 더 어려워진다.</li></ul><h3 id="9-1-변수-제거하기"><a href="#9-1-변수-제거하기" class="headerlink" title="9-1. 변수 제거하기"></a>9-1. 변수 제거하기</h3><ul><li>불필요한 임시 변수들<br>이러한 변수가 구지 필요하지 않는 이유<ul><li>복잡한 표현을 잘게 나누지 않는다.</li><li>명확성에 도움이 되지 않는다.</li><li>한번만 사용되어 중복된 코드를 압축하지 않는다.</li></ul></li><li>중간 결과 삭제하기<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> remove_one = <span class="function"><span class="keyword">function</span> (<span class="params">array, value_to_remove</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index_to_remove = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i +=<span class="number">1</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === value_to_remove) &#123;</span><br><span class="line">      index_to_remove = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (index_to_remove !== <span class="literal">null</span>) &#123;</span><br><span class="line">    array.splice(index_to_remove, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 위의 방법보다는 아래방법 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> remove_one = <span class="function"><span class="keyword">function</span> (<span class="params">array, value_to_remove</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index_to_remove = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i +=<span class="number">1</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === value_to_remove) &#123;</span><br><span class="line">      array.splice(i, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-흐름-제어-변수-제거하기"><a href="#9-2-흐름-제어-변수-제거하기" class="headerlink" title="9-2. 흐름 제어 변수 제거하기"></a>9-2. 흐름 제어 변수 제거하기</h3><ul><li>흐름제어 변수? : 프로그램의 실행과 관련된 방향을 설정하는 데 있다.</li></ul><h3 id="9-3-변수의-범위를-좁혀라"><a href="#9-3-변수의-범위를-좁혀라" class="headerlink" title="9-3. 변수의 범위를 좁혀라"></a>9-3. 변수의 범위를 좁혀라</h3><ul><li>‘전역변수를 피하라’는 조언을 한번쯤 들었을 것이다.<ul><li>전역 변수는 어디에서 어떻게 사용되는지 일일이 확인하기 어려우므로 이는 합당한 조언이다.</li><li>또한, 전역 변수의 이름과 지역 변수의 이름이 중복되어 이름공간이 더러워질 수도 있고, 어떤 코드가 지역 변수를 변경할 때 실수로 전역 변수를 변경하거나 혹은 그 반대의 경우가 일어날 수 있으므로 타당하다.</li></ul></li><li>사실 전역 변수 뿐만 아니라 <strong>모든 변수의 범위를 좁히는 일은 언제나 좋다.</strong></li><li>많은 프로그래밍 언어는 모듈, 클래스, 함수, 블록 범위 같은 다양한 범위/접근 수준을 제공한다.</li><li><p><strong>자바스크립트에서 프라이빗 변수 만들기</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">submitted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> submit_form = <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(submitted)&#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 폼을 두 번 제출하지 말라.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  submitted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>submit_form()</code>만이 전역변수 submitted를 사용하는 유일한 함수처럼 보이지만,<br>확실히 알 수 없다.<br>⇒ 다른 자바스크립트 파일에서 이와는 다른 목적으로 submitted라는 이름이 붙은 전역 변수를 사용할 지도 모르는 일이다!<br>⇒ submitted 변수를 <strong><a href="https://feel5ny.github.io/2017/12/07/JS_06/">클로저</a> 내부에 집어 넣어서 이런 문제를 해결한다.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> submit_form = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> submitted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(submitted)&#123;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 폼을 두 번 제출하지 말라.</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">submitted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>⇒ 프라이빗한 범위를 만드는 효과를 갖는다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[읽기 좋은 코드가 좋은 코드다.]&lt;/strong&gt;를 보고 메모할 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CleanCode" scheme="http://feel5ny.github.io/categories/TIL-9997/CleanCode/"/>
    
    
      <category term="cleanCode" scheme="http://feel5ny.github.io/tags/cleanCode/"/>
    
      <category term="refactoring" scheme="http://feel5ny.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>📓 읽기 좋은 코드가 좋은 코드다. || part1. 표면적 수준에서의 개선</title>
    <link href="http://feel5ny.github.io/2018/08/01/Clean_code_1/"/>
    <id>http://feel5ny.github.io/2018/08/01/Clean_code_1/</id>
    <published>2018-08-01T11:12:34.000Z</published>
    <updated>2018-08-15T14:44:15.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>[읽기 좋은 코드가 좋은 코드다.]</strong>를 보고 메모한 부분을 정리했습니다.</p></blockquote><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>코드는 이해하기 쉬워야 한다. <a href="#first">⇒</a></li><li>이름에 정보 담기 <a href="#second">⇒</a></li><li>오해할 수 없는 이름들 <a href="#third">⇒</a></li><li>미학 <a href="#forth">⇒</a></li><li>주석에 담아야 하는 대상 <a href="#fifth">⇒</a></li><li>명확하고 간결한 주석 달기 <a href="#sixth">⇒</a></li></ol><hr><p><strong>서론</strong><br>좋은 코드는 <strong>무슨 일이 일어나고 있는지</strong>를 빠르게 전달해준다.<br>사용하기에도 즐겁고,<br><strong>자신</strong>에게도 더 좋은 코드를 만들어야 하겠다는 욕구를 불러일으키기도 한다.</p><hr><hr><h1 id="PART-1-표면적-수준에서의-개선"><a href="#PART-1-표면적-수준에서의-개선" class="headerlink" title="PART 1 ) 표면적 수준에서의 개선"></a>PART 1 ) 표면적 수준에서의 개선</h1><p><a id="first"></a></p><h2 id="1-코드는-이해하기-쉬워야-한다"><a href="#1-코드는-이해하기-쉬워야-한다" class="headerlink" title="1. 코드는 이해하기 쉬워야 한다."></a>1. 코드는 이해하기 쉬워야 한다.</h2><ol><li>코드는 다른 사람이 그것을 이해하는 데 들이는 시간을 <strong>최소화</strong>하는 방식으로 작성되어야 한다.<br>⇒ 바로 인지 가능하도록<br>time-til-understanding</li><li>분량이 적으면 항상 더 좋은가?<br>더 분량이 적은 코드로 똑같은 문제를 해결할 수 있다면 그것이 더 낫다.</li><li>이해를 위한 시간은 다른 목표와 충돌되는가?<br><strong>정리가 되지 않은 코드를 고치고 싶을 때는<br>뒤로 한걸음 물러나서 스스로에게 물어보는 게 중요하다.</strong><br><strong>이 코드는 이해하기 쉬운가?</strong></li></ol><h3 id="1-1-표면적-수준"><a href="#1-1-표면적-수준" class="headerlink" title="1-1. 표면적 수준"></a>1-1. 표면적 수준</h3><ul><li>좋은 이름을 짓고,</li><li>좋은 설명을 달고</li><li>코드를 보기 좋게 정렬하는 따위를 의미</li></ul><p>⇒ 이런 수정은 코드를 리팩토링하거나 프로그램이 동작하는 방식을 바꾸지 않고 <code>그 자리에서</code> 곧바로 만들 수 있기 때문에 수정 반영이 쉽다.<br>⇒ 코드베이스를 흔드는 행위이므로 결과적으로 작성하는 모든 코드에 영향을 줄 수 있다.</p><hr><p><a id="second"></a></p><h2 id="2-이름에-정보-담기"><a href="#2-이름에-정보-담기" class="headerlink" title="2. 이름에 정보 담기"></a>2. 이름에 정보 담기</h2><p>변수, 함수, 혹은 클래스 명을 결정할 때<br>⇒ <strong>이름에 정보를 담아내라</strong></p><h3 id="2-1-특정한-단어-고르기"><a href="#2-1-특정한-단어-고르기" class="headerlink" title="2-1. 특정한 단어 고르기"></a>2-1. <strong>특정한 단어 고르기</strong></h3><h4 id="2-1-1-보편적인-단어-피하기"><a href="#2-1-1-보편적인-단어-피하기" class="headerlink" title="2-1.1 보편적인 단어 피하기"></a>2-1.1 보편적인 단어 피하기</h4><p><code>get</code>은 지나치게 보편적이다.</p><ul><li><code>fetch</code></li><li><code>download</code></li></ul><h4 id="2-1-2-더-화려한-단어-고르기"><a href="#2-1-2-더-화려한-단어-고르기" class="headerlink" title="2-1-2. 더 화려한 단어 고르기"></a>2-1-2. 더 <strong>화려한</strong> 단어 고르기</h4><p>send 보다는</p><ul><li>deliver</li><li>dispatch(보내다)</li><li>announce</li><li>distribute(분배하다)</li><li>route</li></ul><p>find 보다는</p><ul><li>search </li><li>extract </li><li>locate</li><li>recover</li></ul><p>start 보다는</p><ul><li>launch</li><li>create</li><li>begin </li><li>open</li></ul><p>make 보다는</p><ul><li>create</li><li>set up</li><li>build generate</li><li>compose</li><li>add</li><li>new</li></ul><h4 id="2-1-3-명확하고-간결한-이름이-더-좋다"><a href="#2-1-3-명확하고-간결한-이름이-더-좋다" class="headerlink" title="2-1-3. 명확하고 간결한 이름이 더 좋다."></a>2-1-3. 명확하고 간결한 이름이 더 좋다.</h4><hr><h3 id="2-2-tmp-retval-foo같은-보편적인-이름-피하기-혹은-언제-그런-이름을-사용해야-하는지-깨닫기"><a href="#2-2-tmp-retval-foo같은-보편적인-이름-피하기-혹은-언제-그런-이름을-사용해야-하는지-깨닫기" class="headerlink" title="2-2. (tmp, retval, foo같은)보편적인 이름 피하기 (혹은 언제 그런 이름을 사용해야 하는지 깨닫기)"></a>2-2. <strong>(tmp, retval, foo같은)보편적인 이름 피하기 (혹은 언제 그런 이름을 사용해야 하는지 깨닫기)</strong></h3><ul><li>tmp, retval(: 반환된 값), foo 같은 이름은<br><strong>내 머리로는 이름을 생각해낼수 없어요..</strong></li><li>더 좋은 이름은<br>: <strong>변수의 목적이나 담고 있는 값을 설명해주어야한다.</strong></li><li><code>tmp</code> : 변수 목적 자체가 코드 몇 줄에서만 사용하는<br> <strong>임시저장소</strong>의 역할을 할 경우에는 사용해도 ok</li><li><p><strong>루프반복자</strong></p><ul><li><code>i</code>, <code>j</code>, <code>iter</code>, <code>it</code> 인덱스나 루프 반복자로 사용된다.</li><li><p>배열이름과 + 인덱스를 합친 반복자로 사용하면 좋다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; clubs.size(); i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; clubs[i].members.size(); j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; users.size(); k++)</span><br><span class="line">      <span class="keyword">if</span>(clubs[i].members[k] == users[j])</span><br><span class="line">          cout &lt;&lt; <span class="string">"user["</span> &lt;&lt; j &lt;&lt; <span class="string">"] is in club["</span>&lt;&lt; i &lt;&lt;<span class="string">"]"</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure></li><li><p>i, j, k보다는 ⇒ <code>club_i</code>, <code>members_i</code>, <code>users_i</code></p></li><li>혹은 <code>ci</code>, <code>mi</code>, <code>ui</code></li></ul></li><li>tmp, it, retval 같은 보편적인 이름을 사용하려면,<br><strong>꼭 그러게 해야하는 이유가 있어야 한다.</strong></li></ul><hr><h3 id="2-3-추상적인-이름-대신-구체적인-이름-사용하기"><a href="#2-3-추상적인-이름-대신-구체적인-이름-사용하기" class="headerlink" title="2-3. 추상적인 이름 대신 구체적인 이름 사용하기"></a>2-3. <strong>추상적인 이름 대신 구체적인 이름 사용하기</strong></h3><hr><h3 id="2-4-접두사-혹은-접미사로-이름에-추가적인-정보-덧붙이기"><a href="#2-4-접두사-혹은-접미사로-이름에-추가적인-정보-덧붙이기" class="headerlink" title="2-4. 접두사 혹은 접미사로 이름에 추가적인 정보 덧붙이기"></a>2-4. <strong>접두사 혹은 접미사로 이름에 추가적인 정보 덧붙이기</strong></h3><h4 id="2-4-1-단위를-포함하는-값들-ex-밀리세컨즈-ms"><a href="#2-4-1-단위를-포함하는-값들-ex-밀리세컨즈-ms" class="headerlink" title="2-4-1. 단위를 포함하는 값들 (ex. 밀리세컨즈 : ~_ms)"></a>2-4-1. 단위를 포함하는 값들 (ex. 밀리세컨즈 : ~<code>_ms</code>)</h4><p>변수가 시간의 양이나 바이트의 수와 같은 측정치를 담고 있다면,<br>⇒ 변수명에 단위를 포함시키는 게 도움이 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> elapsed = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start;</span><br><span class="line"><span class="built_in">document</span>.writeIn(<span class="string">"Load time was: "</span> + elapsed + <span class="string">"seconds"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 위보다는 아래 **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start_ms = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> elapsed_ms = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start_ms;</span><br><span class="line"><span class="built_in">document</span>.writeIn(<span class="string">"Load time was: "</span> + elapsed_ms + <span class="string">"seconds"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="2-4-2-다른-중요한-속성-포함하기-ex-인코딩된-data-data-urlenc"><a href="#2-4-2-다른-중요한-속성-포함하기-ex-인코딩된-data-data-urlenc" class="headerlink" title="2-4-2. 다른 중요한 속성 포함하기 (ex. 인코딩된 data : data_urlenc)"></a>2-4-2. 다른 중요한 속성 포함하기 (ex. 인코딩된 data : <code>data_urlenc</code>)</h4><ul><li><strong>보안 취약한, 불안전함을 인지하고 싶을 때</strong><ul><li>untrustedUrl / unsafeMessageBody …<br>⇒  안전하게 만드는 함수 호출 후에는<br>⇒ trustedUrl, safeMessageBody에 담는다.</li></ul></li><li>변수의 의미를 제대로 이해하는 것이 중요한 상황일때 사용하긔</li><li>예시<ol><li>패스워드가 plaintext에 담겨 있고, 추가적인 처리를 하기 전에 반드시 암호화되어야 한다.<ul><li>password 보다는 ⇒ <strong>plaintext_password</strong></li></ul></li><li>사용자에게 보여지는 설명문이 화면에 나타나기 전에 이스케이프 처리가 되어야한다.<ul><li>comment 보다는 ⇒ <strong>unescaped_comment</strong></li></ul></li><li>html의 바이트가 UTF-8으로 변환되었다.<ul><li>html ⇒ <strong>html_utf8</strong></li></ul></li><li>입력데이터가 url encoded 되었다.<ul><li>data 보다는  ⇒ <strong>data_urlenc</strong></li></ul></li></ol></li></ul><hr><h3 id="2-5-이름이-얼마나-길어져도-좋은지-결정하기"><a href="#2-5-이름이-얼마나-길어져도-좋은지-결정하기" class="headerlink" title="2-5. 이름이 얼마나 길어져도 좋은지 결정하기"></a>2-5. <strong>이름이 얼마나 길어져도 좋은지 결정하기</strong></h3><ul><li>좁은 범위에서는 짧은 이름이 괜찮다.</li></ul><h4 id="2-5-1-약어와-축약형"><a href="#2-5-1-약어와-축약형" class="headerlink" title="2-5-1. 약어와 축약형"></a>2-5-1. 약어와 축약형</h4><ul><li>특정 프로젝트에 국한된 의미를 가진 약어 사용은 좋은 생각이 아니다.</li><li><strong>팀에 새로 합류한 사람이 이름이 의미하는 바를 이해할 수 있을까?</strong></li></ul><ul><li>축약할 때는 보편적인 것은 괜찮다.</li><li>string 대신 <code>str</code>, evaluation 대신 <code>eval</code></li></ul><h4 id="2-5-2-불필요한-단어-제거하기"><a href="#2-5-2-불필요한-단어-제거하기" class="headerlink" title="2-5-2. 불필요한 단어 제거하기"></a>2-5-2. 불필요한 단어 제거하기</h4><ul><li>convertToString()보다는 <code>ToString()</code></li><li>DoServeLoop()보다는 <code>ServeLoop()</code></li></ul><hr><h3 id="2-6-추가적인-정보를-담을-수-있게-이름-구성하기"><a href="#2-6-추가적인-정보를-담을-수-있게-이름-구성하기" class="headerlink" title="2-6. 추가적인 정보를 담을 수 있게 이름 구성하기"></a>2-6. <strong>추가적인 정보를 담을 수 있게 이름 구성하기</strong></h3><p>&lt; 다른 포맷팅 <strong>관습</strong> &gt;</p><ol><li><p>jQuery 함수 호출시 jQuery의 결과를 저장하는 변수 앞에 <code>$</code> 붙이기</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $all_images = $(<span class="string">"img"</span>);</span><br></pre></td></tr></table></figure></li><li><p>밑줄로 id안에는 단어를 구분하고, 대시로 클래스 안에 있는 단어를 구분 할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"middle_column"</span> <span class="attr">class</span>=<span class="string">"main-content"</span>&gt;</span> ...</span><br></pre></td></tr></table></figure></li></ol><hr><hr><p><a id="third"></a></p><h2 id="3-오해할-수-없는-이름들"><a href="#3-오해할-수-없는-이름들" class="headerlink" title="3. 오해할 수 없는 이름들"></a>3. 오해할 수 없는 이름들</h2><p>본인이 지은 이름을<br><strong>‘다른 사람들이 다른 의미로 해석할 수 있을까?’</strong>라는 질문을 던져보며<br>철저하게 확인해야 한다. </p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter()"></a>Filter()</h3><ul><li>고르는 행위인지 제거하는 행위인지 모호하다.<br>⇒ 보편적인 뜻을 갖고 있는 단어를 최대한 사용을 자제하자.</li><li><code>select()</code>나 <code>exclude()</code></li></ul><h3 id="접두어"><a href="#접두어" class="headerlink" title="접두어**"></a>접두어**</h3><ul><li>경계를 포함하는 <strong>한계값</strong>을 다룰 때는 <code>min</code>과 <code>max</code>를 사용하라</li><li>경계를 포함하는 <strong>범위</strong>에는 <code>first</code>와 <code>last</code>를 사용하라</li><li>경계를 포함하고/배제하는 범위에는 <code>begind</code>과 <code>end</code>를 사용하라</li><li>불리언 변수에 이름 붙이기<ul><li><code>is</code> / <code>has</code> / <code>can</code> / <code>should</code></li></ul></li><li>사용자의 기대에 부응하기<ul><li><code>get*()</code> : 가벼운접근자(lightweight accessors)로서 단순히 내부 멤버를 반환한다고 관행적으로 생각한다.</li></ul></li><li>이름을 짓기 위해서 복수의 후보를 평가하기<ul><li>예 ) template, reuse, copy, inherit</li></ul></li></ul><hr><hr><p><a id="forth"></a></p><h2 id="4-미학"><a href="#4-미학" class="headerlink" title="4. 미학"></a>4. 미학</h2><p><strong>좋은 소스 코드는 ‘눈을 편하게’ 해야한다.</strong></p><ul><li>코드의 열을 맞춰라</li><li>의미 있는 순서를 선택하고 일관성 있게 사용하라<br>⇒ 개인적인 기준이 있으면 좋을듯<br>⇒ 중요한 것 먼저 등등..</li></ul><ul><li>선언문을 블록으로 구성하라<ul><li><strong>우리의 뇌는 자연스럽게 그룹과 계층구조를 따라서 동작하므로,</strong><br>코드를 이런 방식으로 조작하면 코드를 읽는 데 도움을 준다.</li></ul></li><li><p>코드를 <strong><code>문단</code></strong>으로 쪼개라</p><ul><li>문단 첫줄에는 주석으로 사용한다.</li></ul></li><li><p><strong>핸들러, 헬퍼함수</strong></p><ul><li><p>핸들러<br>이벤트에 응답해서 호출되는 함수를 이벤트 핸들러(이벤트 리스너)라고 합니다.</p></li><li><p>헬퍼함수<br>함수를 재사용할 수 있는 헬퍼함수</p></li></ul></li></ul><hr><hr><p><a id="fifth"></a></p><h2 id="5-주석에-담아야-하는-대상"><a href="#5-주석에-담아야-하는-대상" class="headerlink" title="5. 주석에 담아야 하는 대상"></a>5. 주석에 담아야 하는 대상</h2><h3 id="5-1-설명하지-말아야-하는-것"><a href="#5-1-설명하지-말아야-하는-것" class="headerlink" title="5-1. 설명하지 말아야 하는 것"></a>5-1. <strong>설명하지 말아야 하는 것</strong></h3><ul><li>무가치한 주석은 달지 말자<ul><li>코드에서 빠르게 유추할 수 있는 내용은 주석으로 달지 말자</li><li>즉, 코드를 읽으면 무슨 일을 수행하는지 알 수 있으면..</li><li>설명 자체를 위한 설명은 달지 말자</li></ul></li><li>나쁜이름에 주석을 달지마라!! ⇒ <strong>대신 이름을 고쳐라</strong><ul><li><strong>좋은 코드 &gt; 나쁜코드 + 좋은 주석</strong></li></ul></li></ul><h3 id="5-2-코딩을-행하면서-머릿속에-있는-정보를-기록하기"><a href="#5-2-코딩을-행하면서-머릿속에-있는-정보를-기록하기" class="headerlink" title="5-2. 코딩을 행하면서 머릿속에 있는 정보를 기록하기"></a>5-2. <strong>코딩을 행하면서 머릿속에 있는 정보를 기록하기</strong></h3><ol><li><p><strong>감독의 설명</strong>을 포함하라<br><strong>중요한 통찰은 기록하자.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이 클래스는 점점 엉망이 되어가고 있다. 어쩌면 'ResourceNode' </span></span><br><span class="line"><span class="comment">// 하위 클래스를 만들어서 정리해야할지도 모르겠다.</span></span><br></pre></td></tr></table></figure></li><li><p>코드에 있는 결함을 설명하라</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 더 빠른 알고리즘을 사용하라.</span></span><br><span class="line"><span class="comment">// TODO(더스틴): JPEG말고 다른 이미지 포맷도 처리할 수 있어야 한다.</span></span><br></pre></td></tr></table></figure><ul><li>코드가 불완전 할 때는 개선 아이디어를 설명하는 것도 좋다.</li><li>널리 사용되는 표시<ul><li><code>TODO:</code> 아직 하지 않은 일</li><li><code>FIXME:</code> 오작동을 일으킨다고 알려진 코드</li><li><code>HACK:</code> 아름답지 않은 해결책</li><li><code>XXX:</code> 위험! 여기 큰 문제가 있다</li><li><code>TextMate:</code> ESC</li></ul></li></ul></li><li>상수에 대한 설명<ul><li>그 상수가 무엇을 하는지, 그것이 왜 특정한 값을 갖게 되었는지 ‘사연’이 존재하기 마련</li><li>사연을 주석에 남기면 좋다. 명확한 변수명이면 구지 안붙여도 됨.</li></ul></li></ol><h3 id="5-3-코드읽는-사람의-입장에서-필요한-정보가-무엇인지-유추하기"><a href="#5-3-코드읽는-사람의-입장에서-필요한-정보가-무엇인지-유추하기" class="headerlink" title="5-3. 코드읽는 사람의 입장에서 필요한 정보가 무엇인지 유추하기"></a>5-3. <strong>코드읽는 사람의 입장에서 필요한 정보가 무엇인지 유추하기</strong></h3><ul><li>나올 것 같은 지문 예측하기</li><li>사람들이 쉽게 빠질 것 같은 함정을 경고하기</li></ul><h4 id="5-3-1-큰-그림에-대한-주석"><a href="#5-3-1-큰-그림에-대한-주석" class="headerlink" title="5-3-1. 큰 그림에 대한 주석"></a>5-3-1. 큰 그림에 대한 주석</h4><p><strong>팀에 새롭게 합류한 사람들은 ‘큰 그림’을 이해하는 데 어려움을 겪는다. 클래스들이 어떻게 상호작용하고, 전체 시스템에서 데이터가 어떻게 흘러 다니고, 출발점이 어디인지 등을 파악해야한다.</strong></p><ul><li>이는 <strong><a href="#upper_note">상위 수준 주석</a></strong>에 포함되어야 한다.</li><li>파일 수준의 주석의 설명은<ul><li>파일 시스템에 편리한 인터페이스를 제공하는 헬퍼 함수들을 담고 있다.</li><li>파일의 퍼미션과 다른 자세한 세부 사항을 처리한다.</li></ul></li></ul><h4 id="5-3-2-요약-주석"><a href="#5-3-2-요약-주석" class="headerlink" title="5-3-2. 요약 주석"></a>5-3-2. 요약 주석</h4><ul><li>함수가 수행하는 기능의 글머리 요약 역할을 수행할 수 있다.</li><li>주석을 보고 요점을 파악할 수 있다.<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GenerateUserReport</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># 이 사용자를 위한 lock을 얻는다.</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 데이터베이스에서 사용자의 정보를 읽는다.</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 정보를 파일에 작성한다.</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 사용자를 위한 lock을 되덜려 넣는다.</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><a id="sixth"></a></p><h2 id="6-명확하고-간결한-주석-달기"><a href="#6-명확하고-간결한-주석-달기" class="headerlink" title="6. 명확하고 간결한 주석 달기"></a>6. 명확하고 간결한 주석 달기</h2><ul><li>주석을 간결하게 하라</li><li>모호한 대명사는 피하라</li><li>엉터리 문장을 다듬어라</li><li>함수의 동작을 명확하게 설명하라</li><li>코너케이스를 설명해주는 입/출력 예를 사용하라<ul><li>예시를 주석에 적는 것도 좋다.</li><li>인자로 어떤 데이터가 들어가고 (입력)<br>어떤 데이터를 반환하는지를 적으면 된다. (출력)</li></ul></li><li>코드의 <strong>의도</strong>를 명시하라 → 버그를 잡을 수 있다.</li><li>이름을 가진 함수 파라미터 주석</li><li>정보 축약형 단어를 사용하라<ul><li>경험적인, 주먹구구식, 순진한 해법과 같이 다양한 의미를 함축하는 단어나 표현이 많다.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[읽기 좋은 코드가 좋은 코드다.]&lt;/strong&gt;를 보고 메모한 부분을 정리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CleanCode" scheme="http://feel5ny.github.io/categories/TIL-9997/CleanCode/"/>
    
    
      <category term="cleanCode" scheme="http://feel5ny.github.io/tags/cleanCode/"/>
    
      <category term="refactoring" scheme="http://feel5ny.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>렌더링 엔진(2) - 렌더 트리 구축</title>
    <link href="http://feel5ny.github.io/2018/06/07/rendering_engine_2/"/>
    <id>http://feel5ny.github.io/2018/06/07/rendering_engine_2/</id>
    <published>2018-06-07T12:20:19.000Z</published>
    <updated>2018-08-15T14:46:26.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">https://d2.naver.com/helloworld/59361</a> 를 읽고 정리했습니다.</p></blockquote><ol><li><a href="https://feel5ny.github.io/2018/05/29/rendering_engine_0/">브라우저의 주요 기능</a></li><li>브라우저의 기본 구조</li><li>렌더링 엔진 동작 과정 <div style="padding: 1em;background-color: lightyellow;"><ol><li><a href="#html_parse">HTML 파싱</a> (for DOM트리 구축)</li><li><a href="#setting">렌더 트리 <strong>구축</strong></a></li><li><a href="#layout">렌더 트리 <strong>배치</strong></a></li><li><a href="#draw">렌더 트리 <strong>그리기</strong></a><br></li></ol></div></li></ol><hr><h1 id="렌더-트리-구축"><a href="#렌더-트리-구축" class="headerlink" title="렌더 트리 구축"></a>렌더 트리 구축</h1><ol><li>HTML 마크업을 처리하고 DOM 트리를 빌드합니다.</li><li>CSS 마크업을 처리하고 CSSOM 트리를 빌드합니다.</li><li>DOM 및 CSSOM을 결합하여 렌더링 트리를 형성합니다.</li></ol><ul><li>DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축한다.</li><li>표시해야 할 순서와 문서의 시각적인 구성 요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적이 있다.</li><li>파폭 : 형상 frames</li><li>웹킷 : 렌더러, 혹은 렌더 객체</li></ul><p><strong>&lt; DOM과 CSSOM을 결함 = 렌더링트리 &gt;</strong></p><ul><li>렌더러는 CSS2 명세에 따라 노드의 CSS박스에 부합하는 <strong>사각형을 표시</strong>한다.</li><li>렌더러는 너비, 높이 그리고 위치와 같은 <strong>기하학적 정보</strong>를 포함한다.</li><li>박스 유형은 노드와 관련된 display 스타일 속성의 영향을 받는다.<ul><li>렌더링 엔진에는 display 속성에 따른 DOM 노드를 위한 렌더러를 만드는 코드가 있다.</li></ul></li><li>렌더링 트리는 표시되는 각 요소의 레이아웃을 계산하는 데 사용되고 픽셀을 화면에 렌더링하는 페인트 프로세스에 대한 입력으로 처리됩니다.</li></ul><h2 id="1-DOM-트리와-렌더-트리의-관계"><a href="#1-DOM-트리와-렌더-트리의-관계" class="headerlink" title="1. DOM 트리와 렌더 트리의 관계"></a>1. DOM 트리와 렌더 트리의 관계</h2><ul><li>렌더러와 DOM 요소는 1:1 대응 관계가 아니다.<ul><li><code>head</code> 요소와 같은 비시각적 DOM 요소는 렌더 트리에 추가되지 않는다.</li><li>display 속성의 <code>none</code>값이 할당된 요소는 트리에 나타나지 않는다.</li></ul></li><li>여러 개의 시각 객체와 대응하는 DOM요소도 있는데 이것들은 보통 하나의 사각형으로 묘사할 수 없는 복잡한 구조다.<br><select name="job"><br>  <option value="">직업선택</option><br>  <option value="학생">학생</option><br>  <option value="회사원">회사원</option><br>  <option value="기타">기타</option><br></select><ul><li>예1) select 요소 = 표시영역 + 드롭다운 목록 + 버튼 <strong>(3개의 렌더러)</strong></li><li>예2) 한 줄에 충분히 표시할 수 없는 문자가 여러 줄로 바뀔 때 새 줄은 별도로 렌더러로 추가</li><li>예3) CSS 명세에 의하면 인라인 박스는 블록 박스만 포함하거나 인라인 박스만을 포함해야 하는데 <strong>인라인과 블록 박스가 섞인 경우 인라인 박스를 감싸기 위한 익명의 블록 렌더러가 생성된다.</strong></li></ul></li><li>어떤 렌더 객체는 DOM노드에 대응하지만 트리의 동일한 위치에 있지 않다.<ul><li>float처리된 요소는 position 속성값이 absolute로 처리된 요소는 흐름에서 벗어나 트리의 다른 곳에 배치된 상태로 형상이 그려진다.</li></ul></li></ul><p><img src="/images/2018/15/render-tree-construction.png"></p><h2 id="2-트리를-구축하는-과정"><a href="#2-트리를-구축하는-과정" class="headerlink" title="2. 트리를 구축하는 과정"></a>2. 트리를 구축하는 과정</h2><ol><li>DOM 트리의 루트에서 시작하여 표시되는 노드 각각을 트래버스합니다.<ul><li>일부 노드는 표시되지 않으며(예: 스크립트 태그, 메타 태그 등), 렌더링된 출력에 반영되지 않으므로 생략됩니다.</li><li>일부 노드는 CSS를 통해 숨겨지며 렌더링 트리에서도 생략됩니다. 예를 들어,—위의 예시에서—span 노드의 경우 ‘display: none’ 속성을 설정하는 명시적 규칙이 있기 때문에 렌더링 트리에서 누락됩니다.</li></ul></li><li>표시된 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용합니다.</li><li>표시된 노드를 콘텐츠 및 계산된 스타일과 함께 내보냅니다.</li></ol><ul><li>웹킷<br>: attachment =&gt; 렌더러를 만드는 과정<br>: RenderView =&gt; 렌더트리 루트</li><li>파폭<br>: 형상구축 =&gt; 렌더러를 만드는 과정<br>: ViewPortFrame =&gt; 렌더트리 루트</li></ul><hr><h2 id="3-스타일-계산"><a href="#3-스타일-계산" class="headerlink" title="3. 스타일 계산"></a>3. 스타일 계산</h2><ul><li>렌더 객체의 시각적 송성에 대한 계산이 필요하다.</li><li>최초의 스타일 시트 : 브라우저가 제공하는 기본 스타일 시트</li></ul><ol><li>메모리 문제가 생길 수 있다.<ul><li>스타일 데이터는 구성이 매우 광범위한데 수 많은 스타일 속성들을 수용하면서 메모리 문제를 야기할 수 있다.</li></ul></li><li>최적화의 필요성<ul><li>최적화되어 있지 않다면 각 요소에 할당된 규칙을 찾는 것은 성능 문제를 야기할 수 있다.</li><li>각 요소에 할당된 규칙 목록을 전체 규칙으로부터 찾아내는 것은 과중한 일이다.</li><li>맞는 규칙을 찾는 과정은 얼핏 보기에는 약속된 방식으로 순탄하게 시작하는 것 같지만 실상 쓸모가 없거나 다른 길을 찾아야만 하는 복잡한 구조가 될 수 있다.<br>예를 들어 이런 복합 선택자가 있다.<br>div div div div { … }</li><li>이 선택자는 3번째 자손 <code>&lt;div&gt;</code>에 규칙을 적용한다는 뜻이다.</li><li>규칙을 적용할 <code>&lt;div&gt;</code> 요소를 확인하려면 트리로부터 임의의 줄기를 선택하고 탐색하는 과정에서 규칙에 맞지 않는 줄기를 선택했다면 또 다른 줄기를 선택해야 한다.</li></ul></li><li>규칙을 적용하는 것은 계층 구조를 파악해야 하는 꽤나 복잡한 다단계 규칙을 수반한다.</li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">https://d2.naver.com/helloworld/59361</a></li><li><a href="https://developers.google.com/web" target="_blank" rel="noopener">https://developers.google.com/web</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://d2.naver.com/helloworld/59361&lt;/a&gt; 를 읽
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Web" scheme="http://feel5ny.github.io/categories/TIL-9997/Web/"/>
    
    
      <category term="Web" scheme="http://feel5ny.github.io/tags/Web/"/>
    
      <category term="browser" scheme="http://feel5ny.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>브렌더링 엔진(1) - 파싱과 DOM트리 구축</title>
    <link href="http://feel5ny.github.io/2018/06/06/rendering_engine_1/"/>
    <id>http://feel5ny.github.io/2018/06/06/rendering_engine_1/</id>
    <published>2018-06-06T12:20:19.000Z</published>
    <updated>2018-08-15T14:46:27.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">https://d2.naver.com/helloworld/59361</a> 를 읽고 정리했습니다.</p></blockquote><ol><li><a href="https://feel5ny.github.io/2018/05/29/rendering_engine_0/">브라우저의 주요 기능</a></li><li>렌더링 엔진 동작 과정 <div style="padding: 1em;background-color: lightyellow;"><ol><li><a href="#html_parse">HTML 파싱</a> (for DOM트리 구축)</li><li><a href="#setting">렌더 트리 <strong>구축</strong></a></li><li><a href="#layout">렌더 트리 <strong>배치</strong></a></li><li><a href="#draw">렌더 트리 <strong>그리기</strong></a><br></li></ol></div></li></ol><hr><h1 id="파싱과-DOM트리-구축"><a href="#파싱과-DOM트리-구축" class="headerlink" title="파싱과 DOM트리 구축"></a>파싱과 DOM트리 구축</h1><ol><li><a href="https://feel5ny.github.io/2018/06/06/rendering_engine_1/#pasing_normal">파싱에 대하여</a><br>문법 / 파서-어휘 분석기 조합 / 변환 / 파싱 예 / 어휘와 구문에 대한 공식적인 정의 / 파서의 종류 / 파서 자동 생성</li><li><a href="https://feel5ny.github.io/2018/06/06/rendering_engine_1/#html_parser">HTML 파서 =&gt; DOM 트리</a><br>문맥자유문법이 아니다 / HTML DTD / DOM / 파싱 알고리즘 / 파싱이 끝난 이후의 동작 / 브라우저의 오류 처리</li><li><a href="https://feel5ny.github.io/2018/06/06/rendering_engine_1/#css_parsing">CSS 파서 =&gt; CSSOM 트리</a></li><li><a href="https://feel5ny.github.io/2018/06/06/rendering_engine_1/#script_stylesheet">스크립트와 스타일 시트의 진행 순서</a></li></ol><h2 id="1-파싱-일반"><a href="#1-파싱-일반" class="headerlink" title="1. 파싱 일반"></a>1. 파싱 일반</h2><ul><li><strong>문서 파싱</strong> : 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것</li><li><strong>파싱 트리</strong>(문법트리 syntax tree) : 파싱결과는 보통 문서 구조를 나타내는 노드 트리</li></ul><p><img src="/images/2018/14/parse.png"><br>2 + 3 - 1</p><h3 id="1-1-문법"><a href="#1-1-문법" class="headerlink" title="1-1. 문법"></a>1-1. 문법</h3><ul><li>파싱은 문서에 작성된 언어 또는 형식의 규칙에 따른다.</li><li>파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다.</li><li><a href="http://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EC%9E%90%EC%9C%A0_%EB%AC%B8%EB%B2%95" target="_blank" rel="noopener">문맥 자유 문법</a> (Context-free grammar, CFG)</li><li>인간의 언어는 이런 모습과 다르기 때문에 기계적인 파싱이 불가능하다.</li></ul><h3 id="1-2-파서-어휘-분석기-조합"><a href="#1-2-파서-어휘-분석기-조합" class="headerlink" title="1-2. 파서-어휘 분석기 조합"></a>1-2. 파서-어휘 분석기 조합</h3><ul><li>파싱은 <code>어휘 분석</code>과 <code>구문 분석</code>으로 구분할 수 있다.<ul><li>어휘 분석 : 자료를 토큰으로 분해하는 과정 ( 사전에 등장하는 모든 단어를 말한다고 볼수 있다. )</li><li>구문 분석 : 언어의 구문 규칙을 적용하는 과정</li></ul></li></ul><p><img src="/images/2018/14/parse_1.png"></p><p>자료를 유효한 토큰으로 분해하는 <strong>어휘 분석기(lexical analysis)</strong>가 있고,<br>언어 구문 규칙에 따라 문서 구조를 분석함으로써 파싱 트리를 생성하는 <strong>파서</strong>가 있다.</p><ul><li>어휘 분석기는 공백과 줄 바꿈 같은 의미 없는 문자를 제거한다.</li></ul><p><img src="/images/2018/14/parsing.png"></p><ul><li>파싱과정은 반복됨</li><li>파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인 (언어 규칙들..)</li><li>규칙과 맞으면 토큰에 해당하는 노드가 파싱 트리에 추가되고 파서는 또 다른 토큰을 요청</li><li>규칙과 맞지 않으면 파서는 토큰을 내부적으로 저장, 토큰과 일치하는 규칙이 발견될 때까지 요청한다.</li><li>맞는 규칙이 없는 경우 예외로 처리하는데 =&gt; 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미</li></ul><h3 id="1-3-변환-컴파일"><a href="#1-3-변환-컴파일" class="headerlink" title="1-3. 변환 (컴파일!!)"></a>1-3. 변환 (컴파일!!)</h3><ul><li>파싱트리는 최종 결과물이 아니다.</li><li>파싱은 보통 문서를 다른 양식으로 변환하는데</li><li>컴파일이 하나의 예가 된다.</li><li>소스 코드를 기계 코드로 만드는 컴파일러는 <strong>파싱 트리 생성 후 이를 기계 코드 문서로 변환한다!</strong></li></ul><p><img src="/images/2018/14/compile.png"></p><h3 id="1-4-파싱-예"><a href="#1-4-파싱-예" class="headerlink" title="1-4. 파싱 예"></a>1-4. 파싱 예</h3><p><img src="/images/2018/14/parse_2.png"></p><ul><li>어휘 : 수학언어는 정수, 더하기 기호, 빼기 기호를 포함한다.</li><li>구문<ol><li>언어 구문의 기본적인 요소는 표현식, 항(정수), 연산자(+,-)이다.</li><li>언어에 포함되는 표현식의 수는 제한이 없다.</li><li>표현식은 “항” 뒤에 “연산자” 그 뒤에 또 다른 항이 따르는 형태로 정의한다.</li><li>연산자는 <strong>더하기 토큰</strong> 또는 <strong>빼기 토큰</strong>이다.</li><li>정수 토큰 또는 하나의 표현식은 항이다.</li></ol></li><li>2++는 어떤 규칙과도 맞지 않기 때문에 유효하지 않은 입력이 된다.</li></ul><h3 id="1-5-어휘와-구문에-대한-공식적인-정의"><a href="#1-5-어휘와-구문에-대한-공식적인-정의" class="headerlink" title="1-5. 어휘와 구문에 대한 공식적인 정의"></a>1-5. 어휘와 구문에 대한 공식적인 정의</h3><h4 id="어휘는-보통-정규표현식으로-표현한다"><a href="#어휘는-보통-정규표현식으로-표현한다" class="headerlink" title="어휘는 보통 정규표현식으로 표현한다."></a>어휘는 보통 정규표현식으로 표현한다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INTEGER : 0|[1-9][0-9]*  </span><br><span class="line">PLUS : +  </span><br><span class="line">MINUS : -</span><br></pre></td></tr></table></figure><h4 id="구문은-보통-BNF-lt-기호-gt-lt-표현식-gt-라고-부르는-형식에-따라-정의한다"><a href="#구문은-보통-BNF-lt-기호-gt-lt-표현식-gt-라고-부르는-형식에-따라-정의한다" class="headerlink" title="구문은 보통 BNF ( &lt;기호&gt; ::= &lt;표현식&gt;)라고 부르는 형식에 따라 정의한다."></a>구문은 보통 <a href="http://ko.wikipedia.org/wiki/BNF" target="_blank" rel="noopener">BNF</a> ( &lt;기호&gt; ::= &lt;표현식&gt;)라고 부르는 형식에 따라 정의한다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expression := term operation term  </span><br><span class="line">operation := PLUS | MINUS  </span><br><span class="line">term := INTEGER | expression</span><br></pre></td></tr></table></figure><p>문법이 <a href="http://www.google.com/url?q=http%3A%2F%2Fko.wikipedia.org%2Fwiki%2F%25EB%25AC%25B8%25EB%25A7%25A5_%25EC%259E%2590%25EC%259C%25A0_%25EB%25AC%25B8%25EB%25B2%2595&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNF47Dj5WH0U-Kl_pN9ai6aCmdOxVg" target="_blank" rel="noopener">문맥자유문법</a>(= 완전히 BNF로 표현 가능한 문법)이라면,<br>언어는 정규 파서로 파싱할 수 있다.</p><h3 id="1-6-파서의-종류"><a href="#1-6-파서의-종류" class="headerlink" title="1-6. 파서의 종류"></a>1-6. 파서의 종류</h3><ul><li>하향식 파서 : 구문의 상위 구조로부터 일치하는 부분을 찾는다.</li><li>상향식 파서 : 낮은 수준에서 점차 높은 수준으로 찾는다.</li></ul><h3 id="1-7-파서-자동-생성"><a href="#1-7-파서-자동-생성" class="headerlink" title="1-7. 파서 자동 생성"></a>1-7. 파서 자동 생성</h3><p><strong>파서 생성기</strong><br>: 파서를 생성해 줄 수 있는 도구</p><ul><li>언어에 =&gt; 어휘나 구문규칙 같은 문법을 부여하면 =&gt; 동작하는 파서를 만들어줌</li><li>파싱에 대한 깊은 이해를 필요로 하고 수동으로 파서를 최적화하여 생성하는 것은 쉬운일이 아니기 때문에 파서 생성기는 유용</li></ul><p><strong>웹킷</strong></p><ul><li><p>플렉스 <strong>Flex</strong> (fast lexical analyzer generator)<br>: lex의 기능을 개선한 자유 소프트웨어 (문법정의 프로그램)<br>: <strong>어휘 생성을 위한 어휘 분석기 발생기</strong><br>: 토큰의 정규 표현식 정의를 포함한 파일을 입력 받는다. (?)</p></li><li><p>바이슨 Bison<br>: 파서 생성을 위한 파서생성기<br>: BNF형식의 언어 구문 규칙을 입력 받는다.<br>: 상향식 이동 감소 파서</p></li></ul><hr><h2 id="2-HTML-파서"><a href="#2-HTML-파서" class="headerlink" title="2. HTML 파서"></a>2. HTML 파서</h2><p><img src="/images/2018/14/html_parser.jpg"><br><img src="/images/2018/14/full-process.png"></p><p>HTML 파서는 HTML 마크업을 파싱 트리로 변환한다.</p><h3 id="2-1-HTML-문법-정의"><a href="#2-1-HTML-문법-정의" class="headerlink" title="2-1. HTML 문법 정의"></a>2-1. HTML 문법 정의</h3><p><a href="https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="noopener">W3C의 명세</a></p><h3 id="2-2-문맥-자유-문법이-아님"><a href="#2-2-문맥-자유-문법이-아님" class="headerlink" title="2-2. 문맥 자유 문법이 아님"></a>2-2. 문맥 자유 문법이 아님</h3><ul><li>모든 전통적인 파서는 HTML에 적용할 수 없다.</li><li>파싱은 CSS와 자바스크립트를 파싱하는 데 사용된다.</li><li>HTML은 파서가 요구하는 문맥 자유 문법에 의해 쉽게 정의할 수 없다.</li><li>HTML은 <code>너그럽다.</code><ul><li>암묵적으로 태그 생략이 가능하다.</li><li>시작태그, 종료 태그등을 생략한다.</li><li>뻣뻣하고 부담스러운 XML에 반하여 HTML은 유연한 문법이다.</li></ul></li><li>공식적인 문법으로 작성하기 어렵게 만드는 문제가 있다..</li></ul><h3 id="2-3-HTML-DTD-문석-형식-정의-Document-Type-Definition"><a href="#2-3-HTML-DTD-문석-형식-정의-Document-Type-Definition" class="headerlink" title="2-3. HTML DTD (문석 형식 정의: Document Type Definition)"></a>2-3. HTML DTD (문석 형식 정의: Document Type Definition)</h3><ul><li><a href="https://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="noopener">DTD</a>는 문맥 자유 문법이 아니다.</li><li>HTML 정의는 DTD형식 안에 있다. (SGML 계역 언어의 정의를 이용한 것)</li><li><strong>HTML5, XHTML, HTML</strong>의 세가지 문서 유형이 존재하며, 기술한 유형에 따라 마크업 문서의 요소와 속성등을 처리하는 기준이 되며 유효성 검사에 이용된다.</li><li><strong>이전 버전의 HTML</strong>(HTML2~HTML4)은 SGML(Standard Generalized Markup Language)에 기반을 두어 만들어졌기 때문에 DTD 참조가 필요하며, 이 때문에 DOCTYPE 선언을 하려면 공개 식별자와 시스템 식별자가 포함된 긴 문자열을 작성해야 한다.</li><li><strong>HTML5</strong>에서는 SGML에 기반을 두지 않아서 DTD 참조가 필요 없으며, 최소한의 코드 작성이 기본 방향이라 매우 간단히 선언할 수 있다.</li></ul><h3 id="2-4-DOM-문서-객체-모델"><a href="#2-4-DOM-문서-객체-모델" class="headerlink" title="2-4. DOM (문서 객체 모델)"></a>2-4. DOM (문서 객체 모델)</h3><ul><li>파싱트리는 <strong>DOM요소</strong>와 <strong>속성 노드</strong>의 트리로서 출력 트리가 된다.</li><li>문서 객체 모델 : HTML문서의 객체 표현이다.</li><li>HTML요소의 연결지점. 즉, 트리의 최상위 객체는 문서이다.</li><li><a href="https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="noopener">HTML 정의</a></li><li><a href="https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="noopener">DOM 정의</a></li></ul><h3 id="2-5-파싱-알고리즘"><a href="#2-5-파싱-알고리즘" class="headerlink" title="2-5. 파싱 알고리즘"></a>2-5. 파싱 알고리즘</h3><p>HTML은 일반적인 하향식 혹은 상향식 파서로 파싱이 안된다.</p><ol><li>언어의 너그러운 속성</li><li>잘 알려져 잇는 HTML 오류에 대한 브라우저의 관용</li><li>변경에 의한 재파싱.<br>일반적으로 소스는 파싱하는 동안 변하지 않지만<br>HTML에서 <strong><code>document.write</code></strong>을 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 실제로는 입력 과정에서 파싱이 수정된다.</li></ol><blockquote><p>일반적인 파싱 기술을 사용할 수 없기 때문에 브라우저는 HTML 파싱을 위해 <strong>별도의 파서</strong>를 생성한다.</p></blockquote><hr><p>TL;DR</p><ul><li>바이트 → 문자 → 토큰 → 노드 → 객체 모델.</li><li>HTML 마크업은 DOM(Document Object Model)으로 변환되고, CSS 마크업은 CSSOM(CSS Object Model)으로 변환됩니다.</li><li>DOM 및 CSSOM은 서로 독립적인 데이터 구조입니다.</li><li>Chrome DevTools Timeline을 사용하면 DOM 및 CSSOM의 생성 및 처리 비용을 수집하고 점검할 수 있습니다.</li></ul><hr><p><a href="https://html.spec.whatwg.org/multipage/parsing.html" target="_blank" rel="noopener">알고리즘</a>은 토큰화와 트리구축 이렇게 2단계로 되어 있다.</p><ol><li><p>byte stream decoder</p><ul><li>브라우저가 HTML의 원시 바이트를 디스크나 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩(예: UTF-8)에 따라 개별 문자로 변환합니다.</li></ul></li><li><p>토큰화</p><ul><li>어휘 분석(lexical analysis)으로서 입력 값을 토큰으로 파싱한다.</li><li>HTML에서 토큰은 <strong>시작 태그, 종료 태그, 속성 이름</strong>과 <strong>속성 값</strong>이다.</li></ul></li><li><p>트리구축</p><ul><li>토큰을 인지해서 트리 생성자로 넘기고 =&gt; 다른 토큰을 확인하기 위해 다음 문자를 확인</li><li>이 과정을 반복</li></ul></li></ol><p>(HTML 파싱 과정그림)</p><p><img src="/images/2018/14/html_parse_algorithm.png"></p><p>아래가 더 세분화된 과정<br><img src="/images/2018/14/parsing-model-overview.svg" width="300px"></p><h4 id="2-5-1-토큰화-알고리즘"><a href="#2-5-1-토큰화-알고리즘" class="headerlink" title="2-5-1. 토큰화 알고리즘"></a>2-5-1. 토큰화 알고리즘</h4><ul><li>알고리즘의 결과물은 HTML 토큰</li><li>알고리즘은 상태기계라고 볼 수 있다.</li><li>각 상태는 하나 이상의 연속된 문자를 입력받아 이 문자에 따라 다음 상태를 갱신</li></ul><p>예시 &gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>0.초기상태 : 자료 상태</p><p><code>&lt;html&gt;</code> <code>&lt;body&gt;</code></p><ol><li>태그 열림 상태 : <code>&lt;</code> 문자를 만나면 변함</li><li>태그 이름 상태<br>: a부터 z까지의 문자를 만나면 <strong>시작 태그 토큰</strong>생성<br>: <code>&gt;</code>를 만날 때까지 유지한다.<br>: 각 문자에는 새로운 토큰 이름이 붙는다. 이때 생성된 토큰은 html 토큰</li><li>자료 상태 : <code>&gt;</code>문자에 도달하면 현재 토큰이 발행된다.</li></ol><p><code>Hello world</code></p><ol><li><strong>문자 토큰</strong> 생성 발행</li><li><code>&lt;</code>문자를 만날 때까지 진행</li></ol><p><code>&lt;/body&gt;</code> <code>&lt;/html&gt;</code></p><ol><li>태그 열림 상태</li><li>태그 이름 상태 : <code>/</code>문자는 <strong>종료 태그 토큰</strong> 생성</li><li>자료 상태 : <code>&gt;</code>문자에 도달하면 현재 토큰이 발행된다.</li></ol><p><img src="/images/2018/14/token_algorithm.png"></p><h4 id="2-5-2-트리-구축-알고리즘"><a href="#2-5-2-트리-구축-알고리즘" class="headerlink" title="2-5-2. 트리 구축 알고리즘"></a>2-5-2. 트리 구축 알고리즘</h4><ul><li>파서 생성 후 문서 객체 생성</li><li>트리 구축이 진행되는 동안, 문서 최상단에서는 DOM 트리가 수정되고 요소가 추가된다.</li><li>토큰화에 의해 발행된 각 <strong>노드</strong>는 트리 생성자에 의해 처리된다.</li><li>각 토큰을 위한 DOM 요소의 명세는 정의되어 있다.</li><li>DOM 트리에 요소를 추가하는 것이 아니라면 열린 요소는 스택(임시 버퍼 저장소)에 추가된다.</li><li>이 스택은 부정확한 중첩과 종료되지 않은 태그를 교정한다.</li><li>알고리즘은 상태 기계라고 설명할 수 있고 상태는 <strong>삽입 모드</strong> 라고 부른다.</li></ul><p>예시 &gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>트리 구축 단계의 입력 값은 토큰화 단계에서 만들어지는 일련의 토큰이다.</li><li>노드화</li></ul><ul><li>초기모드<br>: 받은 html토큰은 html이전 모드가 되면서 이 모드에서 처리된다.<br>: 이것은 <strong>HTMLHtmlElement 요소를 생성</strong>하고 문서 객체의 최상단에 추가된다.</li><li>head이전 모드<br>: “body” 토큰을 받았다.</li><li>head안쪽 모드<br>: “head” 토큰이 없더라도 <strong>HTMLHeadElement는 묵시적으로 생성</strong>되어 트리에 추가될 것이다.</li><li>head다음 모드<br>: body 토큰이 처리 되었고 (토큰화) <strong>HTMLBodyElement가 생성</strong>되어 추가됐으며 “body 안쪽” 모드가 되었다.</li><li>body안쪽 모드<br>: 문자토큰 받음(Hellow world)<br>: 첫 번째 토큰이 생성되고 “본문” 노드가 추가되면서 다른 문자들이 그 노드에 추가될 것이다.</li><li>body다음 모드<br>: body종료 토큰을 받으면</li><li>body다음 다음 모드<br>: html 종료 토큰을 받으면</li></ul><p><img src="/images/2018/14/tree_setting.png"></p><h3 id="2-8-파싱이-끝난-이후의-동작"><a href="#2-8-파싱이-끝난-이후의-동작" class="headerlink" title="2-8. 파싱이 끝난 이후의 동작"></a>2-8. 파싱이 끝난 이후의 동작</h3><ul><li>문서 파싱 이후에 실행되어야 하는 “지연” 모드 스크립트를 파싱하기 시작한다.</li><li>문서 상태는 “완료 complete”가 되고 <strong>load</strong>이벤트가 발생한다. 보다 자세한 내용은 <a href="http://www.w3.org/TR/html5/syntax.html" target="_blank" rel="noopener">HTML5의 토큰화 알고리즘과 트리 구축</a>에서 볼 수 있다.</li></ul><h3 id="2-9-브라우저의-오류-처리"><a href="#2-9-브라우저의-오류-처리" class="headerlink" title="2-9. 브라우저의 오류 처리"></a>2-9. 브라우저의 오류 처리</h3><p>HTML 페이지에서 “유효하지 않은 구문”이라는 오류는 볼 수 없는데,<br>이는 브라우저가 모든 오류 구문을 교정하기 때문이다.</p><p>파서는 토큰화된 입력 값을 파싱하여 문서를 만들고 문서 트리를 생성한다.<br>때문에 파서는 적어도 다음과 같은 오류를 처리해야한다.</p><ol><li>어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.</li><li>파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.</li><li>인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.</li><li>이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.</li></ol><p><strong>&lt; 웹킷의 오류 처리하는 예 &gt;</strong></p><h4 id="2-9-1-lt-br-gt-대신-lt-br-gt"><a href="#2-9-1-lt-br-gt-대신-lt-br-gt" class="headerlink" title="2-9-1. &lt;br&gt; 대신 &lt;/br&gt;"></a>2-9-1. <code>&lt;br&gt;</code> 대신 <code>&lt;/br&gt;</code></h4><ul><li>어떤 사이트는 <code>&lt;br&gt;</code> 대신 <code>&lt;/br&gt;</code>을 사용한다.</li><li>인터넷 익스플로러, 파이어폭스와 호환성을 갖기 위해 웹킷은 이것을 <code>&lt;br&gt;</code>으로 간주한다.</li></ul><h4 id="2-9-2-어긋난-표"><a href="#2-9-2-어긋난-표" class="headerlink" title="2-9-2. 어긋난 표"></a>2-9-2. 어긋난 표</h4><p>어긋난 표는 표 안에 또 다른 표가 th 또는 td 셀 내부에 있지 않은 것을 의미한다.<br>웹킷은 표의 중첩을 분해하여 형제 요소가 되도록 처리한다.</p><h4 id="2-9-3-중첩된-폼-요소"><a href="#2-9-3-중첩된-폼-요소" class="headerlink" title="2-9-3. 중첩된 폼 요소"></a>2-9-3. 중첩된 폼 요소</h4><p>폼 안에 또 다른 폼을 넣은 경우 안쪽의 폼은 무시된다.</p><h4 id="2-9-4-태그-중첩이-너무-깊을-때"><a href="#2-9-4-태그-중첩이-너무-깊을-때" class="headerlink" title="2-9-4. 태그 중첩이 너무 깊을 때"></a>2-9-4. 태그 중첩이 너무 깊을 때</h4><p>최대 20개의 중첩만 허용하고 나머지는 무시한다.</p><h4 id="2-9-5-잘못-닫힌-html-또는-body-태그"><a href="#2-9-5-잘못-닫힌-html-또는-body-태그" class="headerlink" title="2-9-5. 잘못 닫힌 html 또는 body 태그"></a>2-9-5. 잘못 닫힌 html 또는 body 태그</h4><p>깨진 html을 지원한다. 일부 바보 같은 페이지는 문서가 끝나기 전에 body를 닫아버리기 때문에 브라우저는 body 태그를 닫지 않는다. 대신 종료를 위해 end()를 호출한다.</p><hr><p>DOM 트리는 문서 마크업의 속성 및 관계를 포함하지만 요소가 렌더링될 때 어떻게 표시될지에 대해서는 알려주지 않습니다.<br>이것은 CSSOM의 역할.</p><h2 id="3-CSS-파싱"><a href="#3-CSS-파싱" class="headerlink" title="3. CSS 파싱"></a>3. CSS 파싱</h2><ul><li>문맥 자유 문법이다. 때문에 일반적인 파서 유형을 이용하여 파싱이 가능하다.</li><li><a href="http://www.google.com/url?q=http%3A%2F%2Fwww.w3.org%2FTR%2FCSS2%2Fgrammar.html&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGIh6GCKhnkvUO_VA0Mx4LlPaL6Og" target="_blank" rel="noopener">CSS 명세</a></li><li>어휘 문법은 각 토큰을 위한 정규 표현식으로 정의되어 있다.</li><li>구문 문법은 BNF로 설명되어 있다.</li></ul><h3 id="3-1-웹킷-CSS-파서"><a href="#3-1-웹킷-CSS-파서" class="headerlink" title="3-1. 웹킷 CSS 파서"></a>3-1. 웹킷 CSS 파서</h3><ul><li>웹킷은 자동으로 파서를 생성하기 위해 플렉스와 바이슨 파서 생성기를 사용한다.</li><li>웹킷의 바이슨을 사용하여 상향식 이동 감소 파서를 생성</li><li>파이어폭스 : 직접 작성한 하양식 파서를 사용한다.</li><li>모두 CSS 파일은 스타일 시트 객체로 파싱되고, CSS 규칙을 포함한다.</li></ul><p><img src="/images/2018/14/css_parsing.png"></p><h3 id="3-2-브라우저별-사용자-에이전트-스타일"><a href="#3-2-브라우저별-사용자-에이전트-스타일" class="headerlink" title="3-2. 브라우저별 사용자 에이전트 스타일"></a>3-2. 브라우저별 사용자 에이전트 스타일</h3><ul><li>위의 트리는 완전한 CSSOM 트리가 아니고 스타일시트에서 재정의하도록 결정한 스타일만 표시한다는 점에 유의</li><li>모든 브라우저는 ‘사용자 에이전트 스타일’이라고 하는 기본 스타일 집합, 즉 개발자가 고유한 스타일을 제공하지 않을 경우 표시되는 스타일을 제공합니다.</li><li>개발자가 작성하는 스타일은 이러한 기본 스타일(예: 기본 IE 스타일)을 간단하게 재정의합니다.</li></ul><hr><h2 id="4-스크립트와-스타일-시트의-진행-순서"><a href="#4-스크립트와-스타일-시트의-진행-순서" class="headerlink" title="4. 스크립트와 스타일 시트의 진행 순서"></a>4. 스크립트와 스타일 시트의 진행 순서</h2><h3 id="4-1-스크립트"><a href="#4-1-스크립트" class="headerlink" title="4-1. 스크립트"></a>4-1. 스크립트</h3><ul><li>웹은 파싱과 실행이 동시에 수행되는 동기화 모델이다.</li><li><code>&lt;script&gt;</code>태그를 만나서 실행되는 동안 문서의 파싱은 중단된다. (그래서 바디 전에 넣음)</li><li>스크립트가 외부에 있는 경우 우선 네트워크로부터 자원을 가져와야 하는데 이 또한 실시간으로 처리되고 자원을 받을 때까지 파싱은 중단된다.</li><li>스크립트를 “지연(defer)”으로 표시할 수 있는데 지연으로 표시하게 되면 문서 파싱은 중단되지 않고 문서 파싱이 완료된 이후에 스크립트가 실행된다. (비동기)</li></ul><h3 id="4-2-예측-파싱-Speculative-parsing"><a href="#4-2-예측-파싱-Speculative-parsing" class="headerlink" title="4-2. 예측 파싱 (Speculative parsing)"></a>4-2. 예측 파싱 (Speculative parsing)</h3><ul><li>스크립트를 실행하는 동안 다른 스레드는 네트워크로부터 다른 자원을 찾아 내려받고 문서의 나머지 부분을 파싱한다.</li><li>이런 방법은 자원을 병렬로 연결하여 받을 수 있고 전체적인 속도를 개선한다.</li><li>참고로 예측 파서는 DOM 트리를 수정하지 않고 메인 파서의 일로 넘긴다. 예측 파서는 외부 스크립트, 외부 스타일 시트와 외부 이미지와 같이 참조된 외부 자원을 파싱할 뿐이다.</li></ul><h3 id="4-3-스타일-시트"><a href="#4-3-스타일-시트" class="headerlink" title="4-3. 스타일 시트"></a>4-3. 스타일 시트</h3><ul><li>이론적으로 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단할 이유가 없다.</li><li>그러나 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하는 경우라면 문제가 된다.</li><li>스타일이 파싱되지 않은 상태라면 스크립트는 잘못된 결과를 내놓기 때문에 많은 문제를 야기한다.</li><li>파이어폭스는 아직 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단한다.</li><li>웹킷은 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때에만 스크립트를 중단한다.</li></ul><hr><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">https://d2.naver.com/helloworld/59361</a></li><li><a href="https://developers.google.com/web" target="_blank" rel="noopener">https://developers.google.com/web</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko</a></li><li>[WEBDIR] <a href="http://webdir.tistory.com/40" target="_blank" rel="noopener">http://webdir.tistory.com/40</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://d2.naver.com/helloworld/59361&lt;/a&gt; 를 읽
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Web" scheme="http://feel5ny.github.io/categories/TIL-9997/Web/"/>
    
    
      <category term="Web" scheme="http://feel5ny.github.io/tags/Web/"/>
    
      <category term="browser" scheme="http://feel5ny.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>브라우저와 렌더링 엔진</title>
    <link href="http://feel5ny.github.io/2018/05/29/rendering_engine_0/"/>
    <id>http://feel5ny.github.io/2018/05/29/rendering_engine_0/</id>
    <published>2018-05-29T12:20:19.000Z</published>
    <updated>2018-08-15T14:46:13.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">https://d2.naver.com/helloworld/59361</a> 를 읽고 정리했습니다.</p></blockquote><ol><li>브라우저의 주요 기능</li><li>브라우저의 기본 구조</li><li>렌더링 엔진</li></ol><hr><h2 id="1-브라우저의-주요-기능"><a href="#1-브라우저의-주요-기능" class="headerlink" title="1. 브라우저의 주요 기능"></a>1. 브라우저의 주요 기능</h2><ul><li>URI를 입력할 수 있는 주소 표시 줄</li><li>이전 버튼과 다음 버튼</li><li>북마크</li><li>새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼</li><li>홈 버튼</li></ul><h2 id="2-브라우저의-기본-구조"><a href="#2-브라우저의-기본-구조" class="headerlink" title="2. 브라우저의 기본 구조"></a>2. 브라우저의 기본 구조</h2><ol><li><p>사용자 인터페이스</p><ul><li>주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. </li><li>요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.</li></ul></li><li><p>브라우저 엔진</p><ul><li>사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.</li></ul></li><li><p>렌더링 엔진</p><ul><li>요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.</li></ul></li><li><p>통신</p><ul><li>HTTP 요청과 같은 네트워크 호출에 사용됨.</li><li>플랫폼 독립적인 인터페이스이고, 각 플랫폼 하부에서 실행됨.</li></ul></li><li><p>UI 백엔드</p><ul><li>콤보 박스와 창 같은 기본적인 장치를 그림. (콤보박스 : 드롭다운 목록과 텍스트 상자와 조합한 것)</li></ul></li><li><p>자바스크립트 해석기</p><ul><li>자바스크립트 코드를 해석하고 실행.</li></ul></li><li><p>자료 저장소</p><ul><li>이 부분은 자료를 저장하는 계층이다. </li><li>쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. </li><li>HTML5 명세에는 브라우저가 지원하는 ‘웹 데이터 베이스’가 정의되어 있다.</li></ul></li></ol><p><img src="/images/2018/13/browser_basic.png"></p><hr><h2 id="3-렌더링-엔진"><a href="#3-렌더링-엔진" class="headerlink" title="3. 렌더링 엔진"></a>3. 렌더링 엔진</h2><ul><li>요청 받은 내용을 브라우저 화면에 표시한다.</li><li><code>HTML</code> 및 <code>XML</code> 문서와 <code>이미지</code>를 표시할 수 있다.</li></ul><blockquote><p><strong>XML</strong><br>XML이란 문자 기반의 마크업 언어, HTML처럼 데이터를 보여주는 목적이 아닌, 데이터를 저장하고 전달할 목적으로 만들어졌음. XML태그는 HTML태그처럼 미리 정의되어 있지 안혹, 사용자가 직접 정의할 수 있다.</p></blockquote><h3 id="3-1-렌더링-엔진들"><a href="#3-1-렌더링-엔진들" class="headerlink" title="3-1. 렌더링 엔진들"></a>3-1. 렌더링 엔진들</h3><p>파이어복스, 크롬, 사파리는 두 종류의 렌더링 엔진으로 제작되어있다.</p><ul><li>파이어폭스 : 게코엔진</li><li>사파리 : 웹킷</li><li>크롬 : 블링크<br>(크로미움 프로젝트 공식 블로그는 웹킷에서 블링크로 넘어간 이유를 “웹킷이 여러 아키텍처를 지원하면서 웹킷과 크로미움 프로젝트의 복잡성이 증가했고, 이에 따라 집단 혁신 속도가 저하되었기 때문”이라고 밝혔다. <a href="http://huns.me/development/1478" target="_blank" rel="noopener">출처</a>)</li></ul><p><img src="/images/2018/13/rendering_engine.png"><br><img src="/images/2018/13/os_support.png"></p><p><a href="https://en.wikipedia.org/wiki/Comparison_of_browser_engines" target="_blank" rel="noopener">Comparison of browser engines</a></p><h3 id="3-2-동작-과정"><a href="#3-2-동작-과정" class="headerlink" title="3-2. 동작 과정"></a>3-2. 동작 과정</h3><p>렌더링 엔진은</p><div style="padding: 1em;background-color: lightyellow;">1. <a href="#html_parse">HTML 파싱</a> (for DOM트리 구축)<br>  2. <a href="#setting">렌더 트리 <strong>구축</strong></a><br>  3. <a href="#layout">렌더 트리 <strong>배치</strong></a><br>  4. <a href="#draw">렌더 트리 <strong>그리기</strong></a><br></div><ul><li>일련의 과정들이 동기적으로 진행되지 않는다. HTML을 파싱할 때까지 기다리지 않고 렌더 트리 배치와 그리기 과정을 시작한다.</li><li>렌더링 엔진에 따라서 동작과정이 약간 다르다.</li></ul><h4 id="3-2-1-웹킷"><a href="#3-2-1-웹킷" class="headerlink" title="3-2-1. 웹킷"></a>3-2-1. 웹킷</h4><p><img src="/images/2018/13/webkit_logo.png" width="300" style="margin:0;"><br><img src="/images/2018/13/webkit.png"></p><ul><li>렌더트리 (렌더객체로 구성)</li><li>렌더객체</li><li>배치(layout)라는 용어를 사용</li><li>attachment : 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 시각 정보를 연결하는 과정.</li></ul><h4 id="3-2-2-게코"><a href="#3-2-2-게코" class="headerlink" title="3-2-2. 게코"></a>3-2-2. 게코</h4><p><img src="/images/2018/13/gecko-logo.gif" width="100" style="margin:0;"><br><img src="/images/2018/13/gecko.png"></p><ul><li>형상트리(frame tree) : 시각적으로 처리되는 렌더 트리</li><li>형상(frame) : 형상</li><li>배치라는 뜻으로 리플로(<code>reflow</code>)라는 용어를 사용</li><li>콘텐츠 싱크 (content sink) : DOM 요소를 생성하는 공정</li></ul><hr><p>궁금</p><h3 id="1-URI와-URL의-차이점"><a href="#1-URI와-URL의-차이점" class="headerlink" title="1. URI와 URL의 차이점"></a>1. URI와 URL의 차이점</h3><p><strong>URL</strong></p><ul><li><strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator의 약자</li><li>인터넷 상의 자원 위치</li></ul><p><strong>URI</strong></p><ul><li><strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier의 약자</li><li>인터넷 상의 자원을 식별하기 위한 문자열의 구성</li><li>URI이 URL보다 상위개념</li></ul><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">https://d2.naver.com/helloworld/59361</a></li><li><a href="https://developers.google.com/web" target="_blank" rel="noopener">https://developers.google.com/web</a></li><li><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/" target="_blank" rel="noopener">https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://d2.naver.com/helloworld/59361&lt;/a&gt; 를 읽
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Web" scheme="http://feel5ny.github.io/categories/TIL-9997/Web/"/>
    
    
      <category term="Web" scheme="http://feel5ny.github.io/tags/Web/"/>
    
      <category term="browser" scheme="http://feel5ny.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>12/ File Api와 이미지 용량 줄이기</title>
    <link href="http://feel5ny.github.io/2018/05/27/JS_12/"/>
    <id>http://feel5ny.github.io/2018/05/27/JS_12/</id>
    <published>2018-05-27T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.110Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018/12/3.jpg"></p><p>오늘은 이미지 용량을 줄이는, (리사이징이 더 맞는 말이겠죠.) 방법에 대해서 알아보려고 합니다. 로컬에서 이미지 파일을 올리는 것부터 시작하죠. 이를 위해서는 HTML5관련 API 중 하나인 <strong>파일 API</strong>를 이용하고, 이미지 리사이징을 위해서 <strong>캔버스</strong>를 이용할 것입니다. 파일API를 다뤄보고 Blob에 대해서도 알아보죠..(Blob의 더 자세한 내용을 위해 포스팅을 따로 해야 할 것 같습니다.) ( + 제이커리 사용했습니다.)</p><p><img src="/images/2018/12/04.jpg"></p><p>보통 웹에서 글을 게시할 때 이미지를 첨부해야 하는 기능이 있죠. 이미지 업로드시 용량 축소가 기본적으로 들어가야 하고, 이는 프론트단에서 작업해주는게 보통입니다! 유저들이 보통 올리는 이미지는 스마트폰 사진이 일반적일 텐데, 요즘 스마트폰 카메라 성능이 좋아지면서 많게는 개당 8MB까지 나오는 경우도 있죠. 서버단에서 리사이징할 경우 비용이 아깝게 들기 때문에.. 클라이언트에서 이를 작업합니다. 전체 플로우는 이렇습니다.</p><ol><li>File API를 이용하여 이미지 파일 접근 (FileReader)</li><li>img 엘리먼트 생성, dataUrl 삽입</li><li>canvas 생성, img를 다시 리사이징하여 drawing</li><li>canvas의 dataURL를 이용하여 Blob 객체 생성</li><li>전송</li></ol><hr><h2 id="1-File-API-FileReader"><a href="#1-File-API-FileReader" class="headerlink" title="1. File API, FileReader"></a>1. File API, FileReader</h2><p>input의 <code>type=file</code>를 이용해서 이미지 파일에 접근, file 객체들을 files 컬렉션에 담습니다. 각 객체가 파일 하나를 나타냅니다.(Blob)<br>파일 객체에는 여러가지 읽기 전용 프로퍼티가 존재합니다.</p><ul><li>name: 로컬 시스템의 파일 이름</li><li>size: 바이트 단위인 파일 크기</li><li>type: 파일의 망미 타입을 나타내는 문자열 (ex_ “image/png”)</li><li>lastModifiedDate: 파일이 마지막으로 수정된 시점을 나타내는 문자열입니다. 이 프로퍼티는 크롬에만 구현되어있습니다.</li></ul><p><img src="/images/2018/12/01.png"></p><p>파일 API는 FileReader 타입을 통해 파일 데이터를 읽을 수 있습니다.</p><h3 id="1-1-FileReader-타입"><a href="#1-1-FileReader-타입" class="headerlink" title="1-1. FileReader 타입"></a>1-1. FileReader 타입</h3><p>FileReader 타입은 비동기적으로 파일을 읽는 메커니즘입니다. 서버에서 파일을 읽는 것이 아닌, 파일 시스템에서 파일을 읽는 것이라고 이해하자.<br>FileReader 타입에는 파일 데이터를 읽는 여러 가지 메서드가 존재합니다.</p><ul><li>readAsText(file, encoding) : 파일을 평범한 텍스트로 읽고 그 텍스트를 result 프로퍼티에 저장한다. 두 번째 매개변수는 옵션.</li><li>readAsDataURL(file) : 파일을 읽은 다음 이를 표현하는 데이터 URI를 result 프로퍼티에 저장.</li><li>readAsBinaryString(file) : 파일을 읽은 다음 각 문자가 1바이트를 나타내는 문자열을 result 프로퍼티에 저장.</li><li>readAsArrayBuffer(file) : 파일을 읽은 다음 파일 콘텐츠를 포함하는 ArrayBuffer를 result 프로퍼티에 저장.</li></ul><p>읽는 과정은 <strong>비동기</strong>적이므로 FileReader는 <strong>progress, error, load</strong> 이벤트를 일으킵니다.</p><ul><li>progress : 읽어올 데이터가 더 있을 때<ul><li>50밀리 초마다 발생, lengthComputable, loaded, total 같은 정보를 제공한다.</li><li><strong>loaded / total = 버퍼링</strong></li></ul></li><li>error : 에러 생겼을 때<ul><li><code>1</code> : 파일을 찾을 수 없음</li><li><code>2</code> : 보안 에러</li><li><code>3</code> : 읽기 거부</li><li><code>4</code> : 파일을 읽을 수 없음</li><li><code>5</code> : 인코딩 에러</li></ul></li><li>load : 파일을 완전히 읽었을 때</li></ul><p><strong>load 이후에는 readAsDataURL 메서드를 통해 result 프로퍼티에 데이터 URI가 저장되도록 해야 합니다.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html 🚀🚀 --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"upload-wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"upload"</span> <span class="attr">class</span>=<span class="string">"upload-label"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>✨UPLOAD IMAGE ✨<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"upload-imgBtn"</span> <span class="attr">src</span>=<span class="string">"https://uploads.codesandbox.io/uploads/user/1dcc6c5f-ac13-4c27-b2e3-32ade1d213e9/2Go1-photo.svg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- fileReader를 통해 읽은 파일을 넣는 부분 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image-preview"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">class</span>=<span class="string">"image-upload"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>input type=”file” 태그에 onchange 이벤트를 걸어둡니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> load_image = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> files = e.target.files;</span><br><span class="line">  <span class="keyword">const</span> filesArr = <span class="built_in">Array</span>.prototype.slice.call(files);</span><br><span class="line">  <span class="comment">// 여러장의 이미지를 불러올 경우, 배열화</span></span><br><span class="line"></span><br><span class="line">  filesArr.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 뭔가 썸팅 할 것을 넣습니다.</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsDataURL(file); ✨✨</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="string">".image-upload"</span>).on(<span class="string">"change"</span>, e =&gt; load_image(e));</span><br></pre></td></tr></table></figure><hr><h2 id="2-img-엘리먼트-생성-dataUrl-삽입"><a href="#2-img-엘리먼트-생성-dataUrl-삽입" class="headerlink" title="2. img 엘리먼트 생성, dataUrl 삽입"></a>2. img 엘리먼트 생성, dataUrl 삽입</h2><p>이미지는 용량에 따라 로드 속도가 다릅니다. 웹은 이미지에 대해서 비동기적으로 동작하는데 완전히 로드될 때까지 기다리지 않고 웹 페이지를 일단 표시한 후 <strong>이미지는 따로 읽습니다.</strong> 때문에 이미지를 읽은 직후 바로 출력하면 제대로 동작하지 않습니다. filereader를 통해서 파일을 읽은 이후 이미지 리사이징을 하려고 했지만, 이미지가 아직 로드되지 않았는데 리사이징하면 당연히 canvas의 이미지는 존재하지 않겠죠? </p><p>image가 읽혀진 후에 리사이징이 이루어지도록 하기 위해서 filereader와 마찬가지로 load 콜백 내부에 리사이징 함수를 넣어둘 것입니다.<br>load 이벤트를 사용하기 위해 Image 인스턴스를 생성합니다.<br>reader.onload의 콜백 내부에 image 인스턴스를 생성하고, image가 읽을 수 있는 형태가 되면 image.onload가 발생되도록 합니다. (자세한건 코드..!)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> load_image = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> files = e.target.files;</span><br><span class="line">  <span class="keyword">const</span> filesArr = <span class="built_in">Array</span>.prototype.slice.call(files);</span><br><span class="line">  <span class="comment">// 여러장의 이미지를 불러올 경우, 배열화</span></span><br><span class="line"></span><br><span class="line">  filesArr.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.className = <span class="string">"img-item"</span>; <span class="comment">// 스타일 적용을 위해</span></span><br><span class="line">        image.src = e.target.result;</span><br><span class="line">        image.onload = <span class="function"><span class="params">imageEvent</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 이미지가 로드가 되면! 리사이즈 함수가 실행되도록 합니다.</span></span><br><span class="line">          resize_image(image);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsDataURL(file); ✨✨</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="string">".image-upload"</span>).on(<span class="string">"change"</span>, e =&gt; load_image(e));</span><br></pre></td></tr></table></figure><hr><h2 id="3-canvas-생성-img를-다시-리사이징하여-drawing"><a href="#3-canvas-생성-img를-다시-리사이징하여-drawing" class="headerlink" title="3. canvas 생성, img를 다시 리사이징하여 drawing"></a>3. canvas 생성, img를 다시 리사이징하여 drawing</h2><p>resize_image 함수에 인자로 앞서 생성한 image 요소를 넘겨받게 했습니다.<br>리사이징을 위해서 캔버스 엘리먼트를 생성한 후, 캔버스에 2d 컨텍스트의 image를 리사이징된 폭과 높이로 그릴 것입니다.</p><ol><li>캔버스 엘리먼트를 생성.</li><li>해당 image의 높이와 폭을 측정한 후, </li><li>원하는 최대 사이즈의 크기보다 높이가 클 경우 리사이징할 비율을 폭에 곱하고, 반대의 경우 반대로 적용합니다. ( 폭이 클 경우 비율을 높에 곱한다. )</li><li>리사이징된 폭과 높이를 canvas의 높이와 폭이 할당한 후 </li><li>drawing 합니다. canvas의 drawImage() 사용합니다. 매개변수로는 이미지/ 원본의 x y 좌표 / 너비와 높이 / 컨텍스트의 x y 좌표 / 컨텍스트 너비/ 높이</li><li>canvas의 dataURL을 toDataURL 메서드를 이용하여 구합니다. toDataURL 메서드에 이미지 마임 타입을 매개변수로 전달하여 data URI를 받습니다.</li></ol><ul><li>getContext()는 브라우저 별로 지원 범위가 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resize_image = <span class="function"><span class="params">image</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>),</span><br><span class="line">    max_size = <span class="number">1280</span>,</span><br><span class="line">    <span class="comment">// 최대 기준을 1280으로 잡음.</span></span><br><span class="line">    width = image.width,</span><br><span class="line">    height = image.height;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (width &gt; height) &#123;</span><br><span class="line">    <span class="comment">// 가로가 길 경우</span></span><br><span class="line">    <span class="keyword">if</span> (width &gt; max_size) &#123;</span><br><span class="line">      height *= max_size / width;</span><br><span class="line">      width = max_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 세로가 길 경우</span></span><br><span class="line">    <span class="keyword">if</span> (height &gt; max_size) &#123;</span><br><span class="line">      width *= max_size / height;</span><br><span class="line">      height = max_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  canvas.width = width;</span><br><span class="line">  canvas.height = height;</span><br><span class="line">  canvas.getContext(<span class="string">"2d"</span>).drawImage(image, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">  <span class="keyword">const</span> dataUrl = canvas.toDataURL(<span class="string">"image/jpeg"</span>);</span><br><span class="line">  <span class="comment">// 미리보기 위해서 마크업 추가.</span></span><br><span class="line">  $(<span class="string">".image-preview"</span>).append(<span class="string">'&lt;img src="'</span> + dataUrl + <span class="string">'" class="img-item"&gt;'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="4-canvas의-dataURL를-이용하여-Blob-객체-생성"><a href="#4-canvas의-dataURL를-이용하여-Blob-객체-생성" class="headerlink" title="4. canvas의 dataURL를 이용하여 Blob 객체 생성"></a>4. canvas의 dataURL를 이용하여 Blob 객체 생성</h2><p>Data URIs는 네 가지 파트로 구성됩니다<br><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></p><ol><li>접두사(data:)</li><li>데이터의 타입을 가리키는 MIME 타입</li><li>텍스트가 아닌 경우 사용될 부가적인 base64 토큰 그리고 데이터 자체</li></ol><blockquote><p><strong>Base64</strong><br>바이너리 데이터를 문자 코드에 영향을 받지 않는 공통 ASCII 문자로 표현하기 위해 만들어진 인코딩이다. 네이버 지식iN 등의 URL에서 자주 볼 수 있는 형태의 바로 그것.<br>ASCII 문자 하나가 <strong>64진법의 숫자 하나를 의미</strong>하기 때문에 BASE64라는 이름을 가졌다.</p></blockquote><hr><blockquote><p><strong>Blob</strong><br>Blob은 일련의 데이터를 처리하거나 간접 참조하는 객체다. Blob이란 이름은 SQL 데이터베이스에서 유래하였으며 ‘대형 이진 객체(Binary Large Object)’를 의미한다. 자바스크립트에서 Blob은 흔히 이진 데이터를 나타내며 해당 데이터의 크기가 매우 클 수 있지만, 두 가지 특징 모두 강제된 사항은 아니다. 즉, 작은 텍스트 파일의 내용도 Blob으로 나타낼 수 있다. Blob은 대개 바이트의 크기를 알아내거나, 해당 MIME 타입이 무엇인지 요청하며, 데이터를 작은 Blob으로 잘게 나누는 등의 작업에 사용된다. <strong>즉, 데이터 자체라기보다는 데이터를 간접적으로 접근하기 위한 객체인 것이다.</strong></p><p><strong>Blob.size</strong><br>  Blob 객체에 포함된 데이터의 <strong>바이트</strong> 단위의 사이즈를 의미한다.<br><strong>Blob.type</strong><br>  Blob에 포함된 데이터의 MIME 타입을 의미한다. 만약 unknown으로 나올 경우, 이 문자열은 비어있는 것이다.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataURLToBlob = <span class="function"><span class="params">dataURL</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> BASE64_MARKER = <span class="string">";base64,"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// base64로 인코딩 되어있지 않을 경우</span></span><br><span class="line">  <span class="keyword">if</span> (dataURL.indexOf(BASE64_MARKER) === <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> parts = dataURL.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">const</span> contentType = parts[<span class="number">0</span>].split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> raw = parts[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([raw], &#123;</span><br><span class="line">      type: contentType</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// base64로 인코딩 된 이진데이터일 경우</span></span><br><span class="line">  <span class="keyword">const</span> parts = dataURL.split(BASE64_MARKER);</span><br><span class="line">  <span class="keyword">const</span> contentType = parts[<span class="number">0</span>].split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> raw = <span class="built_in">window</span>.atob(parts[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// atob()는 Base64를 디코딩하는 메서드</span></span><br><span class="line">  <span class="keyword">const</span> rawLength = raw.length;</span><br><span class="line">  <span class="comment">// 부호 없는 1byte 정수 배열을 생성 </span></span><br><span class="line">  <span class="keyword">const</span> uInt8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawLength); <span class="comment">// 길이만 지정된 배열</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; rawLength) &#123;</span><br><span class="line">    uInt8Array[i] = raw.charCodeAt(i);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([uInt8Array], &#123;</span><br><span class="line">    type: contentType</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/2018/12/02.png"></p><hr><h2 id="5-전송"><a href="#5-전송" class="headerlink" title="5. 전송"></a>5. 전송</h2><p>ajax로 보낼 경우 FormData 생성후 최종 생성한 Blob 객체를 추가하면 됩니다.</p><iframe src="https://codesandbox.io/embed/9jvp2o30zo" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://mohwa.github.io/blog/javascript/2015/08/31/binary-inJS/" target="_blank" rel="noopener">http://mohwa.github.io/blog/javascript/2015/08/31/binary-inJS/</a></li><li><a href="http://www.soen.kr/html5/html3/3-1-3.htm" target="_blank" rel="noopener">http://www.soen.kr/html5/html3/3-1-3.htm</a></li><li>프론트엔드개발자를 위한 자바스크립트 - File API</li><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Data_URIs</a></li><li><a href="https://namu.wiki/w/BASE64" target="_blank" rel="noopener">https://namu.wiki/w/BASE64</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/API/Blob" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/API/Blob</a></li><li><a href="https://firejune.com/1787/HTML5+ArrayBuffer+API+%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0" target="_blank" rel="noopener">https://firejune.com/1787/HTML5+ArrayBuffer+API+%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</a> (ArrayBuffer - 추후 더 공부하기)</li><li><a href="http://iamawebdeveloper.tistory.com/106" target="_blank" rel="noopener">http://iamawebdeveloper.tistory.com/106</a> [나는 웹개발자!]</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2018/12/3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘은 이미지 용량을 줄이는, (리사이징이 더 맞는 말이겠죠.) 방법에 대해서 알아보려고 합니다. 로컬에서 이미지 파일을 올리는 것부터 시작하죠. 이를 위해서는 HTML5관
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="File API" scheme="http://feel5ny.github.io/tags/File-API/"/>
    
      <category term="canvas" scheme="http://feel5ny.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>(mobile) device-pixel-ratio계산</title>
    <link href="http://feel5ny.github.io/2018/05/13/mediaQuery_01/"/>
    <id>http://feel5ny.github.io/2018/05/13/mediaQuery_01/</id>
    <published>2018-05-13T12:20:19.000Z</published>
    <updated>2018-08-15T14:45:16.665Z</updated>
    
    <content type="html"><![CDATA[<div style="padding: 0px 40px 20px 40px;background: #cbd3da22;margin-top:20px"><br><strong>목차</strong> &#128075;&#128075;<br><br>0. 서론<br>1. @media 대하여..<br>2. -webkit-device-pixel-ratio<br>  - 2-1. 픽셀비율 계산하기<br>  - 2-2. device width와 height 계산하기<br></div><hr><h2 id="0-서론"><a href="#0-서론" class="headerlink" title="0. 서론"></a>0. 서론</h2><p> 현재 작업 중인 프로젝트는 데스크탑 브라우저(여러 브라우저 대응) 뿐만아니라 모바일 기기 대응도 진행해야한다. 너무도 당연히 대응해야하지만!! 기기의 종류들의 크기가 다양해짐에 따라서 미디어쿼리를 적절히 사용해야할 필요가 생겼다.(아이폰X나 갤럭시S9같은.. 스크린이 긴 단말기ㅜ) 게다가 네이티브앱에서 웹뷰를 이용하는 일이 빈번했기 때문에 더더욱..</p><hr><h2 id="1-특정-모바일-디바이스-대응-media"><a href="#1-특정-모바일-디바이스-대응-media" class="headerlink" title="1. 특정 모바일 디바이스 대응 @media"></a>1. 특정 모바일 디바이스 대응 <code>@media</code></h2><p>CSS3의 @media 쿼리를 이용해서 screen의 크기에 따라서 레이아웃 구성을 다르게하는 방법을 구현할 수 있다. 반응형 웹에서는 다른 특별한 설정 없이 max-width같은 media features를 추가하여 브라우저의 width값마다 스타일을 조정할 수 있다. </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*syntax*/</span></span><br><span class="line">@<span class="keyword">media</span> not|only (media type) and (media feature) &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="media-type"><a href="#media-type" class="headerlink" title="media type"></a>media type</h3><ul><li><code>all</code> : 모든 디바이스에 적용</li><li><code>print</code> : printer에 사용</li><li><code>screen</code> : 컴퓨터 스크린, 태블릿, 스마트폰 등에 쓰임</li><li><code>speech</code> : 스크린 리더기에 사용, 스크린 내용을 읽어주는 미디어 일때</li></ul><h3 id="media-features-조건문"><a href="#media-features-조건문" class="headerlink" title="media features(조건문)"></a>media features(조건문)</h3><p>(정말 많군요! &#128064;)</p><ul><li><code>height, width</code> : 둘 다 해당, 둘 다 미디어에 따라 다른 값들이 검출 됨</li><li><code>width : 320px</code> : 미디어가 320px일때</li><li><code>max-width : 320px</code> : 320px 이하의 미디어 일 때</li><li><code>min-width : 320px</code> : 320px 이상의 미디어 일 때</li><li><code>device</code> : device의 물리적인 값들을 기준으로(해상도와 너비는 같지 않을 수 있다)</li><li><code>device-width : 320px</code> : 기기의 너비가 320px일때</li><li><code>max-device-width : 320px</code> : 320px 이하의 화면일 때</li><li><code>min-device-width : 320px</code> : 320px 이상의 화면일 때</li><li><code>orientation</code> :<br>화면 회전 width, height가 아닌 portrait, landscape값으로 구분한다.<br>대부분 세로로 긴 핸드폰의 형태이기 때문에 기본상태는 portrait, 가로로 돌렸을 때는 landscape.<br>데스크톱에는 가로 세로 개념이 없음. <strong>그렇다고 이 개념이 모바일 개념은 아니다.</strong></li></ul><hr><ul><li><code>aspect-ratio</code>, <code>min-aspect-ratio</code>, <code>max-aspect-ratio</code>(화면비율) : width/height (가로 나누기 세로)</li><li><code>aspect-ratio:1</code> : 화면 비율이 1:1인경우</li><li><code>aspect-ratio:16/9</code> : 일반적인 화면 비율인 16:9를 의미합니다(1920*1080)</li><li><code>device-aspect-ratio</code>, <code>min-device-aspect-ratio</code>, <code>max-device-aspect-ratio</code> : 단말기의 물리적인 화면 비율</li></ul><hr><ul><li><code>color</code>, <code>min-color</code>, <code>max-color</code> : 단말기에서 사용하는 최대 색상 비트 수에 대응(단위는 자연수)</li><li><code>color:3</code> : 2³ = 8개의 색상 사용</li><li><code>color-index</code>, <code>min-color-index</code>, <code>max-color-index</code> : 최대 색상 수에 대응</li></ul><hr><ul><li><code>monochrome</code>, <code>min-monochrome</code>, <code>max-monochrome</code> : 흑백만 사용하는 단말기에서의 픽셀당 비트수, 얼마나 자유롭게 표현되는지를 확인함</li><li><code>resolution</code>, <code>min-resolution</code>, <code>max-resolution</code> : 단말기의 해상도</li></ul><hr><ul><li><code>grid</code> : 단말기가 grid방식인지 bitmap방식인지</li><li><code>grid:1</code> ⇒ 문자로만 표기되는 tty, 주로 터미널, 전화액정</li><li><code>grid:0</code> ⇒ 대부분의 컴퓨터와 스마트폰 웹 브라우저에 해당</li></ul><hr><ul><li><code>-webkit-min-device-pixel-ratio</code> : 단말기의 화소와 실제 화면의 pixel간의 비율</li></ul><hr><hr><h2 id="2-webkit-device-pixel-ratio"><a href="#2-webkit-device-pixel-ratio" class="headerlink" title="2. -webkit-device-pixel-ratio"></a>2. -webkit-device-pixel-ratio</h2><p>사실 단말기에 따른 media query는 인터넷 서핑을 잘 하다보면 구할 수 있다.<br>(<a href="http://vizdevices.yesviz.com/" target="_blank" rel="noopener">여긴</a> 내가 좋아하는 정리 사이트)<br>나 또한 정리되어있는 자료에서 device width와 height, -webkit-min-device-pixel-ratio를 구할 수 있었다. 정리된 수치로 잘 사용하고 있었지만, 종종 서치하기 힘든 디바이스까지 대응해야할 경우도 생기곤 한다. 그리고 나에게도 그런 상황이 다가왔다!</p><h3 id="1-픽셀-비율을-계산해보자"><a href="#1-픽셀-비율을-계산해보자" class="headerlink" title="1. 픽셀 비율을 계산해보자."></a>1. 픽셀 비율을 계산해보자.</h3><p>내가 대응해야할 폰은 LG X400이라는 디바이스였다. 최근에 나온 기종이고, 내가 알 수 있는 정보는 아래 표밖에 없었다.<br><img src="/images/2018/11/image.png"></p><p><img style="border-radius: 6px;" src="/images/2018/11/image02.png"></p><h3 id="5-3인치-1280-720-294ppi"><a href="#5-3인치-1280-720-294ppi" class="headerlink" title="5.3인치 1280*720, 294ppi"></a><u style="background: #222222;color: white;padding: 10px 20px;"><strong>5.3인치 1280*720, 294ppi</strong></u></h3><p>@media only screen and<br>(<code>device-width: ?px</code>) and<br>(<code>device-height: ?px</code>) and<br>(<code>-webkit-device-pixel-ratio: ?</code>) {</p><p>위의 값들이 필요하다. 먼저 픽셀 비율부터 구해보자.<br>디바이스 픽셀 비율을 계산하는 데는 세 단계가 필요하다. </p><h4 id="1-1-들고있는-디바이스로부터-시야까지의-실제-거리와-레퍼런스-픽셀의-거리를-비교"><a href="#1-1-들고있는-디바이스로부터-시야까지의-실제-거리와-레퍼런스-픽셀의-거리를-비교" class="headerlink" title="1-1. 들고있는 디바이스로부터 시야까지의 실제 거리와 레퍼런스 픽셀의 거리를 비교."></a>1-1. 들고있는 디바이스로부터 시야까지의 실제 거리와 레퍼런스 픽셀의 거리를 비교.</h4><p>  스펙에 따르면 28인치에서 이상적인 것은 <strong>인치 당 96 픽셀</strong>이다.(표준밀도는 96ppi) 그러나 스마트 폰이기때문에 사람들은 노트북을 들고 다니는 것보다 디바이스를 얼굴에 가깝게 들고있는다. 그 거리를 18 인치로 추정 해본다.<br>  <img src="/images/2018/11/image01.png"></p><h4 id="1-2-주어진-거리에-대해-이상적인-픽셀-밀도를-얻으려면-거리-비에-표준-밀도-96ppi-를-곱한다"><a href="#1-2-주어진-거리에-대해-이상적인-픽셀-밀도를-얻으려면-거리-비에-표준-밀도-96ppi-를-곱한다" class="headerlink" title="1-2. 주어진 거리에 대해 이상적인 픽셀 밀도를 얻으려면 거리 비에 표준 밀도 (96ppi)를 곱한다."></a>1-2. 주어진 거리에 대해 이상적인 픽셀 밀도를 얻으려면 거리 비에 표준 밀도 (96ppi)를 곱한다.</h4><p>idealPixelDensity = (28/18) * 96 = 150 픽셀/인치 (대략) </p><h4 id="1-3-물리적-픽셀-밀도와-이상적인-픽셀-밀도의-비율을-사용하여-장치-픽셀-비율을-얻는다"><a href="#1-3-물리적-픽셀-밀도와-이상적인-픽셀-밀도의-비율을-사용하여-장치-픽셀-비율을-얻는다" class="headerlink" title="1-3. 물리적 픽셀 밀도와 이상적인 픽셀 밀도의 비율을 사용하여 장치 픽셀 비율을 얻는다."></a>1-3. 물리적 픽셀 밀도와 이상적인 픽셀 밀도의 비율을 사용하여 장치 픽셀 비율을 얻는다.</h4><p>devicePixelRatio = 294/150 = 1.96 =&gt; 반올림 =&gt; <strong>2</strong></p><hr><h3 id="2-device-width와-height"><a href="#2-device-width와-height" class="headerlink" title="2. device-width와 height"></a>2. device-width와 height</h3><p>현재 알 수 있었던 해상도는 표에서 1280*720 라고 알 수 있었다.<br>device의 너비와 height는 픽셀 비율을 해상도에서 나누면 된다.</p><ul><li><strong>device-width</strong> = 720/2 = 360</li><li><strong>device-height</strong> = 1280/2 = 640</li></ul><hr><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and</span><br><span class="line">(device-width: <span class="number">360px</span>) and</span><br><span class="line">(device-height: <span class="number">640px</span>) and</span><br><span class="line">(-webkit-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">  💅💅💅💅</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li>해당기기의 ppi와 해상도를 알고 있다면,<br>devicePixelRatio = 해당 기기의 ppi / 150 (왜 150인지는 위에 설명)<br>deviceWidth = 해당기기의 해상도 / devicePixelRatio</li><li>특정 기기 이외에는 min이나 max를 이용하여 정의하면 비슷한 해상도와 픽셀비율을 가진 디바이스에 적용가능하다. </li></ul><hr><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a href="https://medium.com/@junghan_61455/css-media-query-5969b004bd7" target="_blank" rel="noopener">https://medium.com/@junghan_61455/css-media-query-5969b004bd7</a><br><a href="https://www.html5rocks.com/en/mobile/high-dpi/" target="_blank" rel="noopener">https://www.html5rocks.com/en/mobile/high-dpi/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;padding: 0px 40px 20px 40px;background: #cbd3da22;margin-top:20px&quot;&gt;&lt;br&gt;&lt;strong&gt;목차&lt;/strong&gt; &amp;#128075;&amp;#128075;&lt;br&gt;&lt;br&gt;0. 서론&lt;br&gt;1.
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CSS" scheme="http://feel5ny.github.io/categories/TIL-9997/CSS/"/>
    
    
      <category term="css" scheme="http://feel5ny.github.io/tags/css/"/>
    
      <category term="media-query" scheme="http://feel5ny.github.io/tags/media-query/"/>
    
      <category term="mobile" scheme="http://feel5ny.github.io/tags/mobile/"/>
    
      <category term="log" scheme="http://feel5ny.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>(번역) Angular의 observable을 이해하고, 생성하고, 구독해보기</title>
    <link href="http://feel5ny.github.io/2018/03/25/angular_observable/"/>
    <id>http://feel5ny.github.io/2018/03/25/angular_observable/</id>
    <published>2018-03-25T01:23:55.000Z</published>
    <updated>2018-08-15T14:44:27.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>원문 : <a href="https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3" target="_blank" rel="noopener">https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3</a></p></blockquote><hr><p>엥귤러 version2가 나왔을때, 엥귤러는 <code>옵저버블</code>을 소개했다. 옵저버블은 엥귤러의 특정 기능은 아니고, ES7 릴리스에 포함될 비동기 데이터를 관리하기위한 새로운 표준이다. Angular는 이벤트 시스템과 HTTP 서비스에서 옵저버블을 광범위하게 사용한다. 옵저버블들을 이해하는 건 꽤 중요한 일일 수 있다. 그러므로 쉬운 방법으로 옵저버블을 설명하려고 왔다. </p><p><img src="/images/2018/09/observable (1).png"></p><h2 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h2><p>옵저버블은 시간이 지남에 따라 여러값을 가질 수 있는 느긋한 콜렉션이다.<br>옵저버블은 사실.. 꽤 쉽습니다.</p><h3 id="1-Observables는-느긋하다-차가운-옵저버블"><a href="#1-Observables는-느긋하다-차가운-옵저버블" class="headerlink" title="1. Observables는 느긋하다. (차가운 옵저버블)"></a>1. Observables는 느긋하다. (차가운 옵저버블)</h3><p>느긋한 옵저버블을 뉴스 레터로 생각할 수 있다. 각 구독자(subscriber)마다 새로운 뉴스 레터가 만들어진다. 그 뉴스레터들은 구독자들에게만 보내고 다른 사람에게는 보내지 않는다.</p><h3 id="2-Observables는-시간이-지남에-따라-여러-값을-가질-수-있다"><a href="#2-Observables는-시간이-지남에-따라-여러-값을-가질-수-있다" class="headerlink" title="2. Observables는 시간이 지남에 따라 여러 값을 가질 수 있다."></a>2. Observables는 시간이 지남에 따라 여러 값을 가질 수 있다.</h3><p>뉴스 레터 구독을 계속 열어두면, 매번 새로운 뉴스 레터를 받게된다. 발신자(sender)는 받은 시간을 결정하지만 받은 편지함에 곧바로 올 때까지 기다려야한다.</p><p>여러분이 <code>promise</code>의 세상에서 왔다면, 옵저버블과 프로미스간의 다른 중요한 차이점이 있는데, <code>promise</code>은 항상 오직 하나의 값만을 반환한다는 점이다. 또 하나는 옵저버블의 구독을 취소 할 수 있다는 점이다. 뉴스 레터를 더 이상 원하지 않으면 구독을 취소하면된다. 프로미스를 사용하면 이점이 다른건데, 프로미스는 취소 할 수 없다. 프라미스가 당신에게 건네지면, 그 프라미스의 resolve가 이미 진행되고 있으며, 일반적으로 프라미스의 resolve가 실행되는 것을 막을 수 있는 권한이 없다.</p><hr><h2 id="Push-vs-pull"><a href="#Push-vs-pull" class="headerlink" title="Push vs pull"></a>Push vs pull</h2><p>observables를 사용할 때 이해해야 할 핵심 사항은 observables가 push한다는 것이다. (옵저버블은 push 시나리오를 따른다는 말) push와 pull은 데이터 생성자가 데이터 소비자와 커뮤니케이션하는 방법을 설명하는 두 가지 방식이다.</p><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>Pulling일 때 데이터 소비자는 데이터 생성자로부터 데이터를 가져 오는 시점을 결정한다. 생산자는 언제 데이터가 소비자에게 전달되는지를 알지 못한다.<br>모든 자바 스크립트 함수는 pull 시나리오를 사용한다. 함수는 데이터의 프로듀서이며 함수를 호출하는 코드는, 호출에서 하나의 반환 값을 “꺼내”(pull) 가져와 이를 소비한다.</p><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>Pushing일 때, 다른 방향으로 동작한다. 데이터 생성자 (뉴스 레터 생성자)는 소비자 (뉴스 레터 구독자)가 데이터를 가져 오는 시점을 결정합니다.</p><p>프로미스는 오늘날 자바 스크립트에서 사용하는 가장 일반적인 push 방법입니다. 프로미스(생산자) 전달자는 등록된 콜백(소비자)에게 resolve된 값을 전달하고, 프로미스는 함수와는 달리 콜백에 그 값이 “푸시 (push)”되는 시기를 정확하게 결정한다.</p><p>Observables는 JavaScript로 데이터를 푸시하는 새로운 방법이다. 옵저버블은 여러 값의 생산자로서 구독자에게 “푸시 (pushing)”한다.</p><hr><h2 id="엥귤러에서-Observables"><a href="#엥귤러에서-Observables" class="headerlink" title="엥귤러에서 Observables"></a>엥귤러에서 Observables</h2><p>Angular를 사용하기 시작하면 아마도 HTTP 요청을 설정할 때 옵저버블을 만날 것이다. http 요청부분부터 시작해봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">"rxjs/Rx"</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span></span><br><span class="line"><span class="keyword">import</span> &#123; Http, Response &#125; <span class="keyword">from</span> <span class="string">"@angular/http"</span></span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        public http: Http</span><br><span class="line">    ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public fetchUsers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.http.get(<span class="string">"/api/users"</span>)</span><br><span class="line">            .map(<span class="function">(<span class="params">res: Response</span>) =&gt;</span> res.json())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 이제 observable을 반환하는 fetchUsers 메서드를 사용하여 간단한 HttpClient를 만들었다. 어떤 종류의 리스트에 사용자를 표시하고 싶으므로 fetchUsers 메서드를 사용해서 해보자. 이 메소드는 옵저버블을 반환하기 때문에 우리는 그것을 구독해야 한다. Angular에서 우리는 두 가지 방식으로 Observable을 구독 할 수 있다 :</p><h3 id="방식-1"><a href="#방식-1" class="headerlink" title="방식 1:"></a>방식 1:</h3><p>비동기 파이프를 사용하여 템플릿의 옵저버블을 구독하는 방법이 있다. 이로 인해 Angular는 컴포넌트의 생명주기 동안 구독을 처리한다. Angular는 자동으로 구독하고 구독취소한다. 비동기 파이프가 노출되야하므로 모듈에 “CommonModule”을 import하는 것을 잊지 마세요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">"rxjs/Rx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">"../services/client"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">import</span> &#123; IUser &#125; <span class="keyword">from</span> <span class="string">"../services/interfaces"</span></span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">"user-list"</span>,</span><br><span class="line">    templateUrl:  <span class="string">"./template.html"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public users$: Observable&lt;IUser[]&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        public client: HttpClient,</span><br><span class="line">    ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do a call to fetch the users on init of component</span></span><br><span class="line">    <span class="comment">// the fetchUsers method returns an observable</span></span><br><span class="line">    <span class="comment">// which we assign to the users$ property of our class</span></span><br><span class="line">    public ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.users$ = <span class="keyword">this</span>.client.fetchUsers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- We use the async pipe to automatically subscribe/unsubscribe to our observable --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"user__list"</span> *<span class="attr">ngIf</span>=<span class="string">"(users$ | async).length"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"user"</span> *<span class="attr">ngFor</span>=<span class="string">"let user of users$ | async"</span>&gt;</span></span><br><span class="line">        &#123;&#123; user.name &#125;&#125; - &#123;&#123; user.birth_date &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>달러 기호에 유의하세요. 옵저버블 변수 이름에 달러 기호를 사용하면 모범 사례로 간주된다. ($를 Stream의 약어로 쓴다.)이렇게하면 변수가 관찰 가능 여부를 쉽게 식별 할 수 있다.</p><hr><h3 id="방식-2"><a href="#방식-2" class="headerlink" title="방식 2:"></a>방식 2:</h3><p>우리는 실제 <code>subscribe()</code> 메소드를 사용하여 옵저버블을 구독한다. 데이터를 표시하기 전에 먼저 데이터에 뭔가 작업하기를 원한다면 편리할 수 ​​있다. 단점은 구독을 직접 관리해야한다는 것다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">"../services/client"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">import</span> &#123; IUser &#125; <span class="keyword">from</span> <span class="string">"../services/interfaces"</span></span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">"user-list"</span>,</span><br><span class="line">    templateUrl:  <span class="string">"./template.html"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public users: IUser[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        public client: HttpClient,</span><br><span class="line">    ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do a call to fetch the users on init of component</span></span><br><span class="line">    <span class="comment">// we manually subscribe to this method and take the users</span></span><br><span class="line">    <span class="comment">// in our callback</span></span><br><span class="line">    public ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.client.fetchUsers().subscribe(<span class="function">(<span class="params">users: IUser[]</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do stuff with our data here.</span></span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            <span class="comment">// asign data to our class property in the end</span></span><br><span class="line">            <span class="comment">// so it will be available to our template</span></span><br><span class="line">            <span class="keyword">this</span>.users = users</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"user__list"</span> *<span class="attr">ngIf</span>=<span class="string">"users.length"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"user"</span> *<span class="attr">ngFor</span>=<span class="string">"let user of users"</span>&gt;</span></span><br><span class="line">        &#123;&#123; user.name &#125;&#125; - &#123;&#123; user.birth_date &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>템플릿 로직이 꽤 비슷하다는 것을 알 수 있듯이, 당신이 2번 방식으로 간다면 구성 요소 논리는 훨씬 더 복잡해 질 수 있다. 일반적으로 나는 방식1을 선택하는 것이 좋다. 가장 쉽고 구독을 수동으로 관리할 필요가 없다. <code>2번방법에서 구독을 사용하지 않는 동안 열어두면 메모리 누수가 발생하므로 좋지 않다.</code></p><hr><h2 id="Creating-an-observable-yourself"><a href="#Creating-an-observable-yourself" class="headerlink" title="Creating an observable yourself"></a>Creating an observable yourself</h2><p>Angular가 제공한 일반적인 옵저버블을 다루는 방법을 알았으므로 옵저버블을 어떻게 생성하는지 알고있는 것이 좋다. 가장 간단한 버전은 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">"rxjs/Observable"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create observable</span></span><br><span class="line"><span class="keyword">const</span> simpleObservable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// observable execution</span></span><br><span class="line">    observer.next(<span class="string">"bla bla bla"</span>)</span><br><span class="line">    observer.complete()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe to the observable</span></span><br><span class="line">simpleObservable.subscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispose the observable</span></span><br><span class="line">simpleObservable.unsubscribe()</span><br></pre></td></tr></table></figure><p>예제에서 볼 수 있듯이 observables는 새로운 Observable() 호출을 사용하여 만든 다음 observer에 가입하고 next()를 호출하여 실행하고 unsubscribe()를 호출하여 삭제한다.</p><h3 id="observable-만들기"><a href="#observable-만들기" class="headerlink" title="observable 만들기"></a>observable 만들기</h3><p>observables를 만드는 것은 쉽다. 새로운 Observable()을 호출하고 옵저버를 나타내는 하나의 인수를 전달하면됩니다. 그러므로 저는 보통 그것을 “observer”라고 부릅니다.</p><h3 id="옵저버블-구독하기"><a href="#옵저버블-구독하기" class="headerlink" title="옵저버블 구독하기"></a>옵저버블 구독하기</h3><p>옵저버블은 느긋하다는걸 기억하세요. 구독하지 않으면 아무 일도 일어나지 않을 것이다. 옵저버를 구독 할 때 subscribe()를 호출 할 때마다 옵저버블에 독립 설정이 실행된다는 사실을 알면 좋다. 구독 요청은 동일한 옵저버블에 대한 여러 구독자간에 공유되지 않는다.</p><h3 id="옵저버블-실행하기"><a href="#옵저버블-실행하기" class="headerlink" title="옵저버블 실행하기 **"></a>옵저버블 실행하기 **</h3><p>observables 안의 코드는 observables의 실행을 나타낸다. 옵저버블을 만들 때 주어진 매개 변수(observer)에는 <code>옵저버블의 구독자에게 데이터를 보낼 수있는 세 가지 함수가 있다.</code></p><ul><li><code>next</code>: Number나 Array나 객체같은 여러 값을 subscribers에게 보낸다.</li><li><code>error</code>: 자바스크립트 에러나 예외값을 보낸다.</li><li><code>complete</code> : 어떤 값도 보내지 않는다.</li></ul><p><strong><code>next</code> 콜은 구독자에게 실제로 데이터를 전달할 때 가장 일반적이다.</strong> 옵저버블의 실행 중에는 <code>observer.next()</code>의 무한 호출이있을 수 있지만 <code>observer.error()</code> 또는 <code>observer.complete()</code>가 호출되면 실행이 중지되고 더 이상 데이터가 subscribers에게 전달되지 않는다.</p><h3 id="옵저버블-처분"><a href="#옵저버블-처분" class="headerlink" title="옵저버블 처분"></a>옵저버블 처분</h3><p>옵저버블의실행은 무한한 시간 동안 실행될 수 있기 때문에, 실행을 막을 수있는 방법이 필요하다. 각 구독자마다 각 실행이 실행되기 때문에, 메모리와 컴퓨팅 성능이 낭비, 즉 더 이상 데이터가 필요없는 구독자는 구독을 멈추는 것이 중요하다.!</p><p>옵저버블을 구독할 때, 진행중인 실행을 취소하면 구독이 반환된다. 실행을 취소하려면 <code>unsubscribe()</code>를 호출하면 됨.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이 게시물을 통해 옵저버블이 실제로 어떻게 작동하는지 더 잘 이해할 수 있다. 다음 시간에 옵저버블에 대해서 더 많이 얻기 위해서 Rxjs의 파워를 이해하는 것과 그들이 제공하는 모든 헬퍼 함수를 이해하는 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;원문 : &lt;a href=&quot;https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3&quot; 
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="angular" scheme="http://feel5ny.github.io/tags/angular/"/>
    
      <category term="prettier" scheme="http://feel5ny.github.io/tags/prettier/"/>
    
      <category term="formatter" scheme="http://feel5ny.github.io/tags/formatter/"/>
    
  </entry>
  
  <entry>
    <title>Angular 프로젝트에 prettier 코드포매터 세팅하기</title>
    <link href="http://feel5ny.github.io/2018/03/11/angular_prettier/"/>
    <id>http://feel5ny.github.io/2018/03/11/angular_prettier/</id>
    <published>2018-03-11T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:28.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>개인의 경험을 바탕으로 적은 글이기에 피드백은 언제나 댓글로 환영합니다. :)</p></blockquote><hr><p><strong>목차</strong></p><ol><li><p>모듈 세팅</p><ul><li>프리티어 설치하기<ul><li>에디터에만 세팅하기</li><li>프로젝트에 세팅하기</li></ul></li><li>프리티어 옵션 값</li></ul></li><li><p>precommit, 커밋 전 옵션에 맞춰 재포맷 하는 hook 추가.</p><ul><li>lint stage</li><li>husky</li></ul></li></ol><hr><p>한 프로젝트에 프론트엔드 개발자가 여러 명일 경우 각자의 코드 스타일이 다르기 때문에 <strong>통일성</strong>을 위해 코드 포메터를 사용하면 코드를 깔끔하게 공유할 수 있다. 현재 진행 중인 angular 프로젝트에 react 프로젝트에서 사용했었던 <strong>Prettier</strong>라는 포매터를 사용하기로 결정했다. 초반에 어떻게 세팅할지만 논의하면 된다.</p><p>프리티어를 엥귤러 프로젝트에 적용하면서 겪었던 부분을 글로 공유하고자 한다.<br>참고로 에디터는 <code>vscode</code>를 사용하고 있다.</p><p><img src="/images/2018/08/prettier.gif"></p><hr><h2 id="1-모듈-세팅"><a href="#1-모듈-세팅" class="headerlink" title="1. 모듈 세팅"></a>1. 모듈 세팅</h2><p>angular cli 로 프로젝트를 생성하면 기본 구조가 세팅이 되는데, 엥귤러는 타입스크립트가 주력 언어이므로 타입스크립트를 위한 tslint.json 파일과 tsconfig.json 파일이 함께 세팅된다.<br><code>tslint.json</code> 파일은 tslint 가 사용하는 linting(구문 체크) 설정 파일이다. tslint 란 An extensible linter for the TypeScript language. 즉 타입스크립트 린터이다!<br><img src="/images/2018/08/05.png" align="right" width="250px" style="margin-left: 10px;"><br>vscode 에서는 tslint 확장 프로그램을 설치하면 구문과 다른 곳을 빨간 줄로 표시해준다.<br><code>tsconfig.json</code>파일은 타입스크립트 컴파일 옵션 설정 파일이다.</p><h4 id="우리는-tslint의-옵션-포맷에-Prettier의-커스텀-옵션을-추가하기로-결정하였다"><a href="#우리는-tslint의-옵션-포맷에-Prettier의-커스텀-옵션을-추가하기로-결정하였다" class="headerlink" title="우리는 tslint의 옵션 포맷에 + Prettier의 커스텀 옵션을 추가하기로 결정하였다."></a>우리는 <strong>tslint</strong>의 옵션 포맷에 + <strong>Prettier</strong>의 커스텀 옵션을 추가하기로 결정하였다.</h4><hr><h3 id="1-1-프리티어-설치하기"><a href="#1-1-프리티어-설치하기" class="headerlink" title="1-1. 프리티어 설치하기"></a>1-1. 프리티어 설치하기</h3><p><img src="/images/2018/08/03.png"></p><p><strong>* 에디터에만 적용하기</strong><br>프리티어 <code>패키지</code>를 설치하는 방법과 <code>플러그인</code>으로 세팅하는 방법이 있다.<br>개인적으로만 사용하거나 다른 개발자들이 모두 vscode 를 사용한다면 프리티어 플러그인을 설치하고 workspace settings 에만 설정해도 프리티어 세팅은 완료된다.<br><code>Code &gt; Preference &gt; Settings &gt; Workspace Settings</code></p><p><img src="/images/2018/08/01.png" width="250px" align="left" style="margin-bottom:10px"><br><img src="/images/2018/08/02.png"><br>위처럼 폴더가 생성된다. 폴더를 팀원들과 공유해도 괜찮고, 혹은 아래 옵션 객체만 팀 내의 docs에 공유해도 괜찮다. (나중에 들어올 팀원이 vscode를 쓴다는 전제가 있어야..ㅎ)</p><hr><p><strong>* 프로젝트에 적용하기</strong><br>패키지 매니저로 프리티어를 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prettier -D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;prettier.printWidth&quot;: 80,</span><br><span class="line">  &quot;prettier.useTabs&quot;: false,</span><br><span class="line">  &quot;prettier.tabWidth&quot;: 2,</span><br><span class="line">  &quot;prettier.bracketSpacing&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프리티어 옵션은 여러 가지 방식으로 세팅이 가능하다. rc 파일을 따로 만들어서 관리할 수도 있고, json 파일로 만들어서 관리를 할 수 있다. 우리 프로젝트에서는 package.json 파일에 포함시키기로 했다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">    "typescript": "~2.4.2"</span><br><span class="line">  &#125;,</span><br><span class="line">  "prettier": &#123;</span><br><span class="line">    "printWidth": 80,</span><br><span class="line">    "useTabs": false,</span><br><span class="line">    "tabWidth": 2,</span><br><span class="line">    "bracketSpacing": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode 세팅에서 <code>&quot;editor.formatOnSave&quot;: true</code>를 설정하면 저장하는 것과 동시에 프리티어가 적용된다.</p><hr><h3 id="1-2-프리티어-옵션-값"><a href="#1-2-프리티어-옵션-값" class="headerlink" title="1-2. 프리티어 옵션 값"></a>1-2. 프리티어 옵션 값</h3><p>프리티어에는 여러 가지 기본 옵션 값들이 있다. <a href="https://prettier.io/docs/en/options.html" target="_blank" rel="noopener">Prettier</a> 자세한 내용은 홈페이지에서 확인 가능하다.</p><ol><li>Print Width<ul><li>한 줄에서 wrap 이 되는 기준의 글자 수를 정한다.</li><li>default <code>80</code></li></ul></li><li>Tab Width<ul><li>탭의 스페이스 사이즈</li><li>default <code>2</code></li></ul></li><li>Tabs<ul><li>탭을 쓸 건지 안 쓸 건지</li><li>boolean</li></ul></li><li>Semicolons<ul><li>문장 마지막에 세미콜론을 붙일지 안 붙일지</li><li>boolean</li></ul></li><li>Quotes<ul><li>true 이면 single quate</li></ul></li><li>Trailing Commas<ul><li>마지막에 콤마 붙이기</li><li>none / es5 / all</li></ul></li><li>Bracket Spacing</li><li>JSX Brackets</li><li>Arrow Function Parentheses</li><li>Range</li><li>Parser</li><li>FilePath</li><li>Require pragma</li><li>Insert Pragma</li><li>Prose Wrap</li></ol><p>우리의 프로젝트에서는 아래의 옵션을 세팅했다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"printWidth"</span>: <span class="number">80</span>,</span><br><span class="line">  <span class="attr">"useTabs"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"tabWidth"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"bracketSpacing"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printWidth 를 120 으로 하기도 하던데, 그건 취향껏! (에어비엔비는 80)</p><hr><h2 id="2-precommit-커밋-전-재포맷-하는-hook-추가"><a href="#2-precommit-커밋-전-재포맷-하는-hook-추가" class="headerlink" title="2. precommit, 커밋 전 재포맷 하는 hook 추가."></a>2. precommit, 커밋 전 재포맷 하는 hook 추가.</h2><p>개발자마다 쓰는 에디터가 다르고, 각자가 각자 에디터에 세팅하는 부분에서 나올 수 있는 에러들을 방지하기 위해 프로젝트 자체에 세팅한 후 커밋 할 때마다 세팅하는 방법이 있다.<br>pre-commit 툴과 함께 사용하면 되는데 많이들 사용하는 <code>husky</code>와 <code>lint-staged</code> 모듈을 사용하면 된다.</p><p>프리커밋 툴을 사용하면 git add 을 입력할 때 (<code>husky</code> : hook) 린트 옵션에 맞춰서 재포맷을(<code>lint-staged</code> : 재포맷) 시켜준다. 이때 옵션에 tslint 옵션도 재포맷 설정에 넣어줄 수 있으므로 git add 명령어 만으로 tslint 와 prettier 의 옵션들을 적용시킬 수 있다.</p><p><img src="/images/2018/08/04.png"></p><hr><p><strong>모듈 설치</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev lint-staged husky</span><br></pre></td></tr></table></figure><ol><li>package.json 에 precommit 스크립트를 추가하고</li><li>lint-staged 옵션을 추가하면 된다.<br>이때 prettier 를 읽는 스크립트와<br>tslint 를 검사하고 fix 하는 스크립트를 추가한다.</li></ol><p><code>tslint --fix -c tslint.json -p tsconfig.json</code><br>c 는 config 의 약어. tslint.json 파일의 옵션들을 확인하고 규칙에 맞춰서 fix 한다.<br>p 는 project 의 약어. tsconfig.json 파일에 적힌 파일 경로에서 린트될 파일을 찾는다.</p><hr><p><strong>package.json</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    "precommit": "lint-staged"</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">    "lint-staged": &#123;</span><br><span class="line">        "*.&#123;ts,tsx&#125;": [</span><br><span class="line">        "prettier --write",</span><br><span class="line">        "tslint --fix -c tslint.json -p tsconfig.json",</span><br><span class="line">        <span class="string">"git add"</span></span><br><span class="line">        ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Reference</p><ul><li><a href="https://medium.com/@victormejia/setting-up-prettier-in-an-angular-cli-project-2f50c3b9a537" target="_blank" rel="noopener">Setting up Prettier in an Angular CLI Project</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;개인의 경험을 바탕으로 적은 글이기에 피드백은 언제나 댓글로 환영합니다. :)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;모듈 세팅&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="angular" scheme="http://feel5ny.github.io/tags/angular/"/>
    
      <category term="prettier" scheme="http://feel5ny.github.io/tags/prettier/"/>
    
      <category term="formatter" scheme="http://feel5ny.github.io/tags/formatter/"/>
    
  </entry>
  
  <entry>
    <title>Airbnb - lottie - bodymovin 웹에서 사용해보기</title>
    <link href="http://feel5ny.github.io/2018/02/25/interaction_01/"/>
    <id>http://feel5ny.github.io/2018/02/25/interaction_01/</id>
    <published>2018-02-25T12:20:19.000Z</published>
    <updated>2018-02-25T16:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>airbnb 앱을 쓰다보면 곳곳에서 다양한 애니메이션을 볼 수 있다. 한 서비스에 애니메이션이 있으면 있을수록 자연스러운 사용성 유도, 사용자의 감성에도 메세지를 전할 수 있고, 서비스의 브랜드가 더 기억에 오래남고 강해진다고 생각한다. </p><p>모션을 좋아하는 성향과 모션이 줄 수 있는 위의 특징때문에 곳곳에 모션을 넣는 것을 좋아하는데, 그러던 중 airbnb의 <code>lottie</code> 서비스가 눈에 들어왔다. 예전부터 테스트만해보고 넣어보는 것을 시도했었는데, react-native로 앱을 만드는 부분에 로딩애니메이션으로도 넣어보았지만 아직 웹에서는 넣어보지 않아서 이번 기회에 해당 블로그 header의 아바타에 움직임을 넣어보았다.<br>(최근 <a href="https://ant.design/" target="_blank" rel="noopener">antd</a>의 메인에서도 쓴걸 확인!)</p><p><img src="/images/2018/07/logo-ny_1.gif" width="300px"></p><p><strong>장단점</strong></p><ul><li>작업을 다하고 든 생각은.. gif보다 경량화시킬 수 있을거라는 생각을 했지만, gif보다 3배나 파일이 컸다.</li><li>대신 svg로 이미지가 들어가기 때문에 벡터상태로 선명하게 들어간다. gif는 움직이는대신 화질이 떨어지는 단점이 있는데 이를 보안한다는 점에서 굉장한 장점.</li><li>after effect를 좀 다뤄야한다는 .. 진입장벽이 있다. </li></ul><p><strong>간단 작업 순서</strong></p><ol><li><a href="https://www.adobe.com/kr/products/aftereffects.html" target="_blank" rel="noopener">after effect</a>로 작업하기</li><li>after effect에 bodymovin 플러그인 설치</li><li>작업 후 최종 렌더링할 컴포넌트 =&gt; bodymovin 플러그인을 사용하여 렌더링<ul><li>렌더링 옵션이 여러개가 있다. 본인의 프로젝트에 맞춰서 렌더링하면 됨.</li></ul></li><li>렌더링 이후 export된 json파일, js파일을 html에 잘 임포트를 시키면 끝!</li></ol><hr><h1 id="1-after-effect로-작업하기"><a href="#1-after-effect로-작업하기" class="headerlink" title="1. after effect로 작업하기"></a>1. after effect로 작업하기</h1><p>shape animation이나 여러가지 모션그래픽은 에프터이펙트로 작업합니다. bodymovin 플러그인을 사용하기 위해서는 after effect로 작업된 파일이 필요합니다.</p><p><img src="/images/2018/07/01.png"></p><p><strong>작업할 때 알아야할 점 (버그)</strong></p><ul><li>레이어 그룹해제 : 일러스트레이터를 임포트할 때 해당 레이어 내부에 group되어있는 부분을 전부 단일 레이어로 만들어야합니다. (그룹이 모두 해제되어있는 상태여야함)</li><li>마스크는 레이어당 하나만 : 하나의 shape 레이어에서 마스크를 동시에 2개를 사용시 둘중 하나만 인식이 됩니다. (아직 로티의 버그인 듯) 로티에서 해결해줄때까지 ㅠ 우선은 마스크를 한 레이어당 하나만 사용하면서 모션을 잡으셔야합니다.</li><li>너무 많은 레이어와 긴 시간의 모션은 스크립트도 용량이 크게 나옵니다. 웬만하면 loop되는 애니메이션으로 작업하셔야 합니다.</li></ul><h1 id="2-after-effect에-bodymovin-플러그인-설치"><a href="#2-after-effect에-bodymovin-플러그인-설치" class="headerlink" title="2. after effect에 bodymovin 플러그인 설치"></a>2. after effect에 bodymovin 플러그인 설치</h1><p>bodymovin이라는 플러그인을 설치하고 해당 플러그인을 사용하여 렌더링 해야합니다.</p><p><strong>설치방법</strong></p><ol><li>에펙이 실행되고 있다면 닫으십시오.</li><li>ZXP installer를 설치해야합니다. <a href="http://aescripts.com/learn/zxp-installer/" target="_blank" rel="noopener">설치경로</a></li><li>bodymovin 확장프로그램을 설치합니다. 다운로드를 클릭하여 다운받으세요. <a href="https://github.com/airbnb/lottie-web/tree/master/build/extension" target="_blank" rel="noopener">설치경로</a></li><li>ZXP installer를 실행시킨후 3번에서 다운받은 bodymovin.zxp을 드래그하여 ZXP installer에 넣습니다. (에펙에 플러그인 설치완료)</li><li>에펙을 오픈한 후 “Window &gt; Extensions”를 보시면 “Bodymovin”가 있는걸 확인할 수 있습니다.</li></ol><p>참고 &gt; <a href="http://airbnb.io/lottie/after-effects/bodymovin-installation.html" target="_blank" rel="noopener">http://airbnb.io/lottie/after-effects/bodymovin-installation.html</a></p><h1 id="3-bodymovin으로-렌더링하기"><a href="#3-bodymovin으로-렌더링하기" class="headerlink" title="3. bodymovin으로 렌더링하기"></a>3. bodymovin으로 렌더링하기</h1><div class="video-container"><iframe src="//www.youtube.com/embed/5XMUJdjI0L8" frameborder="0" allowfullscreen></iframe></div><blockquote><p>위의 방법대로 진행하면 오케이!</p></blockquote><p><img src="/images/2018/07/03.png"><br>에펙에서 “Window &gt; Extensions”의 “Bodymovin”를 오픈하면 위의 그림처럼 창이 하나 오픈됩니다. 우리가 필요한 파일은 <code>json</code>파일과 <code>js</code>파일입니다.</p><h2 id="3-1-json파일로-렌더링하기"><a href="#3-1-json파일로-렌더링하기" class="headerlink" title="3-1. json파일로 렌더링하기"></a>3-1. json파일로 렌더링하기</h2><ol><li><p>렌더링할 컴포넌트를 선택합니다.<br><img src="/images/2018/07/04-1.png"></p></li><li><p>어떤 포맷으로 렌더링할지 settings에서 선택해야합니다.<br><img src="/images/2018/07/04.png"></p></li><li><p>옵션은 여러가지가 있는데, 다중선택이 가능합니다.<br><img src="/images/2018/07/05.png"></p></li><li><p>셋팅이 완료되면 경로를 지정합니다. =&gt; 어떤 포맷으로 렌덜이되는지 확인할 수 있습니다.<br><img src="/images/2018/07/04-3.png"></p></li><li><p>위의 렌더링버튼을 누르시면 렌더링 시작.<br><img src="/images/2018/07/04-4.png"></p></li></ol><h2 id="3-2-js파일로-렌더링하기"><a href="#3-2-js파일로-렌더링하기" class="headerlink" title="3-2. js파일로 렌더링하기"></a>3-2. js파일로 렌더링하기</h2><ol><li><p>오른쪽 상단의 get the player를 선택합니다.<br><img src="/images/2018/07/04-2.png"></p></li><li><p>왼쪽의 get the player를 누르면 js파일을 받을 수 있습니다.<br><img src="/images/2018/07/06.png"></p></li></ol><h1 id="4-렌더링-이후-export된-파일-프로젝트에-import시키기"><a href="#4-렌더링-이후-export된-파일-프로젝트에-import시키기" class="headerlink" title="4. 렌더링 이후 export된 파일 프로젝트에 import시키기"></a>4. 렌더링 이후 export된 파일 프로젝트에 import시키기</h1><p>hexo블로그에 셋팅할 경우 파일은 아래 경로로 옮깁니다.<br><code>themes &gt; hueman &gt; source &gt; js</code></p><p><img src="/images/2018/07/02.png" width="200px" style="margin: 0;"></p><p><strong>필요한 파일</strong></p><ol><li>bodymoivn.js</li><li>data.json</li></ol><p>셋팅방법은 <a href="https://codepen.io/airnan/project/editor/ZeNONO/의" target="_blank" rel="noopener">https://codepen.io/airnan/project/editor/ZeNONO/의</a> 구조를 참고하였습니다.</p><ul><li>js파일 로드하는 스크립트 코드 html에 추가.</li><li>index.js파일에서 아래처럼 json파일을 불러오면 home이외의 메뉴에서는 로드되지 않습니다. (hexo의 generate방식때문)<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> animation = bodymovin.loadAnimation(&#123;</span></span><br><span class="line"><span class="javascript">        container: <span class="built_in">document</span>.getElementById(<span class="string">"bm"</span>),</span></span><br><span class="line"><span class="javascript">        renderer: <span class="string">"svg"</span>,</span></span><br><span class="line"><span class="javascript">        loop: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        autoplay: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        path: <span class="string">"logo_ny.json"</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>해결방법</strong><br>좋은 방법이라고는 생각되지 않으므로 피드백환영합니다.</p><ul><li><code>index.js</code>의 경로를 아래처럼 수정 후,</li><li>js폴더에 json파일을 넣으시고,</li><li>json파일도 따로 로드합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lottie_index.js</span></span><br><span class="line"><span class="keyword">var</span> animation = bodymovin.loadAnimation(&#123;</span><br><span class="line">    container: <span class="built_in">document</span>.getElementById(<span class="string">"bm"</span>),</span><br><span class="line">    renderer: <span class="string">"svg"</span>,</span><br><span class="line">    loop: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">true</span>,</span><br><span class="line">    path: <span class="string">"../../../../logo_ny.json"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scripts.ejs</span></span><br><span class="line">&lt;%- js(<span class="string">'js/lottie'</span>) %&gt;</span><br><span class="line">&lt;%- js(<span class="string">'js/lottie_index'</span>) %&gt;</span><br><span class="line">&lt;script src=<span class="string">"/js/logo_ny.json"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;airbnb 앱을 쓰다보면 곳곳에서 다양한 애니메이션을 볼 수 있다. 한 서비스에 애니메이션이 있으면 있을수록 자연스러운 사용성 유도, 사용자의 감성에도 메세지를 전할 수 있고, 서비스의 브랜드가 더 기억에 오래남고 강해진다고 생각한다. &lt;/p&gt;
      
    
    </summary>
    
      <category term="blog" scheme="http://feel5ny.github.io/categories/blog/"/>
    
      <category term="style" scheme="http://feel5ny.github.io/categories/blog/style/"/>
    
    
      <category term="lottie" scheme="http://feel5ny.github.io/tags/lottie/"/>
    
      <category term="bodymovin" scheme="http://feel5ny.github.io/tags/bodymovin/"/>
    
  </entry>
  
  <entry>
    <title>앵귤러 미리 예습해보기_ToDoList</title>
    <link href="http://feel5ny.github.io/2018/02/15/Angular_practice/"/>
    <id>http://feel5ny.github.io/2018/02/15/Angular_practice/</id>
    <published>2018-02-15T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:28.396Z</updated>
    
    <content type="html"><![CDATA[<p><strong>출처</strong></p><ol><li>inflearn : Angular 기본과 간단한 To-Do 어플리케이션 만들기</li><li><a href="http://poiemaweb.com/" target="_blank" rel="noopener">http://poiemaweb.com/</a> : angular 파트</li></ol><p><strong>요약</strong></p><p><strong>목차</strong> </p><ol><li>Angular CLI</li><li>Angular Hello world</li><li>Module</li><li>Component 알아보기</li><li>Templete 알아보기</li><li>컴포넌트 커뮤니케이션</li><li>컴포넌트 스타일 처리</li><li>Pipe</li></ol><hr><h2 id="1-Angular-CLI"><a href="#1-Angular-CLI" class="headerlink" title="1. Angular CLI"></a>1. Angular CLI</h2><p>Angular CLI는 Node.js의 프로젝트이기때문에 노드의 설치가 필요하다. 노드버전은 6.9.0 이상이어야한다.</p><h3 id="0-셋팅하기"><a href="#0-셋팅하기" class="headerlink" title="0. 셋팅하기"></a>0. 셋팅하기</h3><ol><li>노드 설치 후</li><li><code>npm i -g @angular/cli</code></li><li><code>ng new 프로젝트 이름</code></li></ol><h3 id="1-Angular-CLI-1"><a href="#1-Angular-CLI-1" class="headerlink" title="1. Angular CLI"></a>1. Angular CLI</h3><p><code>tree src</code>라고 명령어를 입력하면 src 하위 파일 디렉토리 tree가 출력된다.<br><code>tree -L 1</code> 해당 디렉토리의 첫번째 레벨 트리만 출력된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── app</span><br><span class="line">│   ├── app.component.css</span><br><span class="line">│   ├── app.component.html</span><br><span class="line">│   ├── app.component.spec.ts</span><br><span class="line">│   ├── app.component.ts</span><br><span class="line">│   └── app.module.ts</span><br><span class="line">├── assets</span><br><span class="line">├── environments</span><br><span class="line">│   ├── environment.prod.ts</span><br><span class="line">│   └── environment.ts</span><br><span class="line">├── favicon.ico</span><br><span class="line">├── index.html</span><br><span class="line">├── main.ts</span><br><span class="line">├── polyfills.ts</span><br><span class="line">├── styles.css</span><br><span class="line">├── test.ts</span><br><span class="line">├── tsconfig.app.json</span><br><span class="line">├── tsconfig.spec.json</span><br><span class="line">└── typings.d.ts</span><br></pre></td></tr></table></figure></p><h4 id="app-폴더"><a href="#app-폴더" class="headerlink" title="app 폴더"></a><code>app</code> 폴더</h4><p>어플리케이션 관련된 파일들이 들어가게 된다.<br>app/app.component.{ts, html, css, spec.ts}<br>: 루트 컴포넌트를 구성하는 컴포넌트 클래스, HTML 템플릿. CSS, 유닛테스트 파일</p><p>app/app.module.ts<br>: Angular 구성요소를 등록하는 루트 모듈.</p><h4 id="environments"><a href="#environments" class="headerlink" title="environments"></a><code>environments</code></h4><p><code>.prod</code> 프로젝트를 빌드할 때 프러덕션 모드로 빌드하게 되면 environment.prod.ts 내용들이 environment.ts 여기에 덮여쓰여지게된다. 앱에서 쓴 환경변수(서버 url…)를 프러덕션용 환경변수로 쓸 수 있게 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng serve</span><br></pre></td></tr></table></figure><p>서버를 실행시키면 로컬호스트에서 확인이 가능하다.</p><h3 id="CLI를-살펴보자"><a href="#CLI를-살펴보자" class="headerlink" title="CLI를 살펴보자."></a>CLI를 살펴보자.</h3><p><code>ng help</code>를 입력하면 ng cli 리스트들이 쭉 나온다. 아래는 자주 사용하는 명령어만 적어둠.</p><ol><li><code>ng build &lt;options...&gt;</code><br>Build커맨드는 소스코드를 빌드해서 dist/ 에 빌드해주는 명령어이다.</li></ol><ul><li>주로 사용하는 CLI<ul><li><code>--aot (Boolean) Build using Ahead of Time compilation.</code></li><li><code>--watch (Boolean) (Default: false) Run build when files change.</code></li></ul></li></ul><ol><li><p><code>ng completion &lt;options...&gt;</code><br>CLI 명령어를 자동 완성시켜주는 것을 설정하겠다 라는 커맨드이다.</p></li><li><p><code>ng doc &lt;keyword&gt; &lt;options...&gt;</code><br>앵귤러 공식 docs를 열어줍니다.</p></li><li><p><code>ng e2e &lt;options...&gt;</code><br>end to end 테스트를 하겠다는 것이다. 브라우저를 띄어서 테스트 하는 것.</p></li><li><p><code>ng eject &lt;options...&gt;</code><br>우리가 만든 앵귤러 CLI 프로젝트는 웹팩기반인데, webpack configuration를 밖으로 빼내어서 webpack configuration를 수정해서 프로젝트에 맞게 바꾸고 싶을 때 사용한다. </p></li><li><p>★★ <code>ng generate &lt;blueprint&gt; &lt;options...&gt;</code><br>사용 빈도수가 높다. 우리가 새로운 컴포넌트나 라우트나 모듈, 클래스 등을 agular CLI를 통해서 만들어지는데, 각각의 만들어지는 방법이 다르다. (옵션이 다르다.) </p></li><li><p><code>ng get &lt;options...&gt;</code><br>configuration를 한번 읽어오는 것</p></li><li><p><code>ng lint &lt;options...&gt;</code><br>프로젝트의 코드의 스타일 가이드에 맞춰서 작성이 잘 되고 있는지 체킹해준다.</p></li><li><p><code>ng new &lt;options...&gt;</code></p></li><li><p><code>ng serve &lt;options...&gt;</code><br>어플리케이션을 서버로 띄어준다. (빌드 후에)</p></li><li><p><code>ng set &lt;options...&gt;</code><br>앵귤러 CLI는 configuration(설정파일들)들이 있는데 그것들을 셋팅해준다.</p></li><li><p><code>ng test &lt;options...&gt;</code><br>유닛테스트 관련한 CLI, 컴포넌트나 서비스등 각각의 컴포넌트를 테스트 할때</p></li><li><p><code>ng version &lt;options...&gt;</code></p></li><li><p><code>ng xi18n &lt;options...&gt;</code><br>다국어 처리하는 시간에 자세히 살펴보도록 한다.</p></li></ol><hr><h2 id="2-Angular-Hello-world"><a href="#2-Angular-Hello-world" class="headerlink" title="2. Angular Hello world"></a>2. Angular Hello world</h2><p><code>.angular-cli.json</code> 파일은 description이라고 생각하면된다.</p><h3 id="2-1-main-ts"><a href="#2-1-main-ts" class="headerlink" title="2-1. main.ts"></a>2-1. main.ts</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; enableProdMode &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; platformBrowserDynamic &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser-dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app/app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; environment &#125; <span class="keyword">from</span> <span class="string">'./environments/environment'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (environment.production) &#123;</span><br><span class="line">  enableProdMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure><p><code>platformBrowserDynamic</code>메서드 : 엥귤러가 우리가 만든 코드를 컴파일을 해서 실제 실행될 수 있는 자바스크립트 코드로 만들어내는데 브라우저에서 다이나믹하게 동적으로 하겠다는 메서드이다. (just-in-time으로)<br><code>bootstrapModule(루트모듈)</code> : 우리가 사용할 어플리케이션의 루트모듈을 설정하고 앵귤러 어플리케이션을 실행시키는 것이다. 루트모듈을 부트스트랩한다 라고도 한다.</p><h3 id="2-2-app-module-ts"><a href="#2-2-app-module-ts" class="headerlink" title="2-2. app.module.ts"></a>2-2. app.module.ts</h3><p>@NgModule 데코레이터의 인자로 전달되는 메타데이터에 애플리케이션 전체의 설정 정보를 기술한 루트 모듈이다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">  <span class="comment">// 부트스트랩은 배열이라는 값을 갖고 있는데 이는 AppComponent에 index.html에 넣어주겠다는 말이다.</span></span><br><span class="line">  <span class="comment">// AppComponent에는 app-root라는 셀력터에 연결되어있다.</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br><span class="line"><span class="comment">// @NgModule은 데코레이터</span></span><br><span class="line"><span class="comment">// 앵귤러 모듈이라는 것(NgModule)을 정의한 클래스가 되는 것이다.</span></span><br><span class="line"><span class="comment">// 앵귤러의 루트모드를 설정하는 클래스이다.</span></span><br></pre></td></tr></table></figure></p><ul><li>앵귤러의 루트모듈(AppModule)를 설정하는 클래스이다.</li></ul><h3 id="2-3-app-component-ts"><a href="#2-3-app-component-ts" class="headerlink" title="2-3. app.component.ts"></a>2-3. app.component.ts</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.css'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;</span><br><span class="line">  title = <span class="string">'app'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>모든 컴포넌트의 부모 역할을 담당하는 루트 컴포넌트이다.</li></ul><p><img src="/images/post_img/35/angular-process.png"></p><blockquote><p>Anuglar 어플리케이션의 흐름 <a href="http://poiemaweb.com/angular-architecture" target="_blank" rel="noopener">+</a></p></blockquote><h3 id="3-index-html"><a href="#3-index-html" class="headerlink" title="3. index.html"></a>3. index.html</h3><p><code>/dist/index.html</code>는 빌드(ng build)의 결과물로 실제 배포 시에는 서버로 이관된다.<br>ng serve 명령어에 의해 <strong>내장 개발 서버</strong>를 사용하여 로컬 환경에서 프로젝트를 실행(preview)하는 경우, Angular CLI 내부적으로 <code>빌드를 자동 수행</code>하므로 빌드(ng build)를 별도 실행하여 /my-app/dist/index.html를 생성할 필요는 없다.<br>자동으로 빌드되어 가상 드라이브에 저장되어 있는 index.html를 내장개발 서버가 로드한다고 이해하면 된다.</p><p><code>inline.bundle.js</code> : 웹팩 유틸리티가 포함된 Webpack loader<br><code>polifills.bundle.js</code> : polyfil 의존성 모듈(core-js, zone.js)를 번들링한 파일<br><code>styles.bundle.js</code> : 스타일 전의를 번들링한 파일<br><code>vendor.bundle.js</code> : 의존성 모듈(@angular/*, RxJS 등)을 번들링한 파일<br><code>main.bundle.js</code> : 개발자가 작성한 컴포넌트, 디렉티브, 서비스 등 소스코드를 번들링한 파일</p><h2 id="3-Module"><a href="#3-Module" class="headerlink" title="3. Module"></a>3. Module</h2><h4 id="3-1-ES6-모듈"><a href="#3-1-ES6-모듈" class="headerlink" title="3-1. ES6 모듈"></a>3-1. ES6 모듈</h4><p>모듈이란</p><ul><li>세부 구현이 숨겨지고 공개 API를 이용해 다른 코드에서 재사용 가능한 코드</li><li>각각의 파일들이 모듈이 된다. 변수 스코프가 모듈로 제한이 된다.</li><li>2016년 08월 1.0.0-beta.11부터 Angular의 빌드 시스템은 SystemJS에서 <code>Webpack</code>으로 변경되었다. We moved the build system from SystemJS to Webpack.</li></ul><h4 id="3-2-엥귤러-모듈"><a href="#3-2-엥귤러-모듈" class="headerlink" title="3-2. 엥귤러 모듈"></a>3-2. 엥귤러 모듈</h4><p>컴포넌트, 파이프, 서비스 등과 같은 앵귤러 어플리케이션의 주요 부분을 기능단위로 그룹핑하게 해준다.</p><ul><li>모든 앵귤러 어플리케이션은 하나의 Root Module을 가진다.</li><li>여러 Feature Module을 가질 수 있다.</li><li>재사용할 수 있는 기능을 외부에 배포하기 위해 사용되기도 한다. </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g m todo</span><br></pre></td></tr></table></figure><p>app 하위에 todo라는 폴더가 생성되고 todo.module.ts라는 모듈파일이 만들어진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c todo/todos --module todo/todo.module.ts --export</span><br></pre></td></tr></table></figure><p>g는 generate,<br>c는 component,<br>m은 module,<br>todo 밑에 todos라는 폴더를 둔다.<br>todos에서 만들어진 component를 관리하는 모듈을 지정해주기 위해서 <code>--module</code>이라는 플래그를 사용, 관리하는 모듈 이름을 붙여준다.<code>todo/todo.module.ts</code><br>해당 모듈파일이 다른 곳에서 사용할 수 있다는 의미의 –export라는 플래그를 추가한다. –export플래그를 추가하면 NgModule 데코레이터의 메타데이터 내부에 export 옵션이 추가되며 todoComponent가 자동으로 추가된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TodosComponent &#125; <span class="keyword">from</span> <span class="string">'./todos/todos.component'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule</span><br><span class="line">  ],</span><br><span class="line">  declarations: [TodosComponent],</span><br><span class="line">  exports: [TodosComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><ul><li>declarations는 탬플릿에서 사용하는 컴포넌트를 의미한다.</li></ul><p><strong>모듈 정리</strong></p><ul><li>외부컴포넌트를 export하고싶을 때나 import하고 싶을 때는 module파일의 데코레이터에 옵션값을 추가한다.</li><li>cli에서 컴포넌트를 생성하면서 자동으로 export 옵션에 추가하는 방법은 <code>--export</code> 플래그를 사용하는 것이다.</li></ul><h2 id="4-Component"><a href="#4-Component" class="headerlink" title="4. Component"></a>4. Component</h2><ul><li>빌딩 블록 LEGO</li><li>HTML 요소들의 그룹</li><li>뷰와 로직으로 구성</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수라고 생각하면 된다. 함수를 호출하는 것처럼 사용하고 있다.</span></span><br><span class="line"><span class="comment">// 데코레이터 내부의 메타데이터를 정의하고 있다.</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-todos'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./todos.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./todos.component.css'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TodosComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>selector</code><br><code>.</code>이나 <code>#</code>을 앞에 붙여서 css에서의 선택자와 유사하게 사용도 가능하다. 현재는 <code>.</code>이나 <code>#</code>이 없기 때문에 태그명으로 정의된 것이다.</li><li><code>templateUrl</code><br>view에 대한 정의를 template에서 정의한다.</li><li><code>styleUrls</code><br>style이 작성된 url을 정의한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c todo/todos/todo –inline-template –inline-style</span><br></pre></td></tr></table></figure><ul><li>template이 따로 html파일로 생성되지 않고, todo내부에 생성된 component의 컴포넌트 데코레이터의 메타데이터에 <code>template</code>이 생성된다.</li><li>template에는 리터럴로 html을 넣을 수 있다.</li><li>이를 inline방식으로 넣어지는 template스타일인데 위의 명령어로 자동으로 해당 방식의 컴포넌트를 생성할 수 있다.</li></ul><h2 id="5-Agular-Template"><a href="#5-Agular-Template" class="headerlink" title="5. Agular Template"></a>5. Agular Template</h2><ul><li>HTML 코드로서 템플릿을 표현</li><li>Tempate 표현식과 Template 문장이 있음</li><li>바인딩<ul><li>바인딩의 대상 : 속성, 이벤트 ngModel, class, style</li></ul></li></ul><p><img src="/images/post_img/35/01.png"><br><img src="/images/post_img/35/binding.jpg"><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>나의 하루<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>2월 15일<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">"let todo of todos"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> [<span class="attr">checked</span>]=<span class="string">"todo.done"</span>&gt;</span> &#123;&#123;todo.text&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"할 일 추가하기"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>*ngFor=&quot;let todo of todos&quot;</code><br>todos라는 객체의 todo요소들을 referencing한다고 생각하면 된다.</p><p><strong>ngFor</strong><br>Angular의 ngFor “repeater” 지시자(directive)</p><h3 id="5-1-내장-directive"><a href="#5-1-내장-directive" class="headerlink" title="5-1. 내장 directive"></a>5-1. 내장 directive</h3><ul><li>디렉티브(Directive / 지시자)는 <code>DOM의 모든 것(모양이나 동작 등)을 관리하기 위한 지시(명령)</code>이다. HTML 요소 또는 어트리뷰트의 형태로 사용하여 디렉티브가 사용된 요소에게 무언가를 하라는 지시(directive)를 전달한다.</li><li>디렉티브는 애플리케이션 전역에서 사용할 수 있는 공통 관심사를 컴포넌트에서 분리하여 구현한 것으로 컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다. 컴포넌트도 뷰를 생성하고 이벤트를 처리하는 등 DOM을 관리하기 때문에 큰 의미에서 디렉티브로 볼 수 있다.</li></ul><h4 id="5-1-1-컴포넌트-디렉티브"><a href="#5-1-1-컴포넌트-디렉티브" class="headerlink" title="5-1-1. 컴포넌트 디렉티브"></a>5-1-1. 컴포넌트 디렉티브</h4><ul><li>컴포넌트의 템플릿을 표시하기 위한 디렉티브</li><li><code>@Component</code>데코레이터의 메타데이터 객체의 selector 프로퍼티에 임의의 디렉티브의 이름을 정의한다.</li></ul><h4 id="5-1-2-어트리뷰트-디렉티브"><a href="#5-1-2-어트리뷰트-디렉티브" class="headerlink" title="5-1-2. 어트리뷰트 디렉티브"></a>5-1-2. 어트리뷰트 디렉티브</h4><ul><li>어트리뷰트 디렉티브는 HTML요소의 어트리뷰트와 같이 사용하여 해당 요소의 모양이나 동작을 제어한다. </li><li><code>ngClass</code>, <code>ngStyle</code>와 같은 빌트인 어트리뷰트 디렉티브가 있다.</li><li>클래스 바인딩은 표현식 또는 클래스 리스트를 나타내는 문자열을 바인딩한다. </li><li>ngClass 디렉티브는 문자열, 배열, 객체를 바인딩할 수 있다.</li></ul><h4 id="5-1-3-구조-디렉티브"><a href="#5-1-3-구조-디렉티브" class="headerlink" title="5-1-3. 구조 디렉티브"></a>5-1-3. 구조 디렉티브</h4><ul><li>DOM 요소를 반복생성(ngFor)</li><li>조건에 의한 추가 또는 제거 (ngIf, ngSwitch)를 통해 돔 레이아웃을 변경한다.</li><li><code>*</code>를 접두사로 추가하며 <code>[]</code>를 사용하지 않는다.</li></ul><p><strong>ngIf</strong><br>ngIf 디렉티브는 우변 표현식의 연산 결과가 참이면 해당 요소(호스트 요소)를 DOM에 추가하고 거짓이면 해당 요소(호스트 요소)를 DOM에서 제거한다. 우변의 표현식은 true 또는 false로 평가될 수 있어야한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;element *ngIf=<span class="string">"expression"</span>&gt;...&lt;<span class="regexp">/element&gt;</span></span><br></pre></td></tr></table></figure></p><p>ngIf 디렉티브 앞에 붙은 *(asterisk)는 아래 구문의 문법적 설탕(syntactic sugar)이다. 즉 위 코드는 아래의 코드로 변환된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ng-template [ngIf]=<span class="string">"expression"</span>&gt;</span><br><span class="line">  &lt;element&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ng-template&gt;</span><br></pre></td></tr></table></figure><p>Angular는 <em>ngIf를 만나면 호스트 요소를 <code>ng-template</code> 디렉티브로 래핑하고 </em>ngIf를 <strong>프로퍼티 바인딩으로 변환한다.</strong>(<code>[ngIf]=&quot;expression&quot;</code>) ngFor와 ngSwitch 디렉티브도 동일한 패턴을 따른다.</p><ul><li>ng-template 디렉티브는 페이지에서 렌더링 될 요소를 div 또는 span 등의 요소와 함께 사용할 필요가 없는 요소들을 그룹화할 때 사용한다. </li></ul><p><strong>ngIf else</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">if</span> <span class="keyword">else</span> --&gt;</span><br><span class="line">&lt;element *ngIf=<span class="string">"expression; else elseBlock"</span>&gt;Truthy condition&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">&lt;ng-template #elseBlock&gt;Falsy condition&lt;/</span>ng-template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="keyword">if</span> <span class="keyword">else</span> --&gt;</span><br><span class="line">&lt;element *ngIf=<span class="string">"expression; then thenBlock else elseBlock"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span></span><br><span class="line">&lt;ng-template #thenBlock&gt;Truthy condition&lt;/ng-template&gt;</span><br><span class="line">&lt;ng-template #elseBlock&gt;Falsy condition&lt;/ng-template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="keyword">if</span> --&gt;</span><br><span class="line">&lt;element *ngIf=<span class="string">"expression; then thenBlock"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span></span><br><span class="line">&lt;ng-template #thenBlock&gt;Truthy condition&lt;/ng-template&gt;</span><br></pre></td></tr></table></figure></p><p><strong>ngFor</strong><br>ngFor 디렉티브는 컴포넌트 클래스의 컬렉션을 반복하여 호스트 요소(ngFor 디렉티브가 선언된 요소) 및 하위 요소를 DOM에 추가한다. 컬렉션은 일반적으로 배열을 사용한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;element *ngFor=<span class="string">"let item of items"</span>&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;element *ngFor="let item of items; let i=index; let odd=odd; trackBy: trackById"&gt;...&lt;/</span>element&gt;</span><br></pre></td></tr></table></figure></p><p>인덱스를 취득할 필요가 있는 경우, 인덱스를 의미하는 index를 사용하여 변수에 인덱스를 할당받을 수 있다. index 이외에도 first, last, even, odd와 같은 로컬 변수가 제공된다. 자세한 내용은 ngFor API reference를 참조하기 바란다.</p><p>ngFor 디렉티브 앞에 붙은 *(asterisk)는 아래 구문의 문법적 설탕(syntactic sugar)이다. 즉 위 코드는 아래의 코드로 변환된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ng-template ngFor <span class="keyword">let</span>-item [ngForOf]=<span class="string">"items"</span>&gt;</span><br><span class="line">  &lt;element&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ng-template&gt;</span><br><span class="line"></span><br><span class="line">&lt;ng-template ngFor <span class="keyword">let</span>-item [ngForOf]=<span class="string">"items"</span> <span class="keyword">let</span>-i=<span class="string">"index"</span> <span class="keyword">let</span>-odd=<span class="string">"odd"</span> [ngForTrackBy]=<span class="string">"trackById"</span>&gt;</span><br><span class="line">  &lt;element&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ng-template&gt;</span><br></pre></td></tr></table></figure><p><strong>ngSwitch</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;element [ngSwitch]=<span class="string">"expression"</span>&gt;</span><br><span class="line">  &lt;!-- <span class="keyword">switch</span> 조건이 <span class="string">'case1'</span>인 경우 DOM에 추가 --&gt;</span><br><span class="line">  &lt;element *ngSwitchCase=<span class="string">"'case1'"</span>&gt;...&lt;element&gt;</span><br><span class="line">  &lt;!-- <span class="keyword">switch</span> 조건이 <span class="string">'case2'</span>인 경우 DOM에 추가 --&gt;</span><br><span class="line">  &lt;element *ngSwitchCase=<span class="string">"'case2'"</span>&gt;...&lt;element&gt;</span><br><span class="line">  &lt;!-- <span class="keyword">switch</span> 조건과 일치하는 ngSwitchCase가 없는 경우 DOM에 추가 --&gt;</span><br><span class="line">  &lt;element *ngSwitchDefault&gt;...&lt;element&gt;</span><br><span class="line">&lt;<span class="regexp">/element&gt;</span></span><br></pre></td></tr></table></figure></p><p>ngSwitch 디렉티브 앞에 붙은 *(asterisk)는 아래 구문의 문법적 설탕(syntactic sugar)이다. 즉 위 코드는 아래의 코드로 변환된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;element [ngSwitch]=<span class="string">"expression"</span>&gt;</span><br><span class="line">  &lt;ng-template [ngSwitchCase]=<span class="string">"'case1'"</span>&gt;</span><br><span class="line">    &lt;element&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>ng-template&gt;</span><br><span class="line">  &lt;ng-template [ngSwitchCase]=<span class="string">"'case2'"</span>&gt;</span><br><span class="line">    &lt;element&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>ng-template&gt;</span><br><span class="line">  &lt;ng-template ngSwitchDefault&gt;</span><br><span class="line">    &lt;element&gt;...&lt;<span class="regexp">/element&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>ng-template&gt;</span><br><span class="line">&lt;<span class="regexp">/element&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;출처&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;inflearn : Angular 기본과 간단한 To-Do 어플리케이션 만들기&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://poiemaweb.com/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Angular" scheme="http://feel5ny.github.io/categories/TIL-9997/Angular/"/>
    
    
      <category term="angular" scheme="http://feel5ny.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>jquery 뽀개기(1)</title>
    <link href="http://feel5ny.github.io/2018/01/21/jquery/"/>
    <id>http://feel5ny.github.io/2018/01/21/jquery/</id>
    <published>2018-01-21T01:10:04.000Z</published>
    <updated>2018-08-15T14:43:51.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><ul><li>html은 위에서 아래로 순차적으로 실행된다.</li><li>jquery의 ready나 load메서드가 있을 경우 위에서 아래로 순차적으로 실행되지 않고 각 메서드의 특징별로 순서가 진행된다.</li></ul><h2 id="1-ready"><a href="#1-ready" class="headerlink" title="1. ready()"></a>1. <code>ready()</code></h2><p>제이쿼리 <code>ready</code> 메서드는 <strong>DOM이 완전히 로드되었을 때 코드를 실행하도록 구현되어있다.</strong><br>(리액트의 <code>componentDidMount</code>)</p><p>제이쿼리 3.0 이전 버전에서는, ready 메서드를 호출할 수 있는 몇 가지 방법이 있다.</p><ul><li><code>document</code> 엘리먼트로 호출 : <code>$(document).ready(handler);</code></li><li>빈 엘리먼트로 호출 : <code>$().ready(handler);</code></li><li>또는 특정 엘리먼트 없이 바로 호출 : <code>$(handler);</code></li></ul><h3 id="1-1-ready와-load-이벤트의-차이점"><a href="#1-1-ready와-load-이벤트의-차이점" class="headerlink" title="1-1. ready와 load 이벤트의 차이점"></a>1-1. ready와 load 이벤트의 차이점</h3><p>ready 이벤트는 DOM이 로드되고 <strong>엘리먼트 접근이 안전할 때</strong> 발생한다.<br>(= ready는 document 객체에 한해서만 적용되는 메소드.)<br>반대로 load 이벤트는 DOM과 모든 어셋들이 <strong>로드된 이후에</strong> 발생한다.</p><ul><li>모든 어셋들이 로드되기까지 로딩스피너를 보여주거나 이미지 사이즈를 계산하려고 한다면 load이벤트는 적절하다.</li><li>외부자원 접근(images, scripts, frames, iframes 등)과 window 객체에 대해 적용되는 메소드이며 </li></ul><h2 id="2-입력값을-확인하고-변경하기-GET-SET"><a href="#2-입력값을-확인하고-변경하기-GET-SET" class="headerlink" title="2. 입력값을 확인하고 변경하기 (GET/SET)"></a>2. 입력값을 확인하고 변경하기 (GET/SET)</h2><h3 id="input의-hidden"><a href="#input의-hidden" class="headerlink" title="input의 hidden"></a>input의 hidden</h3><p>form태그 안에 hidden타입 input을 넣어 폼전송에 필요한 데이터를 담아 사용합니다. 혹은 보이지 않는 변수를 선언할 때 사용.</p><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p><code>$(셀렉터).함수();</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// alert(document.getElementById("txt1").value);</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// var txt1 = $("#txt1").val()</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// var hdn1 = $("#hdn1").val()</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> slct1 = $(<span class="string">"#slct1"</span>).val()</span></span><br><span class="line"><span class="javascript">      <span class="comment">// alert(txt1)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// alert(hdn1)</span></span></span><br><span class="line"><span class="undefined">      alert(slct1)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt1"</span> <span class="attr">value</span>=<span class="string">"제이쿼리를 뽀게버리겠다"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"hdn1 "</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"slct1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"select1"</span>&gt;</span>셀렉트1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"select2"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>셀렉트2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"select3"</span>&gt;</span>셀렉트3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#txt1"</span>).val(<span class="string">"text2"</span>)</span><br></pre></td></tr></table></figure><h2 id="3-내가-원하는-태그-속성과-HTML-값을-확인하고-변경하기"><a href="#3-내가-원하는-태그-속성과-HTML-값을-확인하고-변경하기" class="headerlink" title="3. 내가 원하는 태그 속성과 HTML 값을 확인하고 변경하기"></a>3. 내가 원하는 태그 속성과 HTML 값을 확인하고 변경하기</h2><h3 id="속성값-변경하기"><a href="#속성값-변경하기" class="headerlink" title="속성값 변경하기"></a>속성값 변경하기</h3><p><code>$(&#39;#div1&#39;).attr(&quot;style&quot;, &quot;color:red;&quot;)</code></p><h3 id="자식-엘리먼트-트리-갖고오기"><a href="#자식-엘리먼트-트리-갖고오기" class="headerlink" title="자식 엘리먼트 트리 갖고오기"></a>자식 엘리먼트 트리 갖고오기</h3><p>GET: <code>$(&quot;#node1&quot;).html()</code><br>SET(html): <code>$(&quot;#node1&quot;).html(&quot;&lt;h1&gt;테스트&lt;/h1&gt;&quot;)</code><br>SET(text): <code>$(&quot;#node1&quot;).text(&quot;&lt;h1&gt;테스트&lt;/h1&gt;&quot;)</code> : html화 하지 않고 텍스트로만 출력된다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"node1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>테이블입니다.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="4-내가-원하는-위치에-HTML-삽입하기"><a href="#4-내가-원하는-위치에-HTML-삽입하기" class="headerlink" title="4. 내가 원하는 위치에 HTML 삽입하기"></a>4. 내가 원하는 위치에 HTML 삽입하기</h2><p><code>before()</code><br><code>after()</code><br><code>prepend()</code><br><code>append()</code></p><h2 id="5-셀렉터-알아보기"><a href="#5-셀렉터-알아보기" class="headerlink" title="5. 셀렉터 알아보기"></a>5. 셀렉터 알아보기</h2><p><code>$(&quot;input[name=rad]:checked&quot;).val()</code></p><h3 id="input의-타입종류"><a href="#input의-타입종류" class="headerlink" title="input의 타입종류"></a>input의 타입종류</h3><ul><li><code>text</code> : 기본값. 한 줄의 텍스트 입력 칸을 만듦 (기본 너비 문자는 20)</li><li><code>password</code> : text 속성과 같지만, 문자를 숨겨서 표시 (별표)</li><li><code>checkbox</code> : 체크박스를 만듦</li><li><code>radio</code> : 라디오 버튼 만듦</li><li><code>button</code> : 누름 버튼</li><li><code>submit</code> : 전송 버튼</li><li><code>reset</code> : 재설정 버튼</li><li><code>file</code> : 파일 선택 창을 만듦.</li><li><code>hidden</code> : 사용자에게 보이지 않는 숨김 창을 만듦.</li><li><p><code>image</code> : 이미지로 된 전송 버튼을 만듦 (src 속성으로 이미지 url 지정)</p></li><li><p><code>color</code> : 색상 선택 창을 만듦.</p></li><li><code>date</code> : 날짜 입력 창을 만듦 (년/월/일)</li><li><code>datetime</code> : 날짜 시간 창을 만듦 (년/월/일/시/분/초/초의 분할) 표준시간</li><li><code>datetime-local</code> : 날짜 시간 차응ㄹ 만듦 (년/월/일/시/분/초/초의 분할) 표준시간 없음</li><li><code>email</code> : email 주소 창을 만듦</li><li><code>month</code> : 달과 년 창을 만듦 (표준 시간 없음)</li><li><code>number</code> : 숫자 입력을 위한 창을 만듦(숫자 제한을 둘 수도 있음)<ul><li>max : 최대값 / min: 최소값 / step: 허락하는 숫자간격 / value: 기본값</li></ul></li><li><code>range</code> : 정확한 값이 중요하지 않는 숫자를 입력하는 창을 만듦 (슬라이더 장치처럼)</li><li><code>search</code> : 검색 창을 만듦</li><li><code>tel</code> : 전화번호 입력창을 만듦</li><li><code>time</code> : 시간 입력 창을 만듦 (표준 시간 없음)</li><li><code>url</code> : 주소 입력 창</li><li><code>week</code> : 주와 년 입력 창 (표준시간 없음)</li></ul><h2 id="6-내가-원하는대로-태그에-스타일을-제어해보자"><a href="#6-내가-원하는대로-태그에-스타일을-제어해보자" class="headerlink" title="6. 내가 원하는대로 태그에 스타일을 제어해보자."></a>6. 내가 원하는대로 태그에 스타일을 제어해보자.</h2><p><code>$(&quot;div:eq(0)&quot;).css(&quot;color:red;&quot;)</code> : <code>div:eq(0)</code>란, div엘리먼트들 중에서 첫번째 div요소</p><p>클래스 제어하기</p><ul><li><code>addClass(&quot;클래스명&quot;)</code> 클래스명을 지정된 셀렉터에 추가한다.</li><li><code>removeClass(&quot;클래스명&quot;)</code> 클래스명을 지정된 셀렉터로부터 지운다.</li><li><code>hasClass(&quot;클래스명&quot;)</code> 클래스명이 지정된 셀렉터로부터 존재하는지 여부를 판단. (return으로 boolean값)</li></ul><h2 id="7-traversing-함수-셀렉터를-시작으로-내가-추적하고자-하는-태그-알아내기"><a href="#7-traversing-함수-셀렉터를-시작으로-내가-추적하고자-하는-태그-알아내기" class="headerlink" title="7. traversing 함수. 셀렉터를 시작으로 내가 추적하고자 하는 태그 알아내기."></a>7. traversing 함수. 셀렉터를 시작으로 내가 추적하고자 하는 태그 알아내기.</h2><p><code>parent()</code> : 부모노드<br><code>find()</code> : 자식노드중 태그명을 찾는다.<br><code>prev()</code> : 같은 레벨에서의 직전 노드<br><code>next()</code> : 같은 레벨에서 다음 노드 (직후)</p><h2 id="8-jquery용-for문인-each-함수에-대해서-알아보자"><a href="#8-jquery용-for문인-each-함수에-대해서-알아보자" class="headerlink" title="8. jquery용 for문인 each()함수에 대해서 알아보자."></a>8. jquery용 for문인 <code>each()</code>함수에 대해서 알아보자.</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./jquery-1.12.4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">"div"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> a = $(<span class="keyword">this</span>).find(<span class="string">"input[type=text]"</span>).val()</span></span><br><span class="line"><span class="javascript">        <span class="comment">// $("div").eq(index) == $(this)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// $(this)는 each문이나 이벤트에서 자주 사용한다.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (index == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(a)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      )</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"첫번째값"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"두번째값"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"세번째값"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"네번째값"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-마우스-키보드-이벤트-함수-사용해보고-이해하기-1"><a href="#9-마우스-키보드-이벤트-함수-사용해보고-이해하기-1" class="headerlink" title="9. 마우스 + 키보드 이벤트 함수 사용해보고 이해하기 (1)"></a>9. 마우스 + 키보드 이벤트 함수 사용해보고 이해하기 (1)</h2><h3 id="1-click"><a href="#1-click" class="headerlink" title="1. click"></a>1. <code>click</code></h3><ul><li><code>on(&#39;click&#39;)</code>과의 차이점 : on을 사용하게되면, 추가된 요소에 더 적은 메모리를 사용하고 작업할 수 있기 때문에 <code>.click</code>보다 더 선호한다. (<a href="https://code.i-harness.com/ko/q/8b311e" target="_blank" rel="noopener">참고</a>)</li></ul><h3 id="1-1-click을-사용할-때"><a href="#1-1-click을-사용할-때" class="headerlink" title="1.1 click을 사용할 때"></a>1.1 <code>click</code>을 사용할 때</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button.alert"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>위와 같이 선택기와 일치하는 모든 단일 요소에 대해 <strong>별도의 처리기</strong>가 만들어집니다. 그 의미는<ul><li>일치하는 요소가 많으면 많은 동일한 처리기가 만들어 지므로 메모리 사용 공간이 증가합니다.</li><li>동적으로 추가 된 항목에는 처리기가 없습니다. 즉, 위의 html에 새로 추가 된 “경고!” 핸들러를 <strong>리 바인드</strong>하지 않으면 버튼이 작동하지 않습니다.  (= 동적으로 생성된 요소에는 먹히지 않는다는 말)</li></ul></li></ul><h3 id="1-2-on을-사용할-때"><a href="#1-2-on을-사용할-때" class="headerlink" title="1.2 .on을 사용할 때"></a>1.2 <code>.on</code>을 사용할 때</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div#container"</span>).on(<span class="string">'click'</span>, <span class="string">'button.alert'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>동적으로 생성 된 요소를 포함하여 선택기와 일치하는 모든 요소에 대한 단일 처리기이다.</p><ol><li><code>keypress</code> : 콜백함수에서 이벤트 객체를 받을 수 있는데, 내부에 keyCode값이 있어서 어떤 키보드를 누르는지에대한 정보를 얻을 수 있다. </li><li><code>keyup</code> : esc의 경우에는 keypress가 아니라 keyup에서 작동된다.</li></ol><h2 id="10-Ajax"><a href="#10-Ajax" class="headerlink" title="10. Ajax"></a>10. Ajax</h2><p>html로 받는 형태로만 정리하겠음.</p><ul><li>form action(url)과 url값은 같다. type(method), (post/get/put/delete/…)</li><li>form은 알아서 input 태그들을 전송하지만, ajax는 data 속성을 줘야한다.</li><li>data에는 post로 보낼때 보낼 data를 넣는다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">''</span>, </span><br><span class="line">  type: <span class="string">''</span>,</span><br><span class="line">  dataType: <span class="string">''</span>,</span><br><span class="line">  <span class="comment">// data: &#123;&#125;,</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>json 렌더하기<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      $(<span class="string">"#loadButton"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url: <span class="string">"https://api.github.com/users"</span>,</span><br><span class="line">          type: <span class="string">'GET'</span>,</span><br><span class="line">          dataType: <span class="string">'json'</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $.map(data, <span class="function"><span class="keyword">function</span> (<span class="params">data, i</span>) </span>&#123;</span><br><span class="line">              $(<span class="string">'#table'</span>).append(<span class="string">`&lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;data.login&#125;</span>&lt;/td&gt;&lt;td&gt;&lt;img src=<span class="subst">$&#123;data.avatar_url&#125;</span>/&gt;&lt;/td&gt;&lt;/tr&gt;`</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="11-기타"><a href="#11-기타" class="headerlink" title="11. 기타"></a>11. 기타</h2><ol><li><code>trim()</code><br>앞뒤의 공백제거만 가능하다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = $(<span class="string">'#test'</span>).val()</span><br><span class="line">$.tring(text)</span><br></pre></td></tr></table></figure><ol><li><p><code>remove()</code> <code>empty()</code><br><code>$(&quot;#showhide&quot;).empty();</code> : showhide라는 아이디값을 갖고 있는 요소의 자식요소들이 비워진다.<br><code>$(&quot;#showhide&quot;).remove();</code> : showhide라는 아이디값을 갖고 있는 요소가 삭제된다.(아예)</p></li><li><p>선택한 태그의 인덱스값만 알고싶을 때</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./jquery-1.12.4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'.btn'</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> index = $(<span class="string">".btn"</span>).index(<span class="keyword">this</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 각 버튼을 누르면 해당되는 index의 레이어를 출력시켜라.</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 단, 다른 영역들은 닫혀야하고 클릭된 영역만을 보여줘야한다.</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">".layer"</span>).hide();</span></span><br><span class="line"><span class="javascript">        $(<span class="string">".layer"</span>).eq(index).show();</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"버튼1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"버튼2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"버튼3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layer"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    레이어1입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어1입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어1입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어1입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layer"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    레이어2입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어2입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어2입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어2입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layer"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    레이어3입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어3입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어3입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 레이어3입니다.</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;basic&quot;&gt;&lt;a href=&quot;#basic&quot; class=&quot;headerlink&quot; title=&quot;basic&quot;&gt;&lt;/a&gt;basic&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;html은 위에서 아래로 순차적으로 실행된다.&lt;/li&gt;
&lt;li&gt;jquery의 ready나 lo
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Jquery" scheme="http://feel5ny.github.io/categories/TIL-9997/Jquery/"/>
    
    
      <category term="jquery" scheme="http://feel5ny.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>11/ 정규표현식</title>
    <link href="http://feel5ny.github.io/2018/01/20/JS_11/"/>
    <id>http://feel5ny.github.io/2018/01/20/JS_11/</id>
    <published>2018-01-20T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.109Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>목차</strong></p><ol><li>정규표현식<ol><li>플래그</li><li>패턴</li><li>자주사용하는 정규표현식</li></ol></li><li>JS Regular Expression<ol><li>RegExp Constructor</li><li>RegExp Method<ol><li>RegExp.prototype.exec()</li><li>RegExp.prototype.test()</li></ol></li></ol></li></ol><hr><hr><h2 id="1-정규표현식"><a href="#1-정규표현식" class="headerlink" title=" 1. 정규표현식"></a><a name="RegExp"></a> 1. 정규표현식</h2><p><img src="/images/2018/06/regular_expression.png" width="400px"><br><code>RegExp.prototype.exec(text)</code> :<br><code>RegExp.prototype.test(text)</code> : boolean값이 반환된다.<br><code>String.prototype.match(rxgexr)</code> : 매치되는 문자열들을 반환한다.<br><code>String.prototype.replace(rxgexr, &#39;&#39;)</code> : 첫번째 인자로 찾아진 문자열을 두번째 인자로 교체한다.<br><code>String.prototype.search(rxgexr)</code> : 배열의 길이<br><code>String.prototype.split(rxgexr)</code> : 인자값을 제외하고, 인자값을 기준으로 split된 배열이 반환됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'This is a pen.'</span>;</span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/is/ig</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp 객체의 메소드</span></span><br><span class="line"><span class="built_in">console</span>.log(regexr.exec(targetStr)); <span class="comment">// [ 'is', index: 2, input: 'This is a pen.' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String 객체의 메소드</span></span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'is', 'is' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(targetStr.replace(regexr, <span class="string">'IS'</span>)); <span class="comment">// ThIS IS a pen.</span></span><br><span class="line"><span class="built_in">console</span>.log(targetStr.search(regexr)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(targetStr.split(regexr));  <span class="comment">// [ 'Th', ' ', ' a pen.' ]</span></span><br></pre></td></tr></table></figure><h3 id="1-1-플래그"><a href="#1-1-플래그" class="headerlink" title="1.1 플래그"></a>1.1 플래그</h3><p>플래그는 옵션이므로 선택적으로 사용한다.<br>플래그를 사용하지 않은 경우 문자열 내 검색 매칭 대상이 1개 이상이더라도 <strong>첫번째 매칭한 대상만</strong>을 검색하고 종료한다.</p><ul><li><code>i</code> : ignore Case : <strong>대소문자를 구별하지 않고 검색한다.</strong></li><li><code>g</code> : Global : <strong>문자열 내의 모든 패턴을 검색한다.</strong></li><li><code>m</code> : Multi Line : <strong>문자열의 행이 바뀌더라도 검색을 계속한다.</strong></li></ul><hr><hr><h3 id="1-2-패턴"><a href="#1-2-패턴" class="headerlink" title="1.2 패턴"></a>1.2 패턴</h3><p>패턴에는 찾고자 하는 대상을 문자열로 지정한다.<br>또한 패턴은 특별한 의미를 가지는 메타문자(Metacharacter) 또는 기호로 표현할 수 있다. </p><hr><h4 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1 /.../"></a>1.2.1 <code>/.../</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 임의의 문자 3개</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/.../</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA ', index: 0, input: 'AA BB Aa Bb' ]</span></span><br></pre></td></tr></table></figure><p><code>.</code>은 임의의 문자 한 개를 의미한다. 문자의 내용은 무엇이든지 상관없다. 위의 경우 <code>.</code>를 3개 연속하여 패턴을 생성하였으므로 패턴과 일치하는 3자리 문자를 추출한다.<br>플래그가 없으므로 추출을 반복하지 않는다. 문자열 내의 모든 패턴을 검색하기 위해 <code>g</code>사용<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 임의의 문자 3개를 반복하여 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/.../g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA ', 'BB ', 'Aa ' ]</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="1-2-2-일치하는-문자-또는-문자열-추출"><a href="#1-2-2-일치하는-문자-또는-문자열-추출" class="headerlink" title="1.2.2 일치하는 문자 또는 문자열 추출 + | []"></a>1.2.2 일치하는 문자 또는 문자열 추출 <code>+</code> <code>|</code> <code>[]</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A'를 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr1 = <span class="regexp">/A/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr1)); <span class="comment">// 'A'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regexr2 = <span class="regexp">/A/ig</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr2)); <span class="comment">// [ 'A', 'A', 'A', 'a' ]</span></span><br></pre></td></tr></table></figure><p>앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 <code>+</code>를 붙인다. 아래의 경우 앞선 패턴는 A이므로 A+는 AA 또는 A를 의미한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA AAA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A'가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/A+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA', 'AAA', 'A' ]</span></span><br></pre></td></tr></table></figure></p><p><code>|</code>를 사용하면 or의 의미를 가지게 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A' 또는 'B'를 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/A|B/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'A', 'A', 'B', 'B', 'A', 'B' ]</span></span><br></pre></td></tr></table></figure></p><p>분해되지 않은 단어 레벨로 추출하기 위해서는 +를 같이 사용하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA AAA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A' 또는 'B'가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/A+|B+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA', 'AAA', 'BB', 'A', 'B' ]</span></span><br></pre></td></tr></table></figure></p><p>위 예제는 패턴을 or로 한번 이상 반복하는 것인데 간단히 표현하면 아래와 같다.<br><code>[]</code>내의 문자는 or로 동작한다. 그 뒤에 <code>+</code>를 사용하여 앞선 패턴을 한번 이상 반복하게 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A' 또는 'B'가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[AB]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA', 'BB', 'A', 'B' ]</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="1-2-3-범위지정"><a href="#1-2-3-범위지정" class="headerlink" title="1.2.3 범위지정"></a>1.2.3 범위지정</h4><h5 id="대문자-알파벳"><a href="#대문자-알파벳" class="headerlink" title="대문자 알파벳"></a>대문자 알파벳</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB ZZ Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A' ~ 'Z'가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[A-Z]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA', 'BB', 'ZZ', 'A', 'B' ]</span></span><br></pre></td></tr></table></figure><hr><h5 id="대소문자-구별없는-알파벳-w"><a href="#대소문자-구별없는-알파벳-w" class="headerlink" title="대소문자 구별없는 알파벳 \w"></a>대소문자 구별없는 알파벳 <code>\w</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb'</span>;</span><br><span class="line"><span class="comment">// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[A-Za-z]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA', 'BB', 'Aa', 'Bb' ]</span></span><br></pre></td></tr></table></figure><p><code>\w</code>는 알파벳과 숫자를 의미한다. <code>\W</code>는 <code>\w</code>와 반대로 동작한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb 24,000'</span>;</span><br><span class="line"><span class="comment">// 알파벳과 숫자 또는 ','가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[\w,]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA', 'BB', 'Aa', 'Bb', '24,000' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 알파벳과 숫자가 아닌 문자 또는 ','가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[\W,]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ ' ', ' ', ' ', ' ', ',' ]</span></span><br></pre></td></tr></table></figure></p><hr><h5 id="숫자-추출하기"><a href="#숫자-추출하기" class="headerlink" title="숫자 추출하기"></a>숫자 추출하기</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb 24,000'</span>;</span><br><span class="line"><span class="comment">// '0' ~ '9'가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[0-9]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ '24', '000' ]</span></span><br></pre></td></tr></table></figure><p><code>,</code>때문에 분리되는 것을 막기 위해 <code>,</code>를 범위 안에 포함시킨다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb 24,000'</span>;</span><br><span class="line"><span class="comment">// '0' ~ '9' 또는 ','가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[0-9,]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ '24,000' ]</span></span><br></pre></td></tr></table></figure></p><p>숫자 추출하기를 간단하게 표현하면 아래와 같다.<br><code>\d</code>는 숫자를 의미한다. <code>\D</code>는 <code>\d</code>와 반대로 동작한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'AA BB Aa Bb 24,000'</span>;</span><br><span class="line"><span class="comment">// '0' ~ '9' 또는 ','가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[\d,]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ '24,000' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한번이상 반복되는 문자열을 반복 검색</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[\D,]+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(targetStr.match(regexr)); <span class="comment">// [ 'AA BB Aa Bb ', ',' ]</span></span><br></pre></td></tr></table></figure></p><hr><hr><h3 id="1-3-자주-사용하는-정규표현식"><a href="#1-3-자주-사용하는-정규표현식" class="headerlink" title="1.3 자주 사용하는 정규표현식"></a>1.3 자주 사용하는 정규표현식</h3><h4 id="1-3-1-특정단어로-시작"><a href="#1-3-1-특정단어로-시작" class="headerlink" title="1.3.1 특정단어로 시작? ^"></a>1.3.1 특정단어로 시작? <code>^</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'abcdef'</span>;</span><br><span class="line"><span class="comment">// 'abc'로 시작하지 검사</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/^abc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-특정단어로-끝나나"><a href="#1-3-2-특정단어로-끝나나" class="headerlink" title="1.3.2 특정단어로 끝나나? $"></a>1.3.2 특정단어로 끝나나? <code>$</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'abcdef'</span>;</span><br><span class="line"><span class="comment">// 'ef'로 끝나는지 검사</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/ef$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-숫자인가"><a href="#1-3-3-숫자인가" class="headerlink" title="1.3.3 숫자인가?"></a>1.3.3 숫자인가?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'12345'</span>;</span><br><span class="line"><span class="comment">// 모두 숫자인지 검사</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/^\d+$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="1-3-4-공백인가-s"><a href="#1-3-4-공백인가-s" class="headerlink" title="1.3.4 공백인가? \s"></a>1.3.4 공백인가? <code>\s</code></h4><p><code>\s</code>는 공백을 의미한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">' Hi!'</span>;</span><br><span class="line"><span class="comment">// 1개 이상의 공백으로 시작하는지 검사</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/^[\s]+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="1-3-5-아이디로-사용-가능한가"><a href="#1-3-5-아이디로-사용-가능한가" class="headerlink" title="1.3.5 아이디로 사용 가능한가? {}"></a>1.3.5 아이디로 사용 가능한가? <code>{}</code></h4><p><code>{}</code> : 자리수를 의미한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'abc123'</span>;</span><br><span class="line"><span class="comment">// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사</span></span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/^[A-Za-z0-9]&#123;4,10&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h4 id="1-3-6-메일주소-형식인가"><a href="#1-3-6-메일주소-형식인가" class="headerlink" title="1.3.6 메일주소 형식인가?"></a>1.3.6 메일주소 형식인가?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'ungmo2@gmail.com'</span>;</span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]&#123;2,3&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="1-3-7-현드폰-번호-형식인가"><a href="#1-3-7-현드폰-번호-형식인가" class="headerlink" title="1.3.7 현드폰 번호 형식인가?"></a>1.3.7 현드폰 번호 형식인가?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'010-1234-5678'</span>;</span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/^\d&#123;3&#125;-\d&#123;3,4&#125;-\d&#123;4&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="1-3-8-특수문자-포함인가"><a href="#1-3-8-특수문자-포함인가" class="headerlink" title="1.3.8 특수문자 포함인가?"></a>1.3.8 특수문자 포함인가?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetStr = <span class="string">'abc#123'</span>;</span><br><span class="line"><span class="keyword">var</span> regexr = <span class="regexp">/[\&#123;\&#125;\[\]\/?.,;:|\)*~`!^\-_+&lt;&gt;@\#$%&amp;\\\=\(\'\"]/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(regexr.test(targetStr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><hr><h2 id="2-JS-Regular-Expression"><a href="#2-JS-Regular-Expression" class="headerlink" title=" 2. JS Regular Expression"></a><a name="RegExp"></a> 2. JS Regular Expression</h2><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-regexp" target="_blank" rel="noopener">http://poiemaweb.com/js-regexp</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;정규표현식&lt;ol&gt;
&lt;li&gt;플래그&lt;/li&gt;
&lt;li&gt;패턴&lt;/li&gt;
&lt;li&gt;자주사용하는 정규표현식&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;JS Regular Expression&lt;ol&gt;

      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git rebase와 삽질</title>
    <link href="http://feel5ny.github.io/2018/01/05/log_003/"/>
    <id>http://feel5ny.github.io/2018/01/05/log_003/</id>
    <published>2018-01-05T14:23:55.000Z</published>
    <updated>2018-08-15T14:45:09.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>요즘 작업 중인 프로젝트에서 평소에 했던 방식처럼 한 기능 당, 한 테스크당 브랜치를 생성해서 작업하고 있었다. 개인프로젝트이기 때문에.. 따로 dev 브랜치는 만들진 않았고 master에서 작업 브랜치를 만들었는데, </p><h4 id="1-검색기능을-만들었어야-해서-master에서-Search-Todo라는-브랜치를-생성"><a href="#1-검색기능을-만들었어야-해서-master에서-Search-Todo라는-브랜치를-생성" class="headerlink" title="1. 검색기능을 만들었어야 해서 master에서 Search-Todo라는 브랜치를 생성"></a>1. 검색기능을 만들었어야 해서 <code>master</code>에서 <code>Search-Todo</code>라는 브랜치를 생성</h4><p><img src="/images/2018/04/git-log-01.jpg" width="400px"></p><h4 id="2-이미지-클릭시-다른-탭으로-이동하는-기능을-만들어야-해서-Move-Todo-to-Timer라는-브랜치-생성"><a href="#2-이미지-클릭시-다른-탭으로-이동하는-기능을-만들어야-해서-Move-Todo-to-Timer라는-브랜치-생성" class="headerlink" title="2. 이미지 클릭시 다른 탭으로 이동하는 기능을 만들어야 해서 Move Todo to Timer라는 브랜치 생성"></a>2. 이미지 클릭시 다른 탭으로 이동하는 기능을 만들어야 해서 <code>Move Todo to Timer</code>라는 브랜치 생성</h4><p><img src="/images/2018/04/git-log-02.jpg" width="400px"></p><h4 id="3-Move-Todo-to-Timer에서-작업하다-잘-안되는-부분이-있어서-다른-기능-구현시작-Search-Todo로-돌아가서-Add-Sound브랜치-생성"><a href="#3-Move-Todo-to-Timer에서-작업하다-잘-안되는-부분이-있어서-다른-기능-구현시작-Search-Todo로-돌아가서-Add-Sound브랜치-생성" class="headerlink" title="3. Move Todo to Timer에서 작업하다 잘 안되는 부분이 있어서 다른 기능 구현시작. Search-Todo로 돌아가서 Add-Sound브랜치 생성"></a>3. <code>Move Todo to Timer</code>에서 작업하다 잘 안되는 부분이 있어서 다른 기능 구현시작. <code>Search-Todo</code>로 돌아가서 <code>Add-Sound</code>브랜치 생성</h4><p><img src="/images/2018/04/git-log-03.jpg" width="400px"></p><h4 id="4-Add-Sound-작업이-잘-완료되어서-Search-Todo에-rebase-시킴"><a href="#4-Add-Sound-작업이-잘-완료되어서-Search-Todo에-rebase-시킴" class="headerlink" title="4. Add-Sound 작업이 잘 완료되어서 Search-Todo에 rebase 시킴"></a>4. <code>Add-Sound</code> 작업이 잘 완료되어서 Search-Todo에 rebase 시킴</h4><ul><li>사운드 작업이라서 Xcode를 좀 건드림.</li><li>게다가 Xcode를 중간에 업데이트해서 Xcode 파일 부분부분 변경됨</li></ul><p><img src="/images/2018/04/git-log-04.jpg" width="400px"><br><img src="/images/2018/04/git-log-04-01.jpg" width="400px"></p><h4 id="5-Move-Todo-to-Timer-작업이-끝나서-Search-Todo에-rebase-시키기로-함"><a href="#5-Move-Todo-to-Timer-작업이-끝나서-Search-Todo에-rebase-시키기로-함" class="headerlink" title="5. Move Todo to Timer 작업이 끝나서 Search-Todo에 rebase 시키기로 함"></a>5. <code>Move Todo to Timer</code> 작업이 끝나서 <code>Search-Todo</code>에 rebase 시키기로 함</h4><p><strong>문제 발생 지점</strong></p><ul><li>rebase시 각 커밋마다 rebase할 브랜치와 비교해서 충돌 지점을 체킹함.<ul><li>여기서 기존 코드랑 수신코드랑 다 받으면 되는거 아닌가 하겠지만,</li><li>그건 변경된 코드 부분마다 달라서 잘 확인을 하면서 받아야함.<ul><li>다행히 최근에 작업한 코드라 괜찮았지, 만약에 작업을 방대하게 많이 했거나 오래전에 작업했던 부분이었다면 더 문제됐을듯.</li><li><span style="color:red"><strong>여기서 Xcode 작업 코드를 잘못 받아버림.</strong></span> (흑흑흑흑 😫😫😫😫) </li></ul></li></ul></li><li>충돌 체킹 하고, 다시 <code>git add .</code>, <code>git rebase --continue</code>하면 다음 커밋 비교로 넘어감.<br><img src="/images/2018/04/git-log-05.jpg" width="400px"></li></ul><h4 id="6-Search-Todo브랜치에서-error"><a href="#6-Search-Todo브랜치에서-error" class="headerlink" title="6. Search-Todo브랜치에서 error.."></a>6. <code>Search-Todo</code>브랜치에서 error..</h4><p><code>Cannot read property &#39;IsAndroid&#39; of undefined</code> 이 에러를 넘어가질 않음.</p><ul><li>react-native-sound 모듈은 안드로이드 대응까지 하는데, react-native와 link되는 부분이 적용되지 않아서 나오는 문제라함.</li><li>사실 이 에러는 sound 모듈 처음 추가할때 나왔던 에러였는데 재실행해서 해결했던 기억이 남.</li><li>똑같이 해봤지만 안됨.<br><img src="/images/2018/04/error.png" width="400px"><blockquote><p>하 넘나 넘어가고싶었던 빨간색이었따..</p></blockquote></li></ul><p>나와 같은 문제를 겪은 사람 찾음</p><ul><li><a href="https://github.com/zmxv/react-native-sound/issues/36" target="_blank" rel="noopener">https://github.com/zmxv/react-native-sound/issues/36</a></li><li>그냥 컴파일 할때 생성되는 파일, 폴더들 다 삭제하고 다시 rebuild하거나, 터미널, 시뮬레이터 에디터 다 재시동 후에 다시 run하면 된다고 했지만..</li><li>난 뭔가 안됐다…. 후</li></ul><h4 id="7-다른-브랜치도-공통된-에러인가-해서-다시-Move-Todo-to-Timer로-돌아가봄"><a href="#7-다른-브랜치도-공통된-에러인가-해서-다시-Move-Todo-to-Timer로-돌아가봄" class="headerlink" title="7. 다른 브랜치도 공통된 에러인가 해서 다시 Move Todo to Timer로 돌아가봄."></a>7. 다른 브랜치도 공통된 에러인가 해서 다시 <code>Move Todo to Timer</code>로 돌아가봄.</h4><p>잘 작동됨</p><ul><li>진짜 Xcode를 잘못건드렸다는 것을 확신하게 되었다.</li></ul><h4 id="8-다시-Search-Todo로-돌아가서-확인했는데"><a href="#8-다시-Search-Todo로-돌아가서-확인했는데" class="headerlink" title="8. 다시 Search-Todo로 돌아가서 확인했는데"></a>8. 다시 <code>Search-Todo</code>로 돌아가서 확인했는데</h4><p>어랏? 잘 잘동됨</p><ul><li>순간적으로 더블체킹 하지않고.. 단순히 된다는 확신에 기쁜 마음으로 master에 merge시킴.</li><li>rebase 충돌 병합하다가 문제 생길까봐 이번에는 merge만 진행.</li></ul><h4 id="9-master-merge-이후에-순간-느껴지는-불안감에-다시-실행해봄"><a href="#9-master-merge-이후에-순간-느껴지는-불안감에-다시-실행해봄" class="headerlink" title="9. master merge 이후에 순간 느껴지는 불안감에.. 다시 실행해봄."></a>9. master merge 이후에 순간 느껴지는 불안감에.. 다시 실행해봄.</h4><p>하 안됨.<br><img src="/images/2018/04/error.png" width="400px"></p><blockquote><p>😵</p></blockquote><ul><li>8번에서 잘 작동된 이유는..컴파일을 다시 하고 확인했어야 했는데.. reload만해서 됐었던 것.</li><li>흐억. master에 잘못된 코드가 올라갔네.</li></ul><h4 id="10-그냥-돌아가자"><a href="#10-그냥-돌아가자" class="headerlink" title="10. 그냥 돌아가자.."></a>10. 그냥 돌아가자..</h4><p>문제가 발생했던 5번 이전으로 돌아가는게 그냥 좋겠다는 생각을 했음.</p><ul><li>master로 돌아가서 <code>git reset --hard 커밋주소</code></li><li>reset은 위험하고 거기에 –hard까지 붙이면 더더욱 위험하지만</li><li>Xcode라고 확신은 했지만, 정확하진 않았기 때문에.. 이전 커밋을 삭제하기로함.</li><li>어차피 문제가 발생했을 때의 브랜치에서 작업했던 코드량이 정말 적어서 다시 작업해도 괜찮았다.</li></ul><h4 id="11-master는-4번-상태로-다시-돌아갔다"><a href="#11-master는-4번-상태로-다시-돌아갔다" class="headerlink" title="11. master는 4번 상태로 다시 돌아갔다."></a>11. master는 4번 상태로 다시 돌아갔다.</h4><ul><li>Sound만 잘 적용된 상태</li><li>master에서 새로운 브랜치 생성해서 (<code>Move to Timer</code>) 다시 작업 후 master에 merge 시킴<ul><li>지금 생각해보면 <code>Search-Todo</code>에서 충돌 전 커밋 <code>cherry-pick</code>으로 갖고와도 됐는데</li></ul></li></ul><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><ul><li>git rebase 이후 충돌 병합시 신중하자</li><li>master나 dev같이 root branch에 merge하기 전에 신중하자</li><li>git 공부 더하자</li><li>한 브랜치에서 2가지 브랜치를 생성할 경우 신중하자.</li></ul><p>참고링크<br>rebase <a href="https://backlog.com/git-tutorial/kr/stepup/stepup6_4.html" target="_blank" rel="noopener">https://backlog.com/git-tutorial/kr/stepup/stepup6_4.html</a><br>cherry-pick <a href="https://backlog.com/git-tutorial/kr/stepup/stepup2_8.html" target="_blank" rel="noopener">https://backlog.com/git-tutorial/kr/stepup/stepup2_8.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;요즘 작업 중인 프로젝트에서 평소에 했던 방식처럼 한 기능 당, 한 테스크당 브랜치를 생성해서 작업하고 있었다. 개인프로젝트이
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="log" scheme="http://feel5ny.github.io/categories/TIL-9997/log/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>기타 용어들</title>
    <link href="http://feel5ny.github.io/2018/01/02/CS_07/"/>
    <id>http://feel5ny.github.io/2018/01/02/CS_07/</id>
    <published>2018-01-02T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:23.805Z</updated>
    
    <content type="html"><![CDATA[<p>목록</p><ol><li><a href="#dns">dns</a></li><li><a href="#subnet">subnet</a></li><li><a href="#NAT">NAT</a></li><li><a href="#port">port</a></li><li><a href="#socket">socket</a></li><li><a href="#mac-address">mac address</a></li></ol><hr><h1 id="1-dns"><a href="#1-dns" class="headerlink" title=" 1. dns"></a><a name="dns"></a> 1. dns</h1><p>DNS(도메인 네임 시스템)는 <code>.com</code> 또는 <code>.net</code>과 같은 특정 최상위 도메인(TLD)의 모든 도메인 네임 및 해당하는 IP 주소를 저장하는 데이터베이스입니다. DNS는 인터넷에서 컴퓨터 시스템과 리소스를 식별하고 찾습니다. 예를 들어, 웹 주소 또는 URL을 입력하면 DNS가 입력된 이름과 해당 위치의 IP 주소를 일치시키고 사용자를 해당 사이트에 연결시켜 줍니다.</p><p><img src="/images/2018/02/dns1.png"></p><hr><h1 id="2-subnet"><a href="#2-subnet" class="headerlink" title=" 2. subnet"></a><a name="subnet"></a> 2. subnet</h1><ul><li>서브넷(subnet)은 “subnetwork”을 줄인 말로서 어떤 기관에 소속된 네트웍이지만 따로 분리되어 있는 한 부분으로 인식될 수 있는 네트웍을 말한다. </li><li>일반적으로 하나의 서브넷은 하나의 지역, 한 빌딩 또는 같은 근거리통신망 내에 있는 모든 컴퓨터들을 나타낼 수 있다.</li><li><p>여러 개의 서브넷으로 나뉘어진 어떤 조직의 네트웍은 인터넷에 하나의 공유된 네트웍 주소로 접속될 수 있다. 만약 서브넷이 없다면, 그 조직은 물리적으로 분리된 서브 네트웍마다 하나씩, 여러 군데의 인터넷 접속을 가지게 될 것이며, 그렇게 함으로써 한정된 량의 인터넷 주소가 쓸모 없이 낭비될 수도 있게된다.</p></li><li><p>인터넷은 네트웍 사용자들 간에 서로 커뮤니케이션을 하기 위한 네트웍의 집합이다. </p></li><li>커뮤니케이션을 위해서는 양측의 사용자 또는 호스트가 관련되어 있는 발신지와 도착지 네트웍, 그리고 네트웍 내의 특정한 컴퓨터의 주소가 있어야 한다. 이 주소를 IP 주소라고 부른다. </li><li>32 비트의 IP 주소는 크게 두 부분으로 나뉘는데, 하나는 네트웍을 식별하는 네트웍 번호이고, 다른 하나는 네트웍 내의 특정한 컴퓨터나 호스트를 식별하는 호스트 번호이다. </li><li>한 기관에서 특정한 서브넷을 확인시키기 위해 컴퓨터나 호스트를 식별하는 주소 내의 비트들을 일부 사용할 수 있다. </li><li><p>그러므로 실제로는 IP 주소에는 네트웍 번호, 서브넷 번호, 그리고 컴퓨터 번호 등 세 부분이 포함되어 있는 셈이다.<br><img src="/images/2018/02/ipaddress.jpg"></p></li><li><p><a href="https://www.icann.org/" target="_blank" rel="noopener">https://www.icann.org/</a></p></li></ul><hr><h1 id="3-NAT-Network-Address-Translation"><a href="#3-NAT-Network-Address-Translation" class="headerlink" title=" 3. NAT (= Network Address Translation)"></a><a name="NAT"></a> 3. NAT (= Network Address Translation)</h1><ul><li>NAT는 외부 네트웍에 알려진 것과 다른 IP 주소를 사용하는 내부 네트웍에서, IP 주소를 변환하는 것이다. </li><li>일반적으로, 한 회사는 자신의 내부 네트웍 주소를 하나 또는 그 이상의 공인 IP 주소로 사상한다. 그리고 들어오는 패킷들 상의 공인 IP 주소를 다시 사설 IP 주소로 변환한다. </li><li>이렇게 함으로써 나가거나 들어오는 각 요구들은 주소 변환과정을 반드시 거쳐야 하기 때문에, </li><li>보안문제를 확실하게 하는데 도움이 되며, 또한 </li><li>요구를 제한하거나 인증하고, 또 </li><li>이전의 요구와 일치시키는 기회를 제공한다. </li><li><p>NAT은 또한 회사에서 필요한 공인 IP 주소의 수를 보존하며, 회사가 외부 네트웍과의 통신에서 단 하나의 공인 IP 주소를 사용할 수 있게 한다.</p></li><li><p>NAT은 라우터의 일부로서 포함되며, 종종 통합된 방화벽의 일부가 되기도 한다. </p></li><li>네트웍 관리자들은 공인 IP 주소에서 사설 IP 주소로, 사설 IP 주소에서 공인 IP 주소로 사상하기 위한 NAT 표를 만든다. </li><li>NAT은 라우팅 정책과 함께 사용될 수도 있다. </li><li>NAT은 IP 주소를 정적으로 정의하거나, 또는 동적으로 변환하도록 설정될 수 있다. 시스코에서 만든 NAT 버전은 관리자가 다음과 같은 것들의 사상을 위한 표를 만들도록 해 준다.</li></ul><p><img src="/images/2018/02/nat.gif"></p><hr><h1 id="4-port"><a href="#4-port" class="headerlink" title=" 4. port"></a><a name="port"></a> 4. port</h1><p>네트워크의 입출력단자들을 포트(PORT)라고 하며 번호로 지정되는데 포트의 번호는 0에서 65535까지 입니다.<br>TCP/IP 네트웍에서 포트 번호는, 들어오는 트래픽을 컴퓨터 내에서 실행되고 있는 적절한 프로그램에 분배시키기 위해 할당되는 숫자를 말한다. 이것은 물리적인 플러그나 소켓이 아니며, 다만 <strong>논리적인 할당</strong>일 뿐이다</p><ul><li>프로그래밍에서, 포트는 “논리적인 접속장소”이며, 특히 인터넷 프로토콜인 TCP/IP를 사용할 때에는 클라이언트 프로그램이 네트웍 상의 특정 서버 프로그램을 지정하는 방법으로 사용된다. </li><li>웹 프로토콜인 HTTP와 같이, TCP/IP의 상위 프로토콜을 사용하는 응용프로그램에서는 미리 지정된 포트번호들을 가지고 있다. </li><li>이런 것들은 IANA에 의해 지정되었으며, “잘 알려진 포트들”이라고 불린다. </li><li>다른 응용프로그램 프로세스들은 매번 접속할 때마다 포트번호가 동적으로 부여된다. 서버 프로그램이 처음 시작되면, 지정된 포트번호로 바인드된다. 그 서버를 사용하려는 모든 클라이언트 프로그램들은 지정된 포트번호에 바인드해야만 한다. </li><li>바인드가 되면  두개의 컴퓨터간 네트워크를 이용한 통신시 발신지 컴퓨터에서 출발한 사용자 데이터(패킷)는 TCP/IP의 각 계층을 거치면서 최종적으로 목적지 주소(IP)를 가지고 있는 컴퓨터에 도착하게 됩니다. 패킷을 수신한 컴퓨터는 전송시에 사용되었던 주소필드를 제거하고, 패킷 안에 있는 데이터만을 응용프로그램에 넘겨줍니다. </li></ul><p>이 포트들은 크게 세 가지 영역으로 나누어서 지정되어 있습니다.</p><h3 id="1-0번-포트에서-1023포트-까지"><a href="#1-0번-포트에서-1023포트-까지" class="headerlink" title="1. 0번 포트에서 1023포트 까지"></a>1. 0번 포트에서 1023포트 까지</h3><p>well-known port number 라고 하며 미리 특수용도로 지정되어 있습니다. (IANA(Internet Assigned Numbers Authority)에서 관리한다.)</p><p>21번: FTP<br>22번: SSH<br>23번: TELNET<br>25번: SMTP(이메일송신)<br>53번: DNS<br>61번: SNMP(네트워크관리)<br>80번: HTTP(웹페이지를 열기 위한 용도)<br>110번: POP3(이메일수신)<br>115번: SFTP<br>135번: RPC<br>139번: NetBIOS<br>143번: IMAP<br>194: IRC<br>443: SSL<br>445: SMB</p><h3 id="2-등록된-포트로-사용할-경우-1024-49151번을-사용합니다"><a href="#2-등록된-포트로-사용할-경우-1024-49151번을-사용합니다" class="headerlink" title="2. 등록된 포트로 사용할 경우 1024~49151번을 사용합니다."></a>2. 등록된 포트로 사용할 경우 1024~49151번을 사용합니다.</h3><p>1433: MSQL<br>3306: MySQL<br>3389: Remote Desktop<br>5632: PCAnywhere<br>5900: VNC<br>6112: Warcraft III</p><h3 id="3-개인적-용도라면-49152-65535번을-사용하도록-규정되어-있습니다"><a href="#3-개인적-용도라면-49152-65535번을-사용하도록-규정되어-있습니다" class="headerlink" title="3. 개인적 용도라면 49152~65535번을 사용하도록 규정되어 있습니다."></a>3. 개인적 용도라면 49152~65535번을 사용하도록 규정되어 있습니다.</h3><p>클라이언트/서버 방식의 프로그램에서 포트의 사용</p><ol><li>서버/클라이언트 프로그램에서는 서버에서 사용하는 포트번호를 클라이언트 프로그램에서도 동일하게 맞추어 주어야 합니다.</li><li>서버/클라이언트 프로그램에서 사용하는 포트가 개방되도록 라우터 또는 공유기 등의 설정메뉴에서 개방해야 합니다.</li><li>서버/클라이언트 프로그램에서 포트를 설정하지 않으면 임의로 포트를 설정해 주는 프로그램이 일부 있습니다.</li></ol><hr><h1 id="5-socket"><a href="#5-socket" class="headerlink" title=" 5. socket"></a><a name="socket"></a> 5. socket</h1><ul><li>두 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 양쪽에 생성되는 <strong>링크의 단자</strong>입니다.</li><li>두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있습니다.</li><li>결국 소켓이 구현됨으로써 네트워크 및 전송 계층의 캡슐화가 가능해집니다. </li><li><p>소켓은 원래 캘리포니아 버클리 대학 분교에서 UNIX용으로 개발되었으며,  UNIX에서의 입출력 메소드의 표준인 개방/읽기/쓰기/닫기 메커니즘을 따릅니다.</p></li><li><p>소켓 함수는 동기모드(블록킹) / 비동기 모드 (논블록킹)으로 동작합니다.</p></li><li>차이점은 만약 데이터가 도착하지 않는 상태에서 recv()로 데이터를 수신하고자 했을 때 데이터가 올 때까지 대기(block)하느냐 , 그냥 수신된 데이터가 없다는 정보만 리턴하고 넘어가느냐 입니다.</li><li>실제로 대기한다는 의미는 시스템을 멈추고 기다린다는 것이 아니라 다른 쓰레드나 프로세스(process)로 실행 권을 넘기는 것이기 때문에 프로세서는 항상 적절한 동작을 하게 됩니다.</li><li>비동기 모드로 데이터가 올 떄까지 풀링(polling)하면서 대기하는 것과는 기다린다는 의미에서는 동일하지만 프로세서를 활용한다는 면에서는 하늘과 땅 차이라고 할 수 있습니다. 이런 병렬적인 처리에 대한 고려가 필요하게 됩니다.</li><li>그리고 직접적인 소켓 통신을 처리하는 함수는 아니지만 소켓 처리에 대해서 Multiplex처리(하나의 쓰레드, 혹은 적은 수의 쓰레드에서 여러 개의 소켓을 처리)를 해주는 select , epoll , IOCP 같은 기능적인 함수군도 염두해 두어야겠습니다.</li></ul><h2 id="6-MAC-address-Media-Access-Control-Address"><a href="#6-MAC-address-Media-Access-Control-Address" class="headerlink" title=" 6. MAC address (= Media Access Control Address)"></a><a name="mac-address"></a> 6. MAC address (= Media Access Control Address)</h2><p>MAC 주소는, 무선 LAN 카드 또는 무선 LAN 기능 내장 기기에 개별적으로 부여되는 16진수 12자리의 단말 식별 번호(예:12:34:56:78:90:AB)입니다. OS에 따라 “물리적 주소” 또는”Wi-Fi 주소”라고 표시됩니다.</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><ul><li>동적 IP 할당</li></ul><ol><li>특정 IP에서 오는 것 차단<ul><li>ex. 특정 사이트 차단. 접속을 못하게 함. </li><li>공유기 안에 혹은 라우팅 컴퓨터 안에서 설정.</li></ul></li><li>특정 포트만 전송 가능</li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://www.verisign.com/ko_KR/website-presence/online/domain-name-system/index.xhtml" target="_blank" rel="noopener">https://www.verisign.com/ko_KR/website-presence/online/domain-name-system/index.xhtml</a></li><li><a href="https://www.verisign.com/assets/DNS101_ko_KR.pdf" target="_blank" rel="noopener">https://www.verisign.com/assets/DNS101_ko_KR.pdf</a></li><li><a href="http://www.terms.co.kr/subnet.htm" target="_blank" rel="noopener">http://www.terms.co.kr/subnet.htm</a></li><li><a href="http://www.terms.co.kr/NAT.htm" target="_blank" rel="noopener">http://www.terms.co.kr/NAT.htm</a></li><li><a href="http://egloos.zum.com/Esunny/v/4130787" target="_blank" rel="noopener">http://egloos.zum.com/Esunny/v/4130787</a></li><li><a href="http://popbox.tistory.com/66" target="_blank" rel="noopener">http://popbox.tistory.com/66</a></li><li><a href="https://ko.wikipedia.org/wiki/MAC_%EC%A3%BC%EC%86%8C" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/MAC_%EC%A3%BC%EC%86%8C</a></li><li><a href="http://popbox.tistory.com/66" target="_blank" rel="noopener">http://popbox.tistory.com/66</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;목록&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#dns&quot;&gt;dns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#subnet&quot;&gt;subnet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#NAT&quot;&gt;NAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#port&quot;&gt;por
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CS" scheme="http://feel5ny.github.io/categories/TIL-9997/CS/"/>
    
    
      <category term="CS" scheme="http://feel5ny.github.io/tags/CS/"/>
    
      <category term="network" scheme="http://feel5ny.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>3 way handshake</title>
    <link href="http://feel5ny.github.io/2018/01/01/CS_06/"/>
    <id>http://feel5ny.github.io/2018/01/01/CS_06/</id>
    <published>2018-01-01T01:23:55.000Z</published>
    <updated>2018-08-15T14:44:21.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-way-handshake"><a href="#3-way-handshake" class="headerlink" title="3 way handshake"></a>3 way handshake</h2><p>Client와 Server 또는 P2P Socket 통신 등, 네트워크를 사용한 통신시 TCP 통신을 많이 사용한다.<br>TCP 통신을 위한 네트워크 연결은 3 way handshake 라는 방식으로 연결된다.<br>쉽게 이야기 하면, 서로의 통신을 위한 관문(port)을 확인하고 연결하기 위하여 3번의 요청/응답 후에 연결이 되는 것이다.</p><p><img src="/images/2018/01/handshake.jpg"></p><p>먼저 Server에서 열려있는 포트는 LISTEN 상태이고 Client에서는 Closed 상태이다.</p><ol><li><p>Client에서 Server에 연결 요청을 하기위해 SYN 데이터를 보낸다. (SYN = synchronize sequence numbers)</p></li><li><p>Server에서 해당 포트는 LISTEN 상태에서 SYN 데이터를 받고 SYN_RCV로 상태가 변경된다.<br>그리고 요청을 정상적으로 받았다는 대답(ACK)와 Client도 포트를 열어달라는 SYN 을 같이 보낸다.<br>(ACK = acknowledgment)</p></li><li><p>Client에서는 SYN+ACK 를 받고 ESTABLISHED로 상태를 변경하고 서버에 요청을 잘 받았다는 ACK 를 전송한다.<br>ACK를 받은 서버는 상태가 ESTABLSHED로 변경된다.</p></li></ol><p>위와 같이 3번의 통신이 정상적으로 이루어지면, 서로의 포트가 ESTABLISHED 되면서 연결이 되게 된다.</p><h3 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h3><ul><li>Closed : 닫힌 상태</li><li>LISTEN : 포트가 열린 상태로 연결 요청 대기 중</li><li>SYN_RCV : SYNC 요청을 받고 상대방의 응답을 기다리는 중</li><li>ESTABLISHED : 포트 연결 상태</li></ul><p>현재의 포트 상태 확인은 netstat 명령어로 할 수 있다.</p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://hyeonstorage.tistory.com/286" target="_blank" rel="noopener">http://hyeonstorage.tistory.com/286</a></li><li><a href="http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake" target="_blank" rel="noopener">http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-way-handshake&quot;&gt;&lt;a href=&quot;#3-way-handshake&quot; class=&quot;headerlink&quot; title=&quot;3 way handshake&quot;&gt;&lt;/a&gt;3 way handshake&lt;/h2&gt;&lt;p&gt;Client와 Server 또는 
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CS" scheme="http://feel5ny.github.io/categories/TIL-9997/CS/"/>
    
    
      <category term="CS" scheme="http://feel5ny.github.io/tags/CS/"/>
    
      <category term="network" scheme="http://feel5ny.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>8/ DOM 확장</title>
    <link href="http://feel5ny.github.io/2017/12/28/JS_08_4/"/>
    <id>http://feel5ny.github.io/2017/12/28/JS_08_4/</id>
    <published>2017-12-28T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><hr><hr><p><strong>목차</strong></p><ol><li>선택자 API<ol><li>querySelector() 메서드</li><li>querySelectorAll() 메서드</li><li>matchesSelector() 메서드</li></ol></li><li>요소 간 이동</li><li>HTML5<ol><li>클래스 관련 추가사항<ul><li>getElementsByClassName() 메서드</li><li>classList 프로퍼티</li></ul></li><li>포커스 관리</li><li>HTMLDocument의 변화<ul><li>readyState 프로퍼티</li><li>호환성 모드</li></ul></li><li>문자셋 프로퍼티</li><li>커스텀 데이터 속성</li><li>마크업 삽입<ul><li>innerHTML</li><li>outerHTML</li><li>insertAdjacentHTML() 메서드</li><li>메모리와 성능 문제</li></ul></li><li>scrollIntoView() 메서드</li></ol></li><li>전용 확장<ol><li>문서모드</li><li>children 프로퍼티</li><li>contains() 메서드</li><li>마크업 삽입<ul><li>innerText 프로퍼티</li><li>outerText 프로퍼티</li></ul></li><li>스크롤</li></ol></li></ol><hr><hr><p>DOM은 그 자체로도 매우 잘 정의된 API이긴 하지만, 특정 브라우저 전용 방법으로 확장하여 기능을 추가할 때도 많다.</p><h2 id="1-선택자-API"><a href="#1-선택자-API" class="headerlink" title=" 1. 선택자 API"></a><a name="location"></a> 1. 선택자 API</h2><ul><li>자바스크립트 라이브러리 중에 가장 인기 있는 기능은 CSS 선택자로 패턴을 만들고 그에 맞는 DOM 요소를 선택하는 능력이다. </li><li>선택자 API는 CSS 쿼리에 대한 브라우저의 네이티브 지원으로 W3C에서 명세화를 시작햇다.</li><li>이 기능을 구현한 자바스크립트 라이브러리들은 모두 기초적인 CSS 파서를 직접 만들고, 기존의 DOM 메서드를 이용해 문서 노드를 이동하며 <strong>패턴에 일치하는 노드를 골라내는 방식</strong>을 사용했다.</li><li><code>querySelector()</code></li><li><code>querySelectorAll()</code></li><li>Document 타입과 Element타입에서 사용가능하다.</li></ul><h3 id="1-1-querySelector-메서드"><a href="#1-1-querySelector-메서드" class="headerlink" title="1-1. querySelector() 메서드"></a>1-1. querySelector() 메서드</h3><ul><li>매개변수로 CSS 쿼리를 받는다.</li><li>패턴에 일치하는 첫번째 자손 요소를 반환한다. 없으면 null</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body 요소를 가져온다.</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID가 "myDiv"인 요소를 가져온다.</span></span><br><span class="line"><span class="keyword">const</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스가 "selected"인 요소 중 첫 번째를 가져온다.</span></span><br><span class="line"><span class="keyword">const</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스가 "button"인 이미지 중 첫 번째를 가져온다.</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure><h3 id="1-2-querySelectorAll-메서드"><a href="#1-2-querySelectorAll-메서드" class="headerlink" title="1-2. querySelectorAll() 메서드"></a>1-2. querySelectorAll() 메서드</h3><ul><li>querySelector()와 유사한데, 일치하는 노드 전체를 반환한다.</li><li>즉, HTMLCollection(live)이 아닌 NodeList(non-live), 정적 인스턴스를 반환한다. (유사배열 형태)</li><li>매개변수에는 여러 CSS 쿼리를 넣어도 된다. <code>&quot;h1, h2, h3&quot;</code></li></ul><h3 id="1-3-matchesSelector-메서드-matches-로-변경됨"><a href="#1-3-matchesSelector-메서드-matches-로-변경됨" class="headerlink" title="1-3. matchesSelector() 메서드 ( matches()로 변경됨 ) +"></a>1-3. matchesSelector() 메서드 ( matches()로 변경됨 ) <a href="https://developer.mozilla.org/ko/docs/Web/API/Element/matches" target="_blank" rel="noopener">+</a></h3><ul><li>선택자 API 레벨2 명세</li><li>매개변수로 CSS 선택자를 받고 요소가 그에 일치하면 true, 일치하지 않으면 false</li></ul><hr><hr><h2 id="2-요소-간-이동"><a href="#2-요소-간-이동" class="headerlink" title=" 2. 요소 간 이동"></a><a name="location"></a> 2. 요소 간 이동</h2><ul><li>버전 9 미만의 IE는 타 브라우저와 달리 요소 사이의 공백을 텍스트 노드로 반환하지 않는다. </li><li>이 때문에 childNodes나 firstChild 같은 프로퍼티를 사용할 때 차이가 발생한다. </li><li>DOM 명세를 유지하면서 브라우저 사이의 차이를 극복하려는 노력으로 요소간 이동 명세에서는 새 프로퍼티 그룹을 정의햇다.</li></ul><p>요소간 이동 API에서 추가된 새 프로퍼티들</p><ul><li><code>childElementCount</code> : <strong>자식 요소 숫자</strong>를 반환하되 텍스트 노드와 주석은 제외한다.</li><li><code>firstElementChild</code> : 첫번째 자식 요소를 가리킨다. </li><li><code>lastElementChild</code> : 마지막 자식 요소를 가리킨다.</li><li><code>previousElementSibling</code> : 이전 형제 요소를 가리킨다. </li><li><code>nextElementSibling</code> : 다음 형제 요소를 가리킨다. </li></ul><hr><hr><h2 id="3-HTML5"><a href="#3-HTML5" class="headerlink" title=" 3. HTML5"></a><a name="location"></a> 3. HTML5</h2><ul><li>이전의 HTML 명세는 자바스크립트 인터페이스에 대해서는 간단히만 설명하고 마크업 언어에만 집중했으며 자바스크립트와의 연결은 DOM으로 미뤘다. </li><li>HTML5 명세는 마크업 언어와 함께 사용하도록 디자인된 자바스크립트 API를 상세히 설명하고 정의한다.</li></ul><h3 id="3-1-클래스-관련-추가사항"><a href="#3-1-클래스-관련-추가사항" class="headerlink" title="3-1. 클래스 관련 추가사항"></a>3-1. 클래스 관련 추가사항</h3><h4 id="getElementsByClassName-메서드"><a href="#getElementsByClassName-메서드" class="headerlink" title="getElementsByClassName() 메서드"></a><code>getElementsByClassName()</code> 메서드</h4><ul><li>클래스 이름 문자열을 매개변수로 받는다.</li><li>반환값 : HTMLCollection (live)</li><li>호출한 요소의 자손만 쿼리하여 반환한다.</li></ul><h4 id="반환값이-살아있는-객체라서-생기는-이슈"><a href="#반환값이-살아있는-객체라서-생기는-이슈" class="headerlink" title="반환값이 살아있는 객체라서 생기는 이슈"></a>반환값이 살아있는 객체라서 생기는 이슈</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTMLCollection을 반환한다.</span></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 클래스 어트리뷰트의 값을 변경한다.</span></span><br><span class="line">  elems[i].className = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// blue red blue</span></span><br></pre></td></tr></table></figure><p>HTMLCollection은 실시간으로 Node의 상태 변경을 반영한다. (live HTMLCollection)<br>실시간으로 Node의 상태 변경을 반영하기 때문에 loop가 필요한 경우 주의가 필요하다.<br>아래와 같은 방법으로 회피할 수 있다.</p><p>방법1 &gt; 역방향으로 돌리기<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'red'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = elems.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  elems[i].className = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>방법2 &gt; none-live NodeList를 반환하는 querySelectorAll을 사용한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// querySelectorAll는 Nodelist(non-live)를 반환한다. IE8+</span></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.red'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">  elems[i].className = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="classList-프로퍼티"><a href="#classList-프로퍼티" class="headerlink" title="classList 프로퍼티"></a>classList 프로퍼티</h4><ul><li>클래스 이름을 조작할 때는 <code>className</code> 프로퍼티를 이용해 클래스 이름을 추가하거나 제거, 교체했다.<ul><li>한 요소에 클래스가 3가지가 적용되어 있을 경우 이름 변경에 불편함이 있다.</li></ul></li><li>classList 프로퍼티는 <a href="https://developer.mozilla.org/ko/docs/Web/API/DOMTokenList" target="_blank" rel="noopener">DOMTokenList</a>란 새 컬렉션 타입의 인스턴스이다.<ul><li>다른 DOM 컬렉션과 마찬가지로 length존재 item() 메서드나 대괄호 표기법을 통해 데이터를 갖고올 수 있다.</li></ul></li><li>크롬과 파폭3.6이상 가능</li></ul><p><img src="/images/post_img/61/01.png"></p><p><a href="https://developer.mozilla.org/ko/docs/Web/API/DOMTokenList" target="_blank" rel="noopener">DOMTokenList</a>의 메서드</p><ul><li>add(value) : 주어진 문자열 값을 목록에 추가한다.</li><li>contains(value) : 주어진 값이 목록에 존재하면 true, 그렇지 않으면 false</li><li>remove(value) : 주어진 문자열 값을 목록에서 제거</li><li>toggle(value) : 값이 목록에 존재하면 제거하고 그렇지 않으면 추가</li></ul><hr><h3 id="3-2-포커스-관리"><a href="#3-2-포커스-관리" class="headerlink" title="3-2. 포커스 관리"></a>3-2. 포커스 관리</h3><ul><li>어느 요소에 포커스가 있는지, 현재 문서에 포커스가 있는지 판단하는 능력은 웹 접근성에 대단히 중요.</li></ul><h4 id="document-activeElement"><a href="#document-activeElement" class="headerlink" title="document.activeElement"></a><code>document.activeElement</code></h4><ul><li>항상 현재 포커스를 가진 DOM 요소를 가리키는 포인터를 포함한다.</li><li>키보드 탭 키를 통한 포커스, focus() 메서드로 자동 포커스를 받는다.</li></ul><h4 id="document-hasFocus"><a href="#document-hasFocus" class="headerlink" title="document.hasFocus()"></a><code>document.hasFocus()</code></h4><ul><li>문서에 포커스가 있는지 나타내는 불리언 값을 반환한다.</li></ul><hr><h3 id="3-3-HTMLDocument의-변화"><a href="#3-3-HTMLDocument의-변화" class="headerlink" title="3-3. HTMLDocument의 변화"></a>3-3. HTMLDocument의 변화</h3><h4 id="readyState-프로퍼티"><a href="#readyState-프로퍼티" class="headerlink" title="readyState 프로퍼티"></a>readyState 프로퍼티</h4><ul><li>readyState 프로퍼티에 가능한 값은 2가지 이다.<ul><li>loading</li><li>complete</li></ul></li><li>문서를 불러왔는지 확인하는 것</li><li>보통은 onload 이벤트 핸들러를 사용했다.</li></ul><h4 id="lt-head-gt-프로퍼티"><a href="#lt-head-gt-프로퍼티" class="headerlink" title="&lt;head&gt; 프로퍼티"></a><code>&lt;head&gt;</code> 프로퍼티</h4><ul><li><code>document.head</code>로도 <code>&lt;head&gt;</code>요소 참조가 가능하다.</li><li>크롬과 사파리 5 가능</li></ul><hr><h3 id="3-4-문자셋-프로퍼티"><a href="#3-4-문자셋-프로퍼티" class="headerlink" title="3-4. 문자셋 프로퍼티"></a>3-4. 문자셋 프로퍼티</h3><ul><li>문서의 문자셋을 다루는 프로퍼티</li></ul><h4 id="document-charset"><a href="#document-charset" class="headerlink" title="document.charset"></a><code>document.charset</code></h4><ul><li>문서의 문자셋을 나타내며, 새 문자셋 지정도 가능</li><li>파폭, 사파리, 오페라, 크롬</li></ul><h4 id="document-defaultCharset"><a href="#document-defaultCharset" class="headerlink" title="document.defaultCharset"></a><code>document.defaultCharset</code></h4><ul><li>브라우저 및 시스템의 기본 설정에 따라 문서에 기본적으로 적용해야 할 문자셋을 나타낸다.</li><li>IE, 사파리, 크롬</li></ul><hr><h3 id="3-5-커스텀-데이터-속성-data"><a href="#3-5-커스텀-데이터-속성-data" class="headerlink" title="3-5. 커스텀 데이터 속성 data-"></a>3-5. 커스텀 데이터 속성 <code>data-</code></h3><ul><li>HTML5 요소에서는 요소의 렌더링에 필요한 정보나 시맨틱 값이 아닌 데이터를 접두사 <strong>data-</strong>가 붙은 비표준 속성에 제공하도록 한다.</li><li>data- 뒤에는 자유롭게 네이밍</li><li>요소의 <strong>dataset</strong>프로퍼티를 통해 접근할 수 있다.</li><li>이름-값 쌍으로 이루어진 <code>DOMStringMap</code> 인스턴스이다.</li><li>커스텀 데이터 속성은 요소에 데이터를 연결해야 하지만 사용자에게는 보이고 싶지 않을 때 유용하다.</li><li>이 테크닉은 링크 추적, 매시업에서 페이지 각 부분의 식별자로 흔히 쓰인다.</li></ul><p><img src="/images/post_img/61/03.png"><br><img src="/images/post_img/61/02.png"></p><hr><h3 id="3-6-마크업-삽입"><a href="#3-6-마크업-삽입" class="headerlink" title="3-6. 마크업 삽입"></a>3-6. 마크업 삽입</h3><p>마크업이 포함된 콘텐츠를 추가하는 것은 <a href="https://namu.wiki/w/XSS" target="_blank" rel="noopener">크로스 스크립팅 공격</a>(XSS: Cross-Site Scripting Attacks)에 취약하다.</p><hr><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><ol><li>읽기모드 : 요소와 주석, 텍스트 노드 등의 자식 노드를 모두 나타내는 HTML 표현을 반환한다.<ul><li>innerHTML이 어떤 텍스트를 반활할지는 브라우저마다 다르다.</li></ul></li><li>쓰기모드 : 주어진 값을 바탕으로 새 DOM 서브트리를 만들어서 요소의 잣기 노드를 완전히 교체한다.<ul><li>주어진 문자열을 DOM 서브트리로 파싱해 이미 존재하는 자식 노드를 모두 교체한다.</li></ul></li></ol><ul><li>모든 요소가 innerHTML을 지원하지 않는다. <ul><li>col, colgroup, framset, head, html, style, table, tbody, thead, tfoot, tr, title도 지원하지 않는다.</li></ul></li></ul><hr><h4 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h4><ol><li>읽기모드 : 호출한 HTML 요소를 자식 노드와 <strong>함께</strong> 반환</li><li>쓰기모드 : 주어진 HTML 문자열을 파싱하여 DOM 서브트리를 생성하고 호출한 노드 전체를 교환하다.</li></ol><ul><li>나머지 특징은 innerHTML과 동일</li></ul><hr><h4 id="insertAdjacentHTML-메서드"><a href="#insertAdjacentHTML-메서드" class="headerlink" title="insertAdjacentHTML() 메서드"></a>insertAdjacentHTML() 메서드</h4><ul><li>삽입할 위치와 HTML 텍스트 두 가지를 매개변수로 받는다.</li></ul><p>삽입할 위치 매개변수</p><ul><li><code>beforebegin</code> : 호출한 요소 바로 앞에 삽입</li><li><code>afterbegin</code> : 호출한 요소 첫번째 자식 요소 바로 앞에 삽입</li><li><code>beforeend</code> : 호출한 요소 마지막 자식 요소 바로 다음에 삽입</li><li><code>afterend</code> : 호출한 요소 바로 다음에 삽입</li></ul><p><img src="/images/post_img/61/04.png"></p><hr><h4 id="메모리와-성능-문제"><a href="#메모리와-성능-문제" class="headerlink" title="메모리와 성능 문제"></a>메모리와 성능 문제</h4><ul><li>위의 메서드들로 자식 노드를 교체하면 메모리에 문제가 생길 수 있는데 IE가 특히 심하다.<br>문제가 발생하는 지점</li><li>제거한 서브트리 요소에 이벤트 핸들러나 기타 자바스크립트 객체가 할당되어 있을 때</li><li>위의 상태에서 해당 핸들러나 프로퍼티를 사용하여 요소를 문서트리에서 제거한다면, 요소와 이벤트 핸들러 사이의 연결이 메모리에 남는다.<ul><li>이른 작업이 계속되면 메모리 사용량이 점점 늘어난다.</li><li>innerHTML, insertAdjacentHTML() 사용할 때는 제거할 요소의 이벤트 핸들러나 자바스크립트 객체 프로퍼티를 모두 제거하길 권한다.</li></ul></li></ul><hr><h3 id="3-7-scrollIntoView-메서드"><a href="#3-7-scrollIntoView-메서드" class="headerlink" title="3-7. scrollIntoView() 메서드"></a>3-7. scrollIntoView() 메서드</h3><p>모든 HTML요소에 존재하며 브라우저 창이나 컨테이너 요소를 스크롤해서 해당 요소가 뷰포트에 보이게 한다.</p><ul><li>매개변수로 true나 생략하면 창 전체를 스크롤하여 요소 상단과 뷰포트 상단을 맞춘다.</li></ul><hr><hr><h2 id="4-전용-확장"><a href="#4-전용-확장" class="headerlink" title=" 4. 전용 확장"></a><a name="location"></a> 4. 전용 확장</h2><ol><li>문서모드</li><li>children 프로퍼티</li><li>contains() 메서드</li><li>마크업 삽입<ul><li>innerText 프로퍼티</li><li>outerText 프로퍼티</li></ul></li><li>스크롤</li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-dom" target="_blank" rel="noopener">http://poiemaweb.com/js-dom</a></li></ol><h3 id="생소했던-단어"><a href="#생소했던-단어" class="headerlink" title="생소했던 단어"></a>생소했던 단어</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;목
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>8/ DOM(1) - 노드의 계층 구조(2)</title>
    <link href="http://feel5ny.github.io/2017/12/27/JS_08_2/"/>
    <id>http://feel5ny.github.io/2017/12/27/JS_08_2/</id>
    <published>2017-12-27T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><hr><hr><p><strong>목차</strong></p><ol><li>Node 타입</li><li>Document 타입</li><li>Element 타입</li><li><a href="#text">Text 타입</a><ul><li>텍스트 노드 생성</li><li>텍스트 노드 통일</li><li>텍스트 노드 분할</li></ul></li><li><a href="#Comment">Comment 타입</a></li><li><a href="#CDATASection">CDATASection 타입</a></li><li><a href="#DocumentType">DocumentType 타입</a></li><li><a href="#DocumentFragment">DocumentFragment 타입</a></li><li><a href="#Attr">Attr 타입</a></li></ol><hr><hr><h2 id="4-Text-타입"><a href="#4-Text-타입" class="headerlink" title=" 4. Text 타입"></a><a name="text"></a> 4. Text 타입</h2><ul><li>이 노드에는 평범한 텍스트가 포함되고 글자 그대로 사용된다.</li><li>이스케이프된 HTML 문자는 포함할 수 있지만 HTML 코드는 포함할 수 없다.</li></ul><h4 id="Text-노드의-특징"><a href="#Text-노드의-특징" class="headerlink" title="Text 노드의 특징"></a>Text 노드의 특징</h4><ul><li>nodeType은 <strong>3</strong></li><li>nodeType은 <strong>“#text”</strong></li><li>parentNode는 <strong>Element</strong></li><li><strong>자식 노드를 가질 수 없다.</strong></li></ul><p><img src="/images/post_img/59/textNode.jpg"></p><ul><li>Text 노드에 포함된 텍스트는 nodeValue 프로퍼티나 data 프로퍼티로 가져올 수 있다.</li><li>둘중에 하나를 바꾸면 노드에 반영된다.</li><li>공백도 length값에 포함된다.</li><li>텍스트 노드의 값을 바꿀때 알아둬야 할 점은 문자열이 문서 타입에 따라 HTML 또는 XML에 맞게 인코드 된다.</li></ul><h4 id="텍스트를-조작하는-메서드"><a href="#텍스트를-조작하는-메서드" class="headerlink" title="텍스트를 조작하는 메서드"></a>텍스트를 조작하는 메서드</h4><ul><li>appendData(text) : 노드 마지막에 text 추가.</li><li>deleteData(offset, count) : offset부터 count만큼 삭제</li><li>insertData(offset, count, text) : offset 위치에 text 삽입</li><li>replaceData(offset, count, text) : offset부터 (offset + count) 까지의 텍스트를 text로 교체</li><li>splitText(offset) : offset 위치를 기준으로 텍스트 노드를 둘로 나눈다.</li><li>substringData(offset, count) : offset위치부터 (offset + count)까지의 텍스트를 꺼낸다.</li></ul><h3 id="텍스트-노드-생성-document-createTextNode"><a href="#텍스트-노드-생성-document-createTextNode" class="headerlink" title="텍스트 노드 생성 document.createTextNode()"></a>텍스트 노드 생성 <code>document.createTextNode()</code></h3><ul><li>매개변수로 삽입할 텍스트를 받는다.</li><li>새 텍스트 노드를 생성하면 ownerDocument 프로퍼티가 설정되지만 문서 트리에 삽입하기 전에는 브라우저 창에 표시되지 않는다.</li><li>일반적으로 요소는 단 하나의 자식 텍스트 토드만 가진다.<ul><li>여러 개를 가질 때도 있다.</li><li>이때 <code>normalize()</code>를 사용하면 두 가지 텍스트가 공백없이 합쳐진다.</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>)</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure><h3 id="텍스트-노드-통일-normalize"><a href="#텍스트-노드-통일-normalize" class="headerlink" title="텍스트 노드 통일 normalize()"></a>텍스트 노드 통일 <code>normalize()</code></h3><h3 id="텍스트-노드-분할-splitText"><a href="#텍스트-노드-분할-splitText" class="headerlink" title="텍스트 노드 분할 splitText()"></a>텍스트 노드 분할 <code>splitText()</code></h3><hr><hr><h2 id="5-Comment-타입"><a href="#5-Comment-타입" class="headerlink" title=" 5. Comment 타입"></a><a name="Comment"></a> 5. Comment 타입</h2><hr><hr><h2 id="6-CDATASection-타입"><a href="#6-CDATASection-타입" class="headerlink" title=" 6. CDATASection 타입"></a><a name="CDATASection"></a> 6. CDATASection 타입</h2><hr><hr><h2 id="7-DocumentType-타입"><a href="#7-DocumentType-타입" class="headerlink" title=" 7. DocumentType 타입"></a><a name="DocumentType"></a> 7. DocumentType 타입</h2><hr><hr><h2 id="8-DocumentFragment-타입"><a href="#8-DocumentFragment-타입" class="headerlink" title=" 8. DocumentFragment 타입"></a><a name="DocumentFragment"></a> 8. DocumentFragment 타입</h2><hr><hr><h2 id="9-Attr-타입"><a href="#9-Attr-타입" class="headerlink" title=" 9. Attr 타입"></a><a name="Attr"></a> 9. Attr 타입</h2><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://meetup.toast.com/posts/89" target="_blank" rel="noopener">http://meetup.toast.com/posts/89</a></li></ol><h3 id="생소했던-단어"><a href="#생소했던-단어" class="headerlink" title="생소했던 단어"></a>생소했던 단어</h3><ol><li>MIME타입</li><li>Gecko</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;목
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>8/ DOM(1) - 노드의 계층 구조(1)</title>
    <link href="http://feel5ny.github.io/2017/12/26/JS_08_1/"/>
    <id>http://feel5ny.github.io/2017/12/26/JS_08_1/</id>
    <published>2017-12-26T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.<br>넘나 많은 프로퍼티와 메서드들 @_@</p></blockquote><hr><p>브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM(문서 객체 모델: Document Object Model)을 생성한다.</p><p><img src="/images/post_img/58/client-server.png"></p><ul><li>텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하기 위해서는 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다. </li><li><p>브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다.</p></li><li><p>즉 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다. </p></li><li><p>이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다.</p></li><li><p>이러한 웹 문서의 동적 변경을 위해 DOM은 프로그래밍 언어가 자신에 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 JavaScript 객체로 제공된다. </p></li><li>이를 DOM API(Application Programming Interface)라고 부른다. </li><li>달리 말하면 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법은 메모리 상에 존재하는 DOM을 변경하는 것이고, 이때 필요한 것이 DOM에 접근하고 변경하는 프로퍼티와 메소드의 집합인 DOM API이다.</li></ul><p>DOM은 HTML, JavaScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이며 플랫폼/프로그래밍 언어 중립적이다. DOM은 다음 두 가지 기능을 담당한다.</p><hr><p><strong>목차</strong></p><ol><li><a href="#node">Node 타입</a><ul><li>nodeName, nodeValue<ul><li>요소의 경우 nodeName은 태그명, nodeValue는 null</li></ul></li><li>노드 사이의 관계<ul><li>ChildNodes / ParentNodes / firstChild / lastChild / hasChildNodes(), ownerDocument 프로퍼티</li></ul></li><li>노드 조작<ul><li>appendChild() / insertBefore() / replaceChild() / removeChild()</li></ul></li><li>기타 메서드<ul><li>cloneNode() / nomalize()</li></ul></li></ul></li><li><a href="#document">Document 타입</a><ul><li>Document 자식 노드<ul><li>documentElement(=<code>&lt;html&gt;</code>)</li></ul></li><li>문서 정보<ul><li>document.title / document.URL / document.domain / document.referrer</li></ul></li><li>요소 위치<ul><li>getElementById() / getElementByTagName() (namedItem) / getElementByName()</li></ul></li><li>특별한 컬렉션<ul><li>document.anchors / document.applets / document.forms / document.images / document.links</li></ul></li><li>DOM 준수 탐지<ul><li>hasFeature()</li></ul></li><li>문서에 쓰기<ul><li>write() / writeIn() / open() / close()</li></ul></li></ul></li><li><a href="#element">Element 타입</a><ul><li>HTML 요소<ul><li>id / title / lang / dir / className</li></ul></li><li>속성 얻기<ul><li>getAttribute()</li></ul></li><li>속성 설정<ul><li>setAttribute()</li></ul></li><li>속성 제거<ul><li>removeAttribute()</li></ul></li><li>attributes 프로퍼티<ul><li>getNamedItem() / removeNamedItem(name) / setNamedItem(), item()</li></ul></li><li>요소 생성<ul><li>createElement()</li></ul></li><li>요소의 자식<br>—- 2편 &#128071;</li></ul></li><li>Text 타입</li><li>Comment 타입</li><li>CDATASection 타입</li><li>DocumentType 타입</li><li>DocumentFragment 타입</li><li>Attr 타입</li></ol><hr><hr><h1 id="노드의-계층-구조"><a href="#노드의-계층-구조" class="headerlink" title="노드의 계층 구조"></a>노드의 계층 구조</h1><ul><li>문서 객체 모델 DOM은 HTML과 XML 문서에 대한 애플리케이션 프로그래밍 인터페이스이다. (api)</li><li>DOM은 문서를 노드의 계층 구조 트리로 표현한다.</li><li>개발자는 이를 통해 페이지 각 부분을 추가, 제거, 수정한다.</li><li>자바스크립트를 통해 HTML에 접근이 가능한 이유는 html이 document object model에 따라 기술되고 이 dom 인터페이스를 통해 기술된 html element가 <strong>객체</strong>로써 자바스크립트와 연결되기 때문에 접근이 가능한 것이다.</li></ul><hr><ul><li>노드 타입에는 여러 가지가 있으며 각 타입은 문서에서 서로 다른 정보나 마크업을 표현한다.</li><li>노드 타입은 서로 다른 특징, 데이터, 메서드를 가지며 각 노드는 다른 노드와 관계가 있을 수 있다.</li><li>특정 노드에 뿌리를 둔 트리 구조로 표현된다.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Pate<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/post_img/58/01.jpg"></p><ul><li>여기서 문서(Document) 노드가 루트이다.</li><li>문서 요소 : 문서 노드의 자식. 여기서는 <code>&lt;html&gt;</code><ul><li>문서 하나에 문서 요소 하나만 있을 수 있다.</li><li>HTML페이지에서 문서요소는 항상 <code>&lt;html&gt;</code> 요소이다.</li></ul></li><li>각 마크업은 트리에서 노드로 표현된다.</li><li>총 12가지 노드 타입이 있으며 모든 노드틑 <code>기반 타입</code>(base type)을 상속한다.</li></ul><hr><hr><h2 id="1-Node-타입"><a href="#1-Node-타입" class="headerlink" title=" 1. Node 타입"></a><a name="node"></a> <span style="color:#1a2980">1. Node 타입<span></span></span></h2><ul><li>DOM 레벨 1에는 Node라는 인터페이스가 있다.</li><li>DOM에 존재하는 <code>노드 타입</code>은 모두 이 인터페이스를 구현한다.</li><li>모든 브라우저에서는 Node 타입에 접근할 수 있다.</li><li>자바스크립트 노드 타입은 모두 Node를 상속하므로 모든 노드 타입에서 같은 기본 프로퍼티와 메서드를 고융한다.</li></ul><p>모든 노드에는 타입을 나타내는 nodeType 프로퍼티가 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node.ELEMENT_NODE (<span class="number">1</span>)</span><br><span class="line">Node.ATTRIBUTE_NODE (<span class="number">2</span>)</span><br><span class="line">Node.TEXT_NODE (<span class="number">3</span>)</span><br><span class="line">Node.CDATA_SECTION_NODE (<span class="number">4</span>)</span><br><span class="line">Node.ENTITY_REFERENCE_NODE (<span class="number">5</span>)</span><br><span class="line">Node.ENTITY_NODE (<span class="number">6</span>)</span><br><span class="line">Node.PROCESSING_INSTRUCTION_NODE (<span class="number">7</span>)</span><br><span class="line">Node.COMMENT_NODE (<span class="number">8</span>)</span><br><span class="line">Node.DOCUMENT_NODE (<span class="number">9</span>)</span><br><span class="line">Node.DOCUMENT_TYPE_NODE (<span class="number">10</span>)</span><br><span class="line">Node.DOCUMENT_FRAGMENT_NODE (<span class="number">11</span>)</span><br><span class="line">Node.NOTATION_NODE (<span class="number">12</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE)&#123;</span><br><span class="line">  alert(<span class="string">"Node is an element."</span>)</span><br><span class="line">&#125; <span class="comment">// IE에서는 오류</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">  alert(<span class="string">"Node is an element."</span>)</span><br><span class="line">&#125; <span class="comment">// 모든 브라우저에서 동작</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-1-nodeName-nodeValue"><a href="#1-1-nodeName-nodeValue" class="headerlink" title="1-1. nodeName, nodeValue"></a><span style="color:#26d0ce">1-1. nodeName, nodeValue</span></h3><ul><li>nodeName과 nodeValue는 해당 노드의 정보를 제공한다.</li><li>요소(element)의 nodeName은 요소의 태그명과 일치하고, nodeValue는 <code>null</code>이다.</li><li>텍스트 노드일 경우 nodeValue는 문자열이다.</li></ul><hr><h3 id="1-2-노드-사이의-관계"><a href="#1-2-노드-사이의-관계" class="headerlink" title="1-2. 노드 사이의 관계"></a><span style="color:#26d0ce">1-2. 노드 사이의 관계</span></h3><h4 id="1-2-1-ChildNodes-프로퍼티"><a href="#1-2-1-ChildNodes-프로퍼티" class="headerlink" title="1-2-1. ChildNodes 프로퍼티"></a>1-2-1. ChildNodes 프로퍼티</h4><h5 id="NodeList가-저장된다"><a href="#NodeList가-저장된다" class="headerlink" title="NodeList가 저장된다."></a><code>NodeList</code>가 저장된다.</h5><ul><li>유사배열 객체<br><img src="/images/post_img/58/02.png"></li><li>노드를 순서 있는 목록으로 저장하여 위치 기반으로 접근 가능.</li><li><code>length</code> 프로퍼티 : <strong>호출 당시</strong> 노드리스트에 담긴 노드 숫자임을 기억하자.</li><li>Array의 인스턴스는 아니다.</li><li><strong>DOM 구조의 쿼리 결과</strong></li><li>계속 바뀌므로 살아있는 객체라고도 부른다.</li><li>childNodes는 모든 자식요소 찾기</li><li>children은 모든 자식요소 찾기이지만 요소노드만 찾는다.</li><li><p>노드 리스트에 저장된 노드를 접근하는 방법 (어느쪽을 더 권잔하진 않는다.)</p><ul><li>대괄호 표기법</li><li>item() 메서드<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> count = someNode.childNodes.length;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/post_img/58/03.png"></p></li></ul><h4 id="1-2-2-parentNode-프로퍼티"><a href="#1-2-2-parentNode-프로퍼티" class="headerlink" title="1-2-2. parentNode 프로퍼티"></a>1-2-2. parentNode 프로퍼티</h4><ul><li>childNodes 목록에 포함된 노드는 모두 부모가 같으므로 각각의 parentNode 프로퍼티는 같은 노드를 가리킨다.</li><li>childeNOdes 목록의 각 노드들은 형제관계이며 <code>previousSibling</code> 및 <code>nextSibling</code> 프로퍼티로 이동할 수 있다.</li><li>자식 노드가 하나 뿐이라면 해당 노드의 nextSibling과 previousSibling은 모두 null이다.<br><img src="/images/post_img/58/04.png"></li></ul><h4 id="1-2-3-firstChild-프로퍼티"><a href="#1-2-3-firstChild-프로퍼티" class="headerlink" title="1-2-3. firstChild 프로퍼티"></a>1-2-3. firstChild 프로퍼티</h4><p>childNodes 목록에서 첫번째 노드를 가리킨다.<br>someNode.firstChild = someNode.childNodes[0]</p><h4 id="1-2-4-lastChild-프로퍼티"><a href="#1-2-4-lastChild-프로퍼티" class="headerlink" title="1-2-4. lastChild 프로퍼티"></a>1-2-4. lastChild 프로퍼티</h4><p>childNodes 목록에서 마지막 노드를 가리킨다.<br>someNode.lastChild = someNode.childNodes[someNode.childNodes.length-1]</p><p><img src="/images/post_img/58/05.jpg"></p><h4 id="1-2-5-hasChildNodes-메서드"><a href="#1-2-5-hasChildNodes-메서드" class="headerlink" title="1-2-5. hasChildNodes() 메서드"></a>1-2-5. hasChildNodes() 메서드</h4><p>노드에 자식 노드가 있으면 true를 반환.<br>length로 자식 노드 확인하는 것보다 효과적.</p><h4 id="1-2-6-ownerDocument-프로퍼티"><a href="#1-2-6-ownerDocument-프로퍼티" class="headerlink" title="1-2-6. ownerDocument 프로퍼티"></a>1-2-6. ownerDocument 프로퍼티</h4><p>전체 문서를 표현하는 문서 노드에 대한 포인터<br>노드 계층 구조를 따라 위로 거슬러 올라갈 필요 없이 문서 노드에 빠르게 접근 가능하다.</p><hr><h3 id="1-3-노드-조작"><a href="#1-3-노드-조작" class="headerlink" title="1-3. 노드 조작"></a><span style="color:#26d0ce">1-3. 노드 조작</span></h3><ul><li>노드 사이의 관계 포인터는 모두 읽기 전용</li><li>아래 4가지 메서드는 <strong>자식</strong>에서만 동작하므로 <strong>부모 노드를 정확히 알아야한다.</strong></li></ul><h4 id="1-3-1-appendChild"><a href="#1-3-1-appendChild" class="headerlink" title="1-3-1. appendChild()"></a>1-3-1. <code>appendChild()</code></h4><ul><li>childNodes 목록 마지막에 노드를 추가한다. </li><li>새로 추가한 노드, 부모 노드, childNodes 목록에 포함된 이전의 마지막 자식 노드에서 모든 관계 포인터가 업데이트 된다.</li><li>이미 문서에 존재하고 있는 노드를 추가한다면, 해당 노드는 이전 위치에서 추가된 위치로 옮겨진다.</li></ul><h4 id="1-3-2-insertBefore-삽입할-노드-기준-노드"><a href="#1-3-2-insertBefore-삽입할-노드-기준-노드" class="headerlink" title="1-3-2. insertBefore(삽입할 노드, 기준 노드)"></a>1-3-2. <code>insertBefore(삽입할 노드, 기준 노드)</code></h4><ul><li>삽입할 노드와 기준 노드 2가지를 매개변수로 받는다.</li><li>삽입한 노드는 기준 노드의 <strong>이전</strong>형제가 되며, 이동이 끝나면 메서드는 <strong>삽입한 노드를 반환</strong>한다.</li></ul><p><img src="/images/post_img/58/insertBefore.png"></p><h4 id="1-3-3-replaceChild-삽입할-노드-교체할-노드"><a href="#1-3-3-replaceChild-삽입할-노드-교체할-노드" class="headerlink" title="1-3-3. replaceChild(삽입할 노드, 교체할 노드)"></a>1-3-3. <code>replaceChild(삽입할 노드, 교체할 노드)</code></h4><ul><li>기존 노드를 교체한다.</li><li>교체할 노드(B)에 있던 자리에 삽입할 노드(A)가 들어간다.</li><li><strong>B의 관계 표인터는 모두 A에 복사한다.</strong><ul><li>B는 같은 문서 소유이긴 하지만 문서에서 위치를 지정받지 못한 채 붕 떠 있는 상태이다.</li></ul></li></ul><h4 id="1-3-4-removeChild"><a href="#1-3-4-removeChild" class="headerlink" title="1-3-4. removeChild()"></a>1-3-4. <code>removeChild()</code></h4><ul><li>제거할 노드 하나만 매개변수로 받는다.</li><li>제거된 노드는 아직 해당 문서 소유이긴 하지만 문서에서 위치를 지정받지는 못했다.</li></ul><hr><h3 id="1-4-기타-메서드"><a href="#1-4-기타-메서드" class="headerlink" title="1-4. 기타 메서드"></a><span style="color:#26d0ce">1-4. 기타 메서드</span></h3><h4 id="1-4-1-cloneNode-boolean"><a href="#1-4-1-cloneNode-boolean" class="headerlink" title="1-4-1. cloneNode(boolean)"></a>1-4-1. <code>cloneNode(boolean)</code></h4><ul><li>자신을 호출한 노드의 복제본을 생성한다.</li><li>매개변수로는 자손 노드까지 복제할지 나타내는 불리언이다.<ul><li>true : 자손 노드 전체를 복제</li><li>false : 해당 노드 하나만 복제</li></ul></li><li>복제된 노드를 반환하는데, 이는 여전히 문서 소유이지만 부모 노드가 할당되지 않는다.<ul><li><code>고아노드</code>라고 한다.</li><li>appendChild()나 insertBefore(), replaceChild()를 통해 문서에 추가하기 전에는 <strong>트리 안에 존재하지 않는다.</strong></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepList = myList.cloneNode(<span class="literal">true</span>) <span class="comment">// myList에 ul요소에 대한 참조를 저장했다고 가정</span></span><br><span class="line"><span class="built_in">console</span>.log(deepList.childNodes.length) <span class="comment">// 3 or 7(공백포함)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowList = myList.cloneNode(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(shallowList.childNodes.length) <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="1-4-2-nomalize"><a href="#1-4-2-nomalize" class="headerlink" title="1-4-2. nomalize()"></a>1-4-2. <code>nomalize()</code></h4><ul><li>문서 서브트리에 존재하는 텍스트 노드를 다루는 것 뿐.</li><li>파서의 구현 방식이나 DOM 조작 결과로 텍스트 없는 텍스트 노드가 생기거나 텍스트 노드끼리 형제 노드가 될 가능성이 있다.</li><li><code>nomalize</code>를 호출하면 노드의 자손에서 이 두가지 상황이 생기지 않았는지 검색한다.</li><li>빈 텍스트 노드를 찾으면 제거하고 텍스트 노드끼리 형제인 경우를 발견하면 두 노드를 하나로 합친다.</li></ul><hr><hr><h2 id="2-Document-타입"><a href="#2-Document-타입" class="headerlink" title=" 2. Document 타입"></a><a name="document"></a> <span style="color:#1a2980">2. Document 타입</span></h2><p><img src="/images/post_img/58/06.png"></p><ul><li>자바스크립트는 문서 노드를 Document 타입으로 표현한다.</li><li>브라우저에서 전체 HTML 페이지를 표현하는 문서 객체는 <code>HTMLDocument</code>의 인스턴스</li><li>HTMLDocument는 Document를 상속한다.</li><li>document 객체는 window의 프로퍼티이므로 전역에서 접근할 수 있다. <code>window.document</code></li><li>Document 타입은 HTML 페이지 또는 XML 기반 문서를 표현한다.</li><li>document 객체를 통해 페이지에 대한 정보를 얻고 구조 및 외관을 조작한다.</li></ul><p>Document 노드의 특징</p><ul><li>nodeType은 9</li><li>nodeName은 “#document”</li><li>nodeValue는 null</li><li>parentNode는 null</li><li>ownerDocument는 null</li><li>자식 노드로 DocumentType(최대 1개) Element(최대 1개), Processing Instruction, Comment를 가질 수 있다.</li></ul><hr><h3 id="2-1-Document-자식-노드"><a href="#2-1-Document-자식-노드" class="headerlink" title="2-1. Document 자식 노드"></a><span style="color:#26d0ce">2-1. Document 자식 노드<span></span></span></h3><p>Document 자식으로</p><ul><li>DocumentType</li><li>Element</li><li>ProcessingInstruction</li><li>Comment</li></ul><h4 id="2-1-1-documentElement-프로퍼티"><a href="#2-1-1-documentElement-프로퍼티" class="headerlink" title="2-1-1. documentElement 프로퍼티"></a>2-1-1. <code>documentElement</code> 프로퍼티</h4><ul><li>HTML페이지의 <code>&lt;html&gt;</code>요소를 가리킨다.</li><li><p>childNodes의 document 요소보다 documentElement프로퍼티가 해당 요소에 더 빨리, 더 직접적으로 접근한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>] === <span class="built_in">document</span>.firstChild)</span><br></pre></td></tr></table></figure></li><li><p><strong>document 객체는 HTMLDocument의 인스턴스이므로 <code>&lt;body&gt;</code>요소를 직접적으로 가리키는 body 프로퍼티를 갖는다.</strong></p></li></ul><p>document 객체<br><img src=" /images/post_img/58/document.jpg"></p><h4 id="2-1-2-DocumentType"><a href="#2-1-2-DocumentType" class="headerlink" title="2-1-2. DocumentType"></a>2-1-2. <code>DocumentType</code></h4><p><code>&lt;!DOCTYPE&gt;</code> 태그는 문서의 다른 부분과는 별도의 엔티티로 간주하며 포함된 정보는 다음과 같이 doctype 프로퍼티를 통해 접근할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doctype = <span class="built_in">document</span>.doctype</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-2-문서-정보"><a href="#2-2-문서-정보" class="headerlink" title="2-2. 문서 정보"></a><span style="color:#26d0ce">2-2. 문서 정보</span></h3><ul><li>document 객체는 HTMLDocument의 인스턴스이므로 표준 Document 객체에는 존재하지 않는 프로퍼티를 여럿 가진다.</li><li>이들 프로퍼티는 현재 불러들인 웹 페이지에 대한 정보이다.</li></ul><h4 id="2-2-1-document-title"><a href="#2-2-1-document-title" class="headerlink" title="2-2-1. document.title"></a>2-2-1. <code>document.title</code></h4><ul><li><code>&lt;title&gt;</code> 요소 텍스트가 들어있다.</li><li>읽을 수도 있고 재설정도 가능하다.</li></ul><h4 id="2-2-2-웹페이지-요청과-관련한-프로퍼티"><a href="#2-2-2-웹페이지-요청과-관련한-프로퍼티" class="headerlink" title="2-2-2. 웹페이지 요청과 관련한 프로퍼티"></a>2-2-2. 웹페이지 요청과 관련한 프로퍼티</h4><p>HTTP 헤더에 들어있다.</p><ul><li>URL : 페이지의 완전한 URL</li><li>domain : 페이지의 도메인 이름,</li><li>referrer : 이 페이지를 링크한 페이지의 URL. 없으면 빈 문자열</li></ul><hr><h3 id="2-3-요소-위치"><a href="#2-3-요소-위치" class="headerlink" title="2-3. 요소 위치"></a><span style="color:#26d0ce">2-3. 요소 위치</span></h3><p>특정 요소나 요소 그룹에 대한 참조를 얻는 일을 자주한다.<br>대표적인 2가지 메서드. <code>getElementById()</code>, <code>getElementByTagName()</code></p><h4 id="2-3-1-getElementById"><a href="#2-3-1-getElementById" class="headerlink" title="2-3-1. getElementById()"></a>2-3-1. <code>getElementById()</code></h4><ul><li>찾으려는 요소 ID를 매개변수로 받고 해다 요소를 찾아 반환하며 그런 ID의 요소가 존재하지 않으면 null반환.</li><li>소문자와 대문자를 구분해야한다.</li><li>같은 요소가 2개 이상 존재하면 첫 번째 요소를 반환한다.</li><li>document.getElementBy~ : 단일 엘리먼트를 선택하는 메소드</li><li>document.getElementsBy~ : 다중 엘리먼트를 선택하는 메소드<ul><li>배열형태로 받아진다.</li></ul></li></ul><h4 id="2-3-2-getElementByTagName"><a href="#2-3-2-getElementByTagName" class="headerlink" title="2-3-2. getElementByTagName()"></a>2-3-2. <code>getElementByTagName()</code></h4><ul><li>요소의 태그 이름을 매개변수로 받고 해당하는 요소가 담긴 NodeList를 반환한다.<ul><li>HTML 문서에서는 HTMLCollection 객체를 반환한다.</li></ul></li></ul><p><img src=" /images/post_img/58/HTMLCollection.png"></p><ul><li>NodeList 객체와 마찬가지로 HTMLCollection 객체의 데이터 역시 대괄호기법과 item() 메서드로 접근 가능하다.  </li><li><p>HTMLCollection의 <code>namedItem()</code> 메서드</p><ul><li>name 속성을 통해 컬렉션 데이터에 대한 참조를 얻는다.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"myimage.jpg"</span> <span class="attr">name</span>=<span class="string">"myImage"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> images = <span class="built_in">document</span>.getElementByTagName(<span class="string">"img"</span>)</span><br><span class="line"><span class="keyword">const</span> myImage = images.namedItem(<span class="string">"myImage"</span>)</span><br><span class="line"><span class="keyword">const</span> myImage = images[<span class="string">"myImage"</span>]</span><br></pre></td></tr></table></figure><ul><li>HTMLCollection 객체에서는 대괄호 표기법에 <ul><li>숫자형 색인과 =&gt; <code>item()</code>사용</li><li>문자형 색은을 모두 사용할 수 있다. =&gt; <code>namedItme()</code> 사용</li></ul></li></ul></li><li>문서 전체는 아리테스크<code>*</code>를 사용한다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allElements = <span class="built_in">document</span>.getElementByTagName(<span class="string">"*"</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-4-getElementByName"><a href="#2-3-4-getElementByName" class="headerlink" title="2-3-4. getElementByName()"></a>2-3-4. <code>getElementByName()</code></h4><p>name 속성 값이 주어진 문자열에 일치하는 요소를 반환한다.</p><ul><li>라디오 버튼에 자주 사용한다.</li><li>id 속성은 label요소와 연결하는 역할을 하며</li><li>name 속석은 값을 서버에 보낼 때 이중 단 하나만 보내는 역할을 한다. (체크된)<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"red"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorRed"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorRed"</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"green"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorGreen"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorGreen"</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"blue"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorBlue"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorBlue"</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-4-특별한-컬렉션"><a href="#2-4-특별한-컬렉션" class="headerlink" title="2-4. 특별한 컬렉션"></a><span style="color:#26d0ce">2-4. 특별한 컬렉션</span></h3><p>document객체에는 특별하 컬렉션이 몇가지 있다.<br>각 컬렉션은 모두 HTML Collection 객체이고,<br>문서에 공통된 요소들에 빠르게 접근할 수 있도록 만들어졌다.</p><ul><li><code>document.anchors</code> : name속성이 있는 <code>&lt;a&gt;</code> 요소를 모두 갖고온다.</li><li>(폐기)<code>document.applets</code> : <code>&lt;applet&gt;</code> 요소를 모두 갖고온다. </li><li><code>document.forms</code> : <code>&lt;form&gt;</code> 요소를 모두 가져온다. (document.getElementsByTagName(“form”)과 같다.)</li><li><code>document.images</code> : <code>&lt;img&gt;</code> 요소를 모두 갖고온다.</li><li><code>document.links</code> : href속성이 있는 <code>&lt;a&gt;</code>요소를 모두 가져온다.</li></ul><hr><h3 id="2-5-DOM-준수-탐지"><a href="#2-5-DOM-준수-탐지" class="headerlink" title="2-5. DOM 준수 탐지"></a><span style="color:#26d0ce">2-5. DOM 준수 탐지</span></h3><p><code>hasFeature()</code></p><hr><h3 id="2-6-문서에-쓰기"><a href="#2-6-문서에-쓰기" class="headerlink" title="2-6. 문서에 쓰기"></a><span style="color:#26d0ce">2-6. 문서에 쓰기</span></h3><p><code>write()</code> : 넘겨 받은 텍스트를 그대로 추가하고<br><code>writeIn()</code> : 줄바꿈을 문자(<code>\n</code>)를 문자열 마지막에 추가한다.<br><code>open()</code> : 페이지 스트림을 열고<br><code>close()</code> : 페이지 스트림을 닫습니다.</p><hr><hr><h2 id="3-Element-타입"><a href="#3-Element-타입" class="headerlink" title=" 3. Element 타입"></a><a name="element"></a> <span style="color:#1a2980">3. Element 타입</span></h2><p>Element 요소의 특징</p><ul><li>nodeType은 1이다.</li><li>nodeName은 요소의 태그 이름이다.</li><li>nodeValue는 null이다.</li><li>parentNode는 Document 또는 Element이다.</li><li>자식노드로 Element나 Text, Comment, ProcessingInstruction, CDATASection, EntityReference를 가질 수 있다.</li></ul><hr><h3 id="3-1-HTML-요소"><a href="#3-1-HTML-요소" class="headerlink" title="3-1. HTML 요소"></a><span style="color:#26d0ce">3-1. HTML 요소</span></h3><p>HTMLElement 타입을 통해 표현된다.<br>HTMLElement는 Element를 직접적으로 상속한다.</p><p><code>id</code> : 요소의 고유한 식별자<br><code>title</code> : 요소에 대한 추가 정보, 일반적으로 툴팁으로 표현됨<br><code>lang</code> : 요소 콘텐츠의 언어 코드. 거의 사용되지 않는다.<br><code>dir</code> : 언어의 표기 반향. <code>ltr</code>은 왼쪽 =&gt; 오른쪽, <code>rtl</code>은 오른쪽 =&gt; 왼쪽. 거의 사용되지 않는다.<br><code>className</code> : CSS 클래스인 class 속성을 나타낸다. class가 ECMAScript의 예약어이기 때문에 className이라고 사용한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">class</span>=<span class="string">"bd"</span> <span class="attr">title</span>=<span class="string">"Body text"</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src=" /images/post_img/58/HTMLElement.jpg"></p><hr><h3 id="3-2-속성-얻기-getAttribute"><a href="#3-2-속성-얻기-getAttribute" class="headerlink" title="3-2. 속성 얻기 (getAttribute())"></a><span style="color:#26d0ce">3-2. 속성 얻기</span> (<code>getAttribute()</code>)</h3><p><code>getAttribute(속성이름)</code> : 공식 속성 이외에 커스텀 속성을 가져오는데도 쓸 수 있다.<br><code>setAttribute(속성이름, 속성이름의 값)</code><br><code>removeAttribute(속성이름)</code></p><ul><li>속성이름은 대소문자를 구분하지 않는다.</li><li><strong>HTML5 명세에서는 커스텀 속성 앞에 전치사 <code>data-</code>를 붙여야 유효한 것으로 인정한다.</strong></li><li>getAttribute(“style”)은 객체를 반환, getAttribute(“onclick”)은 함수를 반환한다.</li><li>위의 속성과 차이점때문에 개발자들은 getAttribute()는 거의 사용하지 않고 객체 프로퍼티를 사용한다.</li><li>getAttribute() 메서드는 <strong>주로 커스텀 속성의 값을 가져올 때 사용하다.</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> four = <span class="built_in">document</span>.getElementById(<span class="string">'four'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 어트리뷰트가 존재하지 않으면</span></span><br><span class="line"><span class="keyword">if</span> (!four.hasAttribute(<span class="string">'class'</span>)) &#123;</span><br><span class="line">  <span class="comment">// four에 class 어트리뷰트를 추가하고 값으로 'blue'를 설정</span></span><br><span class="line">  four.setAttribute(<span class="string">'class'</span>, <span class="string">'blue'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// four에 class 어트리뷰트가 존재하면</span></span><br><span class="line">  four.className = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 어트리뷰트의 값을 취득</span></span><br><span class="line"><span class="built_in">console</span>.log(four.getAttribute(<span class="string">'class'</span>)); <span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class 어트리뷰트를 제거</span></span><br><span class="line">four.removeAttribute(<span class="string">'class'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 어트리뷰트의 존재를 확인</span></span><br><span class="line"><span class="built_in">console</span>.log(four.hasAttribute(<span class="string">'class'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-3-속성-설정-setAttribute"><a href="#3-3-속성-설정-setAttribute" class="headerlink" title="3-3. 속성 설정 (setAttribute())"></a><span style="color:#26d0ce">3-3. 속성 설정</span> (<code>setAttribute()</code>)</h3><ul><li>속성 이름과 설정할 값 두가지를 매개변수로 받는다.</li><li>해당 속성이 존재하지 않으면 솏어을 새로 생성하고 값을 설정한다.</li><li>속성 이름은 소문자로 통일된다.</li></ul><hr><h3 id="3-4-속성-제거-removeAttribute"><a href="#3-4-속성-제거-removeAttribute" class="headerlink" title="3-4. 속성 제거 (removeAttribute())"></a><span style="color:#26d0ce">3-4. 속성 제거</span> (<code>removeAttribute()</code>)</h3><ul><li>속성의 값만 지우는 것이 아니라 요소에서 속성을 완전히 제거한다.</li><li>자주 쓰이지는 않는다.</li></ul><hr><h3 id="3-5-attributes-프로퍼티"><a href="#3-5-attributes-프로퍼티" class="headerlink" title="3-5. attributes 프로퍼티"></a><span style="color:#26d0ce">3-5. attributes 프로퍼티</span></h3><ul><li>Element 타입은 DOM 노드 타입 중에서 attributes 프로퍼티를 갖는 유일한 타입이다.</li><li>attributes 프로퍼티에는 NodeList처럼 살아있는 컬렉션 <code>NamedNodeMap</code>이 저장된다.</li><li>요소 속성은 모두 Attr 노드로 표현되며 각 Attr노드는 NamedNodeMap 객체에 저장된다.</li><li>attributes 프로퍼티 안의 각 노드는 <ul><li>nodeName이 속성 이름</li><li>nodeValue는 속성 값</li></ul></li><li>보통은 아래 메서드들 보다는 <code>getAttribute()</code>, <code>removeAttribute()</code>, <code>setAttribute()</code> 메서드가 더 많이 사용된다.</li></ul><p>NamedNodeMap 객체의 메서드들</p><ul><li><code>getNamedItem(name)</code> : nodeName 프로퍼티가 name인 노드를 반환한다.</li><li><code>removeNamedItem(name)</code> : nodeName 프로퍼티가 name인 노드를 목록에서 제거한다.</li><li><code>setNamedItem(node)</code> : node를 목록에 추가하고 nodeName 프로퍼티에 따라 색인한다. </li><li><code>item(pos)</code> : 인덱스가 pos인 노드를 반환한다.</li></ul><p><img src=" /images/post_img/58/getNamedItem.png"></p><p>attributes 메서드들이 유용한 경우는 요소의 속성을 대상으로 루프가 필요할 때.<br>각 속성의 이름과 값을 문자열에 추가한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>(),</span><br><span class="line">    attrName,</span><br><span class="line">    attrValue,</span><br><span class="line">    i,</span><br><span class="line">    len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = element.attributes.length.length; i &lt; len; i++) &#123;</span><br><span class="line">    attrName = element.attributes[i].nodeName;</span><br><span class="line">    attrValue = element.attributes[i].nodeValue;</span><br><span class="line">    pairs.push(attrName + <span class="string">"=\""</span> + attrValue + <span class="string">"\""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pairs.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-6-요소-생성-document-createElement"><a href="#3-6-요소-생성-document-createElement" class="headerlink" title="3-6. 요소 생성 (document.createElement())"></a><span style="color:#26d0ce">3-6. 요소 생성</span> (<code>document.createElement()</code>)</h3><p><img src=" /images/post_img/58/createElement.png" width="400px"></p><ul><li>createElement() 메서드는 새 요소를 생성하고 ownerDocument 프로퍼티를 설정한다.</li><li>생성 이후에는 문서 트리의 일부가 아니므로 appendChild(), insertBefore(), replaceChild() 메서드를 통해 요소를 문서 트리에 추가해야한다.</li><li>IE7이전 버전에는 HTML을 통으로 인자로 넘길 수 있다.</li></ul><hr><h3 id="3-7-요소의-자식"><a href="#3-7-요소의-자식" class="headerlink" title="3-7. 요소의 자식"></a><span style="color:#26d0ce">3-7. 요소의 자식</span></h3><ul><li><p>요소는 자식 요소나 자손 요소를 가질 수 있고, 그 숫자는 제한이 없다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;ul&gt;</code>요소 자식 노드가 7개 생긴다.</p><ul><li><code>&lt;li&gt;</code>는 3개, <code>&lt;text&gt;</code> 4개 (<code>&lt;li&gt;</code>와 텍스트 사이의 공백)</li></ul></li></ul><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-dom" target="_blank" rel="noopener">http://poiemaweb.com/js-dom</a></li><li><a href="http://webclub.tistory.com/339" target="_blank" rel="noopener">http://webclub.tistory.com/339</a></li></ol><h3 id="생소했던-단어"><a href="#생소했던-단어" class="headerlink" title="생소했던 단어"></a>생소했던 단어</h3><ol><li>MIME타입</li><li>Gecko</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;br&gt;넘나 많은 프로퍼티와 메서드들 @_@&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>7/ BOM (브라우저 객체 모델)</title>
    <link href="http://feel5ny.github.io/2017/12/25/JS_07_2/"/>
    <id>http://feel5ny.github.io/2017/12/25/JS_07_2/</id>
    <published>2017-12-25T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><hr><hr><p><strong>목차</strong></p><ol><li>window 객체<br>—- 1편 &#128070;</li><li><a href="#location">location 객체</a><br>2.1 쿼리스트링 확장<br>2.2 location 조작</li><li><a href="#navigator">navigator 객체</a><br>3.1 플러그인 감지<br>3.2 처리기 등록</li><li><a href="#screen">screen 객체</a></li><li><a href="#history">history 객체</a></li></ol><hr><hr><h2 id="2-location-객체"><a href="#2-location-객체" class="headerlink" title=" 2. location 객체"></a><a name="location"></a> 2. location 객체</h2><ul><li>BOM에서 가장 유용한 객체중 하나.</li><li>문서 정보와 함께 내비게이션 기능을 제공하다.</li><li>location객체는 window의 프로퍼티인 동시에 document의 프로퍼티이다.</li><li><code>window.location</code>과 <code>document.location</code>은 같은 객체를 가리킨다.  </li><li>location은 <strong>현재 문서에 대한 정보</strong>를 갖고 있으며 URL을 파싱해서 몇 가지 조각으로 분리해 각각을 프로퍼티에 저장한다.</li></ul><p>location의 프로퍼티들을 살펴보자.</p><ul><li><code>hash</code> (예: “#/0/1” <a href="http://slides.com/nayoung/deck-8#/0/1" target="_blank" rel="noopener">http://slides.com/nayoung/deck-8#/0/1</a>)<ul><li>#기호 다음에 문자가 오는 형태의 URL 해시. URL에 해시가 없다면 빈 문자열</li></ul></li><li><code>host</code> (예: “localhost:4000”)<ul><li>서버 이름과 포트번호 (있다면)</li></ul></li><li><code>hostname</code> (예: “localhost”)<ul><li>포트 번호를 제외한 서버 이름</li></ul></li><li><code>href</code> (예: “<a href="http://localhost:4000/2017/12/28/JS_07/" target="_blank" rel="noopener">http://localhost:4000/2017/12/28/JS_07/</a>“)<ul><li>현재 페이지의 완전한 URL</li><li>location의 <code>toString()</code>메서드는 이 값을 반환</li></ul></li><li><code>pathname</code> (예: “/2017/12/28/JS_07/“)<ul><li>URL에 포함된 디렉터리 및 파일 이름</li></ul></li><li><code>port</code> (예: “4000”)<ul><li>URL의 요청 포트(존재한다면)이다. URL에 포트가 없으면 이 프로퍼티는 빈 문자열 반환</li></ul></li><li><code>protocol</code> (예: “http:”)<ul><li>페이지에서 사용하는 프로토콜. 일반적으로 “http:”나 “https:”중 하나이다. 프로토콜을 <code>스키마</code>라고 부르기도 한다.</li></ul></li><li><code>search</code> (예: “?q=window”)<ul><li>URL의 쿼리스트링 부분. 물음표 기호로 시작하는 문자열을 반환</li></ul></li></ul><hr><h3 id="2-1-쿼리스트링-확장"><a href="#2-1-쿼리스트링-확장" class="headerlink" title="2.1 쿼리스트링 확장"></a>2.1 쿼리스트링 확장</h3><p>URL 정보 중 쿼리스트링은 다루기 쉬운 형태로 제공되지 않는다.<br>즉, 하나씩 분리해서 제공하지 않는다는 말.<br>아래 함수를 이용하면 쿼리스트링을 파싱해서 각 매개변수를 프로퍼티로 갖는 객체를 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params">teset</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> qs = &#123;location.search.length &gt; <span class="number">0</span> &gt; location.search.substring(<span class="number">1</span>) : <span class="string">""</span>&#125;, <span class="comment">// 쿼리스트링이 존재하면 물음표를 제외하고 qs에 할당한다.</span></span><br><span class="line">  args = &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">  item = <span class="literal">null</span>,</span><br><span class="line">  name = <span class="literal">null</span>,</span><br><span class="line">  value = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for 루프에서 사용할 변수</span></span><br><span class="line">  i = <span class="number">0</span>,</span><br><span class="line">  len = items.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 각각 매개변수를 args 객체에 할당</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    item = item[i].split(<span class="string">"="</span>);</span><br><span class="line">    name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">    value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(name.length) &#123;</span><br><span class="line">      args[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>물음표 제거.</li><li>args를 객체 리터럴 형식으로 생성</li><li>args의 객체에 split으로 분리된 배열의 첫번째 인자가 name, 두번째 인자가 value에 들어간다.</li></ol><p><strong>결과</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.co.kr/search?newwindow=1&amp;tbm=isch&amp;q=그리드+다단&amp;cad=h</span><br><span class="line">args = &#123;newwindow: &quot;1&quot;, tbm: &quot;isch&quot;, q: &quot;그리드+다단&quot;, cad: &quot;h&quot;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="decodeURIComponent"><a href="#decodeURIComponent" class="headerlink" title="* decodeURIComponent"></a>* <code>decodeURIComponent</code></h4><p>HTML에서 한글이 섞인 주소는 오작동할 수 있기 때문에 이스케이프 시켜야한다.<br>예 : “나영” =&gt; “%EB%82%98%EC%98%81”<br>이를 <code>인코딩</code>이라고 하며, 반대로 다시 언어화를 시켜주는 <code>디코딩</code>이 있습니다.<br><code>decodeURIComponent</code>는 <code>http://</code> 부터 모두 디코딩을 해줍니다.</p><hr><h3 id="2-2-location-조작"><a href="#2-2-location-조작" class="headerlink" title="2.2 location 조작"></a>2.2 location 조작</h3><ul><li>location.assign(“<a href="https://feel5ny.github.io/">https://feel5ny.github.io/</a>“)<ul><li>메서드</li><li>해당 URL로 이동한다.</li></ul></li><li>location.href = “”<ul><li>현재 위치해있는 URL 뒤에 추가된다.</li></ul></li><li>location.hash = “”<ul><li><code>#</code>와 함께 인자가 URL 뒤에 추가된다.</li><li>hash 프로퍼티를 바꿀 때는 새 URL로 페이지를 다시 읽지 않는다.</li></ul></li><li>location.search = “q=test”<ul><li>현재 주소값에 search가 있는 경우, <code>q=</code> 뒤에 검색 단어를 추가한다.</li></ul></li><li>location.hostname = “www.naver.com”<ul><li>현재 주소에서 앞부분 main 주소값이 바뀐다.</li></ul></li><li>location.pathname<ul><li>첫번째 path가 바뀐다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://developer.mozilla.org/ko/?q=nayn</span></span><br><span class="line">location.pathname = <span class="string">"en-Us"</span></span><br><span class="line"><span class="comment">// https://developer.mozilla.org/en-US/?q=nayn</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>위의 프로퍼티들은 브라우저 히스토리 스택에 쌓이기 때문에 뒤로가기 버튼이 적용된다.<br><strong>replace는 그렇지 않다.</strong></p><ul><li>location.replace(“www.naver.com”)<ul><li>히스토리 스택에 쌓이지 않는다.</li></ul></li><li>location.reload(true)<ul><li>현재 페이지를 다시 불러온다.</li><li><code>매개변수 없이 호출하면</code> 페이지를 가능한 한 가장 효과적인 방법으로 다시 읽는다.<br>즉, 페이지가 바뀌지 않았다면 <strong>브라우저 캐시</strong>에서 읽어온다.</li><li><code>매개변수로 true를 넘기면</code> 서버에서 읽어오도록 강제하게된다.</li><li>reload() 호출 이후의 코드는 네트워크 지연이나 시스템 자원같은 요인에 따라 실행될 수도 있고 아닐 수도 있기 때문에 <strong>코드 마지막에 둔다.</strong></li></ul></li></ul><hr><hr><h2 id="3-navigator-객체"><a href="#3-navigator-객체" class="headerlink" title=" 3. navigator 객체"></a><a name="navigator"></a> 3. navigator 객체</h2><p>클라이언트에서 브라우저를 구별하는 방법의 표준으로 쓰였다.<br>navigator 객체의 프로퍼티는 일반적으로 웹 페이지를 실행 중인 브라우저 타입을 판단하는 데 사용한다.<br>( *은 크롬 )</p><table><thead><tr><th style="text-align:left">프로퍼티/메서드</th><th style="text-align:left">설명</th><th style="text-align:left">IE</th><th style="text-align:center">파이어폭스</th><th style="text-align:center">사파리/크롬</th><th style="text-align:center">오페라</th></tr></thead><tbody><tr><td style="text-align:left">*<code>appCodeName</code></td><td style="text-align:left">브라우저 이름이다. 모질라 브라우저가 아니어도 일반적으로 “Mozila”</td><td style="text-align:left">3.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>appMinorVersion</code></td><td style="text-align:left">추가적인 버전 정보이다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">9.5+</td></tr><tr><td style="text-align:left">*<code>appName</code></td><td style="text-align:left">완전한 브라우저 이름이다.</td><td style="text-align:left">3.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left">*<code>appVersion</code></td><td style="text-align:left">브라우저 버전입니다. 일반적으로 브라우저 실제 버전과는 다르다.</td><td style="text-align:left">3.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>buildID</code></td><td style="text-align:left">브라우저의 빌드 번호이다.</td><td style="text-align:left">-</td><td style="text-align:center">2.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>cookieEnabled</code></td><td style="text-align:left">쿠키가 활성화되어 있는지 나타낸다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>cpuClass</code></td><td style="text-align:left">클라이언트 컴퓨터의 CPU 타입이다. “x86”, “68K”, “Alpha”, “PPC”, “Ohter”가 있습니다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>javaEnabled</code></td><td style="text-align:left">브라우저에 자바가 활성화되어 있는지 나타낸다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left">*<code>language</code></td><td style="text-align:left">브라우저의 우선적 언어(한국어, 영어..)를 나타낸다.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left">*<code>mimeTypes</code></td><td style="text-align:left">브라우저에 등록된 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">마임 타입</a>을 나열한 배열이다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>onLine</code></td><td style="text-align:left">브라우저가 인터넷에 연결되어 있는지 나타낸다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td><td style="text-align:center">9.5+</td></tr><tr><td style="text-align:left"><code>opsProfile</code></td><td style="text-align:left">브라우저가 인터넷에 연결되어 있는지 나타낸다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"><code>oscpu</code></td><td style="text-align:left">거의 사용하지 않으며 문서도 없다.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>platform</code></td><td style="text-align:left">브라우저가 실행중인 운영체제와 CPU를 타나낸다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left">*<code>plugins</code></td><td style="text-align:left">브라우저에 설치된 플러그인을 나열한 배열이다. IE에서는 페이지의 <embed>요소를 나열한 배열이다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>preference()</code></td><td style="text-align:left">사용자 선호사항을 설정한다. 특권모드에서만 접근가능</td><td style="text-align:left">-</td><td style="text-align:center">1.5+</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>product</code></td><td style="text-align:left">브라우저 이름. 일반적으로 <a href="https://ko.wikipedia.org/wiki/%EA%B2%8C%EC%BD%94_(%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83_%EC%97%94%EC%A7%84" target="_blank" rel="noopener">“Gecko”</a>)이다.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>productSub</code></td><td style="text-align:left">브라우저에 대한 추가정보. 일반적으로 게코 버전 정보.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"><code>registerContentHandler()</code></td><td style="text-align:left">웹사이트를 특정 마임 타입 처리기로 등록한다.</td><td style="text-align:left">-</td><td style="text-align:center">2.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"><code>registerProtocolHandler()</code></td><td style="text-align:left">웹사이트를 특정 프로토콜 처리기로 등록한다.</td><td style="text-align:left">-</td><td style="text-align:center">2.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"><code>securityPolicy</code></td><td style="text-align:left">보안 정책 이름이지만 폐기되었다.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"><code>systemLanguage</code></td><td style="text-align:left">운영체제의 언어이다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"><code>taintEnabled()</code></td><td style="text-align:left">변수 테인트가 활성화 되어 잇는지 나타내지만 폐기된 기능.</td><td style="text-align:left">4.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left">*<code>userAgent</code></td><td style="text-align:left">브라우저 문자열이다.</td><td style="text-align:left">3.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>userLanguage</code></td><td style="text-align:left">운영체제의 기본 언어이다.</td><td style="text-align:left">4.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">7.0+</td></tr><tr><td style="text-align:left"><code>userProfile</code></td><td style="text-align:left">사용자 프로필 정보에 접근할 때 사용하는 객체</td><td style="text-align:left">4.0+</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>vendor</code></td><td style="text-align:left">브라우저 제조사 이름이다.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">*<code>vendorSub</code></td><td style="text-align:left">제조사에 대한 추가 정보이다.</td><td style="text-align:left">-</td><td style="text-align:center">1.0+</td><td style="text-align:center">1.0+</td><td style="text-align:center">-</td></tr></tbody></table><hr><h3 id="3-1-플러그인-감지"><a href="#3-1-플러그인-감지" class="headerlink" title="3.1 플러그인 감지"></a>3.1 플러그인 감지</h3><p>현재 크롬의 plugins<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="number">0</span>: MimeType, </span><br><span class="line">    application/x-google-chrome-pdf: MimeType, </span><br><span class="line">    name: <span class="string">"Chrome PDF Plugin"</span>,  <span class="comment">// 플러그인 이름</span></span><br><span class="line">    filename: <span class="string">"internal-pdf-viewer"</span>,  <span class="comment">// 플러그인의 파일 이름</span></span><br><span class="line">    description: <span class="string">"Portable Document Format"</span>, <span class="comment">// 플러그인 설명</span></span><br><span class="line">    length: <span class="number">1</span> <span class="comment">// 플러그인이 처리하는 마임 타입 숫자</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="number">0</span>: MimeType, application/pdf: MimeType, <span class="attr">name</span>: <span class="string">"Chrome PDF Viewer"</span>, <span class="attr">filename</span>: <span class="string">"mhjfbmdgcfjbbpaeojofohoefgiehjai"</span>, <span class="attr">description</span>: <span class="string">""</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">0</span>: MimeType, <span class="number">1</span>: MimeType, application/x-nacl: MimeType, application/x-pnacl: MimeType, <span class="attr">name</span>: <span class="string">"Native Client"</span>, <span class="attr">filename</span>: <span class="string">"internal-nacl-plugin"</span>, <span class="attr">description</span>: <span class="string">""</span>, …&#125;,</span><br><span class="line">  &#123;<span class="number">0</span>: MimeType, <span class="number">1</span>: MimeType, application/x-shockwave-flash: MimeType, application/futuresplash: MimeType, <span class="attr">name</span>: <span class="string">"Shockwave Flash"</span>, <span class="attr">filename</span>: <span class="string">"PepperFlashPlayer.plugin"</span>, <span class="attr">description</span>: <span class="string">"Shockwave Flash 28.0 r0"</span>, …&#125;,</span><br><span class="line">  &#123;<span class="number">0</span>: MimeType, application/x-ppapi-widevine-cdm: MimeType, <span class="attr">name</span>: <span class="string">"Widevine Content Decryption Module"</span>, <span class="attr">filename</span>: <span class="string">"widevinecdmadapter.plugin"</span>, <span class="attr">description</span>: <span class="string">"Enables Widevine licenses for playback of HTML audio/video content. (version: 1.4.8.1030)"</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-2-처리기-등록"><a href="#3-2-처리기-등록" class="headerlink" title="3.2 처리기 등록"></a>3.2 처리기 등록</h3><hr><hr><h2 id="4-screen-객체"><a href="#4-screen-객체" class="headerlink" title=" 4. screen 객체"></a><a name="screen"></a> 4. screen 객체</h2><p>window의 프로퍼티이다.<br>픽셀 너비와 높이 등 클라이언트 화면에 대한 정보가 들어있다.</p><ul><li>개인적인 생각 : UI나 인터렉션부분에서 많이 적용될 듯 하다.</li></ul><p>(*은 크롬)</p><table><thead><tr><th style="text-align:left">프로퍼티/메서드</th><th style="text-align:left">설명</th><th style="text-align:left">IE</th><th style="text-align:center">파이어폭스</th><th style="text-align:center">사파리/크롬</th><th style="text-align:center">오페라</th></tr></thead><tbody><tr><td style="text-align:left">*<code>availHeight</code></td><td style="text-align:left">시스템 요소를 제외한 화면의 픽셀 높이이다.</td><td style="text-align:left">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td></tr><tr><td style="text-align:left">*<code>availLeft</code></td><td style="text-align:left">시스템 요소가 아닌 영역 중 왼쪽에서 첫 번째 픽셀이다. (읽기전용)</td><td style="text-align:left"></td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">*<code>availTop</code></td><td style="text-align:left">시스템 요소가 아닌 영역 중 위에서 첫 번째 픽셀이다. (읽기전용)</td><td style="text-align:left"></td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">*<code>availWidth</code></td><td style="text-align:left">시스템 요소를 제외한 화면의 픽셀 너비이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td></tr><tr><td style="text-align:left"><code>bufferDepth</code></td><td style="text-align:left">시스템 요소를 제외한 화면의 픽셀 너비이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">*<code>colorDepth</code></td><td style="text-align:left">색깔 비트 숫자이며 대부분 32이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td></tr><tr><td style="text-align:left"><code>deviceXDPI</code></td><td style="text-align:left">화면의 실제 가로 DPI이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>deviceYDPI</code></td><td style="text-align:left">화면의 실제 세로 DPI이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>fontSmoothingEnabled</code></td><td style="text-align:left">폰트를 부드럽게 처리하는 기술이 활성화되어있는지 나타낸다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">*<code>height</code></td><td style="text-align:left">화면의 픽셀 높이이다.</td><td style="text-align:left">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td></tr><tr><td style="text-align:left"><code>left</code></td><td style="text-align:left">현재 화면의 왼쪽 모서리로부터의 픽셀 거리이다.</td><td style="text-align:left"></td><td style="text-align:center">○</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>logicalXDPI</code></td><td style="text-align:left">화면의 논리적 가로 DPI이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>logicalYDPI</code></td><td style="text-align:left">화면의 논리적 세로 DPI이다. (읽기전용)</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">*<code>pixelDepth</code></td><td style="text-align:left">화면의 픽셀당 비트 숫자이다. (읽기전용)</td><td style="text-align:left"></td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td></tr><tr><td style="text-align:left"><code>top</code></td><td style="text-align:left">현재 화면의 위쪽 모서리로부터의 픽셀 거리이다.</td><td style="text-align:left"></td><td style="text-align:center">○</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>updateInterval</code></td><td style="text-align:left">화면을 몇 밀리초마다 업데이트하는지 나타낸다.</td><td style="text-align:left">○</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">*<code>width</code></td><td style="text-align:left">화면의 픽셀너비이다.</td><td style="text-align:left">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td><td style="text-align:center">○</td></tr></tbody></table><hr><hr><h2 id="5-history-객체"><a href="#5-history-객체" class="headerlink" title=" 5. history 객체"></a><a name="history"></a> 5. history 객체</h2><ul><li>window의 프로퍼티.</li><li>창을 첫 번째 연 이후 사용자의 내비게이션 히스토리를 보관한다.</li><li>브라우저 창, 탭, 프레임은 각각 자신의 window 객체에 속한 history객체를 가진다.</li><li>보안을 이유로 사용자가 방문했던 URL은 알 수 없다.<br><img src="/images/post_img/57/01.png"><blockquote><p>알 수 없는 url</p></blockquote></li></ul><h3 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h3><h4 id="1-go"><a href="#1-go" class="headerlink" title="1. go()"></a>1. go()</h4><p><code>history.go(-1)</code> : 한페이지 뒤로<br><code>history.go(1)</code> : 한페이지 앞으로<br><code>history.go(2)</code> : 두페이지 앞으로</p><h4 id="2-back"><a href="#2-back" class="headerlink" title="2. back()"></a>2. back()</h4><p>한페이지 뒤로</p><h4 id="3-forward"><a href="#3-forward" class="headerlink" title="3. forward()"></a>3. forward()</h4><p>한페이지 앞으로</p><h3 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h3><p><code>length</code> : history 스택에 기록이 얼마나 많이 있는지 나타낸다. 0일경우 사용자가 페이지를 처음 열었을 때인 것이다.</p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://meetup.toast.com/posts/89" target="_blank" rel="noopener">http://meetup.toast.com/posts/89</a></li></ol><h3 id="생소했던-단어"><a href="#생소했던-단어" class="headerlink" title="생소했던 단어"></a>생소했던 단어</h3><ol><li>MIME타입</li><li>Gecko</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;목
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>7/ BOM (브라우저 객체 모델)</title>
    <link href="http://feel5ny.github.io/2017/12/24/JS_07_1/"/>
    <id>http://feel5ny.github.io/2017/12/24/JS_07_1/</id>
    <published>2017-12-24T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><hr><hr><p><strong>목차</strong></p><ol><li><a href="#window">window 객체</a><br>1.1 <a href="#global">전역 스코프</a> : window.전역변수명, window.전역함수명<br>1.2 <a href="#frame">창 사이의 관계와 프레임</a><br>1.3 <a href="#screen-position">창의 위치</a> : screenLeft, screenTop<br>1.4 <a href="#screen-size">창의 크기</a> : innerWidth, outerWidth<br>1.5 <a href="#navigation&amp;open">내비게이션과 열기</a> : window.open, window.close<br>1.6 <a href="#interval&amp;timeout">인터벌과 타임아웃</a> : setInterval, setTimeout<br>1.7 <a href="#system-popup">시스템 대화상자</a> : alert, prompt, confirm, print, find<br>—- 2편 &#128071;</li><li>location 객체</li><li>navigator 객체</li><li>screen 객체</li><li>history 객체</li></ol><hr><hr><h2 id="1-window-객체"><a href="#1-window-객체" class="headerlink" title=" 1. window 객체"></a><a name="window"></a> 1. window 객체</h2><p>BOM은 웹 페이지 콘텐츠와 무관하게 <code>브라우저 기능을 노출하는 객체</code>이다.</p><p><img src="/images/post_img/56/BOM-01.png"></p><p>브라우저의 인스턴스 =&gt; window 객체<br>웹페이지에서 정의한 모든 객체, 변수, 함수에서는<br><strong>window가 Global 객체(= 표준내장객체) 구실을 하고,</strong><br>window에 정의된 parseInt()등의 메서드를 이용한다. <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">+</a></p><blockquote><p>global objects와 global object는 다르다.<br>global objects는 표중내장객체, global object는 전역객체이다.(실행 컨택스트에서 GO)</p></blockquote><hr><h3 id="1-1-전역-스코프"><a href="#1-1-전역-스코프" class="headerlink" title=" 1.1 전역 스코프"></a><a name="global"></a> 1.1 전역 스코프</h3><p>전역에서 선언한 <code>변수</code>와 <code>함수</code>는 모두<br><strong>window 객체의 프로퍼티 및 메서드</strong>가 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">const</span> sayAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age); <span class="comment">// 전역을 가리키는 this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>.age);  <span class="comment">// 29</span></span><br><span class="line">sayAge();           <span class="comment">// 29</span></span><br><span class="line"><span class="built_in">window</span>.sayAge();    <span class="comment">// 29</span></span><br></pre></td></tr></table></figure></p><h4 id="전역변수와-window-프로퍼티로-직접-정의하는-것의-차이"><a href="#전역변수와-window-프로퍼티로-직접-정의하는-것의-차이" class="headerlink" title="전역변수와 window 프로퍼티로 직접 정의하는 것의 차이."></a>전역변수와 window 프로퍼티로 직접 정의하는 것의 차이.</h4><ul><li>전역 변수는 <code>delete</code>연산자로 제거할 수 없고, window 프로퍼티는 가능하다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age;    <span class="comment">// 제거 안됨</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color;  <span class="comment">// 제거 됨</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>.color)</span><br></pre></td></tr></table></figure><h4 id="선언하지-않았을-가능성이-있는-변수의-존재-여부는-window-객체를-통해-확인-가능"><a href="#선언하지-않았을-가능성이-있는-변수의-존재-여부는-window-객체를-통해-확인-가능" class="headerlink" title="선언하지 않았을 가능성이 있는 변수의 존재 여부는 window 객체를 통해 확인 가능"></a>선언하지 않았을 가능성이 있는 변수의 존재 여부는 window 객체를 통해 확인 가능</h4><p><img src="/images/post_img/56/BOM-02.png"></p><hr><h3 id="1-2-창-사이의-관계와-프레임"><a href="#1-2-창-사이의-관계와-프레임" class="headerlink" title=" 1.2 창 사이의 관계와 프레임"></a><a name="frame"></a> 1.2 창 사이의 관계와 프레임</h3><p>페이지에 프레임이 들어 있으면 각 프레임은 독자적인 window객체를 가지며, frames 컬렉션에 저장된다.</p><hr><h3 id="1-3-창의-위치"><a href="#1-3-창의-위치" class="headerlink" title=" 1.3 창의 위치"></a><a name="screen-position"></a> 1.3 창의 위치</h3><p><code>screenLeft</code>  : 디바이스 화면 왼쪽에서 브라우저 창까지 가로 거리<br><code>screenTop</code> : 디바이스 화면 위쪽에서 브라우저 창까지 세로 거리<br><code>moveBy(가로이동 픽셀수, 세로이동 픽셀수)</code> : (왼-&gt;오 / 위-&gt; 아래)<br><code>moveTo(x좌표, y좌표)</code></p><ul><li><code>moveBy</code> <code>moveTo</code> 크롬, 오페라, IE7이상은 안됨</li></ul><hr><h3 id="1-4-창의-크기"><a href="#1-4-창의-크기" class="headerlink" title=" 1.4 창의 크기"></a><a name="screen-size"></a> 1.4 창의 크기</h3><p>크기측정</p><ul><li><code>innerWidth</code> : 브라우저 창 내부의 페이지 뷰포트 크기 (모바일도 가능)</li><li><code>innerHeight</code> : 브라우저 창 내부의 페이지 뷰포트 크기 (모바일도 가능)</li><li><code>outerWidth</code> : 브라우저 창의 크기</li><li><code>outerHeight</code> : 브라우저 창의 크기</li></ul><p>크기조절 (IE6이상 크롬 오페라에서는 금지)</p><ul><li><code>resizeTo(최종너비, 최종높이)</code></li><li><code>resizeBy(너비 얼만큼 바꿀지, 높이 얼만큼 바꿀지)</code></li></ul><hr><h3 id="1-5-내비게이션과-열기"><a href="#1-5-내비게이션과-열기" class="headerlink" title=" 1.5 내비게이션과 열기"></a><a name="navigation&open"></a> 1.5 내비게이션과 열기</h3><p><code>window.open()</code> : URL로 이동한 후 브라우저 창을 새로 연다.</p><ul><li>이동할 URL, 대상 창, 기능을 나타내는 <code>string</code></li><li>마지막으로 새 페이지가 브라우저 히스토리에서 현재 페이지를 대체할지 나타내는 <code>boolean</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://feel5ny.github.io"</span>, <span class="string">"topFrame"</span>)</span><br><span class="line"><span class="comment">// 두번째 인자는 a태그에서 target과 같다.</span></span><br></pre></td></tr></table></figure></li></ul><p>두번째 인자에는 <code>_self</code>,<code>_parent</code>,<code>_top</code>,<code>_blank</code>사용가능</p><h4 id="팝업창"><a href="#팝업창" class="headerlink" title="팝업창"></a>팝업창</h4><blockquote><p>소셜 인증시 팝업창이 open되고, close될 때 사용된다.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://feel5ny.github.io"</span>, <span class="string">"topFrame"</span>, </span><br><span class="line"><span class="string">"height=400, width=400, top=10, left=10, resizable=yes"</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">옵션</th><th style="text-align:left">값</th><th style="text-align:left">설명</th></tr></thead><tbody><tr><td style="text-align:left"><code>fullscreen</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">브라우저 창을 최대 크기로 생성할지 나타낸다.</td></tr><tr><td style="text-align:left"><code>height</code></td><td style="text-align:left">숫자</td><td style="text-align:left">새 창의 높이이다. 최소값은 100</td></tr><tr><td style="text-align:left"><code>left</code></td><td style="text-align:left">숫자</td><td style="text-align:left">새 창의 x좌표이다. 음수는 쓸 수 없다.</td></tr><tr><td style="text-align:left"><code>location</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">주소 표시줄을 표시할지 나타낸다. 기본 값은 브라우저에 따라 다르다. “no”로 지정하면 브라우저에 따라 주소 표시줄을 숨기거나 비활성화한다.</td></tr><tr><td style="text-align:left"><code>menubar</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">메뉴 바를 표시할지 나타낸다. 기본값은 “no”</td></tr><tr><td style="text-align:left"><code>resizable</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">새 창의 테두리를 드래그해서 크기를 조절할 수 있는지 나타냅니다. 기본값은 “no”</td></tr><tr><td style="text-align:left"><code>scrollbars</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">새 창 콘텐츠가 뷰표트를 넘칠 때 스크롤을 허용할지 나타낸다. 기본값은 “no”</td></tr><tr><td style="text-align:left"><code>status</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">상태 바를 표시할지 나타낸다. 기본 값은 브라우저에 따라 다르다.</td></tr><tr><td style="text-align:left"><code>toolbar</code></td><td style="text-align:left">“yes” or “no”</td><td style="text-align:left">툴바를 표시할지 나타낸다. 기본값은 “no”</td></tr><tr><td style="text-align:left"><code>top</code></td><td style="text-align:left">숫자</td><td style="text-align:left">새 창의 y좌표. 음수는 쓸 수 없다.</td></tr><tr><td style="text-align:left"><code>width</code></td><td style="text-align:left">숫자</td><td style="text-align:left">새 창의 너비. 최솟값은 100</td></tr></tbody></table><h5 id="window-open"><a href="#window-open" class="headerlink" title="window.open()"></a><code>window.open()</code></h5><p>메서드는 새로 생성한 창에 대한 참조를 반환한다.<br>기본적으로 주요 브라우저 창의 위치나 크기를 스크립트에서 바꿀 수 없게 금지되지만, .open으로 생성한 창은 가능하다. (크롬은 CORS에 걸림)<br><code>window.close()</code>는 <code>window.open()</code>으로 생성된 창에서만 적용가능하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://feel5ny.github.io"</span>, <span class="string">"topFrame"</span>, </span><br><span class="line"><span class="string">"height=400, width=400, top=10, left=10, resizable=yes"</span>)</span><br><span class="line"></span><br><span class="line">wroxWin.resizeTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">wroxWin.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>wroxWin</code>은 <code>opener</code>프로퍼티를 갖고 있는데, window.open()을 호출한 창이나 프레임을 가리키는 포인터이다.<br>그 역은 존재하지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://feel5ny.github.io"</span>, <span class="string">"topFrame"</span>, </span><br><span class="line"><span class="string">"height=400, width=400, top=10, left=10, resizable=yes"</span>)</span><br><span class="line"></span><br><span class="line">alert(wroxWin.opener === <span class="built_in">window</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="1-6-인터벌과-타임아웃"><a href="#1-6-인터벌과-타임아웃" class="headerlink" title=" 1.6 인터벌과 타임아웃"></a><a name="interval&timeout"></a> 1.6 인터벌과 타임아웃</h3><p>window에는 코드가 특정 시간에 실행되게끔 해주는 메서드가 있다.<br><code>setTimeout(실해코드, 시간(밀리초))</code> : 일정 시간 뒤에 코드를 실행<br><code>setInterval()</code> : 일정 시간마다 코드를 반복 실행</p><h4 id="128336-setTimeout"><a href="#128336-setTimeout" class="headerlink" title="&#128336; setTimeout()"></a>&#128336; <code>setTimeout()</code></h4><p>자바스크립트는 큐를 이용해 각 코드의 실행을 관리한다.</p><blockquote><p>큐?  Task 큐와 이벤트 루프이다. Task 큐는 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이라 할 수 있고, 이벤트 루프는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 해 준다.</p></blockquote><p><code>clearTimeout(setTimeout이 할당된 변수이름. 혹은 id값)</code> : 타임아웃을 취소할 때 사용한다.</p><h4 id="128171-setInterval"><a href="#128171-setInterval" class="headerlink" title="&#128171; setInterval()"></a>&#128171; <code>setInterval()</code></h4><p>페이지가 종료되거나 인터벌을 취소하기 전에는 일정 시간마다 코드를 반복 실행한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'test'</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><p><code>clearInterval()</code> : 인터벌을 취소한다.<br>인터벌을 취소하지 않으면 페이지가 떠 있는 동안은 계속 실행되므로 <strong>인터벌 취소는 timeout 취소보다 중요</strong></p><hr><h3 id="1-7-시스템-대화상자"><a href="#1-7-시스템-대화상자" class="headerlink" title=" 1.7 시스템 대화상자"></a><a name="system-popup"></a> 1.7 시스템 대화상자</h3><p><code>alert()</code> : Ok<br><code>confirm()</code> : Ok / cancel<br><code>prompt()</code> : input / Ok / cancel</p><ul><li>대화상자의 외관은 css가 아니라 운영체제/브라우저 설정에 따라 다르다.</li><li>동기적이고 modal 성질이 있어서 대화상자가 떠 있을 때는 코드 실행이 중지된다.</li></ul><p><code>window.print()</code> : 인쇄 대화상자 표시<br><code>window.find(&#39;찾을 단어&#39;)</code> : 찾기 대화상자 표시</p><hr><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://meetup.toast.com/posts/89" target="_blank" rel="noopener">http://meetup.toast.com/posts/89</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;목
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>componentDidUpdate</title>
    <link href="http://feel5ny.github.io/2017/12/23/log_002/"/>
    <id>http://feel5ny.github.io/2017/12/23/log_002/</id>
    <published>2017-12-23T09:23:55.000Z</published>
    <updated>2018-08-15T14:45:09.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="componentDidUpdate-prevProps-prevState"><a href="#componentDidUpdate-prevProps-prevState" class="headerlink" title="componentDidUpdate(prevProps, prevState)"></a><code>componentDidUpdate(prevProps, prevState)</code></h2><p><strong>&lt; Props Update &gt;</strong></p><p>props가 업데이트될 때의 과정입니다. 업데이트되기 전에 업데이트가 발생하였음을 감지하고, componentWillReceiveProps 메소드가 호출됩니다. 그 후 shouldComponentUpdate, componentWillUpdate가 차례대로 호출된 후, 업데이트가 완료(render)되면 componentDidUpdate가 됩니다.<br><code>이 메소드들은 첫 번째 인자로 바뀔 props에 대한 정보를 가지고 있습니다.</code> componentDidUpdate만 이미 업데이트되었기 때문에 바뀌기 이전의 props에 대한 정보를 가지고 있습니다.</p><p><img src="/images/post_img/55/01.png"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123; <span class="comment">// 이전 props, state에 대한 정보</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.todos.length !== <span class="keyword">this</span>.props.todos.length) &#123;</span><br><span class="line">      <span class="comment">// 이전 todo리스트의 길이가 달라지면(추가,삭제) 상태변화</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        dataSource: <span class="keyword">this</span>.state.ds.cloneWithRowsAndSections(</span><br><span class="line">          _.groupBy(<span class="keyword">this</span>.props.todos, <span class="string">'createdAt'</span>),</span><br><span class="line">        ),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prevState.isTodoList !== <span class="keyword">this</span>.state.isTodoList) &#123;</span><br><span class="line">      <span class="comment">// 탭 이동</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isTodoList) &#123; <span class="comment">// 완료된 탭일 때,</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="comment">// 완료된 탭만 필터된 datasource</span></span><br><span class="line">          dataSource: <span class="keyword">this</span>.state.ds.cloneWithRowsAndSections(</span><br><span class="line">            _.groupBy(_.filter(<span class="keyword">this</span>.props.todos, <span class="function">(<span class="params">todo</span>) =&gt;</span> todo.isDone), <span class="string">'createdAt'</span>),</span><br><span class="line">          ),</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          dataSource: <span class="keyword">this</span>.state.ds.cloneWithRowsAndSections(</span><br><span class="line">            _.groupBy(<span class="keyword">this</span>.props.todos, <span class="string">'createdAt'</span>),</span><br><span class="line">          ),</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>참고링크<br><a href="https://www.zerocho.com/category/React/post/579b5ec26958781500ed9955" target="_blank" rel="noopener">https://www.zerocho.com/category/React/post/579b5ec26958781500ed9955</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;componentDidUpdate-prevProps-prevState&quot;&gt;&lt;a href=&quot;#componentDidUpdate-prevProps-prevState&quot; class=&quot;headerlink&quot; title=&quot;componentDidUpda
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="log" scheme="http://feel5ny.github.io/categories/TIL-9997/log/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>TCP / UDP</title>
    <link href="http://feel5ny.github.io/2017/12/21/CS_04/"/>
    <id>http://feel5ny.github.io/2017/12/21/CS_04/</id>
    <published>2017-12-21T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:20.888Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/post_img/65/IP.png"></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 소켓은 신뢰할 수 있는 프로토콜이다. 두 머신에서 데이터를 주고 받을 때, 파일에 쓰는 것처럼 한 쪽에서 쓰고 다른 쪽에서 읽을 수 있다.<br>연결은 신뢰할 수 있고 순차적이다.<br>즉, 한 쪽에서 보낸 데이터는 다른 쪽에서 안전하게 받을 수 있다.<br>TCP 소켓도 데이터 스트림이다. 데이터를 잘라 패킷에 담아 네트워크로 보낸다.</p><p>TCP가 단순할 수 있었던 기반에는 IP가 있다.<br>IP에는 커넥션과 관련된 컨셉은 없다. 대신 패킷이 한 컴퓨터에서 다른 컴퓨터로 전달되는 것과 관련이 있다.</p><p>교실에서 손편지를 써서 건너건너 친구에게 전달하는 걸 떠올려보자.<br>어떻게든 친구에게 편지가 도착하긴 하겠지만, 여러 사람을 거쳐 전달될 거다.<br>편지가 친구에게 정확하게 도착할 거란 보장은 없다.<br><strong>단지, 잘 도착하기만 바라고 보낼 뿐이다.</strong><br>편지가 잘 도착했는지 알 수 있는 방법이 없다.<br>물론, 실제론, 어떤 컴퓨터도 가장 빠르게 도달할 수 있는 방법을 알지 못하기 때문에 이보다 더 복잡하기도 하다.<br>가끔은 패킷을 복사해 여러 경로로 보낼 수도 있다. 이에 따라 각각 도착시간이 달라질 수도 있다.</p><h3 id="UDP-user-datagram-protocol"><a href="#UDP-user-datagram-protocol" class="headerlink" title="UDP (user datagram protocol)"></a>UDP (user datagram protocol)</h3><p>다른 방법으로, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결하는 건 어떨까?<br>이 때 UDP를 사용할 수 있다.<br>UDP는 “user datagram protocol”의 약자인데, TCP와 같이 IP 기반 위에 구현되어 있다.<br>하지만, 다른 것과 달리 간단한 작업을 하는 아주 얇은 레이어만 올려져 있다.</p><p>UDP를 사용해서, 목적지의 IP(예: 112.140.20.10) 주소와 포트(예:52432)로 메시지를 보낼 수 있고,<br>컴퓨터를 거쳐 거쳐 목적지까지 도달할 수도 있고, 아님 도착하지 않을 수도 있다.</p><p>받는 곳에서는 포트(52432)를 열어두고, 패킷이 올 때까지 기다린다.<br>이 때, 어떤 컴퓨터에서 온 것이든 모두 받아들인다. (커넥션이 없다는 것을 기억한다)<br>받는 쪽에서는 패킷이 도착했을 때 이게 어느 IP의 어느 포트에서 왔고 크기가 얼마나 되는지 알 수 있다.<br>그리곤 패킷 데이터를 읽을 수 있다.</p><p><strong>UDP는 안정적이지 않은 프로토콜이다.</strong><br>일반적으로는 1~5% 정도의 데이터를 잃는 경우가 많고, 심지어는 전혀 받지 못할 수도 있다. 패킷이 전송된 순서 또한 보장되지 않는다.</p><p>UDP는 IP에서 많은 일을 하지 않는다.<br>데이터가 전송될 수도 안될 수도 있지만, <strong>UDP가 보장해주는 건 데이터의 ‘양’</strong>이다.<br>한 쪽에서 256바이트를 보냈으면, 받는 쪽에서도 무조건 256바이트를 받는다.<br>처음 100바이트를 받을 수는 없다.</p><p>정리</p><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><ul><li>커넥션 기반</li><li>안정성과 순서를 보장한다</li><li>패킷을 자동으로 쪼개준다</li><li>적당한 속도로 보내준다. (회선이 처리할 수 있을 만큼)</li><li>파일을 쓰는 것처럼 사용하기 쉽다</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>커넥션 기반이 아니다. 직접 구현해야 한다</li><li>안정적이지 않고 순서도 보장되지 않는다. 데이터를 잃을 수도, 중복될 수도 있다.</li><li>데이터가 크다면, 보낼 때 직접 패킷 단위로 잘라야 한다.</li><li>회선이 처리할 수 있을만큼 나눠서 보내야 한다.</li><li>패킷을 잃었을 경우, 필요하다면 다양한 방법으로 이를 찾아내서 다시 보내야 한다.</li></ul><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><p>1.<a href="http://ohgyun.com/431" target="_blank" rel="noopener">http://ohgyun.com/431</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/post_img/65/IP.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h3&gt;&lt;p&gt;TCP 소켓은 신뢰할 수 있는 프로토
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CS" scheme="http://feel5ny.github.io/categories/TIL-9997/CS/"/>
    
    
      <category term="CS" scheme="http://feel5ny.github.io/tags/CS/"/>
    
      <category term="network" scheme="http://feel5ny.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>네트워크 basic</title>
    <link href="http://feel5ny.github.io/2017/12/20/CS_03/"/>
    <id>http://feel5ny.github.io/2017/12/20/CS_03/</id>
    <published>2017-12-20T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>수업 전 미리 알아보기</p><hr><p>목차 </p><ol><li><a href="#network">네트워크란?</a></li><li><a href="#internet">인터넷이란?</a></li><li><a href="#osi7">OSI 7 Layer &amp; TCP/IP Model Layer</a></li></ol><hr><h2 id="네트워크란"><a href="#네트워크란" class="headerlink" title=" 네트워크란?"></a><a name="network"></a> 네트워크란?</h2><p>두 대 이상의 컴퓨터 들을 연결하고 서로 통신(이야기) 할수 있는 것</p><h3 id="네트워크의-종류"><a href="#네트워크의-종류" class="headerlink" title="네트워크의 종류"></a>네트워크의 종류</h3><ol><li>PAN (Personal Area Network) : 가장 작은 규모의 네트워크</li><li>LAN (Local Area Network) : 근거리 영역 네트워크</li><li>Man (Metropolitan Area Network) : 대도시 영역 네트워크</li><li>Wan (Wide Area Network) : 광대역 네트워크 (지역과 지역, 지방과 지방, 나라와 나라, 대륙과 대륙을 연결하는 네트워크)</li></ol><p><img src="/images/post_img/66/network.jpg"><br><img src="/images/post_img/66/wan.jpg"></p><h3 id="1-LAN"><a href="#1-LAN" class="headerlink" title="1. LAN"></a>1. LAN</h3><p>Local Area Network : 근거리 통신망<br>LAN의 토폴로지에 따라 버스형, 링형, 스타형, 계층형, 메쉬형 등으로 구분할수 있다.<br>*토폴로지란 (Topologies) : 네트워크를 구성하는 노드와 노드간에 연결 상태에 대한 배치를 의미한다. </p><p><img src="/images/post_img/66/topology.jpg"></p><h4 id="1-1-Bus-Topology-버스형"><a href="#1-1-Bus-Topology-버스형" class="headerlink" title="1-1. Bus Topology (버스형)"></a>1-1. Bus Topology (버스형)</h4><p>신뢰성과 확장성이 좋으며 모든 노드 들이 버스에 <code>T 자형</code>으로 연결 되어 상호 <code>Point - to - Point</code> 형태를 가지게 됩니다. 각 노드들의 연결은 <code>어뎁터(Adapter)</code>를 사용하며 양 끝 단에 <code>Terminator</code>를 두게 됩니다.<br>각 노드의 고장은 전체 네트워크 부분에 영향을 미치는 점을 가지며 CSMA/CD 방식을 주로 사용, 케이블 사용량이 적기 때문에 투자 비용이 적게 드는 편입니다.</p><p>*CSMA/CD 방식이란</p><ul><li>호스트가 채널의 상태를 감지해 충돌을 피하는 매체접근방식</li><li>CSMA(Carrier Sense Multiple Access)</li><li>호스트가 전송하기 전에 매체의 전압을 점검하여 회선이 사용되지 않는 상태임을 확인하고 전송을 시작함</li></ul><h4 id="1-2-Ring-Topology-링형"><a href="#1-2-Ring-Topology-링형" class="headerlink" title="1-2. Ring Topology (링형)"></a>1-2. Ring Topology (링형)</h4><p>통신제어가 간단하고 신뢰성이 높으며 <code>장거리 네트워크</code>에서 사용 가능 합니다.<br><code>링(Ring) 형태</code>를 이루지만 노드간 통신은 <code>Point - to - Point</code> 를 가지며<br>각 노드에서 신호 재생이 가능 하기 때문에 버스 형태와 달리 <strong>거리 제약이 적으며 잡음에도 강합니다.</strong></p><h4 id="1-3-Star-Topology-스타형-성형"><a href="#1-3-Star-Topology-스타형-성형" class="headerlink" title="1-3. Star Topology (스타형/성형)"></a>1-3. Star Topology (스타형/성형)</h4><p>중앙 제어 방식으로 모든 기기가 <code>Point - to - Point</code> 방식으로 연결 되어 있으며 문제 해결이 쉽고 하나의 기기의 고장은 전체에 영향을 미치지 않지만 중앙 제어 장비가 고장이 나면 모든 시스템에 영향을 미치게 됩니다. 케이블 사용량이 많으며 비용 또한 큰 편입니다.</p><h4 id="1-4-Mash-Topology-메쉬형"><a href="#1-4-Mash-Topology-메쉬형" class="headerlink" title="1-4. Mash Topology (메쉬형)"></a>1-4. Mash Topology (메쉬형)</h4><p>네트워크 상의 모든 컴퓨터들이 연결되어진 형태로써 연결 된 기기나 노드가 고장나더라도 다른 경로를 통해 통신이 가능하며 어떠한 경우에도 네트워크가 동작한다는 장점을 가지게 됩니다.<br>하지만, 네트워크에 연결된 기기의 수가 많을 경우 모든 기기와 연결 해야 하기 때문에 <code>케이블 사용량이 많으며</code> 구조 또한 복잡하여 <code>네트워크 관리가 힘들어 진다</code>는 단점을 가지고 있습니다.</p><h4 id="1-5-Fully-Connected"><a href="#1-5-Fully-Connected" class="headerlink" title="1-5. Fully Connected"></a>1-5. Fully Connected</h4><hr><h2 id="2-인터넷이란"><a href="#2-인터넷이란" class="headerlink" title=" 2. 인터넷이란?"></a><a name="internet"></a> 2. 인터넷이란?</h2><p>International Network 의 합성어 로써 TCP/IP ( Transmission Control Protocol / Internet Protocol ) 을 기반으로 전세계의 네트워크를 하나로 연결 하여 각각 PC가 가지고 있는 자료나 정보를 주고 받을 수 있는 광역 네트워크를 인터넷 이라고 합니다.</p><p>*다른 정의</p><ul><li>LAN 과 LAN 을 연결 하는 WAN 이 서로 다른 WAN 들과 연결 되어 하나의 네트워크를 구성한 네크워크를 칭함.</li><li>전세계의 정보를 쉽게 얻을 수 있는 정보의 바다이며, 다양한 정보 자원을 자유로운 분산과 공유를 통해 상업적인 목적 목적이 아닌 무료로 사용 할수 있어야 한다.</li><li>모든 국가 들이 네트워크 통해 연결 되어 전세계를 하나의 공동체로 구성한 네트워크를 인터넷이라 한다.</li></ul><h3 id="2-1-Protocol"><a href="#2-1-Protocol" class="headerlink" title="2-1. Protocol"></a>2-1. Protocol</h3><p>사람과 사람이 통신할때 서로 이해할 수 있는 언어, 공용된 언어를 사용해 전세계 모든 사람과 대화 할수 있다라고 하면, 컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것인데 이 것이 바로 프로토콜(Protocol) 입니다.<br>어떤 시스템이 다른 시스템과 통신을 원활하게 수용하도록 해주는 통신 규약, 약속</p><p>프로토콜의 기능으로써 </p><ol><li>세분화와 재합성</li><li>캡슐화</li><li>연결제어</li><li>오류제어</li><li>흐름제어</li><li>동기화</li><li>순서 결정</li><li>주소 설정</li><li>다중화</li><li>전송 서비스 </li></ol><p>순서 결정<br><img src="/images/post_img/66/protocol_order.png"><br>세분화와 재합성<br><img src="/images/post_img/66/protocol_segment.png"></p><p><img src="/images/post_img/66/protocol.gif"></p><p>프로토콜은 특성에 따라 여러가지 형태로 분류할수 있으며 각각 형태를 구분 지어 본다면</p><ol><li>직접/간접 프로토콜</li><li>단일체/구조적 프로토콜</li><li>대칭/비대칭 프로토콜</li></ol><p>네트워크 용어에서 나오는 P 는 Protocol 의 약자가 대부분이며 대표적으로 인터넷을 할 때 사용되는 프로토콜은 TCP/IP 가 있습니다.<br>TCP/IP 는 Transmission Control Protocol / Internet Protocol 의 약자로써 컴퓨터와 컴퓨터가 통신 회선 등으로 연결 하기 위한 통신 규약입니다.<br>그외 HTTP, ARP, ICMP, SNMP, SMTP, POP, FTP, TFTP, DHCP 등이 프로토콜의 종류입니다.</p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1%ED%8E%B8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%ACNetwork-%EB%9E%80?category=702276" target="_blank" rel="noopener">http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1%ED%8E%B8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%ACNetwork-%EB%9E%80?category=702276</a></li><li><a href="http://www.jidum.com/" target="_blank" rel="noopener">네트워크 쉽게 이해하기-전편</a></li><li><a href="http://minhaep.tistory.com/entry/%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9CProtocol%EC%9D%B4%EB%9E%80" target="_blank" rel="noopener">프로토콜 기능</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;수업 전 미리 알아보기&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#network&quot;&gt;네트워크란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#internet&quot;&gt;인터넷이란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#osi7&quot;&gt;
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CS" scheme="http://feel5ny.github.io/categories/TIL-9997/CS/"/>
    
    
      <category term="CS" scheme="http://feel5ny.github.io/tags/CS/"/>
    
      <category term="network" scheme="http://feel5ny.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Database basic</title>
    <link href="http://feel5ny.github.io/2017/12/19/DB_01/"/>
    <id>http://feel5ny.github.io/2017/12/19/DB_01/</id>
    <published>2017-12-19T09:23:55.000Z</published>
    <updated>2018-08-15T14:43:40.600Z</updated>
    
    <content type="html"><![CDATA[<p>목차 </p><ol><li><a href="#rdbms">RDBMS</a></li><li><a href="#ddl">DDL, DML</a></li><li><a href="#aggregate">Aggregate, Group Function</a></li><li><a href="#sql">SQL</a></li><li><a href="#erd">ERD</a></li><li><a href="#table">Table 생성</a></li></ol><hr><h1 id="1-RDBMS"><a href="#1-RDBMS" class="headerlink" title=" 1. RDBMS"></a><a name="rdbms"></a> 1. RDBMS</h1><p><code>Relational Database Management System</code></p><ul><li>F.커드씨가 도입한 관계형 모델을 기반으로 데이터베이스를 관리하는 방식이다.</li><li>RDBMS의 종류로는 Oracle, Mysql 등이 널리 사용되고있다.</li><li>Relational을 표현하기 위하여 <a href="#erd">ERD</a>(Entity-Relationship Diagram)으로 테이블을 표현한다.</li></ul><hr><hr><h1 id="2-DDL-DML"><a href="#2-DDL-DML" class="headerlink" title=" 2. DDL, DML"></a><a name="ddl"></a> 2. DDL, DML</h1><h2 id="DDL-Data-Definition-Language"><a href="#DDL-Data-Definition-Language" class="headerlink" title="DDL (Data Definition Language)"></a>DDL (Data Definition Language)</h2><p>Table 자체를 구성하는대 사용한다.</p><hr><h3 id="1-Create-db-스키마-객체를-생성"><a href="#1-Create-db-스키마-객체를-생성" class="headerlink" title="1. Create : db 스키마 객체를 생성"></a>1. <code>Create</code> : db 스키마 객체를 생성</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book (</span><br><span class="line">  bookno <span class="built_in">NUMBER</span>(<span class="number">5</span>), <span class="comment">/* 데이터타입을 설정해 주는 것이다. 숫자 5자리까지 */</span></span><br><span class="line">  title VARCHAR2(<span class="number">50</span>), <span class="comment">/* 문자열 50자까지 설정 */</span></span><br><span class="line">  author VARCHAR2(<span class="number">10</span>), <span class="comment">/* 문자열 10자리까지 설정 */</span></span><br><span class="line">  pubdate <span class="built_in">DATE</span> <span class="comment">/* 날짜 데이터타입 */</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="2-Data-Type"><a href="#2-Data-Type" class="headerlink" title="2. Data Type"></a>2. <code>Data Type</code></h3><ul><li><code>VARCHAR2(size)</code> : 가변길이 문자열 (최대 4000byte)</li><li><code>CHAR(size)</code> : 고정길이 문자열 (최대 2000byte)</li><li><code>NUMBER(p,s)</code> : 가변길이 숫자. 전체 p자리 중 소수점 이하 s자리<ul><li><code>p</code> : 38</li><li><code>s</code> : -84 ~ 127</li><li>21 byte</li></ul></li><li><code>DATE</code> : 고정길이 날짜 + 시간 (7byte)</li></ul><hr><h3 id="3-Alter-변경"><a href="#3-Alter-변경" class="headerlink" title="3. Alter : 변경"></a>3. <code>Alter</code> : 변경</h3><ul><li>테이블 칼럼 추가<br><code>ALTER Table Student ADD (name VARCHAR(50));</code></li><li>테이블 칼럼 수정<br><code>ALTER Table Student MODIFY (name VARCHAR(50));</code></li><li>테이블 칼럼 삭제<br><code>ALTER Table Student DROP name;</code></li></ul><hr><h3 id="4-Drop-db-스키마-제거"><a href="#4-Drop-db-스키마-제거" class="headerlink" title="4. Drop : db 스키마 제거"></a>4. <code>Drop</code> : db 스키마 제거</h3><ul><li>db가 날라갈 수 있는 위험한 명령어!</li><li><code>DROP Table Student</code></li></ul><hr><h3 id="5-Truncate-스키마는-유지하면서-자료만-버림"><a href="#5-Truncate-스키마는-유지하면서-자료만-버림" class="headerlink" title="5. Truncate: 스키마는 유지하면서 자료만 버림"></a>5. <code>Truncate</code>: 스키마는 유지하면서 자료만 버림</h3><ul><li><code>TRUNCATE Table Student</code></li></ul><hr><h3 id="6-Rename-이름-변경"><a href="#6-Rename-이름-변경" class="headerlink" title="6. Rename : 이름 변경"></a>6. <code>Rename</code> : 이름 변경</h3><ul><li><code>RENAME Student TO employee</code></li></ul><hr><h3 id="7-Comment-테이블에-설명-추가"><a href="#7-Comment-테이블에-설명-추가" class="headerlink" title="7. Comment : 테이블에 설명 추가"></a>7. <code>Comment</code> : 테이블에 설명 추가</h3><hr><h3 id="8-Constraint-테이블에-제약조건-생성"><a href="#8-Constraint-테이블에-제약조건-생성" class="headerlink" title="8. Constraint : 테이블에 제약조건 생성"></a>8. <code>Constraint</code> : 테이블에 제약조건 생성</h3><p>Table의 특정규약을 설정한다 즉 제약조건이다.</p><ul><li>NOT NULL</li><li>UNIQUE</li><li>CHECK</li></ul><h4 id="PRIMARY-KEY-gt-PRIMARY-KEY는-NOT-NULL-UNIQUE하다"><a href="#PRIMARY-KEY-gt-PRIMARY-KEY는-NOT-NULL-UNIQUE하다" class="headerlink" title="PRIMARY KEY =&gt; PRIMARY KEY는  NOT NULL + UNIQUE하다."></a>PRIMARY KEY =&gt; PRIMARY KEY는  NOT NULL + UNIQUE하다.</h4><ul><li>PK는 한테이블당 한개만 존재</li><li>인덱스 자동생성</li><li>여러 컬럼을 하나의 PK로 설정 가능<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book (</span><br><span class="line">  ssn1 <span class="built_in">NUMBER</span>(<span class="number">6</span>),</span><br><span class="line">  ssn2 <span class="built_in">NUMBER</span>(<span class="number">7</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (ssn1, ssn2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h4 id="FOREIGN-KEY-gt-주의-PRIMARY-KEY에게만-FOREIGN-KEY-가능"><a href="#FOREIGN-KEY-gt-주의-PRIMARY-KEY에게만-FOREIGN-KEY-가능" class="headerlink" title="FOREIGN KEY =&gt; 주의 PRIMARY KEY에게만 FOREIGN KEY 가능"></a>FOREIGN KEY =&gt; 주의 PRIMARY KEY에게만 FOREIGN KEY 가능</h4><ul><li>ON DELETE SET NULL : 해당하는 FK를 NULL로 바꾼다.</li><li>ON DELETE CASCADE : 해당하는 FK를 가진 참조행도 삭제</li></ul><hr><hr><h2 id="DML-Data-Manipulation-Language"><a href="#DML-Data-Manipulation-Language" class="headerlink" title="DML (Data Manipulation Language)"></a>DML (Data Manipulation Language)</h2><p><code>Insert</code>, <code>Delete</code>, <code>Select</code>,<code>Update Table</code> 내부의 data를 바꿀때 사용한다. </p><hr><h3 id="1-Insert"><a href="#1-Insert" class="headerlink" title="1. Insert"></a>1. <code>Insert</code></h3><p>테이블 Data 추가<br><code>INSERT INTO 테이블이름 (col1, col2) VALUES(“val1”, “val2”);</code></p><hr><h3 id="2-Delete"><a href="#2-Delete" class="headerlink" title="2. Delete"></a>2. <code>Delete</code></h3><p>테이블 Data 추가<br><code>DELETE FROM 테이블이름 Where id = 1;</code></p><hr><h3 id="3-Update"><a href="#3-Update" class="headerlink" title="3. Update"></a>3. <code>Update</code></h3><p>테이블 Data 추가<br><code>UPDATE 테이블이름 SET 변경내용 Where id = 1;</code></p><hr><h1 id="3-Aggregate-Group-Function"><a href="#3-Aggregate-Group-Function" class="headerlink" title=" 3. Aggregate, Group Function"></a><a name="aggregate"></a> 3. Aggregate, Group Function</h1><h2 id="Aggregate-Function"><a href="#Aggregate-Function" class="headerlink" title="Aggregate Function"></a>Aggregate Function</h2><h3 id="1-AVG"><a href="#1-AVG" class="headerlink" title="1. AVG"></a>1. AVG</h3><p>평균 구하기<br><code>SELECT AVG(salary) FROM Student;</code></p><ul><li>Group By<br><code>SELECT 부서명, AVG(salary) FROM 직장; =&gt; 오류 발생</code><br>=&gt; <code>SELECT 부서명, AVG(salary) FROM 직장 GROUP BY 부서명</code></li><li>Having</li></ul><h3 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2. SUM"></a>2. SUM</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(col_name) <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(salary) <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><ul><li>COUNT</li><li>MAX</li><li>MIN</li></ul><hr><h1 id="4-SQL"><a href="#4-SQL" class="headerlink" title=" 4. SQL"></a><a name="sql"></a> 4. SQL</h1><h2 id="SQL-Structured-Query-Language"><a href="#SQL-Structured-Query-Language" class="headerlink" title="SQL(Structured Query Language)"></a>SQL(Structured Query Language)</h2><p>: 구조화된 질의 언어</p><ul><li>가장 기본적인 문법</li><li><code>Select</code>(Table의 원하는 col을 선택하다)</li><li><code>From</code> (어떠한 Table에서)</li><li><p><code>Where</code> (특정 조건)</p></li><li><p>Student 테이블을 전부다 가져오고싶다.<br><code>Select*From Student; =&gt; *</code>는 전부를 나타낸다.</p></li><li>Student 테이블중에서 name(col)을 가져오고싶다.<br><code>Select name From Student;</code></li><li>Student 테이블중에서 name(col)이 Joy 가져오고싶다.<br><code>Select name From Student Where name=Joy;</code></li></ul><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p>둘 이상의 테이블을 합쳐서 하나의 테이블로 만든다.</p><ul><li><p><code>Cross Join</code> (Cartasian Product) 모든 가능한 쌍이 나타난다.</p><h4 id="Inner-Join-조건을-만족하는-tuple만-나타난다"><a href="#Inner-Join-조건을-만족하는-tuple만-나타난다" class="headerlink" title="Inner Join 조건을 만족하는 tuple만 나타난다."></a><code>Inner Join</code> 조건을 만족하는 tuple만 나타난다.</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, jobname <span class="keyword">FROM</span> Student <span class="keyword">Inner</span> <span class="keyword">Join</span> Job</span><br><span class="line"><span class="keyword">ON</span> Student.id = Job.student_id;</span><br></pre></td></tr></table></figure></li><li><p><code>Outer Join</code> 조건을 만족하지 않는 tuple도 나타난다. =&gt; null로 표기<br>Left Outer Join =&gt; join table의 왼쪽 table 값중 null인 것도 가져온다.<br>Right Outer Join =&gt; join table의 오른쪽 table 값중 null인 것도 가져온다.<br>Full Outer Join =&gt; 양쪽 table 값중 null인 것도 가져온다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, jobname <span class="keyword">FROM</span> Student <span class="keyword">Left</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Job </span><br><span class="line"><span class="keyword">ON</span> Student.id = Job.student_id;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, jobname <span class="keyword">FROM</span> Student <span class="keyword">Right</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Job</span><br><span class="line"><span class="keyword">ON</span> Student.id = Job.student_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, jobname <span class="keyword">FROM</span> Student <span class="keyword">Full</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Job</span><br><span class="line"><span class="keyword">ON</span> Student.id = Job.student_id;</span><br></pre></td></tr></table></figure><ul><li><code>Natural Join</code> 조건을 만족하는 tuple들의 동일한 col이 합쳐져서 나타난다.</li><li><code>Self Join</code> 자기 자신과 Join</li></ul><hr><h1 id="5-ERD"><a href="#5-ERD" class="headerlink" title=" 5. ERD"></a><a name="erd"></a> 5. ERD</h1><p>Entity-Relationship Diagram<br>mySql에서 자동으로 그려준다.</p><p><img src="/images/post_img/47/01.png"></p><h2 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto increment"></a>auto increment</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#rdbms&quot;&gt;RDBMS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ddl&quot;&gt;DDL, DML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#aggregate&quot;&gt;Aggregate, Group Function&lt;
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Database" scheme="http://feel5ny.github.io/categories/TIL-9997/Database/"/>
    
    
      <category term="database" scheme="http://feel5ny.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Database basic</title>
    <link href="http://feel5ny.github.io/2017/12/19/dev_seminar_angular/"/>
    <id>http://feel5ny.github.io/2017/12/19/dev_seminar_angular/</id>
    <published>2017-12-19T09:23:55.000Z</published>
    <updated>2018-08-15T14:43:44.265Z</updated>
    
    <content type="html"><![CDATA[<ol><li>복습해야할 것</li></ol><ul><li>앵귤러에서 리듀서를 사용해야하는 이유</li><li>service를 주입안해도 store만 주입해도 가능.</li><li>한 페이지에서 한 액션에 여러 컴포넌트가 바뀌어야할 때 좋음.</li><li></li></ul><hr><h1 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h1><h2 id="1-모듈-설치"><a href="#1-모듈-설치" class="headerlink" title="1. 모듈 설치"></a>1. 모듈 설치</h2><h3 id="1-패키지-설치"><a href="#1-패키지-설치" class="headerlink" title="1. 패키지 설치"></a>1. 패키지 설치</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;@clr/angular&quot;: &quot;^0.11.14&quot;,</span><br><span class="line">&quot;@clr/icons&quot;: &quot;^0.11.14&quot;,</span><br><span class="line">&quot;@clr/ui&quot;: &quot;^0.11.14&quot;,</span><br><span class="line">&quot;@webcomponents/custom-elements&quot;: &quot;^1.0.0&quot;</span><br></pre></td></tr></table></figure><blockquote><p>한번에 설치하는 방법<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @clr/&#123;ui,icons,angular&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-스타일-추가"><a href="#2-스타일-추가" class="headerlink" title="2. 스타일 추가"></a>2. 스타일 추가</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;styles&quot;: [</span><br><span class="line">  &quot;../node_modules/@clr/icons/clr-icons.min.css&quot;,</span><br><span class="line">  &quot;../node_modules/@clr/ui/clr-ui.min.css&quot;,</span><br><span class="line">  &quot;styles.css&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ol><li><p>리다리렉트</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;&apos;, redirectTo: BannerComponent &#125;</span><br></pre></td></tr></table></figure></li><li><p>라우터 설치하는.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g m route --routing</span><br></pre></td></tr></table></figure></li><li><p>aot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng server --aot</span><br></pre></td></tr></table></figure></li></ol><p>로그가 남겨질 때 버그가 잇어서 aot추가<br>preload를 사용하려면 aot를 추가해야지 chunk로 나뉘어서 버들링된다.</p><ol><li>preload<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes, &#123;</span><br><span class="line">    preloadingStrategy: PreloadAllModules</span><br><span class="line">  &#125;)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>main bundle에서 전부 다운로드를 하는 것이 아니라, main이 다 받아지면 우선 main만 보여주고, 다른 컴포넌트들은 백그라운드에서 다운받고 있는 상황.<br>(프리로드가 없을때는 main이 초기에 전부다 다운이 받아야 dom이 그려진다.)</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private productService: ProductService) &#123;</span><br><span class="line">    productService.getProducts()</span><br><span class="line">      .do(console.log)</span><br><span class="line">      .subscribe(v =&gt; this.products = v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>modal도 url 관리를 해야함<br>=&gt; 리프레시할때 모달이 꺼지는 상황이 연출될 수 있음.</p></li><li><p>route.snapshot은 그 순간의 라우터<br>다이나믹하게 라우터의 id값을 받고 싶을 경우 observable로 받아야함.<br>route.params.subscribe()</p></li><li><p>어떤 게시물 index에서 아이디가 없는 경우 처리하는 방법.<br><strong>canActivate</strong>사용</p></li><li><p>resolve</p></li></ol><hr><p>쉬는시간</p><hr><ol><li><p>angular에 redux셋팅<br>서비스가 많아질 수록 관리가 힘들어질 수 있다.<br>하나의 서비스처럼 (store) 설정하자.</p></li><li><p>cli를 확장할 수 있다. =&gt; 커스텀한 cli 만들 수 있음.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install @ngrx/schematics</span><br><span class="line">ng set defaults.schematics.collection=@ngrx/schematics</span><br><span class="line">ng g store State --root --module app.module.ts</span><br></pre></td></tr></table></figure></li><li><p>cli로 한꺼번에 생성하는 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g s store home/Home -m home/home.module.ts</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng g s store home/Home -m home/home.module.ts</span><br><span class="line">&gt;  create src/app/store.service.ts (111 bytes)</span><br><span class="line">&gt;  update src/app/home/home.module.ts (329 bytes)</span><br></pre></td></tr></table></figure><hr><ol><li><code>forFeature</code>로 각각 컴포넌트 별로 스토어 연결</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g reducer home/Counter --reducers reducers/index.ts --group --spec fix</span><br></pre></td></tr></table></figure><p><strong>ngrx/effects</strong></p><blockquote><p>비동기 처리때 데이터 성공여부를 후킹하는.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrx/platform</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g feature product-mngt/ProductMngt -m product-mngt.module -g --spec false</span><br></pre></td></tr></table></figure><p>모듈돤위로 effect, reducer, action을 한번에 만들고 싶을 때 =&gt; featrue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;&#125;, state, &#123;key: value&#125;)</span><br></pre></td></tr></table></figure><hr><p>#React</p><ol><li>복습, 공부해야할것</li></ol><ul><li>async, await</li><li>HOC vs RenderProps</li></ul><ol><li>코드 스플리트<br>레이지로드와 비슷</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;복습해야할 것&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;앵귤러에서 리듀서를 사용해야하는 이유&lt;/li&gt;
&lt;li&gt;service를 주입안해도 store만 주입해도 가능.&lt;/li&gt;
&lt;li&gt;한 페이지에서 한 액션에 여러 컴포넌트가 바뀌어야할 때 좋음
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Database" scheme="http://feel5ny.github.io/categories/TIL-9997/Database/"/>
    
    
      <category term="database" scheme="http://feel5ny.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>2/ React data 처리</title>
    <link href="http://feel5ny.github.io/2017/12/18/React_03/"/>
    <id>http://feel5ny.github.io/2017/12/18/React_03/</id>
    <published>2017-12-17T16:21:19.000Z</published>
    <updated>2018-08-15T14:45:36.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>스터디 공유용 자료입니다.</p></blockquote><hr><p>목차</p><ol><li>fetch API</li><li>실습</li></ol><hr><h2 id="1-fatch-api"><a href="#1-fatch-api" class="headerlink" title="1. fatch api"></a>1. fatch api</h2><p>axios와 비슷한 promise 기반의 HTTP REQUEST API<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">참고</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 응답 data를 받고 싶은 곳.</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 에러를 받고 싶은 곳.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/little-big-programming/%EB%82%B4%EA%B0%80-fetch-api%EB%A5%BC-%EC%93%B0%EC%A7%80-%EB%AA%BB%ED%96%88%EB%8D%98-%EC%9D%B4%EC%9C%A0-3c23f0ec6b82" target="_blank" rel="noopener">fatch api의 단점을 경험한 포스팅</a></p><hr><h2 id="2-실습"><a href="#2-실습" class="headerlink" title="2. 실습"></a>2. 실습</h2><p>api주소 <a href="https://api.github.com/users" target="_blank" rel="noopener">https://api.github.com/users</a></p><ol><li>시맨틱 셋팅</li><li>Lifecycle Hook 중 한 곳에 get method 셋팅</li><li>받은 데이터 저장</li><li>로딩처리<ul><li><a href="https://codepen.io/" target="_blank" rel="noopener">codepen</a></li></ul></li><li>view</li></ol><hr><h2 id="3-Lodash"><a href="#3-Lodash" class="headerlink" title="3. Lodash"></a>3. Lodash</h2><p>A modern JavaScript utility library delivering modularity, performance &amp; extras.</p><ul><li>주로 서버에서 오는 데이터 구조가 렌더해야할 구조와 다를 때 사용합니다.<br><a href="https://lodash.com/docs/4.17.4" target="_blank" rel="noopener">https://lodash.com/docs/4.17.4</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;스터디 공유용 자료입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;목차&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fetch API&lt;/li&gt;
&lt;li&gt;실습&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-fatch-api&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="React" scheme="http://feel5ny.github.io/categories/TIL-9997/React/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>1/ React router</title>
    <link href="http://feel5ny.github.io/2017/12/13/React_02/"/>
    <id>http://feel5ny.github.io/2017/12/13/React_02/</id>
    <published>2017-12-13T00:21:19.000Z</published>
    <updated>2018-08-15T14:45:36.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>스터디 공유용 자료입니다.<br><a href="http://slides.com/woongjae/react-router#/" target="_blank" rel="noopener">http://slides.com/woongjae/react-router#/</a> 참고하였습니다.</p></blockquote><p>리액트는 SPA위한 자바스크립트 라이브러리이기 때문에, 클라이언트 사이드 렌더링과 클라이언트 사이드 라우팅이 필요합니다.</p><ul><li>react-router는 하나의 라이브러리이다. <a href="https://reacttraining.com/" target="_blank" rel="noopener">+</a></li><li>다른 router라이브러리도 있고, 직접 만들 수 있다.</li><li>페이스북에서 공식적으로 나온 라이브러리는 아니지만, 많은 사람들이 쓰고 있는 라우터 라이브러리이다. </li><li>react router v3는 다르다고 봐야한다.</li><li>react-router와 react-router-dom이 나눠져 있는 이유는 리액트 네이티브에서도 사용하기 위해서이다.</li></ul><h3 id="리액트-라우터를-사용하는-이유"><a href="#리액트-라우터를-사용하는-이유" class="headerlink" title="리액트 라우터를 사용하는 이유"></a>리액트 라우터를 사용하는 이유</h3><ul><li>여러 페이지들이 존재하는 서비스를 만들때 필요. </li><li>url 주소나 특정상태에 따라서 view를 나누기 위해서 사용한다. </li></ul><hr><h3 id="라우터의-여러-API"><a href="#라우터의-여러-API" class="headerlink" title="라우터의 여러 API"></a>라우터의 여러 API</h3><p>자주 사용하는 API를 봅시다.</p><p>가장 기본셋팅 </p><ol><li><code>BrowserRouter</code></li><li><code>Link</code></li><li><code>Route</code></li></ol><h2 id="셋팅하기"><a href="#셋팅하기" class="headerlink" title="셋팅하기"></a>셋팅하기</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app 프로젝트이름 --scripts-version=react-scripts-ts</span><br></pre></td></tr></table></figure><p>react-router-dom을 설치하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure></p><p>type definition 추가.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/react-router-dom</span><br></pre></td></tr></table></figure></p><ol><li>css 프레임워크를 붙여봅시다.<br><a href="https://react.semantic-ui.com/" target="_blank" rel="noopener">https://react.semantic-ui.com/</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add semantic-ui-react</span><br><span class="line">yarn add semantic-ui-css</span><br></pre></td></tr></table></figure></li></ol><p>css import는 최상위 컴포넌트에서</p><ul><li>css는 전역으로 설정됩니다.</li></ul><ol><li>import 허락<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"allowSyntheticDefaultImports": true</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-lt-BrowserRouter-gt"><a href="#1-lt-BrowserRouter-gt" class="headerlink" title="1. &lt;BrowserRouter&gt;"></a>1. <code>&lt;BrowserRouter&gt;</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br></pre></td></tr></table></figure><ul><li>브라우저 히스토리를 이용해서 구현할 라우터</li><li>하나의 자식만을 가질 수 있기 때문에, div로 감싸야한다. 아니면 자식이 여러명이라는 에러가 뜸.</li><li>다른 라우팅 컴포넌트(Route, Link)를 사용하기 위해서 기본적으로 감싸줘야 함</li><li><code>window.history.pushState()</code>로 동작하는 라우터 (리로드 없이 주소만 갱신하는 함수)</li><li>이와 비슷하게 HashRouter는 Hash(#/)으로 동작하는 Router임</li></ul><h4 id="2-lt-Link-gt"><a href="#2-lt-Link-gt" class="headerlink" title="2. &lt;Link&gt;"></a>2. <code>&lt;Link&gt;</code></h4><p>HTML의 a태그와 유사하다.</p><ul><li><a>로 렌더링되고 사용법도 비슷하지만,</a></li><li>실제 동작은 <a>와 다르게 페이지 전체를 리로드하지 않고</a></li><li>필요한 부분만 리로드하게 됨<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-lt-Route-gt"><a href="#3-lt-Route-gt" class="headerlink" title="3. &lt;Route&gt;"></a>3. <code>&lt;Route&gt;</code></h4><ul><li>path 속성으로 경로지정</li><li>render, component, children 속성으로 렌더링</li><li>실제 경로가 지정한 경로와 완벽히 매치되지 않더라도, 경로를 포함만 해도 렌더링</li><li>정확히 매칭될 때만 렌더하고 싶은 경우 exact 옵션 사용</li><li>컴포넌트에 <code>match, location, history</code>라는 객체를 넘김</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exact=&#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-Route-gt-props-알아보기"><a href="#lt-Route-gt-props-알아보기" class="headerlink" title="&lt;Route&gt; props 알아보기"></a><code>&lt;Route&gt;</code> props 알아보기</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = <span class="function">(<span class="params">props: RouteComponentProps&lt;&#123; postId: <span class="built_in">string</span> &#125;&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h3&gt;Post: &#123;props.match.params.postId&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="match-객체"><a href="#match-객체" class="headerlink" title="match 객체"></a>match 객체</h4><p><route>의 <code>path</code>에 정의한 것과 매치된 정보를 담고있음</route></p><h3 id="location-객체"><a href="#location-객체" class="headerlink" title="location 객체"></a>location 객체</h3><p>브라우저의 window.location 객체와 비슷함<br>URL을 다루기 쉽게 쪼개서 가지고 있음</p><h3 id="history-객체"><a href="#history-객체" class="headerlink" title="history 객체"></a>history 객체</h3><p>브라우저의 window.history 객체와 비슷함<br>주소를 임의로 변경하거나 되돌아갈 수 있음<br>주소를 변경하더라도 SPA 동작방식에 맞게 페이지 일부만 리로드</p><h4 id="4-lt-Redirect-gt"><a href="#4-lt-Redirect-gt" class="headerlink" title="4. &lt;Redirect&gt;"></a>4. <code>&lt;Redirect&gt;</code></h4><ul><li>말그대로 Redirect를 하는 컴포넌트</li><li>마운트 되면 지정한 경로로 이동함</li><li>기본적으로 replace 방식</li><li>location 객체를 통해 리다이렉트 할 수도 있음<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.localStorage.token) &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;Redirect to="/login" /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            exact</span><br><span class="line">            path="/"</span><br><span class="line">            component=&#123;HomePage&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-withRouter"><a href="#5-withRouter" class="headerlink" title="5. withRouter"></a>5. <code>withRouter</code></h4><p>withRouter HOC를 통해 히스토리 객체의 속성과 <route>의 match에 액세스 할 수 있습니다. withRouter는 <route> render props : {match, location, history}와 같은 props로써 ㅇ라우트가 변경할 때마다 해당 구성 요소를 다시 렌더링합니다.</route></route></p><h4 id="6-Switch"><a href="#6-Switch" class="headerlink" title="6. Switch"></a>6. <code>Switch</code></h4><ul><li><code>&lt;Route&gt;</code>를 감싸서 사용</li><li>JavaScript의 switch 문과 비슷</li><li><route>중 매치되는 <code>첫번째</code>만 렌더</route></li><li><route>에 path를 지정하지 않은 경우, 매치되는 <route> 컴포넌트가 없을 때 렌더</route></route></li><li>따라서 순서에 유의해야함<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &#123;<span class="comment">/* intro페이지 &amp; 네비게이션 없는 페이지 */</span>&#125;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/login"</span></span><br><span class="line">    component=&#123;LoginPage&#125;</span><br><span class="line">  /&gt;w</span><br><span class="line">  &#123;<span class="comment">/* 서비스 페이지 (로그인 이후 접근 가능) &amp; 네비게이션 있는 페이지*/</span>&#125;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/share"</span></span><br><span class="line">    component=&#123;SharePage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    exact</span><br><span class="line">    path=<span class="string">"/"</span></span><br><span class="line">    component=&#123;HomePage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/diary"</span></span><br><span class="line">    component=&#123;DiaryPage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/report"</span></span><br><span class="line">    component=&#123;ReportPage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/weight"</span></span><br><span class="line">    component=&#123;WeightPage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/search/:sc"</span></span><br><span class="line">    component=&#123;SearchResultPage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/search"</span></span><br><span class="line">    component=&#123;SearchPage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/recipe/:id"</span></span><br><span class="line">    component=&#123;RecipePage&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-NavLink"><a href="#7-NavLink" class="headerlink" title="7. NavLink"></a>7. <code>NavLink</code></h4><ul><li>조금 특별한 <link></li><li><code>to</code>에 지정한 path와 URL이 매칭되는 경우,</li><li>특별한 스타일, 클래스를 적용할 수 있음</li></ul><h3 id="쉬어가기"><a href="#쉬어가기" class="headerlink" title="쉬어가기"></a>쉬어가기</h3><ul><li>모달을 달아보면서 state개념잡기.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;스터디 공유용 자료입니다.&lt;br&gt;&lt;a href=&quot;http://slides.com/woongjae/react-router#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://slides.com/woong
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="React" scheme="http://feel5ny.github.io/categories/TIL-9997/React/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>소팅 알고리즘</title>
    <link href="http://feel5ny.github.io/2017/12/10/CS_02/"/>
    <id>http://feel5ny.github.io/2017/12/10/CS_02/</id>
    <published>2017-12-10T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:19.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>아직 정리 덜 됨.</p></blockquote><p>정렬할 데이터가 특수한 형태가 아니라면 standard 정렬 알고리즘을 쓰는것이 가장 좋지만, 정렬알고리즘에도 여러가지가 있고 각각의 정렬방법마다 빅오 노테이션이 다르다.</p><hr><p>목차 </p><ol><li>버블 정렬 bubble sort</li><li>선택 정렬 Selection sort</li><li>삽입 정렬 Insertion sort</li><li>병합 정렬 Merge sort</li><li>퀵 정렬 Quick sort</li></ol><hr><h2 id="1-버블정렬-Bubble-sort"><a href="#1-버블정렬-Bubble-sort" class="headerlink" title="1. 버블정렬(Bubble sort)"></a>1. 버블정렬(Bubble sort)</h2><p>버블정렬은 가장 쉬운 정렬 알고리즘이지만 시간복잡도가 좋은 퍼포먼스를 내지 못해서 실제로는 잘 사용되지 않는다.<br>시간복잡도는 O(n²)이며 공간복잡도는 하나의 배열만 사용하여 정렬을 진행하기 때문에 O(n)이다.<br>자신과 다음의 요소를 비교하여 인덱스를 정한다.</p><p><img src="/images/post_img/50/bubble.gif"></p><hr><h2 id="2-선택정렬-Selection-sort"><a href="#2-선택정렬-Selection-sort" class="headerlink" title="2. 선택정렬(Selection sort)"></a>2. 선택정렬(Selection sort)</h2><p>선택정렬은 시간복잡도가 O(n²)으로 버블정렬과 정렬하는 알고리즘이 버블정렬과 유사하다.<br><strong>한번 순회를 하면서 가장 큰 수를 찾아서 배열의 마지막 위치와 교환한다.</strong></p><p><img src="/images/post_img/50/selection.gif"></p><hr><h2 id="3-삽입정렬-Insertion-Sort"><a href="#3-삽입정렬-Insertion-Sort" class="headerlink" title="3. 삽입정렬(Insertion Sort)"></a>3. 삽입정렬(Insertion Sort)</h2><p>삽입정렬은 1부터 n까지 Index를 설정하여 현재위치보다 아래쪽을 순회하며 현재위치의 값을 현재위치보다 아래쪽으로 순회하며 알맞은 위치에 넣어주는 정렬알고리즘이다.<br>삽입정렬은 이미 정렬이 되어있다면 O(n)의 시간복잡도를 가지게된다. 정렬이 되어있는 경우라면 한번 순회하며 체크만 하기 때문이며 Big-O 시간복잡도는 O(n²)이다.</p><p><img src="/images/post_img/50/insertion.gif"></p><hr><h2 id="4-병합정렬-Merge-sort"><a href="#4-병합정렬-Merge-sort" class="headerlink" title="4.병합정렬 (Merge sort)"></a>4.병합정렬 (Merge sort)</h2><ul><li>재귀의 이해가 있어야한다.</li></ul><p>병합정렬은 정렬할 리스트를 반으로 쪼개나가며 좌측과 우측 리스트를 계속하여 분할해 나간 후 각 리스트내에서 정렬 후 병합(merge) 정렬 후 병합하는 과정을 통해 정렬하는 알고리즘이다.<br>병합정렬은 가장 많이 쓰이는 정렬 알고리즘 중 하나 이며 시간복잡도는 최소 O(nlogn)을 보장하게 된다.</p><ol><li>Divide</li><li>Conquer</li><li>Combine</li></ol><p><img src="/images/post_img/50/merge.gif"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 합병정렬 </span></span><br><span class="line"><span class="comment">// 퀵정렬과 마찬가지로 분할 정복 알고리즘중 하나이다.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console.log(MergeSort([234, 45634, 23, 41, 2345, 34, 23, 1, 4, 3, 6, 234, 4536, 55, 234, 23, 456, 45, 234, 1, 856, 9, 67, 56, 7]))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">const</span> right = arr.slice(middle, len);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Divide-amp-Conquer"><a href="#Divide-amp-Conquer" class="headerlink" title="Divide &amp; Conquer"></a>Divide &amp; Conquer</h3><p>전략</p><ul><li>주어진 문제를 작은 문제들로 분할하고</li><li>작은 문제에서 해를 구한 후</li><li>구한 해를 이용해서 주어진 문제의 해를 구하는 방법</li></ul><p>특징</p><ul><li>주어진 문제를 동일한 종류의 작은 문제로 분할</li><li>문제 분할 과정이 <strong><code>재귀적</code></strong>으로 처리됨</li></ul><blockquote><p>Fractal같은 문제라고 생각하면 된다.</p></blockquote><p>구성</p><ol><li><p>Divide<br>문제를 크기가 작은 동일한 종류의 sub problems로 분할</p></li><li><p>Conquer<br>재귀적으로 subproblems</p></li><li></li></ol><p>시간복잡도 구성요소</p><ol><li>문제를 분할하는 시간</li><li>분할된 문제 수 * 분할된 문제의 시간 복잡도</li><li>분할된 문제의 결과를 combine하는 시간</li></ol><p>sequence : 연속된 데이터의 집단</p><p><img src="/images/post_img/50/merge.png"><br>MERGE-SORT는 combine하는 함수이다.</p><h3 id="배열-요소가-홀수일-경우-어떻게-반을-나눌까"><a href="#배열-요소가-홀수일-경우-어떻게-반을-나눌까" class="headerlink" title="배열 요소가 홀수일 경우 어떻게 반을 나눌까.?"></a>배열 요소가 홀수일 경우 어떻게 반을 나눌까.?</h3><p>크게 고려하지 않아도 되지만, 타입캐스팅 방법처럼 계산 후 앞부분이 하나를 더 가져갈지를 판단한다.</p><h3 id="타입캐스팅"><a href="#타입캐스팅" class="headerlink" title="타입캐스팅"></a>타입캐스팅</h3><p>  타입을 바꿔주는. </p><hr><h2 id="5-퀵정렬-Quick-sort"><a href="#5-퀵정렬-Quick-sort" class="headerlink" title="5. 퀵정렬(Quick sort)"></a>5. 퀵정렬(Quick sort)</h2><p>퀵정렬은 real-world 데이터에서 빠르다고 알려져 있어 <code>가장 많이 쓰는</code> 정렬알고리즘이다.<br>퀵정렬은 pivot을 선정하여 pivot을 기준으로 좌측과 우측으로 pivot보다 작은값은 왼쪽 pivot보다 큰값은 오른쪽으로 재배치를 하고 계속하여 분할하여 정렬하는 알고리즘이다.<br>최악의 경우에는 O(n²)의 비교를 수행하지만 일반적으로 O(nlogn)의 시간복잡도를 가진다.</p><p><img src="/images/post_img/50/quick.gif"></p><hr><p>읽어볼 글</p><ol><li>quick sort는 항상 빠를까? <a href="http://asfirstalways.tistory.com/338" target="_blank" rel="noopener">+</a></li><li>quick sort에서 nlogn은 어떤 원리에서 나온 걸까? <a href="http://egloos.zum.com/wrice/v/3097929" target="_blank" rel="noopener">+</a></li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://medium.com/@fiv3star/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sorting-algorithm-%EC%A0%95%EB%A6%AC-8ca307269dc7" target="_blank" rel="noopener">https://medium.com/@fiv3star/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sorting-algorithm-%EC%A0%95%EB%A6%AC-8ca307269dc7</a></li><li><a href="http://asfirstalways.tistory.com/338" target="_blank" rel="noopener">http://asfirstalways.tistory.com/338</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;아직 정리 덜 됨.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정렬할 데이터가 특수한 형태가 아니라면 standard 정렬 알고리즘을 쓰는것이 가장 좋지만, 정렬알고리즘에도 여러가지가 있고 각각의 정렬방법마다 빅오 노테이션이 다
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CS" scheme="http://feel5ny.github.io/categories/TIL-9997/CS/"/>
    
    
      <category term="CS" scheme="http://feel5ny.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>클린코드를 위한 리팩토링</title>
    <link href="http://feel5ny.github.io/2017/12/09/Refactoring/"/>
    <id>http://feel5ny.github.io/2017/12/09/Refactoring/</id>
    <published>2017-12-09T11:12:34.000Z</published>
    <updated>2018-08-15T14:45:48.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="코드의-구린내"><a href="#코드의-구린내" class="headerlink" title="코드의 구린내 +"></a>코드의 구린내 <a href="https://github.com/KWSStudy/Refactoring/wiki/%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B5%AC%EB%A6%B0%EB%82%B4" target="_blank" rel="noopener">+</a></h2><p>구린게 있으면 그 부분을 바로 잡으세요.<br>리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링 기법을 적용하는 방법만큼 중요하다.</p><hr><h3 id="1-중복코드"><a href="#1-중복코드" class="headerlink" title="1. 중복코드"></a>1. 중복코드</h3><p>구린내의 제왕 중복코드.<br>똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선<br>한 클래스의 두 메서드 안에 같은 코드가 들어있는경우 -&gt; 메서드 추출 기법을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서 드를 두 곳에서 호출<br>수퍼클래스의 두 하위 클래스에 같은 코드가 들어 있는 경우 -&gt; 메서드 추출 기법을 적용해서 중복을 없앤 후 메서드 상향 기법을 적용하면 된다.<br>위 상황에 코드가 똑같지 않고 비슷하다면 메서드 추출기법을 적용해서 같은 부분과 다른 부분을 분리해야 한다. 그런 다음 경우에 따라 템플릿 메서드 형성 기법을 적용해야 할 수도있다.<br>두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해서 알고리즘 전환 기법을 적용하면 된다.<br>중복 코드가 메서드 가운데에 있다면 주변 메서드 추출을 적용하면된다.<br>서로 상관 없는 두 클래스 안에 중복코드가 있을 때 -&gt; 한 클래스 안의 중복 코드를 클래스 추출 이나 모듈 추출 을 적용해 제 3의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다. 또는 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른클래스에서 그 메서드를 호출하거나 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법이 있다.</p><h3 id="2-장황한-메서드"><a href="#2-장황한-메서드" class="headerlink" title="2. 장황한 메서드"></a>2. 장황한 메서드</h3><p>최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.<br>짧은 메서드를 이해하기 쉽게하려면 메서드 명을 잘 정해야한다. 메섣의 기능을 한눈에 알 수 있는 메서드명을 사용하면 그 메서드안의 코드를 분석하지 않아도된다.<br>메서드 호출이 원래 코드보다 길어지는 한이 있어도, 메서드 명은 그 코드의 의도를 잘 반영하는 것으로 정해야한다.<br>메서드명은 기능 수행 방식이 아니라 목적(즉, 기능자체)을 나타내는 이름으로 정한다.<br>메서드 추출기법을 적용한다.<br>코드를 여러 덩어리로 분리하려면?<br>주석을 찾는 것 -&gt; 기능 설명이 주석으로 처리된 코드 구간을 메서드로 만들면 된다. (긴 메서드에서 기능 설명이 주석으로 되어있는 부분)<br>조건문과 루프도 역시 메서드로 추출</p><h3 id="3-방대한-클래스"><a href="#3-방대한-클래스" class="headerlink" title="3. 방대한 클래스"></a>3. 방대한 클래스</h3><p>기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어있다. 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련</p><h3 id="4-과다한-매개변수"><a href="#4-과다한-매개변수" class="headerlink" title="4. 과다한 매개변수"></a>4. 과다한 매개변수</h3><p>매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편, 더많은 데이터가 필요해질 때마다 계속 수정해야 한다<br>즉 매개변수는 객체를 넘기도록 한다. 객체를 넘김으로써 위 문제들이 해결</p><h3 id="5-수정의-산발"><a href="#5-수정의-산발" class="headerlink" title="5. 수정의 산발"></a>5. 수정의 산발</h3><p>수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다.<br>하나의 클래스를 여러 개의 변형 객체로 분리하는것이 좋다. 그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.</p><h3 id="6-기능의-산재"><a href="#6-기능의-산재" class="headerlink" title="6. 기능의 산재"></a>6. 기능의 산재</h3><p>하나의 수정으로 여러 클래스가 바뀌게 되는 문제<br>수정할 부분들을 전부 하나의 클래스 안에 넣어줘야 한다.</p><h3 id="7-잘못된-소속"><a href="#7-잘못된-소속" class="headerlink" title="7 .잘못된 소속"></a>7 .잘못된 소속</h3><p>메서드가 자신이 속해있는 클래스보다 다른 클래스에서 더 호출이 이루어질 경우 해당 메서드를 더 접근이 많은 클래스로 옮겨줘야 한다.</p><h3 id="8-데이터-뭉치"><a href="#8-데이터-뭉치" class="headerlink" title="8. 데이터 뭉치"></a>8. 데이터 뭉치</h3><p>두 클래스에 들어 있는 인스턴스 변수나 여러 메서드 시그너처(메서드명과 인수들 목록을 메서드 시그너처 라고 부릅니다.)에 들어있는 매개변수 처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려있는 경우<br>이렇게 몰려있는 데이터 뭉치는 객체로 만들어야한다.</p><h3 id="9-강박적-기본-타입-사용"><a href="#9-강박적-기본-타입-사용" class="headerlink" title="9. 강박적 기본 타입 사용"></a>9. 강박적 기본 타입 사용</h3><p>관련된 데이터를 묶지 못하고 흩어놓게 되면, 각각의 데이터에 대한 정보를 외부에 공개해야한다.<br>함수를 만들때도 각각의 데이터를 파라미터로 넘겨주어야 하기에 파라미터의 갯수가 늘어나게 된다.<br>기본형만 사용할 바에는 객체를 만들어서(구조화)해서 사용해라<br>이때는 각각의 관련된 데이터를 하나의 구조체로 묶어 주어야한다.</p><h3 id="10-switch-문"><a href="#10-switch-문" class="headerlink" title="10. switch 문"></a>10. switch 문</h3><p>switch 문의 단점은 반드시 중복이 생긴다는 점이다. 동일한 switch가 다른 곳에서 또 쓰일가능성이 크다<br>switch 문에 새 코드행을 추가하려면 그렇게 여기저기에 존재하는 switch 문을 전부 찾아서 수정해야한다.<br>이 문제를 해결할수 있는 방법은 다형성 즉 재정의를 이용하는 것이다.<br>switch 문을 메서드 추출로 빼낸 후 메서드 이동을 실시해서 그 메서드를 재정의해야 할 클래스에 옮겨 넣으면 된다.</p><h3 id="11-평행-상속-계층"><a href="#11-평행-상속-계층" class="headerlink" title="11. 평행 상속 계층"></a>11. 평행 상속 계층</h3><p>한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위 클래스도 만들어야 한다.<br>중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속계층의 인스턴스를 참조하게 만들면 된다.</p><h3 id="12-직무유기-클래스"><a href="#12-직무유기-클래스" class="headerlink" title="12. 직무유기 클래스"></a>12. 직무유기 클래스</h3><p>하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다.<br>비용만큼의 기능을 수행하지 못하는 비효율적인 클래스는 삭제해야한다.</p><h3 id="13-막연한-범용-코드"><a href="#13-막연한-범용-코드" class="headerlink" title="13. 막연한 범용 코드"></a>13. 막연한 범용 코드</h3><p>메서드나 클래스가 오직 테스트 케이스에만 사용된다면 구린내를 풍기는 유력한 용의자로 막연한 범용코드를 지목할 수 있다. 이러한 메서드나 클래스를 발견하면 그것과 그것을 실행하는 테스트 케이스는 삭제하자.</p><h3 id="14-임시-필드"><a href="#14-임시-필드" class="headerlink" title="14. 임시 필드"></a>14. 임시 필드</h3><p>객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다.<br>이러한 떠돌이 해당 변수들을 사용하는 class를 생성한다</p><h3 id="15-메시지-체인"><a href="#15-메시지-체인" class="headerlink" title="15. 메시지 체인"></a>15. 메시지 체인</h3><p>메시지 체인?<br>클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고 …. 연쇄적으로 요청이 발생하는 문제점</p><h3 id="16-과잉-중개-메서드"><a href="#16-과잉-중개-메서드" class="headerlink" title="16. 과잉 중개 메서드"></a>16. 과잉 중개 메서드</h3><p>어떤 클래스의 인터페이스를 보니 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있을경우</p><h3 id="17-지나친-관여"><a href="#17-지나친-관여" class="headerlink" title="17. 지나친 관여"></a>17. 지나친 관여</h3><p>클래스 끼리 관계가 지나치게 밀접한 나머지 서로의 private를 알아내느라 과도한 시간낭비<br>서로 지나지게 친밀한 클래스는 메서드 이동과 필드 이동으로 떼어 낸다.</p><h3 id="18-인터페이스가-다른-대용-클래스"><a href="#18-인터페이스가-다른-대용-클래스" class="headerlink" title="18. 인터페이스가 다른 대용 클래스"></a>18. 인터페이스가 다른 대용 클래스</h3><p>기능은 같은데 시그너처가 다른 메서드에는 메서드명 변경을 실시해야 한다.</p><h3 id="19-미흡한-라이브러리-클래스"><a href="#19-미흡한-라이브러리-클래스" class="headerlink" title="19. 미흡한 라이브러리 클래스"></a>19. 미흡한 라이브러리 클래스</h3><p>라이브러리 클래스에 넣어야 할 메서드가 두 개 뿐이라면 외래 클래스에 메서드 추가 기법을, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기 법을 사용</p><h3 id="20-데이터-클래스"><a href="#20-데이터-클래스" class="headerlink" title="20. 데이터 클래스"></a>20. 데이터 클래스</h3><p>데이터 클래스(domain)는 필드 캡슐화기법을 실시해야한다<br>변경되지 않아야 하는 필드에는 쓰기 메서드 제거를 적용</p><h3 id="21-방치된-상속물"><a href="#21-방치된-상속물" class="headerlink" title="21. 방치된 상속물"></a>21. 방치된 상속물</h3><p>하위클래스가 부모클래스에게 상속받은 메서드나 데이터가 하위클래스에서 더이상 쓰이지 않거나 필요 없게 되었을때.<br>위 문제의 원인은 잘못된 계층구조<br>새 대등 클래스를 작서하고 메서드 하향과 필드하향을 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣는다.</p><h3 id="22-불필요한-주석"><a href="#22-불필요한-주석" class="headerlink" title="22. 불필요한 주석"></a>22. 불필요한 주석</h3><p>주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어보자.<br>주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다.<br>어떤 코드를 넣은 이유를 메모해 놓을 경우에도 주석을 넣는 것이 적절하다.</p><hr><h2 id="레거시-코드를-받았을-때-좋은-코드로-바꾸는-방법"><a href="#레거시-코드를-받았을-때-좋은-코드로-바꾸는-방법" class="headerlink" title="레거시 코드를 받았을 때 좋은 코드로 바꾸는 방법 +"></a>레거시 코드를 받았을 때 좋은 코드로 바꾸는 방법 <a href="https://m.blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220638991588&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" target="_blank" rel="noopener">+</a></h2><p><img src="/images/post_img/45/legacy.png"></p><p>레거시 코드의 양이 방대할 경우 부분별로 리팩토링을 진행해야 한다. 이 때, 유의할 점은 정확한 목표를 가져야 한다는 것이다. 대부분의 개발자는 성능 개선에만 초점을 두는데, 이는 또 다른 레거시 코드를 만들어 낼 수 있다. 레거시 코드를 변경하는 목적은 변경 자체가 아니라 변경시키는 행위이다. 따라서 각각의 작업 끝에는 항상 테스트 코드가 있어야 한다. 이 점을 항상 유념하며 리팩토링을 진행해야 한다.</p><h5 id="1-변경지점-식별"><a href="#1-변경지점-식별" class="headerlink" title="1. 변경지점 식별"></a>1. 변경지점 식별</h5><p>변경시킬 지점을 알기 위해서는 대상 프로그램의 전체적인 아키텍처를 보아야한다. 노트/스케치나 스크래치 리팩토링 기법과 같은 방법을 통해 변경해야 할 지점을 식별하자.</p><h5 id="2-테스트-지점-찾기"><a href="#2-테스트-지점-찾기" class="headerlink" title="2. 테스트 지점 찾기"></a>2. 테스트 지점 찾기</h5><p>리팩토링이 필요한 부분을 찾았다면 이제 어느 부분에 테스트 루틴을 작성할 것인지 결정해야 한다. 이를 위한 가장 간단한 판단 기준은 모든 메소드에 대해 테스트를 수행하는 것이다. 또한, 각 메소드들이 의존관계를 이루는 묶음끼리도 테스트가 필요한데, 이를 위해 의존관계를 최소화시키는 것이 중요하다.</p><h5 id="3-의존관계-깨기"><a href="#3-의존관계-깨기" class="headerlink" title="3. 의존관계 깨기"></a>3. 의존관계 깨기</h5><p>코드에서의 의존관계는 다른 클래스나 인터페이스에 방향성을 가지고 의지하는 코드를 의미한다. 예를 들어 A 클래스에서 B 클래스에 있는 메서드를 호출하는 상황을 가정해 보자. 이때 A 클래스가 변경되었다고 해서 B 클래스까지 변경될 필요는 없다. 이를 A 클래스가 B 클래스에 의존하고 있다고 말한다.</p><p>이러한 의존관계는 상황별 &amp; 종류별로 매우 다양하며 이를 해소하기 위한 방법도 각양각색이다. 기본적으로 의존관계란 코드의 유지 보수성을 떨어트리기 때문에, 의존관계를 최소화시키는 것이 중요하다. 각 상황별 의존관계 해소 방법을 알고 싶다면, 책으로 출간된 마이클 패더스의 Working Effectively with Legacy Code를 읽어보기 바란다.</p><h5 id="4-테스트-루틴-작성"><a href="#4-테스트-루틴-작성" class="headerlink" title="4. 테스트 루틴 작성"></a>4. 테스트 루틴 작성</h5><p>테스트 루틴을 작성할 때에는 코드의 동작을 이해하는 데 필요하다고 느끼는 만큼의 사례를 작성해야 한다. 기능을 추출하거나 이동시키려 한다면 사례별로 동작들의 존재 여부와 연결을 검증할 수 있는 테스트 루틴을 작성한다. 이동시키고자 하는 코드를 수행하는지와 그 코드가 적절히 연결되었는지를 검증한 후에 변환을 수행하도록 한다.</p><h5 id="5-변경-후-리팩토링"><a href="#5-변경-후-리팩토링" class="headerlink" title="5. 변경 후 리팩토링"></a>5. 변경 후 리팩토링</h5><p>전체적으로 볼 때 리팩토링은 덩치가 큰 메소드를 작은 단위로 쪼개는 것이다. 이렇게 된다면 코드를 좀 더 이해하기 쉽게 작성할 수 있다. 또한, 재사용성을 높일 수 있으며 시스템 안의 다른 영역들에 있는 로직과의 중복을 제거할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;코드의-구린내&quot;&gt;&lt;a href=&quot;#코드의-구린내&quot; class=&quot;headerlink&quot; title=&quot;코드의 구린내 +&quot;&gt;&lt;/a&gt;코드의 구린내 &lt;a href=&quot;https://github.com/KWSStudy/Refactoring/wiki/%
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CleanCode" scheme="http://feel5ny.github.io/categories/TIL-9997/CleanCode/"/>
    
    
      <category term="refactoring" scheme="http://feel5ny.github.io/tags/refactoring/"/>
    
      <category term="TDD" scheme="http://feel5ny.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘과 시간 복잡도</title>
    <link href="http://feel5ny.github.io/2017/12/09/CS_01/"/>
    <id>http://feel5ny.github.io/2017/12/09/CS_01/</id>
    <published>2017-12-09T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:18.520Z</updated>
    
    <content type="html"><![CDATA[<p>목차 </p><ol><li>알고리즘</li><li>시간 복잡도</li><li>Big O 표기법</li><li>Asymptotic Complexity 점근적 분석</li><li>재귀함수<ul><li>합 구하기</li><li>피보나치 수열</li></ul></li></ol><hr><p>좋은 알고리즘의 필요 요건과, 알고리즘의 실행 속도를 평가하는 방법을 알아본다.</p><h2 id="1-알고리즘"><a href="#1-알고리즘" class="headerlink" title="1. 알고리즘"></a>1. 알고리즘</h2><p>우리는 <code>finite amount of space and time</code>에 집중해야한다.<br>알고리즘은 <strong>유한한</strong> 자원을 가진 환경에서 주어진 문제를 푸는 동작의 모임이다.<br>적은 시간과 적은 자원(공간)을 이용해 문제를 해결하는 알고리즘이 좋은 알고리즘이다.</p><blockquote><p><a href="https://feel5ny.github.io/2017/11/30/JS_02/">+</a> 웹 브라우저에서 사용할 수 있는 메모리는 일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적다. 적은 메모리만 할당받는 주된 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 운영체제를 다운시키는 일을 방지하기 위함이다.<br>메모리 제한은 변수 할당 뿐만 아니라 호출스택, 스레드에서 실행할 수 있는 문장수에도 영향을 미친다.<br>즉! 가능한 최소한의 메모리만 사용해야 페이지의 성능을 올릴 수 있다. </p></blockquote><h3 id="예제-Facebook-친구-2명이-가진-공통-친구-리스트를-만드는-가장-빠르-방법은"><a href="#예제-Facebook-친구-2명이-가진-공통-친구-리스트를-만드는-가장-빠르-방법은" class="headerlink" title="예제_Facebook 친구 2명이 가진 공통 친구 리스트를 만드는 가장 빠르 방법은?"></a>예제_Facebook 친구 2명이 가진 공통 친구 리스트를 만드는 가장 빠르 방법은?</h3><p>n명의 페이스북 친구를 가진 A와 m명의 페이스북 친구를 가진 B의 공통 친구의 수는</p><ul><li>단순하게 생각한다면 n*m</li><li>800명, 400명이라면 320,000번의 비교로 찾을 수 있다.</li><li>시간복잡도를 배우고, 연산횟수를 줄이는 방법을 생각해보자.</li></ul><hr><h2 id="2-시간복잡도"><a href="#2-시간복잡도" class="headerlink" title="2. 시간복잡도 +"></a>2. 시간복잡도 <a href="https://en.wikipedia.org/wiki/Time_complexity" target="_blank" rel="noopener">+</a></h2><p>시간복잡도란 알고리즘이 문제를 해결하기 위한 <strong><code>시간(연산)의 횟수</code></strong>를 말한다.<br>computational complexity that measures or estimates the time<br>taken for running an algorithm.<br>Time complexity is commonly estimated by counting the number of <code>elementary operations</code> performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. </p><p>알고리즘을 평가하는데 있어 수행시간과 메모리 사용량을 평가기준으로 두는데<br>수행시간에 해당하는 것이 <code>시간 복잡도</code> Time Complexity,<br>메모리 사용량에 해당하는 것이 <code>공간 복잡도</code> Space Complexity이다.</p><p>연산 횟수를 카운팅 할때 3가지 경우가 있다.</p><ol><li>최선의 경우 Best Case</li><li>최악의 경우 Worst Case</li><li>평균적인 경우 Average Case</li></ol><p>평균적인 경우가 가장 이상적으로 보이겠지만 알고리즘이 복잡해 질수록 평균적인 경우는 구하기가 매우 어려워 진다. 그러므로 <strong>최악의 경우</strong>로 알고리즘의 성능을 파악한다.</p><h3 id="2-1-Program-Step에서-Elementary-Operation이란"><a href="#2-1-Program-Step에서-Elementary-Operation이란" class="headerlink" title="2-1. Program Step에서 Elementary Operation이란?"></a>2-1. Program Step에서 Elementary Operation이란?</h3><ul><li>프로그램의 진행 정도를 나타내는 기본 단위이다.</li></ul><ol><li>대입연산</li><li>덧셈, 뺄셈, 곱셈, 나눗셈</li><li>비교구문</li><li>함수호출</li></ol><p>즉, 알고리즘의 실행 순서를 따라가며 Elementary Operation이 일어나느 수를 측정한다.</p><h3 id="2-2-어떻게-카운팅할까"><a href="#2-2-어떻게-카운팅할까" class="headerlink" title="2-2. 어떻게 카운팅할까."></a>2-2. 어떻게 카운팅할까.</h3><ol><li>전역변수를 이용하여 Elementary Operation을 카운팅한다.</li><li>각 실행문 별로 Step수와 실행 횟수를 분석한다.</li></ol><h3 id="2-2-1-전역변수를-이용하여-Elementary-Operation을-카운팅"><a href="#2-2-1-전역변수를-이용하여-Elementary-Operation을-카운팅" class="headerlink" title="2-2-1. 전역변수를 이용하여 Elementary Operation을 카운팅"></a>2-2-1. 전역변수를 이용하여 Elementary Operation을 카운팅</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">list, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tempSum = <span class="number">0</span>; <span class="comment">// 대입연산</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    count++;   <span class="comment">// loop 한번 돌 때마다</span></span><br><span class="line">    tempSum += list[i];</span><br><span class="line">    count++;  <span class="comment">// 대입연산</span></span><br><span class="line">  &#125;</span><br><span class="line">  count++;  <span class="comment">// for loop 끝날 때 한번</span></span><br><span class="line">  count++;  <span class="comment">// return 수행</span></span><br><span class="line">  <span class="keyword">return</span> tempSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-2-각-실행문-별로-Step수와-실행-횟수를-분석한다"><a href="#2-2-2-각-실행문-별로-Step수와-실행-횟수를-분석한다" class="headerlink" title="2-2-2. 각 실행문 별로 Step수와 실행 횟수를 분석한다."></a>2-2-2. 각 실행문 별로 Step수와 실행 횟수를 분석한다.</h3><p><img src="/images/post_img/48/01.png"></p><p>주어진 프로그램 2개의 성능 비교 및 분석</p><ul><li>프로그램 P1의 성능 : C1 <em> n^2 + C2 </em> n</li><li>프로그램 P2의 성능 : C3 * n</li></ul><p>C1, C2, C3에 따라서 대소 비교 결과가 다름.<br>어떤 C1, C2, C3에 대해서도 C1 <em> n^2 &gt; C3 </em> n을 만족하는 n은 존재함.</p><p>n이 작으면 프로그램 P1의 성능이 더 좋을 수도 있다.<br>n이 충분히 <code>크면</code> 항상 프로그램 P2의 성능이 좋다. (P1에는 n이 제곱이기 때문에)</p><p>작은 경우 모두 성능이 좋으므로 문제될 것은 없다.<br><strong>따라서 n이 큰 경우의 처리가 중요하다.</strong></p><hr><h2 id="3-Big-O-표기법"><a href="#3-Big-O-표기법" class="headerlink" title="3. Big O 표기법"></a>3. Big O 표기법</h2><p>Big O가 중요한 이유를 알기 위해서는 Asymptotic Complexity에 대해 알야아한다.<br>알고리즘의 성능평가는 시간복잡도와 공간복잡도를 계산하고, 적 표기법으로 나타내면 된다. </p><p><img src="/images/post_img/48/02.png"></p><p>위 예와 같이 T(n)으로 표현한 함수의 <code>최고차항의 차수</code>가 빅오가 된다.<br>빅오의 순서는 아래와 같고 커질수록 좋지 않다.<br>보통 O(n^2)이상의 복잡도를 가지는 알고리즘은 좋지 않다.</p><p><img src="/images/post_img/48/03.png"><br><img src="/images/post_img/48/05.png"><br><img src="/images/post_img/48/04.png"></p><hr><h2 id="4-Asymptotic-Complexity"><a href="#4-Asymptotic-Complexity" class="headerlink" title="4. Asymptotic Complexity"></a>4. Asymptotic Complexity</h2><p>입력의 크기가 충분히 클 때의 <code>시간복잡도</code>와 <code>공간복잡도</code>를 분석하는 것. </p><p>프로그램 성능이 Asymptotic(점진적인) Complexity </p><ul><li>프로그램의 입력 크기 등 성능을 결정하는 주요 특성 값이 매우 클 때의 프로그램의 성능.</li><li>프로그램의 실행 속도가 어떤 경향을 가지는지를 평가한다고 생각하면 된다.</li><li>ex. 입력의 크기가 n이고 n이 매우 큰 경우</li><li>프로그램 성능 평가의 매우 중요한 기준.</li></ul><h3 id="4-1-점근적-분석의-필요성"><a href="#4-1-점근적-분석의-필요성" class="headerlink" title="4-1. 점근적 분석의 필요성"></a>4-1. 점근적 분석의 필요성</h3><p>어떠한 문제 해결을 위한 알고리즘의 성능분석을 할 때, 주어지는 데이터의 형태나 실험을 수행하는 환경, 또는 실험에 사용한 시스템의 성능등 다양한 요소에 의해 공평한 결과가 나오기 힘들고 비교 결과가 항상 일정하지 않을 수 있다.</p><p>이를 효과적으로 해결하는 방법이 점근적 분석법이다. 점근적 분석법은 <code>각 알고리즘이 주어진 데이터의 크기를 기준으로 수행시간 혹은 사용공간이 얼마나 되는지를 객관적으로 비교할 수 있는 기준을 제시해 준다.</code><br>O(빅오), Ω(오메가), Θ(세타)등이 있다. 일반적으로 빅오와 세타표기가 많이 사용된다.</p><h3 id="4-2-빅오-표기법-O-Notation"><a href="#4-2-빅오-표기법-O-Notation" class="headerlink" title="4-2. 빅오 표기법 O Notation"></a>4-2. 빅오 표기법 O Notation</h3><ul><li>점근적 상한선(Asymptotic upper bound)</li><li>주어진 알고리즘이 아무리 나빠도 비교하는 함수와 같거나 좋다.</li><li>정의 : O(g(n)) = {f(n) : there exist positive constants c and n0 such that 0≤f(n)≤cg(n) for all n≥n0}<br><img src="/images/post_img/48/o_notation.png"><br>n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 cg(n)보다 작거나 같다는 의미이다. 그래프가 아래에 있을 수록 수행시간이 짧은 것이므로 성능이 좋은 것이다.</li></ul><h3 id="4-3-오메가-표기법-Ω-Notation"><a href="#4-3-오메가-표기법-Ω-Notation" class="headerlink" title="4-3. 오메가 표기법 Ω Notation"></a>4-3. 오메가 표기법 Ω Notation</h3><ul><li>점근적 하한선(Asymptotic lower bound)</li><li>주어진 알고리즘이 아무리 좋아도 비교하는 함수와 같거나 나쁘다.</li><li>정의 : Ω(g(n)) = {f(n) : there exist positive constants c and n0 such that 0≤cg(n)≤f(n) for all n≥n0}<br><img src="/images/post_img/48/omega_notation.png"><br>n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 cg(n)보다 크거나 같다는 의미이다.</li></ul><h3 id="4-4-세타-표기법-Θ-Notation"><a href="#4-4-세타-표기법-Θ-Notation" class="headerlink" title="4-4. 세타 표기법 Θ Notation"></a>4-4. 세타 표기법 Θ Notation</h3><ul><li>점근선 상한선과 점근적 하한선의 교집합(Asymptotic tighter bound)</li><li>주어진 알고리즘이 아무리 좋아지거나 나빠지더라도 비교하는 함수의 범위안에 있다.</li><li>정의 : Θ(g(n)) = {f(n) : there exist positive constants c1, c2 and n0 such that 0≤c1g(n)≤f(n)≤c2g(n) for all n≥n0}<br><img src="/images/post_img/48/theta_notation.png"><br>n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 c1g(n)보다 크거나 같거나 c2g(n)보다 작거나 같다는 의미이다</li></ul><hr><h4 id="cf-의사코드란-pseudo-code"><a href="#cf-의사코드란-pseudo-code" class="headerlink" title="cf. 의사코드란? pseudo-code +"></a>cf. 의사코드란? pseudo-code <a href="https://medium.com/djangogirlsseoul-codecamp/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C-pseudo-code-%EB%9E%80-d892a3479b1d" target="_blank" rel="noopener">+</a></h4><p>의사(疑似: 비교할 의, 비슷할 사 | Pseudo: 가짜의- ) 코드는 컴퓨터 프로그램이나 알고리즘이 수행해야할 내용을 우리가 사용하는 언어 (한국어 또는 영어 등)로 간략히 서술해 놓은 것을 말합니다. 왜 의사코드를 사용해야 하나요?</p><p>의사코드는 코딩 입력을 시작하기 전, <code>사고를 좀더 명확히 정립하게 만들어주어</code> 프로그램을 설계하는데 도움이 됩니다. 실제 코드 입력을 처음 시작할 때가 제일 힘듭니다! 단순히 소스코드를 입력하는 것보다 함수(function) 프로그램을 만들 때 많은 시간을 낭비할 수 있습니다. 약 10분 정도 각 풀이법의 장점과 단점을 주도면밀하게 살펴보면서 의사코드 작성한다면, 이후 디버그를 수정하고 코드를 재분해 하는데 걸리는 시간을 단축할 수 있습니다.</p><blockquote><p>모델링이라고 생각해보자.</p></blockquote><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://ledgku.tistory.com/33" target="_blank" rel="noopener">http://ledgku.tistory.com/33</a></li><li><a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">http://bigocheatsheet.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;알고리즘&lt;/li&gt;
&lt;li&gt;시간 복잡도&lt;/li&gt;
&lt;li&gt;Big O 표기법&lt;/li&gt;
&lt;li&gt;Asymptotic Complexity 점근적 분석&lt;/li&gt;
&lt;li&gt;재귀함수&lt;ul&gt;
&lt;li&gt;합 구하기&lt;/li&gt;
&lt;li&gt;피보나치 
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="CS" scheme="http://feel5ny.github.io/categories/TIL-9997/CS/"/>
    
    
      <category term="CS" scheme="http://feel5ny.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>단위 테스트는 왜 해야할까</title>
    <link href="http://feel5ny.github.io/2017/12/08/TDD_01/"/>
    <id>http://feel5ny.github.io/2017/12/08/TDD_01/</id>
    <published>2017-12-08T09:23:55.000Z</published>
    <updated>2018-08-15T14:46:40.677Z</updated>
    
    <content type="html"><![CDATA[<hr><p>목차 </p><ol><li>단위테스트. 다들 중요하다고 하는데 왜 중요할까?</li><li>결국 클린코드를 위한 길</li><li>TDD : Test Driven Development</li><li>실습</li></ol><hr><h2 id="1-단위테스트-다들-중요하다고-하는데-왜-중요할까"><a href="#1-단위테스트-다들-중요하다고-하는데-왜-중요할까" class="headerlink" title="1. 단위테스트. 다들 중요하다고 하는데 왜 중요할까? +"></a>1. 단위테스트. 다들 중요하다고 하는데 왜 중요할까? <a href="https://cjh5414.github.io/why-pytest/" target="_blank" rel="noopener">+</a></h2><p>단위테스트는 모듈이나 어플리케이션 안에 있는 개별적인 코드 단위가 예상대로 작동하는지 확인하는 반복적인 행위이다. </p><p>프로젝트에 단위 테스트를 적용하는 데에는 “내 코드가 제대로 동작하는지 확인하는 것”이라는 명백한 이유 외에도 몇 가지 장점이 있다.</p><ul><li>단위 테스트는 코드가 “어떻게!”작성하는지 생각하는데 도움을 준다. </li><li>게다가 “무엇”을 해야하는지에 있어서 구현 선택을 검토하는데 해가 되지 않고, 그 선택들이 적절한지 아닌지 알아낸다. 주된 효과로는 단위 테스트를 추가하는 것은 애플리케이션의 유닛(함수/메소드)를 더 <code>작게</code> 만든다.</li></ul><blockquote><p>많은 일을 하는 테스팅 코드는 어렵다.’<br>‘많은 일을 하는 디버깅 코드는 어렵다.’<br>이 두 가지 문제의 해결법은 많은 일을 하지 않도록 코드를 작성하는 것이다. 각각의 함수를 단 한가지만의 일을 하도록 작성해야 한다. 이렇게 하면 단위 테스트로 쉽게 테스트할 수 있다. (하나의 함수에 대해 많은 단위 테스트가 필요하지 않는다.)<br>내 동료가 메소드를 더 작게 분리해야 하는지에 대해 판단할 때 사용하는 문구가 있다. 만약 코드의 역할을 다른 프로그래머에게 설명할 때 ‘and’라는 단어를 사용했다면 그 메소드는 적어도 하나 이상의 부분으로 나눠야 한다는 것이다. <a href="http://softwareengineering.stackexchange.com/questions/195989/is-it-ok-to-split-long-functions-and-methods-into-smaller-ones-even-though-they/195992#195992" target="_blank" rel="noopener">stackoverflow</a></p></blockquote><p>단위 테스트의 다른 장점은 문제를 빨리 발견하고 변화를 쉽게하며 통합을 간단하게 하고 설계를 개선할 수 있다는 것이다. </p><blockquote><p>여기까지 읽고 나니, 테스트코드를 짜는 것은, 설계도를 만들면서 프로그래밍을 한다고 생각해도 될듯하다. 스케치를하는 느낌! 아키텍처를 짜면서 프로그래밍을 할 수 있다.</p></blockquote><p>단위테스트의 시작은 어렵다. “hot to start unit testing”를 구글에 검색하면 113,000,000의 결과가 나올정도로. 단위테스트를 시작하는 가장 쉬운 방법은 버그를 고치는 것입니다. 그 방법은 아래와 같다.</p><ul><li>버그를 찾는다.</li><li>버그를 고쳤을 때 통과할만한 테스트를 작성한다.</li><li>테스트를 통과할 때까지 코드를 수정한다.</li></ul><hr><hr><h2 id="2-결국-클린코드를-위한-길"><a href="#2-결국-클린코드를-위한-길" class="headerlink" title="2. 결국 클린코드를 위한 길"></a>2. 결국 클린코드를 위한 길</h2><p>요구사항이 수시로 변경되고 프로젝트 일정이 눈에 보이기 시작하면 테스트 코드 없이 바로 로직 구현을 하는 경우가 태반이라고 했다. 물론 신속히 개발할 수 있지만, 나중에 유지 보수 때 문제가 발생한다고 한다. 유지보수라고 하지만 새로운 기능을 요구할 때도 있다. 기존 로직에 영향을 주지 않고 코드를 작성해야 하는데 테스트 코드 없이 구현하다 보면 사이드 이펙트가 여기 저기서 터진다. 결국 유지보수기간에 코드에 대한 테스트 코드를 다시 작성하는 사태..</p><h3 id="클린코드가-우선순위에서-밀려나서는-안되는-3가지-이유"><a href="#클린코드가-우선순위에서-밀려나서는-안되는-3가지-이유" class="headerlink" title="클린코드가 우선순위에서 밀려나서는 안되는 3가지 이유 +"></a>클린코드가 우선순위에서 밀려나서는 안되는 3가지 이유 <a href="http://codesquad.kr/page/specialTdd.html" target="_blank" rel="noopener">+</a></h3><h4 id="1-유지보수하기-좋은-코드"><a href="#1-유지보수하기-좋은-코드" class="headerlink" title="1. 유지보수하기 좋은 코드"></a>1. 유지보수하기 좋은 코드</h4><p>프로그래머 작업 중 가장 많은 시간을 투자하는 일이 유지보수이다. 유지보수하기 좋은 코드를 구현하는 것은 서비스의 성패를 좌우하는 중요한 요소이다. 유지보수하기 좋은 코드를 구현하는 핵심은 클린 코드 구현에 있다.</p><h4 id="2-변화에-대응하는-핵심-능력"><a href="#2-변화에-대응하는-핵심-능력" class="headerlink" title="2. 변화에 대응하는 핵심 능력"></a>2. 변화에 대응하는 핵심 능력</h4><p>운영 중 필연적으로 발생하기 마련인 기능 추가, 버그 수정, 레거시 코드 리뷰(이전 개발자들의 유산과도 같은 코드) 및 수정 작업과 같은 변화 자체에 확장성있게 대응하려면 클린 코드에 대한 이해와 작성 능력이 필수. 변화를 피할 수 없으면 제대로 대응하자.</p><h4 id="3-프로젝트-협업-능력-향상"><a href="#3-프로젝트-협업-능력-향상" class="headerlink" title="3. 프로젝트 협업 능력 향상"></a>3. 프로젝트 협업 능력 향상</h4><p>읽기 좋은 클린 코드를 작성함으로서 오는 장점은 개인에게만 있지 않다. 특히 1인 개발이 아닌, 여러 개발자가 함께 참여하는 프로젝트일수록 확장성 있는 코드 작성 능력을 가진 개발자의 기여도는 높을 수 밖에 없다.</p><h3 id="cf-레거시-코드란-Legacy-code"><a href="#cf-레거시-코드란-Legacy-code" class="headerlink" title="cf. 레거시 코드란 Legacy code"></a>cf. 레거시 코드란 <code>Legacy code</code></h3><ul><li>테스트가 불가능하거나 어려운 코드</li><li><a href="https://feel5ny.github.io/2017/12/09/Refactoring/">클린코드를 위한 리팩토링</a></li></ul><hr><hr><h2 id="3-TDD-Test-Driven-Development"><a href="#3-TDD-Test-Driven-Development" class="headerlink" title="3. TDD : Test Driven Development +"></a>3. TDD : Test Driven Development <a href="http://blog.jeonghwan.net/mocha/" target="_blank" rel="noopener">+</a></h2><ol><li>우선 개발자는 바라는 향상 또는 새로운 함수를 정읳하는 자동화된 테스트 케이스를 작성(초기적 결함을 점검하는)</li><li>케이스를 통과하기 위한 최소한의 양의 코드를 생성</li><li>새 코드를 표준에 맞도록 리팩토링</li></ol><p><img src="/images/post_img/45/tdd-work-flow.gif"><br>일반적으로 RED, GREEN, REFACTOR 세단계를 거쳐 이루어진다.</p><ol><li><code>RED</code> : 실패하는 테스트</li><li><code>GREEN</code> : 테스트에 통과하도록 코드를 작성</li><li><code>REFACTOR</code> : 불필요한 코드를 삭제<br>장점 : 유지보수가 가능한 코드를 작성할수 있고, 버그가 생겨날 여지도 줄고, 높은 가독성을 추구할 수 있다. </li></ol><blockquote><p>참고한 글에서는 심리적인 안정감을 준다고 한다. 테스트 없이 개발하면 그물망 없는 막타워를 뛰어 내리는 심정이라면서.. 코드 한줄한줄이 부담스럽다고 한다.<br>생각해보면 이전 프로젝트에서는 테스트코드 없이 작업에 들어갔었고, 기능구현은 됐으나, 내가 보기 싫은 정도의 무자비한 코드들이 나왔다. 그러다보니 리팩토링조차 하지 못하는 상황.. 그런 의미에서 클린코드를 위한 작업이라고 생각하면, 좋을 듯하다.</p></blockquote><hr><h3 id="BDD-Behaviour-Driven-Development"><a href="#BDD-Behaviour-Driven-Development" class="headerlink" title="BDD (Behaviour Driven Development)"></a>BDD (Behaviour Driven Development)</h3><p>BDD는 행동 베이스이다.<br>엔드 유저의 행동을 시나리오로 가져야합니다.<br>가령 로그인을 예로 BDD를 하려면, 셀레늄으로 실제 브라우저에서 렌더링된 아이디와 패스워드를 입력폼에 넣고 로그인 버튼까지 누르는걸 시뮬레이트해야한다.</p><blockquote><p>Given, When, Then<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scenario: User uses wrong password</span><br><span class="line">  Given a username dkfksl;</span><br><span class="line">  And a password kdfksj;</span><br><span class="line">  When the user logs in with username and password</span><br><span class="line">  Then the login form should be shown again</span><br></pre></td></tr></table></figure></p></blockquote><ol><li>특정 값이 주어지고 (Given)</li><li>어떤 이벤트가 발생했을 때 (When)</li><li>그에 대한 결과를 보장해야한다 (Then)</li></ol><hr><hr><h2 id="4-실습"><a href="#4-실습" class="headerlink" title="4. 실습"></a>4. 실습</h2><blockquote><p>react 테스트때는 Enzyme과 묶어서 Mocha 사용할 예정.<br>Typescript사용, type definition으로는 mocha, node, express 셋팅, 의존모듈 : mocha, shoudld, supertest, typescript </p></blockquote><p>실습을 위해 필요한 것과 알야아할 용어</p><ul><li>mocha</li><li>should.js (assert 대체)</li><li>supertest</li><li>sinon<ul><li>mock</li></ul></li></ul><hr><h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h3><p><img src="/images/post_img/45/mocha.svg"><br>Mocha is a feature-rich JavaScript test framework running on Node.js and in the browser, making asynchronous testing simple and fun. Mocha tests run serially, allowing for flexible and accurate reporting, while mapping uncaught exceptions to the correct test cases.</p><p>mocha는 node와 브라우저 모두에 적용할 수 있고, TDD, BDD, QUnit, export 스타일 모두 적용할 수 있는 프레임웍이다. assertion문 또한, 취향(?)에 따라 선택하여 적용할 수 있다.<br>assertion문 expect, should, assert …</p><hr><h3 id="should"><a href="#should" class="headerlink" title="should +"></a>should <a href="http://shouldjs.github.io/" target="_blank" rel="noopener">+</a></h3><ul><li>테스트 코드를 검증할 때 사용하는 써드파티 라이브러리</li><li>가독성이 높은 테스트 코드를 만들 수 있게해주는 장점!</li><li>assert는 nodejs 공식 모듈, should 써드파티 모듈<ul><li>assert란 실행 결과를 비교하기위해 사용하는 내장 모듈.</li><li>노드에서 제공하는 assert라는 라이브러리가 있지만, 노드측에서 발표를 했다! 노드 assert 이외의 서드파티 라이브러리를 사용하라..!!</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.body.should.be.a.Object();              <span class="comment">// res.body는 Object 형태이어야한다. should.be.a</span></span><br><span class="line">res.body.should.have.property(<span class="string">'result'</span>);    <span class="comment">// res.body는 result라는 property를 갖고(have) 있어야 한다. </span></span><br><span class="line">res.body.result.should.have.equal(<span class="string">'Hello Get TDD'</span>) <span class="comment">// res.body.result는 'Hello Get TDD'라는 문자열과 같은 값을 갖고 있어야 한다.</span></span><br></pre></td></tr></table></figure><hr><h3 id="superTest"><a href="#superTest" class="headerlink" title="superTest +"></a>superTest <a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">+</a></h3><ul><li>mocha가 하나의 함수를 테스트했다면, <code>통합테스트</code>(api 기능 테스트)에서 사용하는 라이브러리</li><li>api 서버라면 내부적으로 express 구동 -&gt; 요청보낸 뒤 결과 검증까지함(시나리오 코드 작성)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supertest = <span class="built_in">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server: any = supertest.agent(<span class="string">'http://localhost:3000'</span>)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'테스트 시작'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'GET'</span>, done =&gt; &#123;</span><br><span class="line">    server.get(<span class="string">'/'</span>).expect(<span class="string">"Content-type"</span>, /json/).expect(<span class="number">200</span>)</span><br><span class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        res.body.should.be.a.Object();</span><br><span class="line">        res.body.should.have.property(<span class="string">'result'</span>);</span><br><span class="line">        res.body.result.should.have.equal(<span class="string">'Hello Get TDD'</span>)</span><br><span class="line">        done();</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>서버에서 구현하는 API는 단순히 메모리상의 데이터를 다루는 것만 있는 것은 아닙니다. 사용자 계정 정보 등 영구적으로 저장할 데이터는 데이터베이스에 저장하게 되는데, 서버에 이 정보를 데이터베이스에서 조회한 뒤 API로 응답하는 경우가 빈번합니다.<br>그럼 유닛 테스트를 위해 데이터베이스에 직접 자료를 넣어야 할까요? 그렇게 할 수도 있겠지만 시간이 많이 걸립니다. 왜냐하면 테스트를 위해 데이테베이스 컨넥션을 생성한 뒤 데이터를 입력하고 조회하는 시간이 상당하기 때문입니다. 게다가 이러한 API가 많아질수록 전체 테스트 시간은 늘어나게 됩니다.<br>그래서 목(Mock)을 사용해야 합니다. 데이터베이스 역할을 흉내낼 수 있는 가상의 것을 만들수 있습니다.</p><hr><h3 id="sinon"><a href="#sinon" class="headerlink" title="sinon +"></a>sinon <a href="https://www.slideshare.net/UyeongJu/javascript-test-double-sinonjs" target="_blank" rel="noopener">+</a></h3><p>Sinon.js는 주로 테스트 대상이 의존하는 모듈과 자원의 <code>대역</code>의 용도로 사용한다. 특정 테스트 프레임워크를 의존하지 않기 때문에 QUnit 이외의 테스트 프레임워크와도 함께 사용할 수 있다. Sinon이라는 이름은 트로이 전쟁에서 활양한 스파이의 이름에서 유래했다.<br>복잡한 비동기나 동시 다발적인 이벤트 그리고 애니메이션등 <code>작성하기 어려운 테스트 타입</code>을 Spy, Stub, Mock, FakeTiner, FakeServer 등으로 대체하여 테스트하기 쉽게 만들어 준다.</p><p>MOCK작업을 할 수 있게 하는 라이브러리라고 생각하면된다.<br>MOCK : 데이터 베이스 역할을 흉내내는 가상의 것</p><hr><h4 id="Mock이란"><a href="#Mock이란" class="headerlink" title="Mock이란?"></a>Mock이란?</h4><p>실제 객체를 만들기엔 비용과 시간이 많이 들거나 의존성이 길게 걸쳐져 있어 제대로 구현하기 어려울 경우, 가짜 객체를 만들어 사용한다.</p><ul><li>JavaScript는 비동기 상황을 테스트해야하기 때문에, 실제로 테스트 코드를 짜는 것은 굉장히 까다로운 작업이 될수 있다. </li><li>이러한 것을 해결하기 위한 하나의 방법으로 stub, mock object를 만드는 방법이 있다.</li></ul><hr><h4 id="Mock-객체는-언제-필요한가"><a href="#Mock-객체는-언제-필요한가" class="headerlink" title="Mock 객체는 언제 필요한가?"></a>Mock 객체는 언제 필요한가?</h4><ul><li>테스트 작성을 위한 환경 구축이 어려운 경우<ul><li>환경 구축을 위한 작업 시간이 많이 필요한 경우에 Mock객체를 사용한다. (데이터베이스, 웹서버, 웹애플리케이션서버, FTP서버, 등)</li><li>특정 모듈을 갖고 있지 않아서 테스트 환경을 구축하지 못할 때 또는 타 부서와의 협의나 정책이 필요한 경우에 사용한다.</li></ul></li><li>테스트가 특정 경우나 순간에 의존적인 경우</li><li>테스트 시간이 오래 걸리는 경우</li><li>개인 PC의 성능이나 서버의 성능문제로 오래 걸릴수 있는 경우 시간을 단축하기 위해 사용한다.</li></ul><hr><h3 id="cf-테스트-러너-karma"><a href="#cf-테스트-러너-karma" class="headerlink" title="cf. 테스트 러너 (karma)"></a>cf. 테스트 러너 (karma)</h3><p>JavaScript는 브라우저 환경에 따라, 테스트 결과가 달라지기 때문에, 실제 브라우저에서 테스트를 꼭! 해야만한다. 테스트 러너는 여러 환경에서 동일 테스트를 호출 할 수 있다.</p><hr><p>참고링크</p><ol><li><a href="http://www.incodom.kr/Mock" target="_blank" rel="noopener">http://www.incodom.kr/Mock</a></li><li><a href="http://webframeworks.kr/tutorials/expressjs/expressjs_test_code/" target="_blank" rel="noopener">http://webframeworks.kr/tutorials/expressjs/expressjs_test_code/</a></li><li><a href="https://mochajs.org/" target="_blank" rel="noopener">https://mochajs.org/</a></li><li><a href="http://jinbroing.tistory.com/148" target="_blank" rel="noopener">http://jinbroing.tistory.com/148</a></li><li><a href="https://hyunseob.github.io/2016/05/09/assert-nodejs-test-module/" target="_blank" rel="noopener">https://hyunseob.github.io/2016/05/09/assert-nodejs-test-module/</a></li><li><a href="https://suhyeon.github.io/2017/12/10/TDD-1/" target="_blank" rel="noopener">https://suhyeon.github.io/2017/12/10/TDD-1/</a></li><li><a href="http://seokjun.kr/node-js-tdd/" target="_blank" rel="noopener">http://seokjun.kr/node-js-tdd/</a></li><li><a href="http://blog.jeonghwan.net/mocha/" target="_blank" rel="noopener">http://blog.jeonghwan.net/mocha/</a></li><li><a href="http://meetup.toast.com/posts/126" target="_blank" rel="noopener">http://meetup.toast.com/posts/126</a></li><li><a href="https://sungjk.github.io/2017/03/03/testing-react-application.html" target="_blank" rel="noopener">https://sungjk.github.io/2017/03/03/testing-react-application.html</a></li><li><a href="http://woogri.tistory.com/entry/BDD-BDD-%EB%84%88%EB%8A%94-%EC%96%B4%EB%94%94%EC%84%9C-%EC%98%A8%EA%B1%B0%EB%8B%88" target="_blank" rel="noopener">http://woogri.tistory.com/entry/BDD-BDD-%EB%84%88%EB%8A%94-%EC%96%B4%EB%94%94%EC%84%9C-%EC%98%A8%EA%B1%B0%EB%8B%88</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;단위테스트. 다들 중요하다고 하는데 왜 중요할까?&lt;/li&gt;
&lt;li&gt;결국 클린코드를 위한 길&lt;/li&gt;
&lt;li&gt;TDD : Test Driven Development&lt;/li&gt;
&lt;li&gt;실습&lt;/li&gt;
&lt;/ol&gt;
&lt;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="TDD" scheme="http://feel5ny.github.io/categories/TIL-9997/TDD/"/>
    
    
      <category term="TDD" scheme="http://feel5ny.github.io/tags/TDD/"/>
    
      <category term="mocha" scheme="http://feel5ny.github.io/tags/mocha/"/>
    
  </entry>
  
  <entry>
    <title>6/ 함수표현식의 다른 용도</title>
    <link href="http://feel5ny.github.io/2017/12/07/JS_06/"/>
    <id>http://feel5ny.github.io/2017/12/07/JS_06/</id>
    <published>2017-12-07T12:20:19.000Z</published>
    <updated>2018-08-15T14:44:07.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><p>목차 </p><ol><li><a href="#recursion">함수와 재귀</a></li><li><a href="#closure">클로저</a><br>2-1. 클로저 사용 (반복문)<br>2-2. 클로저의 메모리 누수<br>2-3. 클로저를 이용한 고유 변수(private variable : 객체 외부에서 접근할 수 없는 변수)<br>   = 은닉화</li></ol><hr><h2 id="1-함수의-재귀"><a href="#1-함수의-재귀" class="headerlink" title=" 1. 함수의 재귀"></a><a name="oop"></a> 1. 함수의 재귀</h2><p>함수의 재귀 부분은 <a href="https://feel5ny.github.io/2017/12/02/JS_04/">함수Part 포스팅</a>의 callee의 예시를 보면서 설명했었다. 추가로 스트릭트 모드일 경우에 <code>arguments.callee</code>에 접근할 수 없으므로 이를 보완하는 방법을 알아본다.</p><ul><li>이름 붙은 함수 표현식을 써서 같은 결과를 낼 수 있게 한다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123; <span class="comment">// f()를 생성하여 factorial에 할당.</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>f라는 이름은 함수를 다른 변수에 할당하더라도 그대로 유지되므로 재귀 호출은 정확히 실행됨.</p><hr><h2 id="2-클로저"><a href="#2-클로저" class="headerlink" title=" 2. 클로저"></a><a name="closure"></a> 2. 클로저</h2><p>클로저란 <strong>다른 함수의 스코프에 있는 변수에 접근 가능한 함수</strong>이다.(내부함수가 외부함수의 스코프에 접근가능). 즉, <strong>내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미</strong>한다.<br><strong><code>생성될 당시의 환경을 기억하는 함수를 말한다.</code></strong> 클로저를 잘 이해하기 위해서는 스코프 체인이 어떻게 생성되고 사용되는지 자세히 알아야 한다.</p><p>함수에서 변수에 접근할 때마다 스코프 체인에서 해당 이름의 변수를 검색한다. 함수 실행이 끝나면 로컬 활성화 객체는 파괴되고 메모리에는 전역 스코프만 남는다. 하지만 클로저는 외부함수가 실행을 마쳐도 활성화 객체는 내부함수가 파괴될 때가지 메모리에 남는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value1 = object1[propertyName]</span><br><span class="line">    <span class="keyword">const</span> value2 = object1[propertyName]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compare = createComparisonFunction(<span class="string">"name"</span>)</span><br><span class="line"><span class="keyword">const</span> result = compare(&#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">"Greg"</span>&#125;)</span><br><span class="line">compare = <span class="literal">null</span>; <span class="comment">// 함수파괴 - GC이 메모리 회수가능</span></span><br></pre></td></tr></table></figure><p><img src="/images/post_img/43/01"><br>내부 함수가 반환되어 다른 컨텍스트에서 실행되는 동안에도 <code>propertyName</code>에 접근하 수 있다. 이런 일이 가능한 것은 내부 함수의 스코프 체인에 <code>createComparisonFunction()</code>의 스코프가 포함되기 때문이다.</p><ol><li>외부함수가 실행을 마치고 익명함수를 반환하면 익명함수의 스코프체인은 외부함수의 활성화객체AO와 전역변수객체GO를 포함하도록 초기화된다. <ul><li>이 때문에 익명 함수는 외부 함수의 번수 전체에 접근할 수 있다.</li></ul></li><li>아직 익명함수의 스코프 체인에서 활성객체를 참조하기 때문에 외부 함수가 실행을 마쳤는데도 활성객체는 파괴디지 않는다.<ul><li>즉 활성화객체는 익명함수가 파괴될 때까지 메모리에 남는다. </li></ul></li></ol><h3 id="중간지점-개념정리"><a href="#중간지점-개념정리" class="headerlink" title="중간지점..개념정리"></a>중간지점..개념정리</h3><p>자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우,<br>내부함수가 외부함수의 스코프에 접근할 수 있고,<br>외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며<br>내부함수에 의해서 소멸하게 되는 특성을 클로저라고 부른다.</p><p>외부함수의 지역변수를 Free variable(자유변수)이라고 부르는데, 클로저라는 이름은 <strong>자유변수에 함수가 닫혀있다(Closed)라는 의미로, 자유변수에 엮여있는 함수라는 뜻</strong>이다.</p><p>외부함수가 이미 반환되었어도 <strong>외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우, 계속 유지된다.</strong> (내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제변수에 접근한다.)</p><p>클로저는 외부함수의 스코프를 보관해야하므로 다른 함수에 비해 메모리를 많이 요구한다. 클로저를 과용하면 메모리 문제가 생길 수 있으니, 반드시 필요할 때만 사용하길 권장한다.</p><h3 id="2-1-클로저-사용-반복문"><a href="#2-1-클로저-사용-반복문" class="headerlink" title="2-1. 클로저 사용 (반복문)"></a>2-1. 클로저 사용 (반복문)</h3><p>함수 안에 함수를 정의하고 내부에 정의한 함수를 노출시키면, 클로저를 사용할 수 있다. 함수를 노출시키기 위해서는 함수를 반환하거나 다른 함수로 전달하면 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result 배열에 들어가는 모든 함수가 스코프체인에 <code>createFunctions()</code>의 활성화객체를 포함하므로, 이들은 모두 같은 변수, i를 참조한다. 때문에 마지막에 할당된 i가 저장이 되는것이다. </p><p><img src="/images/post_img/43/02-1.jpg" witdth="700"></p><p>이는 for루프의 초기문에 사용된 var키워드 변수의 스코프가 전역이기 때문에 발생하는 현상이므로, ES6의 <code>let</code>키워드를 이용하여 블록레벨 스코프 개념을 만들면 원하는 결과값이 나오긴한다.</p><p>하지만.. 우선 let이 없다는 상황에서 클로저를 사용하여 원하는 결과값을 반환해보자.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    result[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/post_img/43/02-2.jpg" witdth="700"></p><ol><li>즉시실행함수이기 때문에 함수가 실행되면서 내부함수가 반환된다.<ul><li>즉시실행함수는 한번만 호출시 처음 한번만 실행된다. </li></ul></li><li>num에 i를 매개변수로 넘기기 때문에(복사) result에 들어가는 익명함수에는 자유변수 num이 생겼다고 보면되다.</li><li>배열에 들어가는 함수는 즉시실행함수 매개변수로 i를 받는다. i는 num에 매개변수로 <strong>복사</strong>가되고, num은 해당 함수의 자유변수가 된다. 반환된 내부함수는 자유변수 num에 엮여있는 함수 클로저가 된다. 때문에 외부함수에서 매개변수로 받는 i값에 따라 고유한 num과 클로저를 갖게 된다.</li></ol><h3 id="2-2-클로저의-메모리-누수"><a href="#2-2-클로저의-메모리-누수" class="headerlink" title="2-2. 클로저의 메모리 누수"></a>2-2. 클로저의 메모리 누수</h3><p>클로저는 외부함수의 활성화객체 참조를 계속 유지하기 때문에 참조카운트가 줄지 않는다. (가비지컬렉션이 잡지 치우지 못한다.) 필요하다면 클로저를 갖고 있는 변수에 null을 할당하여 참조를 끊어야한다.</p><h3 id="2-3-클로저를-통한-은닉화-고유변수"><a href="#2-3-클로저를-통한-은닉화-고유변수" class="headerlink" title="2-3. 클로저를 통한 은닉화 (고유변수)"></a>2-3. 클로저를 통한 은닉화 (고유변수)</h3><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode</a></li><li><a href="http://poiemaweb.com/js-closure" target="_blank" rel="noopener">http://poiemaweb.com/js-closure</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>0/ React</title>
    <link href="http://feel5ny.github.io/2017/12/07/React_01/"/>
    <id>http://feel5ny.github.io/2017/12/07/React_01/</id>
    <published>2017-12-07T12:20:19.000Z</published>
    <updated>2018-08-15T14:45:36.622Z</updated>
    
    <content type="html"><![CDATA[<p>어썸 리액트! &#128153;</p><p>리액트 공식 사이트로 들어가면 부제목으로 이런 글이 있다.<br><code>A JavaScript library for building user interfaces</code><br>UI 작업을 위한 자바스크립트 라이브러리! </p><p>사용자가 서비스를 접하면서 만나게되는 여러 상황에 빠르게 대응할 수 있고, 다양한 UI 트리거를 빠르게 만들 수 있도록 나온 라이브러리가 아닌가 한다. 그만큼 개발에도 사용자 경험을 많이 신경쓰고 있다는 점에서, UI와 인터렉션은 정말 화두 오브 화두. 상태관리를 손쉽게 할 수 있다는 점때문에 개발자가 UX를 고민할 시간이 더 생긴다는 점에서 리액트를 선호한다. 최근에는 앵귤러를 입문하고 있는데, 비슷한 패턴으로 상태관리를 한다고 느껴지긴했지만, 아직 어려운 개념들이 많고.. 그래서 아직 리액트와의 차이점은 잘 모르겠다. </p><hr><p>목차 </p><ol><li>리액트 탄생배경</li><li>리액트의 특징</li></ol><hr><h2 id="1-리액트-탄생배경"><a href="#1-리액트-탄생배경" class="headerlink" title="1. 리액트 탄생배경"></a>1. 리액트 탄생배경</h2><p>front 영역을 제어하기 위해서는 자바스크립트로 DOM을 컨트롤 하면 된다. 이는 다양한 인터렉션 기능들을 구현할 수 있게 해주지만 이 DOM이라는 것을 조작하기에는 여간 까다로운게 아니다.(바닐라로 간단 기능을 짜본사람은 무슨 느낌인지..) 이런 까다로운 DOM을 쉽고 효율적으로 다루기 위해 Jquery 라이브러리가 나왔다. But, 제이커리는 여러가지 <a href="https://www.tokyobranch.net/archives/7463" target="_blank" rel="noopener">이슈</a>를 갖고 있었다.</p><p>SPA 개발을 위한 구글의 오픈소스 자바스크립트 프레임워크인 Angular가 등장하면서 구조화된 프론트엔드 환경을 제시했다. 이런 상황에서 Facebook에서 React가 등장하게 된다. React는 에어비엔비, 넷플릭스, 드랍박스, 트위터 등에서 사용하고 있다. 리엑트는 자바스크립트 라이브러리이며, 라우터와 같이 웹을 만들 때 필요한 도구들을 포함되어 있지 <strong>않다.</strong> (앵귤러는 포함되어있음) 필요한 도구들이 없는 대신? 가볍다. 그리고 빠르게 배울수 있다는 점!</p><h2 id="2-리액트의-특징"><a href="#2-리액트의-특징" class="headerlink" title="2. 리액트의 특징"></a>2. 리액트의 특징</h2><p>React 공식 사이트에서 말하는 특징</p><h3 id="1-Declarative"><a href="#1-Declarative" class="headerlink" title="1. Declarative"></a>1. Declarative</h3><p>React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.<br>Declarative views make your code more predictable and easier to debug.</p><blockquote><p>직관적<br>리액트는 인터렉티브 UI를 어려움없이 만들 수 있습니다. 당신의 어플리케이션의 각각의 상태를 위해 간단한 view들을 디자인을 해보십시요. 리액트는 데이터가 변할때 해당 컴포넌트를 효과적으로 업데이트하고 렌더링 할 수 있습니다. 직관적인 view들은 디버깅하기 더 쉽게, 더 잘 예측할 수 있도록 해줍니다!</p></blockquote><h3 id="2-Component-Based"><a href="#2-Component-Based" class="headerlink" title="2. Component-Based"></a>2. Component-Based</h3><p>Build encapsulated components that manage their own state, then compose them to make complex UIs.<br>Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM.</p><blockquote><p>컴포넌트 단위.<br>자체 상태를 관리하는 캡슐화된 컴포넌트를 만들어서 복잡한 UI를 만들 수 있도록 구성해보세요. 템플릿 대신 자바스크립트로 작성된 컴포넌트 로직을 통해 여러분은 풍부한 데이터를 쉽게 전달하고, DOM에서 상태를 유지할 수 있습니다.</p></blockquote><h3 id="3-Learn-Once-Write-Anywhere"><a href="#3-Learn-Once-Write-Anywhere" class="headerlink" title="3. Learn Once, Write Anywhere"></a>3. Learn Once, Write Anywhere</h3><p>We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code.<br>React can also render on the server using Node and power mobile apps using React Native.</p><blockquote><p>한번배우고, 어디서나 쓰십쇼!<br>우리는 여러분의 기술 스택의 나머지 부분에 대해서 가정하지 않았으므로 여러분은 기존 코드를 다시 작성하지 않고, React에서 새로운 기능을 개발할 수 있습니다. React는 React Native를 사용하여 Node나 모바일 앱을 사용하여 서버에서 렌더링할 수 있습니다.</p></blockquote><hr><h3 id="2-1-Component"><a href="#2-1-Component" class="headerlink" title="2-1. Component"></a>2-1. Component</h3><p>component는 UI를 구성하는 개별적은 View 단위이다. 이 단위들이 레고 블럭처럼 조합되어서 최종 결과물을 만들어낸다. 이는 앵귤러도 같은 개념이다. Component의 강력한 특징은 <strong>재사용</strong>이 가능하다. 틀을 만들어 놓고 여러 컴포넌트로 갖고가서 사용이 가능하다는 것.<br>리덕스 창시자 Dan Abramov는 React의 목표가 성능보다는 유지가능한 앱을 만드는 것!이라고 설명했다고 한다.</p><h3 id="2-2-JSX"><a href="#2-2-JSX" class="headerlink" title="2-2. JSX"></a>2-2. JSX</h3><p>JSX는 React에서 사용하기 위해서 새로 만들어진 자바스크립트 문법이다.<br>React는 작성한 코드를 컴파일하는 과정을 꼭 거쳐야한다. 때문에 리액트에서는 Babel을 사용하고 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>, mountNode)</span></span><br></pre></td></tr></table></figure></p><p>return 내부의 형태와 ReactDom.render의 첫번째 인자는 JSX문법이다. 이를 자바스크립트로 컴파일을 하기위해 Babel을 사용하는 것이다. 자바스크립트로 컴파일 후의 모습은 아래와 같다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(</span><br><span class="line">      <span class="string">"div"</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="string">"Hello "</span>,</span><br><span class="line">      <span class="keyword">this</span>.props.name</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(React.createElement(HelloMessage, &#123; <span class="attr">name</span>: <span class="string">"John"</span> &#125;), mountNode);</span><br></pre></td></tr></table></figure></p><p>React는 Babel과 같은 트랜스파일러를 꼭 사용해야하기 때문에 Webpack등을 사용해야하는데, 왜 구지 이런 셋팅을 하면서까지 JSX를 사용하는 걸까. 위처럼 작성해도 되지만, 공식사이트에서 말한 첫번째 특징인 직관적인(Declarative) 개발을 할 수 있도록 하기 위해 JSX를 사용한다. JSX를 보면 html마크업과 거의 같다고 볼 수 있다. 어떤 결과물이 나올지 이해가 된 상태에서 개발하기 때문에 예측가능 개발을 할 수 있도록 해주며, 개발의 피로도를 상당히 줄여준다.</p><h3 id="2-3-Vitual-DOM"><a href="#2-3-Vitual-DOM" class="headerlink" title="2-3. Vitual DOM"></a>2-3. Vitual DOM</h3><div class="video-container"><iframe src="//www.youtube.com/embed/BYbgopx44vo" frameborder="0" allowfullscreen></iframe></div><p>DOM은 웹의 핵심으로, 말 그대로 브라우저가 화면을 그리기 위한 정보가 담겨있는 문서이다. 이 DOM을 다루는 것이 힘들다는 것은.. 바닐라로 짜보면 알 수 있다. 정확히는 DOM 조작이 전체 동작을 비효율적으로 만드는게 아니라, 그 이후에 일어나는 일 때문에 작업이 더뎌지는 거라고 한다. DOM에 변화가 생기면, 렌더트리를 재생성하고(모든 요소의 스타일이 다시 계산된다.) 레이아웃을 만들고, 페인팅을 하는 과정을 반복한다. 그만큼 DOM을 쉽게 다룰 수 있는 부분은 개발자들의 숙제였고, 그러던 중에 Jquery가 탄생하게 된것이다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div&gt;Hello &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;I am &#123;this.state.chatName&#125;&lt;/</span>div&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>React 컴포넌트는 render를 다시 호출하여 새로운 결과 값을 return한다. 그런데 이 리턴값은 바로 DOM에 반영되지 않는다! 즉 렌더링이 되지 않는다는 말인데, react는 return값을 갖고 새로운 Virtual DOM을 만든다.. 그리고, 현재 브라우저에 보여지고 있는 진짜 DOM과 비교하여 어떤 부분이 달라졌는지 찾아낸다. 달리진 부분을 발견하면 그 부분만! 바뀐 그 부분만 진짜 DOM에 반영한다. 그리고 브라우저는 이 DOM을 해석하고 유저에게 새로운 화면을 그려준다. 즉, 브라우저 내에서 발생하는 연산의 양을 줄이면서 실제 DOM을 조작하는 것보다 성능이 개선이 된다. </p><p>가상돔을 만든 이유는, 직접 DOM을 조작하는 리소스가 많으 드는 행위를 하지않고, DOM을 조작하는 과정을 최적화시켜주고, 컴포넌트 단위로 묶어서 관리할 수 있도록 해준다. 컴포넌트 단위의 개발을 구현하기 위해 보다 효율적인 DOM 조작 방식을 도입한 것이다. </p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://reactjs.org/" target="_blank" rel="noopener">https://reactjs.org/</a></li><li><a href="https://medium.com/@RianCommunity/react%EC%9D%98-%ED%83%84%EC%83%9D%EB%B0%B0%EA%B2%BD%EA%B3%BC-%ED%8A%B9%EC%A7%95-4190d47a28f" target="_blank" rel="noopener">https://medium.com/@RianCommunity/react%EC%9D%98-%ED%83%84%EC%83%9D%EB%B0%B0%EA%B2%BD%EA%B3%BC-%ED%8A%B9%EC%A7%95-4190d47a28f</a></li><li><a href="https://velopert.com/3236" target="_blank" rel="noopener">https://velopert.com/3236</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어썸 리액트! &amp;#128153;&lt;/p&gt;
&lt;p&gt;리액트 공식 사이트로 들어가면 부제목으로 이런 글이 있다.&lt;br&gt;&lt;code&gt;A JavaScript library for building user interfaces&lt;/code&gt;&lt;br&gt;UI 작업을 위한 
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="React" scheme="http://feel5ny.github.io/categories/TIL-9997/React/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>5/ 객체 지향 프로그래밍 (1)</title>
    <link href="http://feel5ny.github.io/2017/12/04/JS_05_1/"/>
    <id>http://feel5ny.github.io/2017/12/04/JS_05_1/</id>
    <published>2017-12-04T05:53:22.000Z</published>
    <updated>2018-08-15T14:44:07.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.<br>이 주제는 조금 더 공부를 해야할 듯 하다.</p></blockquote><p>목차 </p><ol><li>프로퍼티 타입<ul><li>데이터 프로퍼티</li><li>접근자 프로퍼티</li></ul></li><li>다중 프로퍼티 정의</li><li>프로퍼티 속성 읽기</li></ol><hr><p>객체지향언어는 일반적으로 클래스를 통해 같은 프로퍼티와 메서드를 가지는 객체르 여러 개 만든다는 특징이 있다. ECMAScript에는 클래스라는 개념이 없으며 이에 따라 ECMAScript의 객체는 다른 클래스 기반 언어와 다르다. (ES6에는 class라는 개념이 도입되었다.)</p><p>ECMAScript에서 객체는 순서가 없는 값의 배열이다. 각 프로퍼티와 메서드는 이름으로 구별하며 값에 대응한다. 객체는 이름-값 쌍의 그룹이며 각 값은 데이터나 함수가 될 수 있다.</p><hr><hr><h2 id="1-프로퍼티-타입"><a href="#1-프로퍼티-타입" class="headerlink" title=" 1. 프로퍼티 타입"></a><a name="oop"></a> 1. 프로퍼티 타입</h2><p>객체 리터럴 방식으로 객체를 생성할 때 프로퍼티와 메서드를 생성할 수 있다. 이러한 프로퍼티는 모두 자바스크립트에서 <code>프로퍼티의 행동을 정의하는 특징</code>에 따라 생성된다.<br>이들 속성이 자바스크립트 엔진 내부에서 구현하는 것으로 정의했고, 이들 송성을 자바스크립트에서 직접적으로 접근할 수 있는 방법은 없다.<br>이들 속성은 <code>[[Enumerable]]</code>처럼 속성 이름을 대괄호로 감싸서 내부 속성임을 나타낸다. </p><p>데이터 프로퍼티와 접근자 프로퍼티 두가지 타입이 있다.</p><hr><h3 id="1-1-데이터-프로퍼티"><a href="#1-1-데이터-프로퍼티" class="headerlink" title="1-1. 데이터 프로퍼티"></a>1-1. 데이터 프로퍼티</h3><p>데이터 값에 대한 단 하나의 위치를 포함하여 이 위치에서 값을 읽고 쓴다.(무슨말이지?)</p><ol><li><p><code>[[Configurable]]</code><br>프로퍼티가 delete를 통해 삭제하거나, 속성을 바꾸거나 접근자 프로퍼티로 변활할 수 있음을 나타낸다.<br>객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true</p></li><li><p><code>[[Enumerable]]</code><br><code>for-in</code>루프에서 해당 프로퍼티를 반환함을 나타낸다.<br>기본은 true</p></li><li><p><code>[[Writable]]</code><br>프로퍼티 값을 바꿀 수 있음을 나타낸다.<br>기본은 true</p></li><li><p><code>[[Value]]</code><br>프로퍼티의 실제 데이터 값을 포함한다. 프로퍼티의 값을 읽는 위치이고, 새로운 값을 쓰는 위치.<br>기본값은 <code>undefined</code></p><blockquote><p>프로퍼티를 선언만 하고 값을 할당하지 않으면 <code>undefined</code></p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person =&#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 “Nicholas”가 [[Value]] 데이터 프로퍼티에 저장된다는 말이다.</p><hr><h4 id="기본-프로퍼티-속성을-바꾸기-위해서는"><a href="#기본-프로퍼티-속성을-바꾸기-위해서는" class="headerlink" title="기본 프로퍼티 속성을 바꾸기 위해서는?"></a>기본 프로퍼티 <strong>속성</strong>을 바꾸기 위해서는?</h4><p><code>Object.defineProperty()</code>메서드를 사용하면 된다.</p><ul><li>Object.defineProperty() 처럼 강력한 옵션을 사용할 일이 드물겠지만, 자바스크립트 객체를 잘 이해하려면 알고 있으면 좋다. </li><li>전반적인 자바스크립트의 문법을 변화시키고 코드에 대한 해석을 기존처럼 할 수 없는 컨텍스트를 제공한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(프로퍼티를 추가하거나 수정할 객체, 프로퍼티 이름, 서술자 객체)</span><br></pre></td></tr></table></figure></li></ul><h4 id="서술자-객체가-뭐지-descriptor-객체"><a href="#서술자-객체가-뭐지-descriptor-객체" class="headerlink" title="서술자 객체가 뭐지? descriptor 객체"></a>서술자 객체가 뭐지? descriptor 객체</h4><p>해당 속성에 대한 특성을 의미.<br>내부 속성 이름과 같다. 서술자 객체에는 <code>configurable</code>, <code>enumerable</code>, <code>writable</code>, <code>value</code> 4가지 프로퍼티가 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperyt(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// readOnly 형식으로 바꿨다고 생각하자. </span></span><br><span class="line">  value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Nicholas"</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="1-2-접근자-프로퍼티-accessor-함수"><a href="#1-2-접근자-프로퍼티-accessor-함수" class="headerlink" title="1-2. 접근자 프로퍼티 (accessor 함수)"></a>1-2. 접근자 프로퍼티 (accessor 함수)</h3><p>데이터 값이 들어있지 않고, <code>getter</code>함수와 <code>setter</code>함수로 구성된다. (옵셔널)<br>접근자 프로퍼티를 읽을 때는 getter함수가 호출</p><ul><li>유효한 값을 반환할 책임은 이 함수에 있다.</li></ul><p>접근자 프로퍼티의 4가지 속성</p><ol><li><p><code>[[Configurable]]</code><br>프로퍼티가 delete를 통해 삭제하거나, 속성을 바꾸거나 접근자 프로퍼티로 변활할 수 있음을 나타낸다.<br>기본은 true</p></li><li><p><code>[[Enumerable]]</code><br><code>for-in</code>루프에서 해당 프로퍼티를 반환함을 나타낸다.<br>기본은 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">'first-name'</span>: <span class="string">'Joy'</span>,</span><br><span class="line">  <span class="string">'last-name'</span>: <span class="string">'Kim'</span>,</span><br><span class="line">  gender: <span class="string">'female'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prop에 객체의 프로퍼티 이름이 반환된다. 단, 순서는 보장되지 않는다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">': '</span> + person[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first-name: Joy</span></span><br><span class="line"><span class="comment">last-name: Kim</span></span><br><span class="line"><span class="comment">gender: female</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>[[Get]]</code><br>프로퍼티를 <strong>읽을</strong> 때 호출할 함수.<br>기본은 undefined</p></li><li><p><code>[[Set]]</code><br>프로퍼티를 <strong>바꿀</strong> 때 호출할 함수.<br>기본은 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2004</span>, </span><br><span class="line">  <span class="comment">// 밑줄(_)은 이 프로퍼티는 객체의 메서드를 통해서만 접근할 것이고 객체 외부에서는 접근하지 않겠다는 의도를 나타낼 때 흔히 쓰는 표기법 (private와 같은 개념)</span></span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue;</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue <span class="number">-2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition) <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li></ol><p>setter의 경우는 프로퍼티의 값을 바꿨을 때 해당 프로퍼티만 바뀌는 게 아니라 부수적인 절차가 필요한 경우에 사용한다.</p><p>getter만 셋팅할 경우 읽기전용<br>setter만 셋팅될 경우 undefined</p><hr><h2 id="2-다중-프로퍼티-정의"><a href="#2-다중-프로퍼티-정의" class="headerlink" title=" 2. 다중 프로퍼티 정의"></a><a name="oop"></a> 2. 다중 프로퍼티 정의</h2><p>여러개의 프로퍼티를 동시에 수정해야할 경우 <code>Object.defineProperties()</code><br>configurable의 기본값은 true이지만, defineProperties나 defineProperty은 공통적으로 호출만 되면 true로 재지정하지 않는 이상 false가 된다. </p><hr><h2 id="3-프로퍼티-속성-읽기"><a href="#3-프로퍼티-속성-읽기" class="headerlink" title=" 3. 프로퍼티 속성 읽기"></a><a name="oop"></a> 3. 프로퍼티 속성 읽기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(읽어올 프로퍼티가 포함된 객체, 서술자를 가져올 프로퍼티 이름)</span><br></pre></td></tr></table></figure><p>원하는 프로퍼티의 서술자 프로퍼티를 읽을 수 있다.<br>모든 객체에서 사용가능하며, DOM이나 BOM 객체에서도 가능하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// 2004</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get) <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://www.bsidesoft.com/?p=1878#%25ec%25a0%2595%25ec%25a0%2581%25ec%258b%259c%25ec%25a0%2590%25ea%25b3%25bc-%25ec%258b%25a4%25ed%2596%2589%25ec%258b%259c%25ec%25a0%2590" target="_blank" rel="noopener">http://www.bsidesoft.com/?p=1878#%25ec%25a0%2595%25ec%25a0%2581%25ec%258b%259c%25ec%25a0%2590%25ea%25b3%25bc-%25ec%258b%25a4%25ed%2596%2589%25ec%258b%259c%25ec%25a0%2590</a></li><li><a href="http://poiemaweb.com/js-object" target="_blank" rel="noopener">http://poiemaweb.com/js-object</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;br&gt;이 주제는 조금 더 공부를 해야할 듯 하다.&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>4/ 참조타입_Function 타입 (2)</title>
    <link href="http://feel5ny.github.io/2017/12/03/JS_04_2/"/>
    <id>http://feel5ny.github.io/2017/12/03/JS_04_2/</id>
    <published>2017-12-03T11:11:53.000Z</published>
    <updated>2018-08-15T14:44:07.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><p>목차 </p><ol><li><a href="#FunctionProperty">함수의 내부 구조</a></li><li><a href="#FunctionMethod">함수 프로퍼티와 메서드</a></li><li><a href="#several_type">함수의 다양한 형태</a><br>3-1. 즉시실행함수<br>3-2. 내부함수<br>3-3. 콜백함수</li></ol><hr><h2 id="1-함수의-내부-구조"><a href="#1-함수의-내부-구조" class="headerlink" title=" 1. 함수의 내부 구조"></a><a name="FunctionProperty"></a> 1. 함수의 내부 구조</h2><p>함수 내부에는 객체들이 있다. </p><p><img src="/images/post_img/39/01.png" width="80%"></p><p>요약</p><ul><li><code>arguments</code> 함수에 전달된 파라미터를 모두 포함하는 유사배열객체</li><li><code>this</code> 함수의 호출패턴에 따라 값이 달라진다. </li><li><code>caller</code> 해당 함수를 호출한 함수를 참조하는 값을 갖고있다. 전역함수에서는 null. 재귀함수를 사용할 때 사용가능.</li><li><code>length</code> arguments의 배열 길이. (파라미터의 갯수)</li><li><code>name</code> 함수의 이름</li><li><code>__proto__</code> 모든 객체가 갖고 있는 프로퍼티. [[Prototype]] 이며, 브라우저마다 다르게 명시한다. 해당 객체의 프로토타입을 가리키는 참조값을 갖고있다.</li><li><code>prototype</code> 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</li><li><code>apply</code> 함수를 호출하면서 해당함수의 this를 호출한 함수로 넘기는 역할을 한다.  </li><li><code>call</code> apply와 같은 개념이며, apply와 다른 점은 parmeter를 각각 넘기는 스타일이다.</li><li><code>bind</code> bind() 메소드는 호출될 때 그 this 키워드를 제공된 값으로 설정하고 새로운 함수가 호출될 때 제공되는 주어진 순서의 선행 인수가 있는 새로운 함수를 생성한다.</li></ul><hr><h3 id="1-1-arguments"><a href="#1-1-arguments" class="headerlink" title="1-1. arguments"></a>1-1. <code>arguments</code></h3><p>순회가능한(iterable) 유사배열객체이며, 함수에 전달된 파라미터를 모두 포함한다.<br>arguments 프로퍼티는 arguments 객체를 값으로 가지며, 함수 내부에서 지역변수처럼 사용된다. 즉, 외부에서는 호출할 수 없다. </p><p>arguments 객체에는<br><code>callee</code>, <code>length</code>, <code>Symbol</code> 프로퍼티가 존재한다.<br><code>callee</code> 프로퍼티는 arguments 객체의 소유자인 함수를/ 가리키는 포인터이다.</p><p><img src="/images/post_img/39/02.png" width="80%"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 이름에 의존하는 약점을 callee로 보완</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-this"><a href="#1-2-this" class="headerlink" title="1-2. this"></a>1-2. <code>this</code></h3><h3 id="1-3-caller"><a href="#1-3-caller" class="headerlink" title="1-3. caller"></a>1-3. <code>caller</code></h3><p>caller 프로퍼티에는 해당 함수를 호출한 함수에 대한 <strong>참조</strong>를 저장하며, 전역 스코프에서 호출했다면 <code>null</code>이 저장된다. </p><hr><h2 id="2-함수-프로퍼티와-메서드"><a href="#2-함수-프로퍼티와-메서드" class="headerlink" title=" 2. 함수 프로퍼티와 메서드"></a><a name="FunctionMethod"></a> 2. 함수 프로퍼티와 메서드</h2><p>함수에서 사용된 this는 실행된 객체를 가리키거나 상위 컨텍스트인 window를 가리킨다.<br><strong>this를 조작해서 다를 객체를 지정하려면?</strong> apply나 call을 사용하면 된다.</p><h3 id="2-1-apply-메서드"><a href="#2-1-apply-메서드" class="headerlink" title="2-1. apply 메서드"></a>2-1. <code>apply</code> 메서드</h3><p>소유자인 <strong>함수를 호출하면서</strong> this를 파라미터로 넘기는데, 결론적으로는 함수 내부에서 this객체의 값을 바꾸는 것이나 마찬가지이다. 매개변수로는 소유자함수에 넘길 this와 매개변수 배열을 (Array의 인스턴스 혹은 arguments)를 받는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// arguments 객체를 넘김</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]) <span class="comment">// 배열을 넘김</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment">//20</span></span><br></pre></td></tr></table></figure></p><h3 id="2-2-call"><a href="#2-2-call" class="headerlink" title="2-2. call"></a>2-2. <code>call</code></h3><p>apply와 같은데, 두번째 파라미터를 array형태가 아니라, 각각 나열해야한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2) <span class="comment">// arguments 객체를 넘김</span></span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment">//20</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-bind"><a href="#2-3-bind" class="headerlink" title="2-3. bind"></a>2-3. <code>bind</code></h3><p>새 함수 인스턴스를 만드는데 그 this는 bind()에 전달된 값이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color= <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o)</span><br><span class="line">objectSayColor() <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/post_img/39/04" width="400"></p><h3 id="2-4-proto-프로퍼티"><a href="#2-4-proto-프로퍼티" class="headerlink" title="2-4. __proto__ 프로퍼티"></a>2-4. <code>__proto__</code> 프로퍼티</h3><p>ECMAScript spec에서는 <strong><code>모든 객체</code>는 자신의 프로토타입을 가리키는 <code>[[Prototype]]</code>이라는 숨겨진 프로퍼티를 가진다</strong>라고 되어있다. <code>[[Prototype]]</code>와 <code>__proto__</code>는 같은 개념이다. </p><h3 id="2-5-prototype프로퍼티"><a href="#2-5-prototype프로퍼티" class="headerlink" title="2-5. prototype프로퍼티"></a>2-5. <code>prototype</code>프로퍼티</h3><p><strong>함수 객체만이 갖고 있는 프로퍼티</strong>로, 자바스크립트 객체지향의 근간이다. <code>__proto__</code>와 다르다.</p><ul><li>함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</li><li>함수가 생성될 때 만들어지며 <code>constructor</code> 프로퍼티를 가지는 객체를 가리킨다. 이 constructor 프로퍼티는 함수 객체 자신을 가리킨다.</li></ul><hr><h2 id="3-함수의-다양한-형태"><a href="#3-함수의-다양한-형태" class="headerlink" title=" 3. 함수의 다양한 형태"></a><a name="several_type"></a> 3. 함수의 다양한 형태</h2><h3 id="3-1-즉시호출함수표현식-IIFE-Immediately-Invoke-Function-Expression"><a href="#3-1-즉시호출함수표현식-IIFE-Immediately-Invoke-Function-Expression" class="headerlink" title="3-1. 즉시호출함수표현식 IIFE, (Immediately Invoke Function Expression)"></a>3-1. 즉시호출함수표현식 IIFE, (Immediately Invoke Function Expression)</h3><p>함수의 정의와 동시에 실행되는 함수를 즉시호출함수라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다.</p><blockquote><p>react에서 componentwillmount의 개념</p></blockquote><p>즉시실행함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 충돌을 방지할 수 있어 이를 위한 목적으로 사용되기도 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 즉시실행함수(named immediately-invoked function expression)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 즉시실행함수(immediately-invoked function expression)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h3 id="3-2-내부함수"><a href="#3-2-내부함수" class="headerlink" title="3-2. 내부함수"></a>3-2. 내부함수</h3><p>함수 내부에 정의된 함수를 내부함수라 한다.<br>내부함수는 부모함수의 변수에 접근할 수 있지만, 부모함수는 자식함수의 변수에 접근할 수 없다.<br><img src="/images/post_img/39/03.jpg" width="400"></p><h3 id="3-3-콜백함수"><a href="#3-3-콜백함수" class="headerlink" title="3-3. 콜백함수"></a>3-3. 콜백함수</h3><p>콜백함수는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다. 보통 이벤트 핸들러 처리때, 비동기식 처리모델에 사용된다. 옵저버(Observer) 디자인 패턴에서 나온 개념이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1초 후 출력된다.'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>비동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다.</p><p>콜백함수는 <strong>콜백 큐</strong>에 들어가 있다가 해당 이벤트가 발생하면 호출된다.<br>콜백 함수는 <strong>클로저</strong>이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다. (<a href="http://meetup.toast.com/posts/89" target="_blank" rel="noopener">참고</a>)</p><p><strong>그런데 왜 이름이 callback 일까?</strong><br>설명1 -<br>선언된 함수를 이용하는 것을 호출 (call) 한다고 표현 한다. 콜백 함수는 운영체제(혹은 웹)에 의해 호출되는 응용 프로그램의 함수라 할 수 있다. 호출되는 방향이 정상적인 호출과 달리 <strong>반대된다는 의미</strong>에서 콜백이라고 한다. 정상적인 함수 호출 방법과는 다르게 운영체제 ( 시스템 ) 측에서 이벤트를 발생시켜서 이에 대한 처리를 해달라고 요청해 오는 과정이 있기 때문에 이와 같은 이름이 붙여졌다고 할 수 있다.</p><p>설명2 -<br>콜백함수란 API 의 반대개념이라고 볼 수 있습니다.<br>또한 말그대로 콜백! CallBack &gt; 반대로 부른다고 해석할 수 있지요.<br>우리는 작성하는 일반 코드내에서<br>보통 API나 SDK에서 제공해주는 함수(Function)들을 호출(Call)하여 사용하곤 한다.<br>이런 방식의 경우, 어떤 이벤트를 제어하기 위해서는 별도의 쓰레드를 생성하여 무한루프로 실시간 검사하는 꽤나 무겁고 살짝 무식한 프로그램들을 만들어야한다.</p><p>보통 이럴때, 사용하는 것이 콜백(CallBack) 함수.<br>물론 시스템상 CallBack함수를 만들어 등록하는 방식이 제공되어야 한다.<br>Windows 프로그램상에서 On??Event()를 통해 등록하는 방식이나, 안드로이드 상에서 Listener를 등록하는 방식이 이와 같다.<br>콜백함수라는 말 그대로 일반 Call의 반대 방향을 말한다.<br>통상적으로 쓰듯이 우리가 시스템상의 함수를 Call하는 것이 아니라, 시스템에서 우리가 만들고 등록한 함수를 Call하는 방식.</p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-function" target="_blank" rel="noopener">http://poiemaweb.com/js-function</a></li><li><a href="http://shinluckyarchive.tistory.com/479" target="_blank" rel="noopener">shinlucky’s Archive</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>4/ 참조타입_Function 타입 (1)</title>
    <link href="http://feel5ny.github.io/2017/12/02/JS_04_1/"/>
    <id>http://feel5ny.github.io/2017/12/02/JS_04_1/</id>
    <published>2017-12-02T02:20:12.000Z</published>
    <updated>2018-08-15T14:44:07.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><p>목차 </p><ol><li><a href="#Function">Function 타입</a></li><li><a href="#declarations_expressions">함수 선언 vs 함수 표현식</a></li><li><a href="#First_class_object">값처럼 쓰는 함수(일급객체)</a></li><li><span style="color:lightgray">함수의 내부 구조</span></li><li><span style="color:lightgray">함수 프로퍼티와 메서드</span><br> <span style="color:gray">4,5번은 Function 2편에서</span></li></ol><hr><h2 id="1-Function-타입"><a href="#1-Function-타입" class="headerlink" title=" 1. Function 타입"></a><a name="Function"></a> 1. Function 타입</h2><p>함수는 객체이다. 모든 함수는 Function타입의 인스턴스이며, 프로퍼티와 메서드가 있다.<br>함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다.</p><h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><ol><li><p>함수 선언식</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>함수 표현식 Function expression</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>일급객체라는 함수의 특징 때문에 함수 리터럴 방식으로 선언 후 변수에 할당할 수 있다.</li><li>할당된 함수를 가리키는 참조값을 저장하게 된다.</li><li>이렇게 생성된 함수는 function 키워드 다음에 함수 이름이 없으므로 <code>익명 함수</code>로 간주한다. <ul><li>익명함수(anonymous function) = 람다함수(lambda)</li><li>name 프로퍼티는 빈 문자열이다.</li><li>함수표현식으로 재귀, 클로저, 고유변수 등을 설명할 수 있다.<br><br></li></ul></li></ul></li><li><p>Function 생성자 사용 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1'</span>,<span class="string">'num2'</span>,<span class="string">'return num1 + num2'</span>)</span><br></pre></td></tr></table></figure><ul><li>함수 리터럴 방식</li><li>당연히 권장하지 않는다.</li><li>ECMAScript 생성자에 전달할 문자열을 다시 평가해야 하므로 성능에 영향이 있다.</li></ul></li></ol><p><strong><code>괄호를 쓰지않는 sum</code></strong><br>괄호를 쓰지 않고 함수 이름만 쓰면 함수를 실행하지 않고 <strong>함수를 가리키는 포인터에 접근(만)하는 것</strong>이다.</p><hr><h2 id="2-함수-선언-vs-함수-표현식"><a href="#2-함수-선언-vs-함수-표현식" class="headerlink" title=" 2. 함수 선언 vs 함수 표현식"></a><a name="declarations_expressions"></a> 2. 함수 선언 vs 함수 표현식</h2><p>자바스크립트 엔진이 <a href="https://feel5ny.github.io/2017/12/01/JS_03/">실행 컨텍스트</a>에 데이터를 불러올 때 중요한 차이가 하나 있다.<br><span style="color: tomato">함수 선언</span>은 어떤 코드도 실행하기 전에 이미 모든 실행 컨텍스트에서 접근하고 실행할 수 있지만<br><span style="color: blue">함수 표현식</span>은 코드 실행이 해당 줄까지 진행하기 전에는 사용할 수 없다.</p><p>실행 컨텍스트와 같이 생각해보자!<br><strong>자바스크립트 엔진은 코드를 평가할 때 제일 먼저 함수 선언을 찾은 다음 이들을 맨 위로 올린다 (함수 호이스팅). <code>함수 표현식</code>은 변수에 함수가 할당된 개념이기 때문에, 해당 변수에 값(함수)이 들어오기 전까지는 <code>undefined</code>로만 선언되어있는 상태이다.(변수 호이스팅)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>즉, 위 코드를 보면 에러가 나는데, sum은 컨텍스트에 있지만 매개변수를 넘길 수 있는 형태가 아니기 때문에(2번째 줄 오기 전까지는 <code>undefined</code>) 해당 코드까지 실행하기 전에는 <code>unexpected identifier</code> 에러를 낸다.<br>(예기치 못한 식별자 = <code>sum(10,10)</code>을 보고 함수형태의 식별자 sum을 기대하고 찾았는데, 함수형태가 아니라서) </p><h4 id="함수-표현식만-사용하자고-권고한다-참고"><a href="#함수-표현식만-사용하자고-권고한다-참고" class="headerlink" title="함수 표현식만 사용하자고 권고한다 : 참고"></a>함수 표현식만 사용하자고 권고한다 : <a href="http://poiemaweb.com/js-function#2-함수-호이스팅function-hoisting" target="_blank" rel="noopener">참고</a></h4><p>JavaScript : The Good Parts의 저자이며 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 <code>함수표현식만을 사용할 것을 권고하고 있다.</code> 함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 <strong>1. 코드의 구조를 엉성하게 만들 수 있다고 지적한다.</strong></p><p>또한 함수선언식으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 <strong>2. 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다.</strong></p><hr><h2 id="3-값처럼-쓰는-함수-일급객체"><a href="#3-값처럼-쓰는-함수-일급객체" class="headerlink" title=" 3. 값처럼 쓰는 함수 (일급객체)"></a><a name="First_class_object"></a> 3. 값처럼 쓰는 함수 (일급객체)</h2><p>자바스크립트 함수는 <strong>일급 객체</strong>이다. </p><p>일급객체란 </p><ol><li>생성(인스턴스 생성가능), </li><li>대입, </li><li>연산, </li><li>인자 또는 반환값으로서의 전달 등 </li></ol><p><strong>프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상</strong>을 의미한다.<br>일급객체일 경우 아래와 같은 특징을 갖는다.</p><div style="background-color: #f1f1f1; padding: 21px;"> 1. 무명의 <a href="https://feel5ny.github.io/2017/11/17/Typescript_04/#literal">리터럴</a>로 표현이 가능하다.<br>2. 변수나 자료구조 (객체, 배열…)에 저장할 수 있다.<br>3. 함수의 파라미터로 전달할 수 있다.<br>4. 반환값(return value)으로 사용할 수 있다. (내부함수)<br></div><p>함수와 다른 객체를 구분 짓는 특징은 호출할 수 있다는 것이다.</p><ol><li>함수가 다른 함수를 반환하는 상황<br>예시1_callSomeFunction<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample example</span></span><br><span class="line"><span class="comment">// callSomeFuncion은 범용함수이다. 범용함수란 더 많은 상황에서 더 잘 적용할 수 있는 함수를 말한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someFunction(someArgument) <span class="comment">// 반환값으로 사용됨</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = callSomeFunction(add10, <span class="number">19</span>);</span><br><span class="line">alert(result); <span class="comment">//20</span></span><br></pre></td></tr></table></figure></li></ol><p>예시2_sort의 createComparisonFunction함수</p><ul><li>해당 객체의 프로퍼티 이름을 확인하여 순서를 배치하는 함수를 반환하는 비교함수이다.</li><li>개체는 해당 속성 중 하나의 값을 기준으로 정렬 할 수 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>)</span>&#123; <span class="comment">// return 연산자 뒤에 내부함수</span></span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName]</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// value1이 앞에 옴</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// value1이 뒤에 옴</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = [&#123;<span class="attr">name</span>: <span class="string">'Joy'</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">'Clara'</span>, <span class="attr">age</span>:<span class="number">28</span>&#125;]</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">'name'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name) <span class="comment">// Clara</span></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">'age'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].age) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="sort-compareFunction"><a href="#sort-compareFunction" class="headerlink" title="sort(compareFunction)"></a><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener"><strong><code>sort(compareFunction)</code></strong></a></h3><p>compareFunction이 제공되지 않으면 <strong>요소를 문자열(toString)로 변환하고 유니 코드 코드 포인트 순서로 문자열을 비교하여 정렬</strong>됩니다. 예를 들어 “바나나”는 “체리”앞에옵니다. 숫자 정렬에서는 9가 80보다 앞에 오지만 숫자는 문자열로 변환되기 때문에 <strong>“80”은 유니 코드 순서에서 “9”앞에옵니다.</strong></p><p>문자열 대신 숫자일 경우 value1과 value2를 빼는방법으로 색인을 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-function" target="_blank" rel="noopener">http://poiemaweb.com/js-function</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘프론트엔드 개발자를 위한 자바스크립트 프로그래밍’ 책을 참고하여 정리합니다. &lt;strong&gt;오류&lt;/strong&gt;가 있다면 언제든지 댓글 남겨주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;목차 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>3/ 실행 컨텍스트와 스코프</title>
    <link href="http://feel5ny.github.io/2017/12/01/JS_03/"/>
    <id>http://feel5ny.github.io/2017/12/01/JS_03/</id>
    <published>2017-12-01T01:13:55.000Z</published>
    <updated>2018-08-15T14:44:07.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788966260768&amp;orderClick=LAG&amp;Kc=" target="_blank" rel="noopener">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a> 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><p>목차 </p><ol><li><a href="#Execution_context">실행컨텍스트란?</a></li><li><a href="#Execution_object">실행컨텍스트의 3가지 객체</a></li><li><a href="#Scope_chain">스코프 체인</a></li><li><a href="#this">this value</a></li></ol><hr><h2 id="1-실행-컨텍스트"><a href="#1-실행-컨텍스트" class="headerlink" title=" 1. 실행 컨텍스트"></a><a name="Execution_context"></a> 1. 실행 컨텍스트</h2><p>실행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다. ECMAScript 스펙에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 즉, 실행 컨텍스트는 <code>실행 가능한 코드가 실행되는 환경</code>이라고 말할 수 있다.<br>실행 가능한 코드란</p><ul><li>전역코드 : 전역 영역에 존재하는 코드</li><li>함수코드 : 함수 내에 존재하는 코드</li><li>Eval코드 : Eval 함수로 실행되는 코드</li></ul><p>일반적으로는 전역코드와 함수코드. </p><p>자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보를 알고 있어야 한다.</p><ul><li>변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티</li><li>함수 선언<ul><li>함수 표현식은 호이스팅이 안되는 이유. (함수 표현식은 변수에 할당되는 방식이기 때문에)</li></ul></li><li>변수의 유효범위 (Scope)</li><li>this</li></ul><p>자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다.</p><hr><h2 id="2-실행-컨텍스트의-3가지-객체"><a href="#2-실행-컨텍스트의-3가지-객체" class="headerlink" title=" 2. 실행 컨텍스트의 3가지 객체"></a><a name="Execution_object"></a> 2. 실행 컨텍스트의 3가지 객체</h2><p>객체의 형태를 가지며 아래의 3가지 프로퍼티를 소유한다.</p><ul><li>Variable object</li><li>Scope chain</li><li>thisValue</li></ul><h3 id="2-1-Variable-object-VO-변수객체"><a href="#2-1-Variable-object-VO-변수객체" class="headerlink" title="2-1. Variable object (VO 변수객체)"></a>2-1. Variable object (VO 변수객체)</h3><p>변수나 함수의 실행 컨텍스트는 <strong>다른 데이터에 접근할 수 있는지, 어떻게 행동하는지를 규정합니다.</strong> 각 실행 컨텍스트에는 변수객체(variable object:VO)가 연결되어 있으며, 해당 컨텍스트에서 정의된 모든 <code>변수</code>와 <code>함수</code>는 이 객체에 존재한다. 코드로는 접근할 수 없다.</p><ul><li>변수</li><li>parameter arguments<ul><li>parameter, 매개변수 : 함수 원형 작성시 사용되는 변수를 인자 (이름보다는 타입이 중요)</li><li>argument, 실행인자 : 코딩 중 함수 호출시 사용되는 변수 또는 실제 값을 인수</li></ul></li><li>함수 선언 (함수 표현식은 제외)</li></ul><p>Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 갖는데, 이 값은 다른 객체를 가리킨다.<br>전역 컨텍스트와 함수 컨텍스트가 가리키는 객체는 다르다. 함수에만 파라미터가 존재한다.</p><h4 id="전역-컨텍스트인-경우"><a href="#전역-컨텍스트인-경우" class="headerlink" title="전역 컨텍스트인 경우"></a><code>전역 컨텍스트인 경우</code></h4><p>Variable Object는 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object/GO)를 가리킨다. 전역변수와 전역함수는 전역 객체의 프로퍼티이다.</p><p><img src="/images/post_img/36/ec-vo-global.png"></p><p>전역 컨텍스트란</p><ul><li>가장 바깥쪽에 존재하는 실행 컨텍스트이다.</li><li><p>ECMAScript를 구현한 환경에 따라 이 컨텍스트를 부르는 이름이 다르다.</p><ul><li>웹 ()<ul><li>전역컨텍스트 : <code>window</code></li><li>전역변수와 전역함수는 모두 window의 프로퍼티 및 메서드로 생성된다.</li></ul></li></ul></li><li><p>전역컨텍스트는 애플리케이션이 종료될 때, 웹페이지를 나가거나 브라우저를 닫을 때까지 유지된다.</p></li></ul><h4 id="함수-컨텍스트인-경우"><a href="#함수-컨텍스트인-경우" class="headerlink" title="함수 컨텍스트인 경우"></a><code>함수 컨텍스트인 경우</code></h4><p>Variable Object는 Activation Object(AO/활성객체)를 가리키며 arguments object가 추가된다.<br>arguments object 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체이다.<br>(이전 글에서 함수의 매개변수로 값이 전달될 때 arguments object에 들어간다고 했다. 전달한 값이 argument라고 생각하면 된다. arguments object: 함수 호출 시 전달된 인수들의 정보를 담고 있는 유사배열객체.)<br><img src="/images/post_img/36/ec-vo-foo.png"></p><h4 id="실행컨텍스트-스택"><a href="#실행컨텍스트-스택" class="headerlink" title="실행컨텍스트 스택"></a><code>실행컨텍스트 스택</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'xxx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="string">'yyy'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="string">'zzz'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><img src="/images/post_img/36/ec_1.png"></p><ol><li>컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다.</li><li>전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다.</li><li>함수를 호출하면 해당 함수의 실행 컨택스트가 생성되며 직전에 실행된 코드블럭의 실행 컨텍스트 위에 쌓인다.</li><li>함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다.<br>ECMAScript 프로그램은 모두 이런 식으로 실행된다.</li></ol><hr><h2 id="3-스코프-체인-SC"><a href="#3-스코프-체인-SC" class="headerlink" title=" 3. 스코프 체인 SC"></a><a name="Scope_chain"></a> 3. 스코프 체인 SC</h2><p>스코프 체인은 일종의 리스트로서 중첩된 함수의 <strong>스코프의 레퍼런스를 차례로 저장하고 있는 개념</strong>이다.<br>즉, 현재 실행컨텍스트의 활성객체(AO)를 선두로하여 순차적으로 상위 컨텍스트의 AO를 가리키며 마지막 리스트는 전역 객체를 가리킨다.</p><p><strong>스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 <code>순서</code>를 정의하는 것.</strong></p><ul><li>함수가 중첩 상태일 때 하위함수 내에서 상위함수의 유효범위까지 참조할 수 있는데 이것는 스코프 체인을 검색하였기 때문이다. </li><li>함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인에 포함된다. </li><li>함수 실행중에 변수를 만나면 그 변수를 우선 현재 Scope, 즉 Activation Object에서 검색해보고, </li><li>만약 검색에 실패하면 스코프 체인에 담겨진 순서대로 그 검색을 이어가게 되는 것이다. </li></ul><p><strong>이것이 스코프 체인이라고 불리는 이유이다.</strong></p><p>이와 같이 순차적으로 스코프 체인에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 Reference 에러를 발생시킨다.<br>스코프 체인은 <code>[[scope]]</code> 프로퍼티로 참조할 수 있다.</p><hr><h2 id="4-this-value"><a href="#4-this-value" class="headerlink" title=" 4. this value"></a><a name="this"></a> 4. this value</h2><p>this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정되는데, 이는 Function 글에서 자세히 다루겠다.</p><hr><h2 id="5-실행-컨텍스트의-생성과정"><a href="#5-실행-컨텍스트의-생성과정" class="headerlink" title=" 5. 실행 컨텍스트의 생성과정"></a><a name="this"></a> 5. 실행 컨텍스트의 생성과정</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'xxx'</span>;<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function foo () &#123;</span></span><br><span class="line"><span class="string">  var y = 'yyy';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  function bar () &#123;</span></span><br><span class="line"><span class="string">    var z = 'zzz';</span></span><br><span class="line"><span class="string">    console.log(x + y + z);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  bar();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo();</span></span><br></pre></td></tr></table></figure><ol><li>전역 코드에 진입<br>컨트롤이 실행 컨텍스트에 진입하기 이전에 유일한 전역 객체(Global Object)가 생성된다. 초기 상태의 전역 객체에는 빌트인 객체(Math, String, Array 등)와 BOM, DOM이 설정되어 있다.</li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-execution-context" target="_blank" rel="noopener">http://poiemaweb.com/js-execution-context</a></li><li><a href="http://nerissa.tistory.com/entry/Parameter%EC%99%80-Argument%EC%9D%98-%EC%B0%A8%EC%9D%B4" target="_blank" rel="noopener">http://nerissa.tistory.com/entry/Parameter%EC%99%80-Argument%EC%9D%98-%EC%B0%A8%EC%9D%B4</a></li><li><a href="http://poiemaweb.com/js-function" target="_blank" rel="noopener">http://poiemaweb.com/js-function</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788966260768&amp;amp;orderCl
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>2/ 메모리 관리와 가비지 콜렉션</title>
    <link href="http://feel5ny.github.io/2017/11/30/JS_02/"/>
    <id>http://feel5ny.github.io/2017/11/30/JS_02/</id>
    <published>2017-11-30T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:07.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788966260768&amp;orderClick=LAG&amp;Kc=" target="_blank" rel="noopener">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a> 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><p><strong>요약</strong><br>가비지 콜렉션은 더 이상 사용하지 않는 메모리를 회수하는 역할을 한다. 메모리를 회수하기 전 사용하지 않는 변수를 체킹해야 하는데 이때 <code>표시하고 지우기</code> 방법과 <code>참조 카운팅</code>이 있다. <code>표시하고 지우기 방법</code>은 처음 컨텍스트의 모든 변수에 마킹을 한 후, 값이 할당되어있거나 참조되어있는 변수의 마킹을 지운다. 지웠음에도 마킹이 남아있는 변수를 회수하는 방식이다. <code>참조 카운팅</code>은 참조 카운트가 0인 변수를 회수하는 방식인데 순환참조의 카운팅 한계가 있기 때문에 주로 표시하고 지우기 방법을 사용한다. 가비지 콜렉터 사이클이 도는 것은 상당한 비용이 발생한다. 메모리 누수 관리를 위해서는 사용하지 않는 변수나 객체는 모두 null로 재할당하여 가비지 컬렉터가 다음 사이클 때 회수하도록 하는 방법, 크롬 개발자도구의 퍼포먼스 탭에서 확인하는 방법 등이 있다.</p><p><strong>목차</strong> </p><ol><li>가비지 콜렉션</li><li>GC가 회수해야할 메모리 식별은 어떻게 하나요?<ol><li>표시하고 지우는 방법 Mark and Sweep</li><li>참조 카운팅 Reference counting</li></ol></li><li>가비지 콜렉터와 성능문제</li><li>자바스크립트로 프로그래밍시 내가 할 수 있는 메모리 관리</li></ol><hr><h3 id="1-가비지-콜렉션"><a href="#1-가비지-콜렉션" class="headerlink" title="1. 가비지 콜렉션"></a>1. 가비지 콜렉션</h3><p>자바스크립트는 <span style="color:blue">인터프리터</span> 언어이다.<br>(인터프리터 언어란 목적 파일 산출과정이 없이 실행과 동시에 줄 단위로 번역이 된고, 저용량 소스에 적합하다. 코드가 실행되는 시점이 런타임이다. <a href="https://feel5ny.github.io/2017/11/08/Typescript_01/">인터프리터와 컴파일러의 차이점</a>)</p><p><img src="/images/post_img/34/cleaner-01.jpg" width="50%"></p><p>고급 언어 인터프리터는 가비지 콜렉터 라는 소프트웨어를 가지고 있다.<br>가비지 컬렉터(<strong>G</strong>arbage <strong>C</strong>ollector)란 <strong>메모리 할당을 추적하고 할당된 메모리가 더 이상 필요 없어졌을 때 해체하는 작업이다.</strong> </p><p>이 프로세스는 주기적으로 실행되는데 코드 실행 중에 특정 시점에서 메모리를 회수하도록 지정할 수도 있다. C나 C++같은 언어에서는 메모리 추적이 매우 중요하기 때문에 메모리 관리가 힘들지만, <span style="color:blue">자바스크립트는 필요한 메모리를 자동으로 할당하고 더 이상 사용하지 않는 메모리는 자동으로 회수하므로 개발자가 직접 메모리를 관리하지 않아도 된다. </span></p><p>가비지 컬렉터는 항상 필요없어진 메모리만을 해제하지만, 모든 필요없어진 메모리를 해제하는 건 아니다. 즉, ‘더 이상 필요없는 모든 메모리’가 아니라 ‘더 이상 필요 없는 <strong>몇몇</strong> 메모리’를 찾아낸다. 이는 가비지 콜렉션 알고리즘의 한계점이 있기 때문이다. </p><hr><h3 id="2-GC가-회수해야할-메모리-식별은-어떻게-하나요"><a href="#2-GC가-회수해야할-메모리-식별은-어떻게-하나요" class="headerlink" title="2. GC가 회수해야할 메모리 식별은 어떻게 하나요?"></a>2. GC가 회수해야할 메모리 식별은 어떻게 하나요?</h3><p>무튼, 어떤 변수가 더 이상 사용되지 않는지, 사용될 가능성이 있는 변수는 무엇인지 추적해야 메모리 회수 대상을 정할 수 있다. 식별 기준은 2가지이다.</p><ol><li>표시하고 지우기 Mark and Sweep</li><li>참조 카운팅 Reference counting</li></ol><h4 id="2-1-표시하고-지우기-Mark-and-Sweep"><a href="#2-1-표시하고-지우기-Mark-and-Sweep" class="headerlink" title="2.1 표시하고 지우기 Mark and Sweep"></a>2.1 표시하고 지우기 Mark and Sweep</h4><p>가장 널리 쓰이는 컬렉션 방법이다.<br>변수가 특정 컨텍스트 안에서 사용할 것으로 정의되면 그 변수는 그 컨텍스트 안에 있는 것으로 <strong>표시</strong>된다. 표시한는 구체적인 방법은 알 필요는 없다.. </p><p>GC가 작동하면 </p><ol><li>메모리에 저장된 변수 전체를 표시한다.</li><li>컨텍스트에 있는 변수, 컨텍스트에 있는 변수가 참조하는 변수의 표시를 지운다.</li><li>표시가 지워지지 않는 변수를 삭제한다.</li></ol><p>가비지 컬렉터는 ‘메모리 청소’를 실행해 표시가 남아 있는 값을 모두 파괴하고 메모리를 회수한다. </p><h4 id="2-2-참조-카운팅-Reference-counting"><a href="#2-2-참조-카운팅-Reference-counting" class="headerlink" title="2.2 참조 카운팅 Reference counting"></a>2.2 참조 카운팅 Reference counting</h4><p>각 값이 얼마나 많이 참조 되었는지 추적한다. </p><ol><li>변수를 선언하고 참조 값이 할당되면 참조 카운트는 1이다.</li><li>다른 변수가 같은 값을 참조하면 참조 카운트가 늘어난다. </li><li>마찬가지로 해당 값을 참조하는 변수에 다른 값을 할당하면 원래 값의 참조 카운트가 줄어든다. </li><li>값의 참조 카운트가 0이 되면 해당 값에 접근할 방법이 없으며, 메모리를 회수해도 안전하다. </li><li>다음 가비지 컬렉터를 실행할 때 참조 카운트가 0인 값에서 사용하던 메모리를 회수한다.</li></ol><p><strong>순환 참조 문제</strong><br>이 알고리즘은 두 object가 서로를 참조하면 문제가 발생한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// objectA : reference count 1</span></span><br><span class="line">  <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// objectB : reference count 2</span></span><br><span class="line"></span><br><span class="line">  objectA.someOtherObject = objectB; <span class="comment">// objectA : 2</span></span><br><span class="line">  objectB.anotherObject = objectA; <span class="comment">// objectB : 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드를 보면 새로운 객체가 생성되면서 참조 카운트가 1이되고,<br>서로 참조하게 되면서 참조카운트가 2가 된다.<br>이 상태에서 스코프를 벗어나게 되면, 해당 변수는 사용되지 않는데, 벗어났음에도 카운트가 0이 아니기 때문에 GC가 컬렉션을 하지 않게 된다. 이는 곧 메모리 낭비로 이어진다.<br>이때는 강제로 null을 항당해서 참조했던 값으로의 연결을 끊어줘야한다.</p><blockquote><p>그래서 대부분의 브라우저에서는 표시하고 지우기 방법을 쓴다.</p></blockquote><hr><h3 id="3-가비지-콜렉터와-성능문제"><a href="#3-가비지-콜렉터와-성능문제" class="headerlink" title="3. 가비지 콜렉터와 성능문제"></a>3. 가비지 콜렉터와 성능문제</h3><p>GC는 주기적으로 실행되며 메모리 내에 할당된 변수가 많다면 상당한 비용이 드는 작업이므로 GC를 실행하는 <strong>타이밍</strong>이 중요하다. 익스플로러는 가비지 컬렉터를 너무 자주 실행하여 성능 문제를 일으키는 것으로 악명이 놓다.</p><hr><h3 id="4-자바스크립트로-프로그래밍시-내가-할-수-있는-메모리-관리"><a href="#4-자바스크립트로-프로그래밍시-내가-할-수-있는-메모리-관리" class="headerlink" title="4. 자바스크립트로 프로그래밍시 내가 할 수 있는 메모리 관리"></a>4. 자바스크립트로 프로그래밍시 내가 할 수 있는 메모리 관리</h3><p>웹 브라우저에서 사용할 수 있는 메모리는 일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적다. 적은 메모리만 할당받는 주된 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 운영체제를 다운시키는 일을 방지하기 위함이다.<br>메모리 제한은 변수 할당 뿐만 아니라 호출스택, 스레드에서 실행할 수 있는 문장수에도 영향을 미친다.<br>즉! 가능한 최소한의 메모리만 사용해야 페이지의 성능을 올릴 수 있다.</p><p><img src="/images/post_img/34/cleaner-02.jpg" width="50%"></p><p>필요 없어진 데이터에는 <code>null</code>을 할당하여 참조를 제거(dereference)하는 편이 좋다. <span style="color:blue">이론상은 그렇지만, 실제로는 많이 사용하지 않는다. 참조를 하고 있는지에 대해서 개발자가 판단하기가 어렵기 때문에 오히려 전체 흐름을 망가뜨리는 행위가 될 수 있다. 우리도 모르게 어디선가 side effect가 발생할 수도있고, 복잡성이 증가한다.(면접 때 면접관님께서 정정해주셨다!)</span><br>수동으로 참조 제거해야 할 대상은 주로 <code>전역변수</code> 및 <code>전역 객체의 프로퍼티</code>이다.<br>(지역변수는 컨텍스트를 빠져나가는 순간 자동으로 참조가 제거된다.)</p><p>참조 제거의 요점은 값의 컨텍스트를 없애서 다음에 가비지콜렉션을 실행할 때 해당 메모리를 회수하도록 하는 것이다. </p><ul><li><p>사용하지 않은 객체, 변수는 모두 <strong>null</strong> 로 초기화</p></li><li><p>이벤트 핸들러를 바인딩 했다면, 모두 <strong>언바인딩</strong></p></li><li>DOM 을 동적으로 생성했다면, <strong>불필요한 객체, 속성(값)을 DOM 에 삽입하지 말자.</strong></li><li>크롬 개발자도구의 Performace탭에서 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool?hl=ko" target="_blank" rel="noopener">timeline</a>확인해보자. </li></ul><hr><h4 id="번외-참고-글-V8-Efficient-Garbage-Collection"><a href="#번외-참고-글-V8-Efficient-Garbage-Collection" class="headerlink" title="(번외 (참고 글)) V8_Efficient Garbage Collection"></a>(번외 (참고 글)) <a href="http://huns.me/development/452" target="_blank" rel="noopener">V8_Efficient Garbage Collection</a></h4><p>V8은 객체가 사용하다가 더 이상 필요 없게 된 메모리를 가비지 콜렉션(garbage collection)이라고 알려진 작업을 통해서 다시 찾아온다. 빠른 객체 할당을 보장하고, 가비지 콜렉션으로 인한 프로그램 정지 시간을 단축시키며, 메모리 파편화를 제거하기 위해서 stop-the-world 방식의 세대적이고, 정확한 가비지 콜렉터(garbage collector)를 채택하고 있다.</p><p>이것은 다음을 의미한다.</p><ul><li>가비지 콜렉션 사이클을 수행할 때 프로그램 실행을 멈춘다.</li><li>가비지 콜렉션 사이클 중 대부분의 시간을 객체의 힙(heap)의 영역을 처리하는데 사용함으로써 어플리케이션 멈춤 현상을 최소화 한다.</li><li>모든 객체가 포인터가 메모리의 어디에 있는지 항상 정확히 알고 있다. 이를 통해 객체를 포인터로 잘못 식별하여 메모리 누수를 일으키는 문제를 피할 수 있다.</li></ul><p>V8에서 객체의 heap은 2개의 부분으로 나누어져 있다. 새로 객체가 생성되는 영역과 가비지 콜렉션 사이클이 진행되는 동안에 살아남은 객체가 있는 영역. 객체가 가비지 콜렉션으로 들어가면 V8은 객체의 포인터를 갱신한다.</p><blockquote><p>변수를 생성하는 것 자체가 메모리를 사용하는 것인데, 이를 회수하고 관리하는 가비지컬렉션이 있다는 것에 흥미로웠다.<br>메모리 누수를 막아서 최소한의 메모리 사용으로 페이지 성능을 향상하는 것이 목적이지만, 사이클이 너무 많이 실행되면 이것 또한 자원낭비.<br>변수의 할당의 최소화하고, 코드 재사용성을 높이고, 전역변수나 전역객체의 프로퍼티가 존재한다면 마지막에 null을 할당해보자.</p></blockquote><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management</a></li><li><a href="http://huns.me/development/452" target="_blank" rel="noopener">http://huns.me/development/452</a></li><li><a href="https://v8project.blogspot.kr/2015/08/getting-garbage-collection-for-free.html" target="_blank" rel="noopener">https://v8project.blogspot.kr/2015/08/getting-garbage-collection-for-free.html</a></li><li><a href="http://hapina.tistory.com/112" target="_blank" rel="noopener">http://hapina.tistory.com/112</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788966260768&amp;amp;orderCl
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>1/ 변수, 원시 값과 참조 값</title>
    <link href="http://feel5ny.github.io/2017/11/29/JS_01/"/>
    <id>http://feel5ny.github.io/2017/11/29/JS_01/</id>
    <published>2017-11-29T09:23:55.000Z</published>
    <updated>2018-08-15T14:44:07.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788966260768&amp;orderClick=LAG&amp;Kc=" target="_blank" rel="noopener">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a> 책을 참고하여 정리합니다. <strong>오류</strong>가 있다면 언제든지 댓글 남겨주세요.</p></blockquote><p>까묵지말자<br>Call-by-value, Call-by-reference</p><p>목차 </p><ol><li><a href="#variable">변수란?</a> 위치를 기억하는 저장소</li><li><a href="#value">원시 값과 참조 값</a> 원시값은 단순한 데이터, 참조 값은 객체를 가리킨다.</li><li><a href="#dynamic">동적 프로퍼티</a> 동적으로 프로퍼티를 추가할 수 있는 값은 참조 값 뿐</li><li><a href="#copy">값 복사</a> 원시 값은 독립적으로 복사가되고, 참조 값은 주소값이 복사된다.</li><li><a href="#parameter">매개변수 전달</a> 매개변수는 오직 값으로 전달된다. (매개변수로 복사)</li><li><a href="#typeof">타입 판별</a> typeof와 instance of</li></ol><hr><h2 id="1-변수란"><a href="#1-변수란" class="headerlink" title=" 1. 변수란?"></a><a name="variable"></a> 1. 변수란?</h2><p>변수는 위치(주소)를 기억하는 저장소이다. (포인터의 개념)<br>위치란 메모리 상의 주소(address)를 의미한다. 즉, 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자이다.</p><p>변수를 통해 메모리에 값을 저장하기 위해서는 우선 필요한 저장 단위(byte)를 알아야한다. <strong>이는 값의 종류에 따라 값을 저장하기 위해 확보해야할 메모리의 크기가 다르기 때문이다.</strong> 이때 값의 종류 즉, 데이터의 종류를 자료형이라고 한다. C-family언어는 정적타이핑 언어로 변수 선언 시 변수에 저장할 값의 종류에 따라 사전에 자료형을 지정하여야 한다.</p><blockquote><p>변수를 선언하는 것부터가 메모리를 사용하는 것이기 때문에 변수사용을 최소한으로 하여, 페이지의 성능을 유지해야한다.</p></blockquote><h3 id="동적-타입-Dynamic-typed"><a href="#동적-타입-Dynamic-typed" class="headerlink" title="동적 타입 Dynamic typed"></a>동적 타입 Dynamic typed</h3><p>jacascript는 동적 타이핑 언어로(느슨한 타입: loosely typed) 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자동으로 자료형이 결정(Type Inference: 타입 추론)된다. 따라서 같은 변수에 여러 자료형의 값을 대입할 수 있다. </p><blockquote><p>타입스크립트는 이런 동적 타이핑 언어의 단점을 보안하기 위해서 타입을 명시해주는 특징을 갖고 있다. </p></blockquote><p>변수는 값을 저장(할당), 참조하기 위해 사용된다. 한번 쓰고 버리는 값이 아닌 유지할 필요가 있는 경우, 변수를 사용한다.</p><hr><h2 id="2-원시-값과-참조-값"><a href="#2-원시-값과-참조-값" class="headerlink" title=" 2. 원시 값과 참조 값"></a><a name="value"></a> 2. 원시 값과 참조 값</h2><p>원시 값과 참조값 두가지 타입의 데이터를 저장할 수 있는데,<br>원시 값은 단순한 데이터이며<br>참조 값은 여러 값으로 구성되는 객체를 가리킨다.<br>변수에 값이 할당되면 <code>자바스크립트 엔진</code>이 해당 값이 원시 데이터인지 참조인지 판단한다.</p><p>참조 값은 메모리에 저장된 객체이다. <code>다른 언어와 달리 자바스크립트는 메모리 위치에 직접 접근하는 것을 허용하지 않고, 객체의 메모리 공간을 직접 조작하는 일은 불가능하다.</code></p><h3 id="참조로-접근한다"><a href="#참조로-접근한다" class="headerlink" title="참조로 접근한다"></a><code>참조로 접근한다</code></h3><p>객체를 조작할 때는 객체 자체가 아니라 해당 객체에 대한 <strong>참조를 조작</strong>하는 것이다. 이런 이유로 객체를 가리키는 값은 ‘참조로 접근한다’고 한다.</p><hr><h2 id="3-동적-프로퍼티"><a href="#3-동적-프로퍼티" class="headerlink" title=" 3. 동적 프로퍼티"></a><a name="dynamic"></a> 3. 동적 프로퍼티</h2><p>참조 값을 다룰 때는 언제든 프로퍼티와 메서드를 추가하거나 바꾸고 삭제 할 수 있다.<br>원시 값에는 프로퍼티가 없지만 추가하려 해도 에러가 생기진 않는다.<br>동적으로 프로퍼티를 추가할 수 있는 값은 참조 값 뿐이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'Clara'</span></span><br><span class="line">alert(person.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Clara'</span></span><br><span class="line">name.age = <span class="number">27</span></span><br><span class="line">alert(name.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-값-복사"><a href="#4-값-복사" class="headerlink" title=" 4. 값 복사"></a><a name="copy"></a> 4. 값 복사</h2><h3 id="원시-값"><a href="#원시-값" class="headerlink" title="원시 값"></a>원시 값</h3><p>원시 값은 다른 변수로 복사할 때는 현재 저장된 값을 새로 생성한 다음 새로운 변수에 복사한다. 복사된 값과 원래 값은 완전히 분리되어 있다.</p><h3 id="참조-값"><a href="#참조-값" class="headerlink" title="참조 값"></a>참조 값</h3><p>참조 값을 변수에서 다른 변수로 복사가되면 그 값이 객체 자체가 아니라 <code>힙</code>에 저장된 객체를 가리키는 <code>포인터</code>라는 점이다. 복사 후에는 두 변수는 정확히 같은 객체를 가리킨다. 따라서 한쪽을 조작하면 다른 쪽에도 반영된다.<br>스택메모리 공간은 함수호출 시마다 생성되고,<br>힙메모리 공간은 객체 생성 시 생성됨.</p><p><img src="/images/post_img/33/reference_copy.jpg" width="80%"></p><hr><h2 id="5-매개변수-전달"><a href="#5-매개변수-전달" class="headerlink" title=" 5. 매개변수 전달"></a><a name="parameter"></a> 5. 매개변수 전달</h2><p>함수 매개변수는 모두 <code>값</code>으로 전달된다. 함수 외부에 있는 값은 함수 내부의 매개변수에 복사된다. 변수는 값으로도, 참조로도 접근할 수 있지만 <strong>매개변수는 오직 <code>값</code>으로만 전달된다.</strong> 메모리 공간을 확보하며 매개변수에 할당된다.</p><h3 id="Call-by-value-값에-의한-호출"><a href="#Call-by-value-값에-의한-호출" class="headerlink" title="Call-by-value (값에 의한 호출)"></a>Call-by-value (값에 의한 호출)</h3><p><img src="/images/post_img/33/primitive.jpg" width="80%"></p><p>매개변수를 값 형태로 넘기면 해당 값은 지역 변수에 <code>복사</code>된다.  arguments 객체에 들어가게 된다.</p><h3 id="Call-by-reference-참조에-의한-호출"><a href="#Call-by-reference-참조에-의한-호출" class="headerlink" title="Call-by-reference (참조에 의한 호출)"></a>Call-by-reference (참조에 의한 호출)</h3><p><img src="/images/post_img/33/reference_parameter_1.jpg" width="80%"><br>함수에 <code>값</code>을 전달했기 때문에 함수 내부에서 매개변수의 값이 바뀌었음에도 불구하고 원래 객체에 대한 참조를 그대로 유지한 것이다.<br>= 즉 객체가 넘어갈때는 참조 형태로 전달되는 것이 아니라 <strong>값으로 넘어간다.</strong> (== 포인터가 넘어간다)</p><p><img src="/images/post_img/33/reference_parameter_2.jpg" width="80%"><br>함수 내부에서 obj를 덮어쓰면 obj는 지역객체를 가리키는 포인터가 되고, 이 지역 객체(obj.name)는 함수 실행이 끝나면 파괴된다.</p><hr><h2 id="6-타입판별"><a href="#6-타입판별" class="headerlink" title=" 6. 타입판별"></a><a name="typeof"></a> 6. 타입판별</h2><p><code>typeof</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> 변수명</span><br></pre></td></tr></table></figure></p><p><code>instanceof</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">변수명 <span class="keyword">instanceof</span> <span class="built_in">Object</span> </span><br><span class="line"><span class="comment">// 이 변수는 Object의 인스턴스인가? </span></span><br><span class="line"><span class="comment">// 결과값은 boolean</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/js-data-type-variable" target="_blank" rel="noopener">http://poiemaweb.com/js-data-type-variable</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788966260768&amp;amp;orderCl
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/TIL-9997/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>persistor.purge()</title>
    <link href="http://feel5ny.github.io/2017/11/29/log_001/"/>
    <id>http://feel5ny.github.io/2017/11/29/log_001/</id>
    <published>2017-11-29T09:23:55.000Z</published>
    <updated>2018-08-15T14:45:09.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/rt2zz/redux-persist" target="_blank" rel="noopener">https://github.com/rt2zz/redux-persist</a><br>redux-persist 정리할 때 purge에 대해서 구체적으로 작성해보겠습니다.</p></blockquote><h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h2><ul><li>작업하면서 계속 리로딩을 하고 있었는데 reducer에서 값을 넣는 모양을 계속 바꿔주면서 작업하고 있었는데, 갑자기 로딩화면만 계속 나오기 시작</li></ul><p>에러 메세지<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: In this environment the sources <span class="keyword">for</span> assign MUST be an object. This error is a performance optimization and not spec compliant</span><br></pre></td></tr></table></figure></p><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h2><p>오류가 있는 persist 저장소를 갖고있어서 그럼.</p><h2 id="솔루션"><a href="#솔루션" class="headerlink" title="솔루션"></a>솔루션</h2><p><a href="https://github.com/rt2zz/redux-persist/issues/536" target="_blank" rel="noopener">https://github.com/rt2zz/redux-persist/issues/536</a></p><ol><li>루트 폴더에 persist를 작성한 부분 중 <code>const persistor = persistStore(store);</code>를 찾아냅니다.</li><li>해당 코드 밑에 <code>persistor.purge();</code>를 넣고 다시 실행 (purge는 persistStore의 데이터를 전부 날리는 역할을 한다.)</li><li>잘 싱행된다면 해당 코드는 삭제하세요.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rt2zz/redux-persist&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/rt2zz/redux-persist&lt;/a&gt;&lt;b
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="log" scheme="http://feel5ny.github.io/categories/TIL-9997/log/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React에 typescript 셋팅하기</title>
    <link href="http://feel5ny.github.io/2017/11/28/Typescript_13/"/>
    <id>http://feel5ny.github.io/2017/11/28/Typescript_13/</id>
    <published>2017-11-28T11:13:22.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>실습은 <a href="https://github.com/saystone/tic-tac-toe" target="_blank" rel="noopener">tic-tac-toc</a>이라는 js 프로젝트를 마이그레이션 하면서 typescript를 연습해본다.<br>raect+typescript는 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a> 참고하였습니다.<br>역시 이론과 실습이 결합할 때가 제일 재밌다!</p></blockquote><p>처음 프로젝트를 생성할 때 부터 타입스크립 버전으로 셋팅하는것이 제일 깔끔하다.</p><h3 id="1-create-react-app-ts-test-scripts-version-react-scripts-ts"><a href="#1-create-react-app-ts-test-scripts-version-react-scripts-ts" class="headerlink" title="1. create-react-app ts-test --scripts-version=react-scripts-ts"></a>1. <code>create-react-app ts-test --scripts-version=react-scripts-ts</code></h3><p>  create-react-app + 프로젝트 이름 + <code>--scripts-version=react-scripts-ts</code> 추가</p><p><img src="/images/post_img/27/01.jpg"></p><ul><li>react에서 사용하는 PropTypes를 사용하지 않아도 된다.</li></ul><blockquote><h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a><code>PropTypes</code></h3><p>컴포넌트 에서 원하는 props 의 Type 과 전달 된 props 의 Type 이 일치하지 않을 때 콘솔에서 오류 메시지가 나타나게 하고 싶을 땐, 컴포넌트 클래스의 propTypes 객체를 설정하면 됩니다. 또한, 이를 통하여 필수 props 를 지정할 수 있습니다. 즉, props 를 지정하지 않으면 콘솔에 오류 메시지가 나타납니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Content.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Content</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.props.title &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt; &#123; this.props.body &#125; &lt;/</span>p&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Content.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    title: React.PropTypes.string,</span></span><br><span class="line"><span class="regexp">    body: React.PropTypes.string.isRequired /</span><span class="regexp">/ isRequired는 필수의 의미이다.</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Content;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-state와-props는-interface로-처리를-해야한다"><a href="#2-state와-props는-interface로-처리를-해야한다" class="headerlink" title="2. state와 props는 interface로 처리를 해야한다."></a>2. state와 props는 interface로 처리를 해야한다.</h3><p>class에서 입출력되는 타입을 검토하기 위해서</p><ol><li><p>배열의 요소가 객체일 경우</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GameState &#123;</span><br><span class="line">  history: <span class="built_in">Array</span>&lt;&#123; squares: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; &#125;&gt; <span class="comment">// Array 요소가 객체일 경우 이렇게 타입을 지정해준다.</span></span><br><span class="line">  stepNumber: <span class="built_in">number</span></span><br><span class="line">  xIsNext: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Game <span class="keyword">extends</span> React.Component&lt;GameProps, GameState&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      history: [</span><br><span class="line">        &#123;</span><br><span class="line">          squares: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      stepNumber: <span class="number">0</span>,</span><br><span class="line">      xIsNext: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>return에 대한 출력값을 타입으로 명시할때</p><h3 id="JSX-Element"><a href="#JSX-Element" class="headerlink" title="JSX.Element"></a><code>JSX.Element</code></h3><p>return 내부가 JSX문법이므로 JSX.Element로 명시하였다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Game <span class="keyword">extends</span> React.Component&lt;GameProps, GameState&gt; &#123;</span><br><span class="line">  render(): JSX.Element &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"game"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"game-board"</span>&gt;</span><br><span class="line">          &lt;Board squares=&#123;current.squares&#125; onClick=&#123;<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">this</span>.handleClick(i)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="game-info"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;&#123;status&#125;&lt;/</span>div&gt;</span><br><span class="line">          &lt;ol&gt;&#123;moves&#125;&lt;<span class="regexp">/ol&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://velopert.com/921" target="_blank" rel="noopener">https://velopert.com/921</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;실습은 &lt;a href=&quot;https://github.com/saystone/tic-tac-toe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tic-tac-toc&lt;/a&gt;이라는 js 프로젝트를 마이그레이션 하면서 
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>11/ Type Inference</title>
    <link href="http://feel5ny.github.io/2017/11/27/Typescript_12/"/>
    <id>http://feel5ny.github.io/2017/11/27/Typescript_12/</id>
    <published>2017-11-27T04:11:43.000Z</published>
    <updated>2018-08-15T14:46:48.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-15" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong></p><ol><li><a href="#inference">타입추론</a></li><li><a href="#array">배열 타입 추론</a></li><li><a href="#return">리턴 타입 추론</a></li><li><a href="#union">유니온 타입과 타입 가드</a></li></ol><hr><h3 id="1-타입추론"><a href="#1-타입추론" class="headerlink" title=" 1. 타입추론"></a><a name="inference"></a> 1. 타입추론</h3><ul><li>기본적으로 타입을 명시적으로 쓰지 않을 때 추론하는 방법에 대한 규칙<ul><li>명시적으로 쓰는 것은 타입 추론이 아니라 <code>코드를 읽기 좋게 하는 지름길</code></li></ul></li><li>let 은 기본적으로 우리가 아는 기본 자료형으로 추론</li><li>const 는 <code>리터럴 타입</code>으로 추론<ul><li>오브젝트 타입을 타입을 쓰지 않으면, 프로퍼티는 let 처럼 추론<ul><li>const person = {name: ‘Mark’, age: 35}; 면</li><li>person =&gt; {name: string; age: number;} 로 추론</li></ul></li></ul></li><li>대부분은 추론이 쉽다.<ul><li>단순 변수</li><li>structuring, destructuring</li></ul></li><li>array, 함수의 리턴에서는 원하는데로 얻기가 힘들다.</li></ul><hr><h3 id="2-배열-타입-추론"><a href="#2-배열-타입-추론" class="headerlink" title=" 2. 배열 타입 추론"></a><a name="array"></a> 2. 배열 타입 추론</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="literal">false</span>]; <span class="comment">// 타입이 다를 경우 union타입으로 추론된다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123; </span><br><span class="line">    dog: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    cat: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array4 = [<span class="keyword">new</span> Dog(), <span class="keyword">new</span> Cat()]</span><br></pre></td></tr></table></figure><hr><h3 id="3-리턴-타입-추론"><a href="#3-리턴-타입-추론" class="headerlink" title=" 3. 리턴 타입 추론"></a><a name="return"></a> 3. 리턴 타입 추론</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">message: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">'world'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'world'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리터럴타입의 ‘world’이거나 0이 나온다.</p><hr><h3 id="4-유니온-타입과-타입-가드"><a href="#4-유니온-타입과-타입-가드" class="headerlink" title=" 4. 유니온 타입과 타입 가드"></a><a name="union"></a> 4. 유니온 타입과 타입 가드</h3><h4 id="타입가드-Type-guard"><a href="#타입가드-Type-guard" class="headerlink" title="타입가드 Type guard"></a><code>타입가드</code> Type guard</h4><p>어떤 Scope에서 타입을 보증하는 런타임 체크를 수행하는 몇 가지 표현식이다. 타입 가드를 정의하기 위해서, 리턴 타입이 <code>Type predicate</code>인 함수를 정의 할 필요가 있다.</p><h4 id="Type-predicate"><a href="#Type-predicate" class="headerlink" title="Type predicate"></a><code>Type predicate</code></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterName is Type</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Car &#123;</span><br><span class="line">    brand: <span class="built_in">string</span>;</span><br><span class="line">    wheel: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPerson</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.name !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">arg: Person | Car</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPerson(arg)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.name);</span><br><span class="line">        <span class="comment">// console.log(arg.brand);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(arg.name);</span></span><br><span class="line">        <span class="built_in">console</span>.log(arg.brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/" target="_blank" rel="noopener">https://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>10/ Decorator</title>
    <link href="http://feel5ny.github.io/2017/11/26/Typescript_11/"/>
    <id>http://feel5ny.github.io/2017/11/26/Typescript_11/</id>
    <published>2017-11-26T12:11:09.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-15" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong><br>아직 잘 이해가 안간다. &#128565;</p><ol><li><a href="#decorator">Decorator 종류</a><ol><li><a href="#ready">Decorator 코드 작성 준비</a></li></ol></li><li>Decorator<ol><li>Class Decorator<ol><li><a href="#basic">Class Decorator Basic</a></li><li><a href="#advanced">Class Decorator Advanced</a></li></ol></li><li><a href="#method">Method Decorator</a></li><li><a href="#property">Property Decorator</a></li><li><a href="#prameter">Prameter Decorator</a></li></ol></li></ol><hr><h3 id="1-Decorator-종류"><a href="#1-Decorator-종류" class="headerlink" title=" 1. Decorator 종류"></a><a name="decorator"></a> 1. Decorator 종류</h3><ul><li>Class Decorator</li><li>Method Decorator</li><li>Property Decorator</li><li>Parameter Decorator<blockquote><p>각자 Decorator의 시그니처가 다르다.</p></blockquote></li></ul><p>Decorator?</p><ul><li>함수 표현식에 해당한다.</li><li><code>@</code>와 같이 써서 표현식 뒤에 오는 대상에 더욱 기능적으로 추가하거나 하는 일들을 할 수 있다.</li><li>함수를 선언한 뒤 <code>@</code>키워드를 이용해 선언된 함수를 Decorator로 사용할 수 있다. </li></ul><hr><h4 id="1-1-Decorator-코드-작성-준비"><a href="#1-1-Decorator-코드-작성-준비" class="headerlink" title=" 1-1. Decorator 코드 작성 준비"></a><a name="ready"></a> 1-1. Decorator 코드 작성 준비</h4><p><code>yarn add typescript -D</code>여기서 <code>D</code>는 <code>dev</code>와 같은 명령어다.</p><hr><h3 id="2-Decorator"><a href="#2-Decorator" class="headerlink" title="2. Decorator"></a>2. Decorator</h3><h3 id="2-1-Class-Decorator"><a href="#2-1-Class-Decorator" class="headerlink" title="2-1. Class Decorator"></a>2-1. Class Decorator</h3><h4 id="2-1-1-Class-Decorator-Basic"><a href="#2-1-1-Class-Decorator-Basic" class="headerlink" title=" 2-1-1. Class Decorator Basic"></a><a name="basic"></a> 2-1-1. Class Decorator Basic</h4><p>여기서 helloFactory 는 팩토리 패턴<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">constructorFn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(constructorFn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloFactory</span>(<span class="params">show: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (show) &#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @hello</span></span><br><span class="line"><span class="meta">@helloFactory</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'new Person()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-1-2-Class-Decorator-Advanced"><a href="#2-1-2-Class-Decorator-Advanced" class="headerlink" title=" 2-1-2. Class Decorator Advanced"></a><a name="advanced"></a> 2-1-2. Class Decorator Advanced</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHello</span>(<span class="params">constructorFn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    constructorFn.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addHello</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'new Person()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">(&lt;<span class="built_in">any</span>&gt;person).hello();</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-Method-Decorator"><a href="#2-2-Method-Decorator" class="headerlink" title=" 2-2. Method Decorator"></a><a name="method"></a> 2-2. Method Decorator</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">editable</span>(<span class="params">canBeEdit: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, propName: <span class="built_in">string</span>, description: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(canBeEdit);</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(propName);</span><br><span class="line">        <span class="built_in">console</span>.log(description);</span><br><span class="line">        description.writable = canBeEdit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'new Person()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@editable</span>(<span class="literal">true</span>)</span><br><span class="line">    hello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.hello();</span><br><span class="line">person.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">person.hello();</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-Property-Decorator"><a href="#2-3-Property-Decorator" class="headerlink" title=" 2-3. Property Decorator"></a><a name="property"></a> 2-3. Property Decorator</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writable</span>(<span class="params">canBeWrite: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, propName: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(canBeWrite);</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(propName);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            writable: canBeWrite</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="meta">@writable</span>(<span class="literal">false</span>)</span><br><span class="line">    name: <span class="built_in">string</span> = <span class="string">'Mark'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'new Person()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-4-Prameter-Decorator"><a href="#2-4-Prameter-Decorator" class="headerlink" title=" 2-4. Prameter Decorator"></a><a name="prameter"></a> 2-4. Prameter Decorator</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">target: <span class="built_in">any</span>, methodName: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(methodName);</span><br><span class="line">    <span class="built_in">console</span>.log(paramIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, @printInfo age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hello(<span class="meta">@printInfo</span> message: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Person &#123; hello: [Function] &#125;</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">[Function: Person]</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/es6-class" target="_blank" rel="noopener">http://poiemaweb.com/es6-class</a></li><li><a href="https://javarouka.github.io/blog/2016/09/30/decorator-exploring/" target="_blank" rel="noopener">https://javarouka.github.io/blog/2016/09/30/decorator-exploring/</a></li><li><a href="http://blog-kr.zoyi.co/channel-frontend-decorator/" target="_blank" rel="noopener">http://blog-kr.zoyi.co/channel-frontend-decorator/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>9/ itertor</title>
    <link href="http://feel5ny.github.io/2017/11/25/Typescript_10/"/>
    <id>http://feel5ny.github.io/2017/11/25/Typescript_10/</id>
    <published>2017-11-25T11:13:22.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-15" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong><br>아직 잘 이해가 안간다. &#128565;</p><ol><li><a href="#forOf">for…of</a></li><li><a href="#forIn">for..in</a></li><li><a href="#symbol">Symbol.iterator</a></li><li><a href="#Iterable">CustomIterable</a></li></ol><hr><h3 id="1-for…of"><a href="#1-for…of" class="headerlink" title=" 1. for…of"></a><a name="forOf"></a> 1. for…of</h3><ul><li>es3<br><code>for(var i = 0; i&lt;array.length; i++)</code></li><li>es5<br><code>array.forEach</code> : return으로 순회를 탈출할 수 없다.</li><li><p>es6<br><code>for..of</code><br><code>for(const item of array)</code><br>원칙적으로는 배열에서만 사용이 가능하다. </p></li><li><p>for-of 루프는 이터러블 객체를 순회한다. for-of 루프는 이터레이터의 next() 메소드를 호출하고 next() 메소드가 반환하는 객체의 done 프로퍼티가 true가 될 때까지 루핑한다.</p></li></ul><hr><h3 id="2-for-in"><a href="#2-for-in" class="headerlink" title=" 2. for..in"></a><a name="forIn"></a> 2. for..in</h3><p>일반적일때는 사용하지 않는 것으로. (엔진에 따라 다르다.)</p><ul><li>배열을 순회할 때는 사용하지 않을 것<ul><li>index 가 number 가 아니라 string 으로 나온다.</li><li>배열의 프로퍼티를 순회할 수도 있다.</li><li>prototype 체인의 프로퍼티를 순회할 수도 있다.</li><li>루프가 무작위로 순회할 수도 있다.</li><li>for..of 를 쓸 것</li></ul></li><li>객체를 순회할 때<ul><li><code>for (const prop of Object.keys(obj))</code> 도 사용할 수 있다.</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'first'</span>, <span class="string">'second'</span>];</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열에 for..of 이용</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item of array) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + <span class="string">', '</span> + item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열에 for..in 이용</span></span><br><span class="line"><span class="comment">// item 이 string 타입의 숫자</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + <span class="string">', '</span> + item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체에 for..of 이용 =&gt; 오류</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (const item of obj) &#123;</span></span><br><span class="line"><span class="comment">    console.log(typeof item + ', ' + item);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체에 for..in 이용</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + <span class="string">', '</span> + item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체의 keys 들에 for..of 이용</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item of <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + <span class="string">', '</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>target 이 es3 인데도 forEach 는 트랜스파일이 되지 않았음.<br><a href="https://github.com/Microsoft/TypeScript/issues/2410" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/issues/2410</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'first'</span>, <span class="string">'second'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line">array.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="3-Symbol-iterator"><a href="#3-Symbol-iterator" class="headerlink" title=" 3. Symbol.iterator"></a><a name="symbol"></a> 3. Symbol.iterator</h3><h4 id="이터러블-iterable"><a href="#이터러블-iterable" class="headerlink" title="이터러블(iterable)"></a><code>이터러블(iterable)</code></h4><p>iterate = 반복하다<br>이터러블은 <strong>순회 가능한 자료 구조</strong>이다. <code>Symbol.iterator</code>를 프로퍼티 key로 사용한 메소드를 구현하는 것에 의해 순회 가능한 자료 구조인 이터러블이 된다.</p><h4 id="이터레이터"><a href="#이터레이터" class="headerlink" title="이터레이터"></a><code>이터레이터</code></h4><p><code>Symbol.iterator</code>를 프로퍼티 key로 사용한 메소드는 이터레이터로 반환한다. 이터레이터는 순회 가능한 자료 구조인 이터러블의 요소를 탐색하기 위한 포인터로서 <code>next()</code> 메소드를 갖는 객체이다. next() 메소드는 value, done 프로퍼티를 갖는 객체를 반환하며 이 메소드를 통해 이터러블 객체를 순회할 수 있다.</p><p>ES6에서 제공하는 built-in iterable은 아래와 같다.</p><ul><li>Array <code>Array.prototype[Symbol.iterator]</code></li><li>String <code>String.prototype[Symbol.iterator]</code></li><li>Map <code>Map.prototype[Symbol.iterator]</code></li><li>Set <code>Set.prototype[Symbol.iterator]</code></li><li>DOM data structures <code>NodeList.prototype[Symbol.iterator]</code> <code>HTMLCollection.prototype[Symbol.iterator]</code></li></ul><ul><li>프로퍼티이며, 함수가 구현되어있으면, iterable 이라고 한다.</li><li>Array, Map, Set, String, Int32Array, Uint32Array, etc. 에는 내장된 구현체가 있으므로 이터러블 하다.</li><li>그냥 객체는 이터러블하지 않다.</li><li>이터레이터를 통해 이터러블한 객체의 Symbol.iterator 함수를 호출한다.</li><li>target : es3 or es5<ul><li>Array 에만 for..of 사용 가능</li><li>일반 객체에 사용하면 오류</li></ul></li><li>target : es6<ul><li>Symbol.iterator 함수를 구현하면 어떤 객체에도 for..of 사용 가능</li></ul></li></ul><hr><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.es6.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> IteratorResult&lt;T&gt; &#123;</span><br><span class="line">    done: <span class="built_in">boolean</span>;</span><br><span class="line">    value: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Iterator&lt;T&gt; &#123;</span><br><span class="line">    next(value?: <span class="built_in">any</span>): IteratorResult&lt;T&gt;; <span class="comment">// next가 필수로 있어야한다.</span></span><br><span class="line">    <span class="keyword">return</span>?(value?: <span class="built_in">any</span>): IteratorResult&lt;T&gt;;</span><br><span class="line">    <span class="keyword">throw</span>?(e?: <span class="built_in">any</span>): IteratorResult&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Iterable&lt;T&gt; &#123;</span><br><span class="line">    [Symbol.iterator](): Iterator&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IterableIterator&lt;T&gt; <span class="keyword">extends</span> Iterator&lt;T&gt; &#123;</span><br><span class="line">    [Symbol.iterator](): IterableIterator&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-CustomIterable"><a href="#5-CustomIterable" class="headerlink" title=" 5. CustomIterable"></a><a name="Iterable"></a> 5. CustomIterable</h3><p>객체는 이터러블이 아니다. 하지만 이터레이션 프로토콜을 준수하여 이터러블 객체를 만들수 있다.</p><ul><li>Symbol.iterator를 key로 사용한 메소드는 next() 함수를 프로퍼티로 가지는 객체를 반환하여야 한다. 그리고 next() 함수는 done과 value 프로퍼티를 가지는 객체를 반환한다. for-of는 done 프로퍼티가 true가 될 때까지 반복하며 done 프로퍼티가 true가 되면 반복을 중지한다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CustomIterable <span class="keyword">implements</span> Iterable&lt;<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> _array: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'first'</span>, <span class="string">'second'</span>];</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: <span class="keyword">this</span>._array[nextIndex++],</span><br><span class="line">                    done: nextIndex &gt; <span class="keyword">this</span>._array.length</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cIterable = <span class="keyword">new</span> CustomIterable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item of cIterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/es6-iteration-for-of" target="_blank" rel="noopener">http://poiemaweb.com/es6-iteration-for-of</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>8/ Generic</title>
    <link href="http://feel5ny.github.io/2017/11/24/Typescript_09/"/>
    <id>http://feel5ny.github.io/2017/11/24/Typescript_09/</id>
    <published>2017-11-24T06:42:10.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-15" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong><br>제네릭은 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다. 정적 타입 언어에서도 이렇게 특정 타입을 위해 만들어진 함수 혹은 클래스를 보다 범용적으로 재사용하기 위한 요구가 있기 때문에 제네릭이라는 프로그래밍 기법이 생긴 게 아닐까한다. </p><ol><li><a href="#generic">~any~ =&gt; generic</a></li><li><a href="#basic">basic generic</a></li><li><a href="#array">Generic Array</a></li><li><a href="#types">Generic Types</a></li><li><a href="#class">Generic Class</a></li><li><a href="#extends">Generic with extends</a></li><li><a href="#multiple">Generic with multiple types</a></li><li><a href="#lookupSystem">type lookup system</a></li></ol><hr><h3 id="1-any-gt-generic"><a href="#1-any-gt-generic" class="headerlink" title=" 1. ~any~ =&gt; generic"></a><a name="generic"></a> 1. ~any~ =&gt; generic</h3><p>any의 사용을 지양하고자 타입을 인자로 넘긴다.</p><ul><li>탬플릿을 만드는 개념. 인자값과 출력값의 타입을 같게 탬플릿을 만들어준다.</li><li>제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 <code>하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다.</code> 한번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다.</li><li><code>T</code>는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 타입 파라미터(Type parameter)라 한다. T는 Type의 약자로 반드시 T를 사용하여야 하는 것은 아니다.</li><li>함수에도 제네릭을 사용할 수 있다. 제네릭을 사용하면 하나의 타입만이 아닌 다양한 타입의 매개변수와 리턴값을 사용할 수 있다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloGeneric</span>&lt;<span class="title">T</span>&gt;(<span class="params">message: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloString</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloNumber</span>(<span class="params">message: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 더 많은 반복된 함수들 ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">message: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloGeneric</span>&lt;<span class="title">T</span>&gt;(<span class="params">message: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello(<span class="string">'Mark'</span>).length);</span><br><span class="line"><span class="built_in">console</span>.log(hello(<span class="number">35</span>).length); <span class="comment">// hello 의 리턴이 any 이기 때문에 타입 헬퍼가 제대로 되지 않음</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(helloGeneric(<span class="number">35</span>).toString()); <span class="comment">// console.log(helloGeneric&lt;number&gt;(35).toString());</span></span><br><span class="line"><span class="comment">// helloGeneric 을 사용하면 정상적으로 사용가능</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-basic-generic"><a href="#2-basic-generic" class="headerlink" title=" 2. basic generic"></a><a name="basic"></a> 2. basic generic</h3><ol><li>Generic 타입을 쓰지 않으면, T 로 추론</li><li>Generic 타입을 쓰면, T 를 확인</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloGeneric</span>&lt;<span class="title">T</span>&gt;(<span class="params">message: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">message:  T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello'</span>));</span><br><span class="line"><span class="keyword">let</span> age = hello(<span class="number">35</span>);</span><br><span class="line">hello&lt;<span class="built_in">number</span>&gt;(<span class="string">'35'</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="3-Generic-Array"><a href="#3-Generic-Array" class="headerlink" title=" 3. Generic Array"></a><a name="array"></a> 3. Generic Array</h3><p>hello 함수의 제네릭 타입을 [] 를 이용하여 배열로 사용할 수 있음</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">messages: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> messages[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello&lt;<span class="built_in">string</span>&gt;([<span class="string">'Hello'</span>, <span class="string">'World'</span>]));</span><br></pre></td></tr></table></figure><hr><h3 id="4-Generic-Type"><a href="#4-Generic-Type" class="headerlink" title=" 4. Generic Type"></a><a name="types"></a> 4. Generic Type</h3><p>구현체에 return T 를 설정하지 않아도, return false 시 오류가 나지 않는다?</p><ul><li>때에 따라서 적합하지 않을 수 있다. </li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloGeneric = &lt;T&gt;<span class="function">(<span class="params">message: T</span>) =&gt;</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello: HelloGeneric = &lt;T&gt;(message: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello'</span>).length);</span><br></pre></td></tr></table></figure><hr><h3 id="5-Generic-Class"><a href="#5-Generic-Class" class="headerlink" title=" 5. Generic Class"></a><a name="class"></a> 5. Generic Class</h3><p>명시적으로 제네릭 타입을 설정하면 오류 </p><ul><li>function에서 generic을 사용할 때의 오류와 같다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> _name: T;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'Mark'</span>);</span><br><span class="line"><span class="comment">// new Person&lt;string&gt;(35);</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-Generic-with-extends"><a href="#6-Generic-with-extends" class="headerlink" title=" 6. Generic with extends"></a><a name="extends"></a> 6. Generic with extends</h3><p>T 가 string 또는 number 를 상속받기 때문에 boolean 은 안된다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt; &#123; <span class="comment">// union type</span></span><br><span class="line">    <span class="keyword">private</span> _name: T;</span><br><span class="line">    <span class="keyword">private</span> _age: T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'Mark'</span>);</span><br><span class="line"><span class="keyword">new</span> Person(<span class="number">35</span>);</span><br><span class="line"><span class="comment">// new Person(true);</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-Generic-with-multiple-types"><a href="#7-Generic-with-multiple-types" class="headerlink" title=" 7. Generic with multiple types"></a><a name="multiple"></a> 7. Generic with multiple types</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> _name: T;</span><br><span class="line">    <span class="keyword">private</span> _age: K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: T, age: K</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'Mark'</span>, <span class="number">35</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="8-type-lookup-system"><a href="#8-type-lookup-system" class="headerlink" title=" 8. type lookup system"></a><a name="lookupSystem"></a> 8. type lookup system</h3><p>keyof 키워드를 알아야한다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test = keyof Person;</span><br><span class="line"><span class="comment">// 리터럴 타입의 유니온 타입이 나온다. "name" | "age"</span></span><br></pre></td></tr></table></figure></p><p>객체와 key값을 인자로 받아서 perperty의 타입값을 알아내는 함수를 만들었다고 치자.<br>함수에서 컴파일 타입을 검증할 수 있는 시스템이 필요하다. =&gt; type lookup system</p><ul><li><code>getProperty</code>: Generic과 type alias를 결합하여 사용하여 type을 찾아낼 수 있는 시스템을 만든다.</li><li><code>setProperty</code>: Generic과 type alias를 결합하여 사용하여 type을 찾아내고, 타입을 다시 재정의 하는 함수</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K, value: T[K]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getProperty(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// console.log(getProperty(person, fullname));</span></span><br><span class="line">setProperty(person, <span class="string">'name'</span>, <span class="string">'Anna'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getProperty(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// setProperty(person, 'name', 24);</span></span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/typescript-generic" target="_blank" rel="noopener">http://poiemaweb.com/typescript-generic</a></li><li><a href="https://www.youtube.com/watch?v=3-nJyzJATq8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=3-nJyzJATq8</a></li><li><a href="https://hyunseob.github.io/2017/01/14/typescript-generic/" target="_blank" rel="noopener">https://hyunseob.github.io/2017/01/14/typescript-generic/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>08 days/ 협업규칙 정하기, 초기 셋팅, 퍼블리싱</title>
    <link href="http://feel5ny.github.io/2017/11/24/dada_02week/"/>
    <id>http://feel5ny.github.io/2017/11/24/dada_02week/</id>
    <published>2017-11-24T01:10:04.000Z</published>
    <updated>2017-12-14T13:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Daily scrum(김나영) <a href="https://docs.google.com/spreadsheets/d/e/2PACX-1vR57PrRMvXjFa1sHCtLX-ifjMt8VEoiPuzKa0ErH-h787p4MqxssYJKt7QaYCReGVIaJEu_HgpMBGRC/pubhtml" target="_blank" rel="noopener">+</a><br>Github <a href="https://github.com/huusz/Da-Da" target="_blank" rel="noopener">+</a></p><hr><p>목차<br>(2017.10.01 ~ 2017.10.09)</p><ol><li><a href="#managing">프로젝트 매니징을 위한 셋팅</a><ul><li>깃헙 셋팅</li><li>깃헙 프로젝트 탭으로 매니징</li><li>테스크 관련 규칙 정하기</li></ul></li><li><a href="#init">프로젝트 초기 셋팅</a><ul><li>의존모듈 셋팅</li><li>css 프레임워크 선택</li><li>css styling 방법</li></ul></li><li><a href="#publishing">퍼블리싱 &#128153;</a> (feat.추석)</li></ol><hr><h2 id="1-프로젝트-매니징을-위한-셋팅"><a href="#1-프로젝트-매니징을-위한-셋팅" class="headerlink" title=" 1. 프로젝트 매니징을 위한 셋팅"></a><a name="managing"></a> 1. 프로젝트 매니징을 위한 셋팅</h2><h3 id="깃헙-셋팅"><a href="#깃헙-셋팅" class="headerlink" title="깃헙 셋팅"></a>깃헙 셋팅</h3><ul><li>깃헙 레포에는 백엔드, 프론트엔드 폴더를 초반에 나누어서 진행하였다.<ul><li><span style="color:blue"><strong>troubleShoot</strong></span><br>위험 상황을 피하는 차원에서 백엔드와 프론트엔드는 레포를 따로 생성하는게 좋다고 하셨음.</li></ul></li><li>처음 시작 시에는 master브랜치에서 브랜치를 각자 생성하여 진행, 풀리케스트 없이 바로 바로 merge하며 진행. (지금 생각하니 헉;)</li><li>퍼블리싱 이후에는 master는 절대적으로 배포용으로만 사용하기로 정함. (브랜치 rock 설정)</li><li>develop-backend, develop-frontend 브랜치를 main브랜치로 정함. </li><li>퍼블리싱 단계에서는 <code>각자 이름-페이지이름</code>으로 브랜치를 생성하기로 정하였다.</li></ul><p><img src="/images/post_img/06/01.png"></p><blockquote><p>퍼블리싱 끝나고 merge 후</p></blockquote><ul><li><span style="color:blue"><strong>troubleShoot</strong></span><br>위의 이미지는 1주일만에 merge한 상황. merge는 자주자주 하는게 좋다.</li></ul><hr><h3 id="깃헙-프로젝트-탭"><a href="#깃헙-프로젝트-탭" class="headerlink" title="깃헙 프로젝트 탭"></a>깃헙 프로젝트 탭</h3><p><img src="/images/post_img/06/02.png"><br>프로젝트 탭은 총 5가지로 구성하였다.</p><ol><li>규칙</li><li>할 일</li><li>진행 중인 작업</li><li>마친 작업</li></ol><p>규칙의 경우 예전에 참여했던 프로젝트의 규칙을 light하게 가져왔다.<br><img src="/images/post_img/06/03.png"></p><p>규칙은 아래와 같이 가볍게 정했다!</p><ol><li>급한 이슈의 경우 라벨 붙이기</li><li>카드당 assign 필수</li><li>작성 규칙<ul><li>[페이지명] 작업 설명<ul><li>EX. [Diary] 식단 추가 작업</li></ul></li><li>페이지가 구분 되지 않는 경우는 [Global]로 한다.<ul><li>EX. [Global] 페이지 라우팅</li></ul></li></ul></li><li>카드 하나당 1개의 작업만 등록한다.</li></ol><ul><li>테스크의 경우 매주 진행했던 오프라인 회의 때 코드리뷰 이후 할일 카드를 같이 생성하기로 정했다.</li></ul><hr><p><span style="color:blue"><strong>Tip</strong></span></p><ul><li>깃헙 프로젝트에서 카드를 이슈로 만들면, 이슈탭에도 자동 등록 가능하다.</li><li>해당 이슈의 커밋이 진행 될 경우, 커밋 메세지에 이슈 number와 명령어를 추가하면 이슈가 자동으로 close나 등등의 작업이 자동화되면서, 이슈에도 log가 남는다.<ul><li>Close: <code>close</code>, <code>closes</code>, <code>closed</code>, <code>fix</code>, <code>fixes</code>, <code>fixed</code>, <code>resolve</code>, <code>resolves</code>, <code>resolved</code></li><li>Reopen: <code>reopen</code>, <code>reopens</code>, <code>reopened</code></li></ul></li></ul><p><span style="color:blue"><strong>Issue</strong></span></p><ul><li>slack notation을 걸어놓지 않아서 이메일로 확인해야했다.</li><li>카드를 close로 옮겨야하는 번거로움이 있었다.<br>(지라같은 툴은 옮기지 이슈가 닫히면 자동으로 옮기짐)</li></ul><hr><hr><h2 id="2-프로젝트-초기-셋팅"><a href="#2-프로젝트-초기-셋팅" class="headerlink" title=" 2. 프로젝트 초기 셋팅"></a><a name="init"></a> 2. 프로젝트 초기 셋팅</h2><h3 id="1-create-react-app"><a href="#1-create-react-app" class="headerlink" title="1. create-react-app"></a>1. create-react-app</h3><hr><h3 id="2-폴더-구조-셋팅"><a href="#2-폴더-구조-셋팅" class="headerlink" title="2. 폴더 구조 셋팅"></a>2. 폴더 구조 셋팅</h3><p>  <code>components/</code> global하게 사용되는 container 컴포넌트<br>  <code>pages/</code> container component와 presentational component를 함께 두었다.</p><hr><h3 id="3-CSS-프레임워크-선택"><a href="#3-CSS-프레임워크-선택" class="headerlink" title="3. CSS 프레임워크 선택 +"></a>3. CSS 프레임워크 선택 <a href="https://www.vobour.com/book/view/LCETueEN7i3MjvEcz" target="_blank" rel="noopener">+</a></h3><p>  <strong>Semantic-UI-React</strong><br>  서비스 컨셉과 유사한 디자인을 갖고 있고 여러 종류의 컴포넌트들이 있어서 사용.</p><hr><h3 id="4-css-styling-방법"><a href="#4-css-styling-방법" class="headerlink" title="4. css styling 방법"></a>4. css styling 방법</h3><h4 id="4-1-첫번째-이슈-디자인-커스텀"><a href="#4-1-첫번째-이슈-디자인-커스텀" class="headerlink" title="4-1. 첫번째 이슈_디자인 커스텀"></a>4-1. 첫번째 이슈_디자인 커스텀</h4><ul><li>시맨틱 프레임워크를 사용해도, 디자인 시안이 있었기 때문에 약간의 커스텀이 필요했다. </li><li>이미 셋팅되어있는 컴포넌트를 커스텀을 해야했기 때문에 css로는 적용이 불가능했다. 인라인으로 적용해야 덮어씌어졌음.</li><li><code>!important</code>로 되어있는 css를 제외하고는 inline 형식으로 작성하기로 결정</li></ul><h4 id="4-2-두번째-이슈-스타일드-컴포넌트-인라인-스타일"><a href="#4-2-두번째-이슈-스타일드-컴포넌트-인라인-스타일" class="headerlink" title="4-2. 두번째 이슈_스타일드 컴포넌트? 인라인 스타일"></a>4-2. 두번째 이슈_스타일드 컴포넌트? 인라인 스타일</h4><p>핫한 스타일드 컴포넌트를 쓸까 인라인 스타일로 작업을 할까 고민했었다. 지금 생각해보면 과감하게 쓸껄…이라고 생각이 든다. 러닝커브가 있을 듯 하여 <code>인라인 스타일</code>로 작업하게 되었다. </p><p><span style="color:blue"><strong>Issue</strong></span><br>인라인스타일로 작업하다보니 <code>:hover</code>, <code>:before</code>, <code>:after</code>과 같은 셀렉터를 사용하지 못했고, css를 부분 부분 섞어 쓰게 되었다. 스타일드 컴포넌트는 이를 해결해주는데.. 그냥 쓸껄!</p><p><img src="/images/post_img/06/04.png" width="150px"></p><hr><h3 id="5-의존모듈-셋팅"><a href="#5-의존모듈-셋팅" class="headerlink" title="5. 의존모듈 셋팅"></a>5. 의존모듈 셋팅</h3><p>디자인 시안을 보면, 필요한 서드파티는 </p><ol><li>일기탭의 에디터</li><li>그래프 차트</li></ol><hr><h4 id="5-1-일기탭-에디터"><a href="#5-1-일기탭-에디터" class="headerlink" title="5-1. 일기탭 에디터"></a>5-1. 일기탭 에디터</h4><ul><li>개인적으로 <a href="https://summernote.org/" target="_blank" rel="noopener">summernote</a>를 좋아하는데, 리액트 친화적이지 않아서 포기</li><li>리액트 친화적인 모듈을 찾다가 페이스북에서 만든 <a href="https://draftjs.org/" target="_blank" rel="noopener">draft.js</a>를 사용하기로 결정.</li><li>나중에 설명하겠지만, 에디터는 post로 보내기 전에 html 형식으로 export했어야 했고, 이 부분에서 많은 난관에 봉착했었다.<ul><li><code>draft-js-export-html</code>로 해결</li></ul></li></ul><hr><h4 id="5-2-그래프-차트"><a href="#5-2-그래프-차트" class="headerlink" title="5-2. 그래프 차트"></a>5-2. 그래프 차트</h4><ul><li>react d3를 사용하려고 했으나, 디자인 시안과 비슷하지 않다는 점, 커스텀이 어려운 점이 있었다.</li><li>두번째 찾은 차트는 Uber에서 나온 <a href="https://uber.github.io/react-vis/" target="_blank" rel="noopener"><code>react-vis</code></a> 리액트 친화적.</li><li>세번째 찾은 차트는 <a href="https://github.com/recharts/recharts" target="_blank" rel="noopener"><strong>rechart</strong></a><ul><li>react와 d3로 만들어졌고, UI가 서비스 컨셉과 잘 어울려서 선택하게 됨.</li></ul></li><li>이또한 나중에 설명하겠지만, 그래프에 데이터를 넣는 구조와 서버에서 날라오는 데이터 구조가 많이 달랐기 때문에 프론트에서 다시 셋팅하는 작업이 필요했음.</li></ul><hr><hr><h2 id="3-퍼블리싱-128153"><a href="#3-퍼블리싱-128153" class="headerlink" title=" 3. 퍼블리싱 &#128153;"></a><a name="publishing"></a> 3. 퍼블리싱 &#128153;</h2><p>프론트엔드는 2명이었다. 각자 하고싶은 페이지를 맡아서 진행했다. 퍼블리싱은 항상 즐겁다! &#128582; 퍼블리싱하면서 발생한 이슈만 정리하겠다.</p><h3 id="간단-라우팅-작업"><a href="#간단-라우팅-작업" class="headerlink" title="+ 간단 라우팅 작업"></a>+ 간단 라우팅 작업</h3><ul><li><code>react-router-dom</code> 의존모듈</li><li>주 사용 API<ul><li>BrowserRouter</li><li>Route</li><li>Link</li><li>Switch (로그인 이후 바꾸주는 역할, 404페이지 라우팅)</li><li>withRouter (중첩 라우팅할 때 사용)</li></ul></li><li><p><code>App.js</code>에 셋팅</p></li><li><p>path</p><ul><li><code>/</code></li><li><code>/diary</code><ul><li>tab용 router파일 따로 셋팅</li><li><code>/diary/food</code></li><li><code>/diary/fitness</code></li><li><code>/diary/review</code></li></ul></li><li><code>/report</code></li><li><code>/weight</code></li><li><code>/search/:sc</code></li><li><code>/recipe/:id</code></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;Daily scrum(김나영) &lt;a href=&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vR57PrRMvXjFa1sHCtLX-ifjMt8VEoiPuzKa0ErH-h787p4MqxssYJKt7Q
      
    
    </summary>
    
      <category term="Project &amp;#127939;" scheme="http://feel5ny.github.io/categories/Project-127939/"/>
    
      <category term="DA, DA" scheme="http://feel5ny.github.io/categories/Project-127939/DA-DA/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
      <category term="publishing" scheme="http://feel5ny.github.io/tags/publishing/"/>
    
  </entry>
  
  <entry>
    <title>7-1/ class 연습</title>
    <link href="http://feel5ny.github.io/2017/11/23/Typescript_08-1/"/>
    <id>http://feel5ny.github.io/2017/11/23/Typescript_08-1/</id>
    <published>2017-11-23T03:11:23.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="연습문제-1"><a href="#연습문제-1" class="headerlink" title="연습문제 1"></a>연습문제 1</h3><p>아래 자바스크립트를 타입스크립트로 바꾸시오<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.honk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"부우우웅"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.accelerate = <span class="function"><span class="keyword">function</span>(<span class="params">speed</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = <span class="keyword">this</span>.speed + speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">"BENZ"</span>);</span><br><span class="line">car.honk();</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br><span class="line">car.accelerate(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br></pre></td></tr></table></figure></p><p>1차<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> speed: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> honk(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'부우우웅'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> accelerate(speed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = <span class="keyword">this</span>.speed + speed;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">"BENZ"</span>);</span><br><span class="line">car.honk();</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br><span class="line">car.accelerate(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br></pre></td></tr></table></figure></p><p>2차<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> _speed: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> honk(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'부우우웅'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> accelerate(speed) &#123;</span><br><span class="line">        <span class="keyword">this</span>._speed = <span class="keyword">this</span>.speed + speed;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> speed(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">"BENZ"</span>);</span><br><span class="line">car.honk();</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br><span class="line">car.accelerate(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br></pre></td></tr></table></figure></p><p>3차<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ICar &#123;</span><br><span class="line">    honk(): <span class="built_in">void</span>;</span><br><span class="line">    accelerate(speed: <span class="built_in">number</span>): <span class="built_in">void</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> _speed: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> honk(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'부우우웅'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> accelerate(speed) &#123;</span><br><span class="line">        <span class="keyword">this</span>._speed = <span class="keyword">this</span>._speed + speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> speed(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">"BENZ"</span>);</span><br><span class="line">car.honk();</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br><span class="line">car.accelerate(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car.speed);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;연습문제-1&quot;&gt;&lt;a href=&quot;#연습문제-1&quot; class=&quot;headerlink&quot; title=&quot;연습문제 1&quot;&gt;&lt;/a&gt;연습문제 1&lt;/h3&gt;&lt;p&gt;아래 자바스크립트를 타입스크립트로 바꾸시오&lt;br&gt;&lt;figure class=&quot;highlight ts
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>7/ class(2)</title>
    <link href="http://feel5ny.github.io/2017/11/22/Typescript_08/"/>
    <id>http://feel5ny.github.io/2017/11/22/Typescript_08/</id>
    <published>2017-11-22T01:32:11.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-14" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong><br>class에서 선언된 멤버변수와 멤버함수를 외부에서 접근이 가능하게 하는 방법, 재선언할 수 있도록 컨트롤하는 방법을 배웁니다. 생성자에도 private화하여 class 내부에서만 선언이 가능하도록 하며, 이는 singleTon 패턴을 정확하게 배치 가능할 수 있게 합니다. readonly 키워드를 붙여서 getter의 역할만 가능하도록 할 수 있습니다. </p><ol><li><a href="#getter_setter">class getter, setter</a></li><li><a href="#member">class 멤버변수</a></li><li><a href="#memberFunction">class 멤버함수</a></li><li><a href="#statcProperty">class private static property or method</a></li><li><a href="#abstract">Abstract Class</a></li><li><a href="#constructor">private constructor</a></li><li><a href="#singleTon">singleTon</a></li><li><a href="#readonly">readonly</a></li></ol><hr><h3 id="1-class-getter-setter"><a href="#1-class-getter-setter" class="headerlink" title=" 1. class getter, setter"></a><a name="getter_setter"></a> 1. class getter, setter</h3><p>get, set을 하는 중에 무언가를 해주기 위해서 사용한다. get과 set 사이에 추가적인 작업이 있을 때 사용한다.</p><ol><li>_ 를 변수명 앞에 붙이고, 내부에서만 사용한다.</li><li>getter를 함수처럼 설정하면, 프로퍼티처럼 꺼내쓸수있다.</li><li>마찬가지로 setter 를 함수처럼 설정하면, 추가 작업을 하고 셋팅할 수 있다.</li></ol><blockquote><p>강사님은 getter setter가 혼란을 줄 수 있는 경우가 있어서 사용하지 않고, 대신 메서드를 같은 역할을 하는 메서드를 만드는데 메서드의 이름을 getName, setName으로 짓는다고 하셨따.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="comment">// 작업</span></span><br><span class="line">        <span class="keyword">this</span>._name = <span class="string">`<span class="subst">$&#123;name&#125;</span> Lee`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person(<span class="string">'Mark'</span>, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line">person.name = <span class="string">'Woongjae'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a><code>getter</code></h4><p>getter는 어떤 멤버 변수에 접근할 때마다 멤버 변수의 값을 조작하는 행위가 필요할 때 사용한다. 사용 방법은 아래와 같다.</p><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a><code>setter</code></h4><p>setter는 어떤 멤버 변수에 값을 할당할 때마다 멤버 변수의 값을 조작하는 행위가 필요할 때 사용한다. 사용 방법은 아래와 같다.</p><hr><h3 id="2-class-멤버변수"><a href="#2-class-멤버변수" class="headerlink" title=" 2. class 멤버변수"></a><a name="member"></a> 2. class 멤버변수</h3><p>객체지향의 class와 거의 유사하다. static property와 static method가 있다.</p><ol><li>static 키워드를 붙힌 프로퍼티는 클래스.프로퍼티로 사용한다.</li><li>static 프로퍼티에 private, protected 를 붙히면 똑같이 동작한다.</li></ol><ul><li>public static은 외부에서 변경이 가능하다.</li><li>default는 public이다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CITY = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> lastName: <span class="built_in">string</span> = <span class="string">'Lee'</span>;</span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this._name&#125;</span> <span class="subst">$&#123;Person.lastName&#125;</span> in <span class="subst">$&#123;Person.CITY&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person(<span class="string">'Mark'</span>, <span class="number">35</span>);</span><br><span class="line">Person.CITY = <span class="string">'Seoul'</span>;</span><br><span class="line">person.print(); <span class="comment">// Mark Lee in Seoul.</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-class-멤버함수"><a href="#3-class-멤버함수" class="headerlink" title=" 3. class 멤버함수"></a><a name="memberFunction"></a> 3. class 멤버함수</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Talk(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'안녕하세요.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.Talk(); <span class="comment">// 안녕하세요.</span></span><br></pre></td></tr></table></figure><p>public static은 의미가 있다.<br>private static 메소드와 프로퍼티는 무슨 의미가 있나?<br>대부분 한 ts파일에 한 class를 사용하고, 모듈을 다른곳에서 쓰기위해서 export import를 쓴다. </p><h4 id="private-static"><a href="#private-static" class="headerlink" title="private static?"></a><code>private static</code>?</h4><ul><li>사용시 class의 private static과 ts파일 안의 제일 상단에 있는 const 변수와 어떤 차이가 있나? 라고 할때 애매하다.</li><li>private이라 애매한 것. </li></ul><hr><h3 id="4-class-private-static-property-or-method"><a href="#4-class-private-static-property-or-method" class="headerlink" title=" 4. class private static property or method"></a><a name="statcProperty"></a> 4. class private static property or method</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PROPERTY = <span class="string">'프라이빗 프로퍼티'</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> METHOD() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'프라이빗 메서드'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person.PROPERTY);</span><br><span class="line">        Person.METHOD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PROPERTY = <span class="string">'모듈 내 변수'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">METHOD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'모듈 내 함수'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(PROPERTY);</span><br><span class="line">        METHOD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-Abstract-Class-128566"><a href="#5-Abstract-Class-128566" class="headerlink" title=" 5. Abstract Class &#128566;"></a><a name="abstract"></a> 5. Abstract Class &#128566;</h3><ol><li>abstract 키워드가 사용된 클래스는 new 로 생성할 수 없다.</li><li>abstract 키워드가 사용된 클래스를 상속하면 abstract 키워드가 붙은 함수를 구현해야 한다.</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> APerson &#123;</span><br><span class="line">    <span class="keyword">protected</span> _name: <span class="built_in">string</span> = <span class="string">'Mark'</span>;</span><br><span class="line">    <span class="keyword">abstract</span> setName(name: <span class="built_in">string</span>): <span class="built_in">void</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> APerson &#123;</span><br><span class="line">    setName(name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const person = new APerson(); // (X)</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><hr><h3 id="6-private-constructor"><a href="#6-private-constructor" class="headerlink" title=" 6. private constructor"></a><a name="constructor"></a> 6. private constructor</h3><ol><li>생성자 함수 앞에 접근제어자인 private 을 붙일 수 있다.</li><li>외부에서 생성이 불가능하다.</li></ol><blockquote><p>내부에서 생성하는 방법을 써야하고, 그러다보니 싱글톤 패턴을 정확하게 배치해서 사용할 수 있게 되었다. </p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Preference &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const p: Preference = new Preference(); (X)</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-singleTon-128580"><a href="#7-singleTon-128580" class="headerlink" title=" 7. singleTon &#128580;"></a><a name="singleTon"></a> 7. singleTon &#128580;</h3><p>자바스크립트의 함수는 new로 생성자를 사용할 때마다 새로이 생성된 객체를 리턴합니다. 하지만 특수한 상황에서는 하나의 함수에서 생성되는 객체가 오직 한개만을 가져야 할 때가 있다. 그럴 경우 사용되는 디자인 패턴이 <code>Singleton Pattern</code></p><ul><li>싱글턴 패턴 : 객체리터럴이 싱글턴 패턴의 대표적.<ul><li>모듈패턴을 변형한 디자인 패턴<ul><li>처음 namespace를 만들 때 사용한다. </li><li>게임을 실행할 때 게임은 한번만 켜져야 하기 때문에 싱글턴이 적절.</li></ul></li></ul></li></ul><ol><li>private 생성자를 이용해서 내부에서만 인스턴스 생성이 가능하도록 함.</li><li>pubilc static 메서드를 통해 private static 인스턴스 레퍼런스를 획득한다.</li><li>Lazy Loading (Initialization) : 최초 실행시가 아니라, 사용시에 할당을 함</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Preference &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">        <span class="comment">// 유일 객체가 정의되지 않았다면 객체를 생성.</span></span><br><span class="line">        <span class="keyword">if</span> (Preference.instance === <span class="literal">null</span>) &#123;</span><br><span class="line">            Preference.instance = <span class="keyword">new</span> Preference();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Preference.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> instance: Preference = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: Preference = Preference.getInstance();</span><br></pre></td></tr></table></figure><hr><h3 id="8-readonly"><a href="#8-readonly" class="headerlink" title=" 8. readonly"></a><a name="readonly"></a> 8. readonly</h3><p>private인데 get, set중 get만 있는 상황과 같다. </p><ol><li><code>private readonly</code> 로 선언된 경우, 생성자에서는 할당이 가능하다.</li><li><code>private readonly</code> 로 선언된 경우, 생성자 이외에서는 할당이 불가능하다.</li><li><code>public readonly</code> 로 선언된 경우, 클래스 외부에서는 다른값을 할당할 수 없다.</li><li>마치 getter 만 있는 경우와 같다.</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> readonly _name: <span class="built_in">string</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> readonly age: <span class="built_in">number</span> = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> setName(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="comment">// this._name = name; (X)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: Person = <span class="keyword">new</span> Person(<span class="string">'Mark'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.age);</span><br><span class="line"><span class="comment">// p.age = 36; // (X)</span></span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/es6-class" target="_blank" rel="noopener">http://poiemaweb.com/es6-class</a></li><li><a href="http://blog.javarouka.me/2012/02/javascripts-pattern-1-singeton-patterrn.html" target="_blank" rel="noopener">http://blog.javarouka.me/2012/02/javascripts-pattern-1-singeton-patterrn.html</a></li><li><a href="http://karl27.tistory.com/10" target="_blank" rel="noopener">http://karl27.tistory.com/10</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>6/ class(1)</title>
    <link href="http://feel5ny.github.io/2017/11/21/Typescript_07/"/>
    <id>http://feel5ny.github.io/2017/11/21/Typescript_07/</id>
    <published>2017-11-21T01:32:11.000Z</published>
    <updated>2018-08-15T14:46:48.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-14" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong><br>타입스크립트에서 주로 사용되는 class의 기초에 대해서 배웁니다. es6에 도입된 <code>class</code>와, public, private, protected 키워드로 class에 접근제어하는 방법을 배우고, class간의 상속 개념을 배웁니다. </p><ol><li><a href="#basic">class 기초</a></li><li><a href="#property">class property</a></li><li><a href="#Access">class Access Modifier</a></li><li><a href="#constructor">class default constructor</a></li><li><a href="#method">class &amp; method</a></li><li><a href="#extends">class extends</a></li></ol><hr><h3 id="1-class-기초"><a href="#1-class-기초" class="headerlink" title=" 1. class 기초"></a><a name="basic"></a> 1. class 기초</h3><ol><li>생성자 함수(<code>constructor</code>)가 없으면, 디폴트 생성자가 불린다.</li><li>클래스의 프로퍼티 혹은 멤버 변수가 정의되어 있지만, 값을 대입하지 않으면 undefined 이다.<br> =&gt; 오브젝트에 프로퍼티가 아예 존재하지 않는다.</li><li>접근제어자 (Access Modifier)는 <code>public</code>이 디폴트이다.</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="comment">// name과 age는 프로퍼티</span></span><br><span class="line">    <span class="comment">// class 바디에는 메소드와 프로퍼티만 포함할 수 있다. </span></span><br><span class="line">    name: <span class="built_in">string</span> = <span class="literal">null</span>; </span><br><span class="line">    age: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// constructor 내부에서 선언한 멤버변수는 this에 바인딩되어 있으므로 언제나 public이다. </span></span><br><span class="line">    &#125; <span class="comment">// 퍼블릭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class에서 default가 public이다.</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'Clara'</span>);</span><br><span class="line"><span class="comment">// 인스턴스를 생성할 때 new 연산자와 함께 호출한 것이 바로 constructor이며 constructor의 파라미터에 전달한 값은 멤버 변수에 할당한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-class-property"><a href="#2-class-property" class="headerlink" title=" 2. class property"></a><a name="property"></a> 2. class property</h3><ul><li>constructor이외에 프로퍼티들을 포함시킬 수 있다. </li><li>프로퍼티에도 값을 할당할 수 있다. 호출시 프로퍼티에 다시 값을 할당하게 되면, 마지막에 할당된 값이 출력된다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span> = <span class="string">'Clara'</span>;</span><br><span class="line">    age: <span class="built_in">number</span> = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name === <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">'nayoung'</span>;</span><br><span class="line">person.age = <span class="number">35</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); </span><br><span class="line"><span class="comment">// Person &#123;name: 'nayoung', age: 35&#125;</span></span><br><span class="line"><span class="comment">// Person의 프로퍼티가 불린 후에 person.name에 다시 할당된 값이 불리어지므로 결론적으로는 'nayoung'이 출력된다.</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-class-Access-Modifier"><a href="#3-class-Access-Modifier" class="headerlink" title=" 3. class Access Modifier"></a><a name="Access"></a> 3. class Access Modifier</h3><h4 id="private"><a href="#private" class="headerlink" title="private"></a><code>private</code></h4><ul><li>절대적으로 접근이 불가능하다.</li></ul><ol><li><code>private</code> 으로 설정된 프로퍼티는 <code>dot(.)</code>으로 접근할 수 없다.</li><li>클래스 내부에서는 private 프로퍼티를 사용할 수 있다.</li><li>private이 붙은 변수나 함수는 _ 를 이름앞에 붙이는데, 이는 문법이 아니라 널리 쓰이는 코딩 컨벤션이다.<blockquote><p>앞에 밑줄과 변수명을 쓰면 private이라는 코딩컨벤션 중 하나였다.</p></blockquote></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person(<span class="number">35</span>);</span><br><span class="line">person.name = <span class="string">'Mark'</span>;</span><br><span class="line"><span class="comment">// person._age (X)</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Person &#123;name: 'Mark', _age: 35&#125;</span></span><br></pre></td></tr></table></figure><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h4><p>부모자식간의 관계에서 상속을 받은 class는(자식) 부모에는 접근 가능하다.</p><ol><li>부모에서 private 으로 설정된 프로퍼티는 상속을 받은 자식에서도 접근할 수 없다.</li><li>부모에서 protected 로 설정된 프로퍼티는 상속을 받은 자식에서 접근이 가능하다.</li><li>상속을 받은 자식 클래스에서 부모 클래스에 this 를 통해 접근하려면, 생성자에서 super(); 를 통해 초기화 해야한다.<blockquote><p>super란? super키워드는 부모 클래스의 프로퍼티를 참조할 때 또는 부모 클래스의 constructor를 호출할 때 사용한다.</p></blockquote></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">    <span class="keyword">private</span> privateProp: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">protected</span> protectedProp: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 아래의 멤버변수와 순서가 바뀌어도 에러가 난다!</span></span><br><span class="line">        <span class="keyword">this</span>.protectedProp = <span class="string">'protected'</span>;</span><br><span class="line">        <span class="comment">// this.privateProp = 'private'; // (X)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-class-default-constructor"><a href="#4-class-default-constructor" class="headerlink" title=" 4. class default constructor"></a><a name="constructor"></a> 4. class default constructor</h3><ul><li>디폴트 생성자는 프로그래머가 만든 생성자가 없을 때 사용할 수 있다.<ul><li>사용자가 만든 생성자가 하나라도 있으면, 디폴트 생성자는 사라진다.<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-class-amp-method"><a href="#5-class-amp-method" class="headerlink" title=" 5. class &amp; method"></a><a name="method"></a> 5. class &amp; method</h3><ol><li>클래스 내부에 작성된 메서드는 public 이 디폴트</li><li>arrow function 으로 작성 가능</li><li>private 을 이용하면 클래스 외부에서 접근 불가</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> _name: <span class="built_in">string</span>, <span class="keyword">private</span> _age: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    print(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`이름은 <span class="subst">$&#123;this._name&#125;</span> 이고, 나이는 <span class="subst">$&#123;this._age&#125;</span> 살 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123; <span class="comment">// arrow function</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`이름은 <span class="subst">$&#123;this._name&#125;</span> 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> printAge(): <span class="built_in">void</span>  &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`나이는 <span class="subst">$&#123;this._age&#125;</span> 살 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person(<span class="string">'Mark'</span>, <span class="number">35</span>);</span><br><span class="line">person.print(); <span class="comment">// 이름은 Mark 이고, 나이는 35 살 입니다.</span></span><br><span class="line">person.printName(); <span class="comment">// 이름은 Mark 입니다.</span></span><br><span class="line"><span class="comment">// person.printAge(); // (X)</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-class-extends"><a href="#6-class-extends" class="headerlink" title=" 6. class extends"></a><a name="extends"></a> 6. class extends</h3><ol><li>상속은 <code>extends</code> 키워드를 이용한다.</li><li>자식 클래스에서 디폴트 생성자는 부모의 생성자와 입력 형태가 같다.</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> _name: <span class="built_in">string</span>, <span class="keyword">protected</span> _age: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    print(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`이름은 <span class="subst">$&#123;this._name&#125;</span> 이고, 나이는 <span class="subst">$&#123;this._age&#125;</span> 살 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`이름은 <span class="subst">$&#123;this._name&#125;</span> 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> printAge(): <span class="built_in">void</span>  &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`나이는 <span class="subst">$&#123;this._age&#125;</span> 살 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">    _name = <span class="string">'Mark Jr.'</span>; <span class="comment">// 나중에 할당된 값이 출력된다. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const p: Child = new Child(); // (X)</span></span><br><span class="line"><span class="keyword">const</span> p: Child = <span class="keyword">new</span> Child(<span class="string">''</span>, <span class="number">5</span>);</span><br><span class="line">p.print(); <span class="comment">// 이름은 Mark Jr. 이고, 나이는 5 살 입니다.</span></span><br></pre></td></tr></table></figure><ol><li>생성자를 정의하고, this 를 사용하려면, <code>super</code> 를 통해 부모의 생성자를 호출해줘야 한다.</li><li>super를 호출할때는 부모 생성자의 입력 타입이 같아야 한다.</li><li>super를 호출하는 것은 클래스 <code>외부</code>에서 호출하는 것과 같다.</li><li><code>protected</code> 함수를 호출해서 그 안의 private 을 출력하는 것에 주의한다.<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> _name: <span class="built_in">string</span>, <span class="keyword">private</span> _age: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    print(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`이름은 <span class="subst">$&#123;this._name&#125;</span> 이고, 나이는 <span class="subst">$&#123;this._age&#125;</span> 살 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> printName = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`이름은 <span class="subst">$&#123;this._name&#125;</span> 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> printAge(): <span class="built_in">void</span>  &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`나이는 <span class="subst">$&#123;this._age&#125;</span> 살 입니다.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Mark Jr.'</span>, age);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.printName();</span><br><span class="line">        <span class="keyword">this</span>.printAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: Child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 이름은 Son 입니다.</span></span><br><span class="line"><span class="comment">// 나이는 1 살 입니다.</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/es6-class" target="_blank" rel="noopener">http://poiemaweb.com/es6-class</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>03 days/ 기획 및 프로토타입, 그리고 디자인</title>
    <link href="http://feel5ny.github.io/2017/11/21/dada_01week/"/>
    <id>http://feel5ny.github.io/2017/11/21/dada_01week/</id>
    <published>2017-11-21T01:10:04.000Z</published>
    <updated>2017-12-14T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Daily scrum +<br>Github <a href="https://github.com/huusz/Da-Da" target="_blank" rel="noopener">+</a></p><blockquote><p>개발부분부터 보길 원하신다면 다음 포스팅부터 읽으셔도 됩니다.</p></blockquote><hr><h3 id="정말-3일만에-끝내신건가요"><a href="#정말-3일만에-끝내신건가요" class="headerlink" title="정말 3일만에 끝내신건가요?"></a>정말 3일만에 끝내신건가요?</h3><p>개발 공부를 하고 있던 만큼, 개발 이외의 시간들은 최대한 단축하고 싶었다. 우리 모두 비슷한 마음이었고, 다행히 이 부분의 스케줄을 잘 조정할 수 있었다. 사실 기획 스탭은 굉장히 중요한 시간이라는건 안다.. 한달이라는 기간이 주어졌기 때문에 선택과 집중을 해야하는 상황에서 우리는 개발기간을 선택했다. 다행히 각 스탭별로 능력을 갖고 있던 팀원들이 모였기 때문에, 이 부분에 대한 커뮤니케이션은 잘 진행되었고, 모두가 물어보는 그 3일만에 개발에 들어갈 수 있었다.<br>(여기서 말한 3일은 아이데이션 기간은 제외한 기간이다.)</p><hr><p>목차</p><ol><li><a href="#ideation">아이데이션</a></li><li><a href="#storyboard">와이어프레임 및 스토리보드</a></li><li><a href="#prototype">프로토타입</a></li><li><a href="#design">디자인</a></li></ol><hr><h2 id="1-아이데이션"><a href="#1-아이데이션" class="headerlink" title=" 1. 아이데이션"></a><a name="ideation"></a> 1. 아이데이션</h2><p>아이디어 논의 회의는 3일 중에.. 끝낸건 아니다ㅎ 그래도 2번의 회의 끝에 확정하게 되었다.<br>9월 7일 팀빌딩을 마치고, 25일 첫 팀프로젝트 오리엔테이션 전까지 2번의 회의를 진행했다.</p><h3 id="1차회의"><a href="#1차회의" class="headerlink" title="1차회의"></a>1차회의</h3><p> 서비스 주제의 경우, <code>요리</code>에 관심이 많던 팀원의 의견에서부터 시작했다. 요리로 키워드가 좁혀지고, 요리로 끊임없는 마인드맵을 그리다가, 첫 회의때는 주제는 결정하지 못했다.<br>그리고 첫 회의 때인만큼, 각자 하고 해보고싶은 테크에 대해서도 같이 얘기해보았는데, 그중 Google Cloud Platform (이하 GCP)의 <strong><a href="https://cloud.google.com/vision/" target="_blank" rel="noopener"><code>Vision api</code></a></strong>를 사용하자는 의견이 나왔다. 간단하게 얘기하자면 사진을 분석하여 어떤 물체가 있는 사진인지 단어를 여러가지 던져주는 api이다. 사실 이외에도 여러 의견들이 나왔었다. 일랙트론, 얼굴인식 api, 등등.. </p><ul><li>1차회의의 결론은 <code>요리</code>로 좁혀졌다는 것.</li></ul><p><img src="/images/post_img/05/05.png"></p><h3 id="2차회의"><a href="#2차회의" class="headerlink" title="2차회의"></a>2차회의</h3><p> 1차회의가 끝난 후 2차회의 전까지 집에서 이것저것 생각 해보았다. </p><ol><li>요리와 사진을 접목시켜서 나올 수 있는 서비스가 무엇일까.</li><li>요리를 사진 찍어서 올릴 상황은 언제인거지.<br>그러다 문득 네이버 블로그 이웃은 <code>다이어트 컨설팅</code>을 하는 언니가 떠올랐다. 그분이 주로 컨설팅 하는 방식은 컨설팅 받은 사람이 칼로리 계산과 영양소를 잘 조절해서 건강한 식사를 해 줄 수 있도록 도와주는 방식인데, 이때 사용하는 방법은 그 사람의 SNS에 무조건 식단 사진을 올리고 칼로리, 영상소를 기록하게 한다. 컨설턴트는 그 내용을 확인하고 1:1로 상담을 진행한다.</li></ol><p>오케이.</p><p>무조건 사진을 올려야한다는 조건과 음식이라는 조건이 일치했고, 2차 회의 때 제시해보았다. 저번 회의때 요리라는 키워드 때문에 레시피 서비스도 얘기했었는데, 레퍼런스를 찾다가 <code>로푸드 레시피</code>를 제공하는 해외사이트를 공유한적이 있었다. 그때의 레퍼런스와 건강함을 추구하는 몇몇 팀원들 덕분에 ㅎㅎ 식단 다이어리 서비스로 확정.<br>바로 러프한 아키텍처를 구상하고 회의를 마무리했다.</p><hr><h2 id="2-와이어프레임-및-스토리보드"><a href="#2-와이어프레임-및-스토리보드" class="headerlink" title=" 2. 와이어프레임 및 스토리보드"></a><a name="wireframe"></a> 2. 와이어프레임 및 스토리보드</h2><ul><li>팀프로젝트 오리엔테이션 및 3차회의</li><li>4차 회의</li><li>기획안 발표</li></ul><h3 id="팀-프로젝트-오리엔테이션-3차회의"><a href="#팀-프로젝트-오리엔테이션-3차회의" class="headerlink" title="팀 프로젝트 오리엔테이션 3차회의"></a>팀 프로젝트 오리엔테이션 3차회의</h3><p>팀 오리엔테이션때는 여러 재밌는 시간을 가졌는데, 프로젝트 시작 전 생각할 수 있는 위험요소를 공유하고, 어떻게 해결할지에 대해서 공유하는 시간을 가졌다. 지금 보니.. 귀여운 리스크들이네.</p><p><strong>Risk</strong></p><ul><li>각자의 욕심을 내세우는 커뮤니케이션 문제로 팀원 간의 관계 악화</li><li>충분한 테스트를 거치지 못해 최종 결과물이 오작동하거나 오류 발생</li><li>환경적 문제 : 소스 손실, 장비 고장</li></ul><p><strong>Solution</strong></p><ul><li>충분한 대화, 타협되지 않을 경우 각자 해당 부분을 담당</li><li>테스트 기간을 무조건 확보한다.</li><li>백업을 자주 한다.</li></ul><p>간단 오리엔테이션과 전체 진행 일정을 들은 후, 팀 회의 시간을 갖게 되었다. 이날은 저번에 짠 아키텍처를 시각화하고, 구체적으로 어떻게 컨셉을 잡을지와 UI구성, 서비스 네이밍, 등을 정했다. 이번 회의때는 몇몇 이슈들이 있었는데 저번 회의가 끝나고, 각자 머리 속으로 구성한 부분이 조금씩 달랐다는 점이었다. 이 날은 그런 생각의 차이를 조정하는 시간을 가졌다.<br>그리고 <strong>건강한 <code>다</code>이어트를 위한 식단 <code>다</code>이어리 서비스, DA DA</strong> 가 확정 되었다.</p><h3 id="스토리보드-작업-소요기간-1일"><a href="#스토리보드-작업-소요기간-1일" class="headerlink" title=" 스토리보드 작업 (소요기간: 1일)"></a><a name="storyboard"></a> 스토리보드 작업 (소요기간: 1일)</h3><p>와이어프레임 ( PDF version <a href="https://github.com/huusz/Da-Da/blob/master/static/dada-wireframe.pdf" target="_blank" rel="noopener">+</a> / Web version <a href="https://docs.google.com/presentation/d/e/2PACX-1vRgjDbUHXEy2dDrOFUiSDvOQ2hTvXXMSGbRQw3Bakq3Xh7Jcw5sVTkolmp-XKsWISoXxpxI6EjV6twg/pub?start=false&amp;loop=false&amp;delayms=3000" target="_blank" rel="noopener">+</a> )</p><ol><li>Information Architecture</li><li>구조도</li><li>화면별 스토리보드</li><li>시나리오</li></ol><hr><h2 id="3-프로토타입"><a href="#3-프로토타입" class="headerlink" title=" 3. 프로토타입 +"></a><a name="prototype"></a> 3. 프로토타입 <a href="https://projects.invisionapp.com/share/2GDPBHAT5" target="_blank" rel="noopener">+</a></h2><p>프로토타입은 Invision, Sketch를 사용했다. 스토리보드를 참고하여 간단 목업스타일로 시안 작업을 진행했고, 인터렉션은 invision에서 작업, 전체 느낌과 컨셉을 확인하는 시간을 가졌다.</p><p><img src="/images/post_img/05/04.png"></p><hr><h2 id="4-디자인"><a href="#4-디자인" class="headerlink" title=" 4. 디자인  +"></a><a name="design"></a> 4. 디자인  <a href="https://projects.invisionapp.com/share/DCE154SUH#/screens" target="_blank" rel="noopener">+</a></h2><p>디자인은 간단하게 키워드를 잡고 진행했다. 심플 + 모던 + 산뜻<br>최대한 음식을 먹고싶은 욕구를 억제했으면 좋겠다는 생각이 들어서 붉은 계열의 색상은 피했다. 식욕억제를 목적으로 블루계열 색상으로 key color를 잡았고, 블랙과 키칼리가 비슷한 비율로 사용되었기 때문에 강약조절이 필요했고, 키칼라에 좀더 힘을 주려기 위해 그라데이션을 사용하였다.<br>프로토타입에서 목업작업을 잘 해놓았기 때문에 그래픽 작업에서는 수월하게 진행할 수 있었다. 역시 기초작업이 제일 중요.<br><img src="/images/post_img/05/03.png"></p><p>최종 디자인 사안 이후 zeplin을 사용해서 팀원 전체와 공유하였다.</p><p><img src="/images/post_img/05/01.png"></p><hr><p><a href="">다음편! &gt;</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;Daily scrum +&lt;br&gt;Github &lt;a href=&quot;https://github.com/huusz/Da-Da&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;+&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;개발부분부터 보길 
      
    
    </summary>
    
      <category term="Project &amp;#127939;" scheme="http://feel5ny.github.io/categories/Project-127939/"/>
    
      <category term="DA, DA" scheme="http://feel5ny.github.io/categories/Project-127939/DA-DA/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
      <category term="plan" scheme="http://feel5ny.github.io/tags/plan/"/>
    
      <category term="design" scheme="http://feel5ny.github.io/tags/design/"/>
    
      <category term="prototype" scheme="http://feel5ny.github.io/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>5/ interface</title>
    <link href="http://feel5ny.github.io/2017/11/20/Typescript_06/"/>
    <id>http://feel5ny.github.io/2017/11/20/Typescript_06/</id>
    <published>2017-11-20T13:10:56.000Z</published>
    <updated>2018-08-15T14:46:48.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-14" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>요약</strong><br>inteface에 대해서 배웁니다. interface 내부에서 타입선언 후 변수에서 사용하며, 함수에서는 <code>implements</code> 키워드를 사용하여 interface를 상속받아 사용합니다. property를 <code>?</code>를 사용하여 옵셔널하게 사용가능하며(안써도 되는 프로퍼티를 명시할 수 있음) interface 끼리 상속이 가능합니다. interface 자체를 함수화하여 사용가능하며, 내부에서는 출력값과 입력값의 타입을 명시합니다. indexable type으로도 옵셔널한 프로퍼티를 만들 수 있습니다.</p><ol><li><a href="#basic">interface 기초</a></li><li><a href="#optional">interface optional property</a><ol><li>optional property</li><li><a href="#indexable">indexable type</a></li></ol></li><li><a href="#functionIn">function in interface</a></li><li><a href="#implements">implements interface</a></li><li><a href="#extends">extends interface</a></li><li><a href="#function">function interface</a></li></ol><hr><h3 id="1-interface-기초"><a href="#1-interface-기초" class="headerlink" title=" 1. interface 기초"></a><a name="basic"></a> 1. interface 기초</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person: &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125; = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    age: <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// person이라는 오브젝트를 설명하고 있는 타입은 리터럴 타입인데,매번 리터럴방식으로 타입을 선언할것인가?</span></span><br><span class="line"><span class="comment">// 아니오..  &gt; interface로 부르자.</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    age: <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// interface는 컴파일 이후에는 나타나지 않는다.</span></span><br></pre></td></tr></table></figure><ul><li>타입을 미리 interface에서 명시 한 후에 해당 interface를 넣어서 타입을 명시한다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">입력값:입력값타입</span>): 출력타입 </span>&#123;</span><br><span class="line">  ~</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = (p:Person): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 입력과 출력을 정확히 명시하지 않으면, </span></span><br><span class="line"><span class="comment">// 추론을 하게 되는데 이는 문제가 될 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">p: Person</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`안녕하세요. <span class="subst">$&#123;p.name&#125;</span> 입니다.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-interface-optional-property"><a href="#2-interface-optional-property" class="headerlink" title=" 2. interface optional property"></a><a name="optional"></a> 2. interface optional property</h3><h4 id="1-있어도-되고-없어도-되는-proerty를-설정-할-수-있다"><a href="#1-있어도-되고-없어도-되는-proerty를-설정-할-수-있다" class="headerlink" title="1. 있어도 되고 없어도 되는 proerty를 설정 할 수 있다."></a>1. 있어도 되고 없어도 되는 proerty를 설정 할 수 있다.</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    <span class="comment">// age를 정의하지 않았기 때문에 person에 빨간줄이 생긴다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  age? : <span class="built_in">number</span> <span class="comment">// &lt;= age 뒤에 ?를 붙이면 된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age?: <span class="built_in">number</span>, <span class="comment">// 옵셔널한 프로퍼티 주는 방법</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    <span class="comment">// age는 optional한 property이기 때문에 없어도 오류가 나지 않는다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-indexable-type"><a href="#2-indexable-type" class="headerlink" title=" 2. indexable type"></a><a name="indexable"></a> 2. indexable type</h4><p>indexable type으로 optional한 타입을 사용 가능하다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. array같은 타입이고</span></span><br><span class="line"><span class="comment">// 2. 사전같은 타입이다.</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// person의 property명으로 인덱스가 어떤 타입이었는지에 따라서</span></span><br><span class="line">    <span class="comment">// property.string 형태의 어떤 indexable type이 들어가면 나머지는 다 string으로 표현할 수 있다.</span></span><br><span class="line">    <span class="comment">// 사전같은 의미이다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Clara'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.anybody = <span class="string">"Clara"</span></span><br><span class="line">person[<span class="number">1</span>] = <span class="string">'hi'</span> <span class="comment">// 배열형태로도 넣을 수 있다.</span></span><br></pre></td></tr></table></figure></p><p><code>person.anybody = &quot;Clara&quot;</code> </p><ul><li>이렇게 객체에 <code>.</code>을 붙인 후 프로퍼티로 타입을 <code>옵셔널</code>하게 줄 수 있기 때문에 optional type으로 사용이 가능하다는 뜻이다. (없어도 에러가 나지 않는다.) </li><li><strong>index는 <code>string</code>이거나 <code>number</code>만 가능하다.</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sa: StringArray = &#123;&#125;; <span class="comment">// 옵셔널하다, 안써도 에러가 안난다.</span></span><br><span class="line">sa[<span class="number">100</span>] = <span class="string">'백'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sd: StringDictionary = &#123;&#125;; <span class="comment">// 옵셔널하다</span></span><br><span class="line">sd.hundred = <span class="string">'백'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringArrayDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sad: StringArrayDictionary = &#123;&#125;;</span><br><span class="line"><span class="comment">// 당연히 옵셔널하다.</span></span><br><span class="line">sad[<span class="number">100</span>] = <span class="string">'백'</span>;</span><br><span class="line">sad.hundred = <span class="string">'백'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sd: StringDictionary = &#123;</span><br><span class="line">    name: <span class="string">'이름'</span> <span class="comment">// 필수</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sd.any = <span class="string">'any'</span>; <span class="comment">// 어떤 프로퍼티도 가능</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringDictionaryNo &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// name: number; </span></span><br><span class="line">    <span class="comment">// (X) 인덱서블 타입이 string 값을 가지기 때문에 number 를 필수로 끌어오면 에러</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-function-in-interface"><a href="#3-function-in-interface" class="headerlink" title=" 3. function in interface"></a><a name="functionIn"></a> 3. function in interface</h3><p>interface 내부에 함수를 넣을 수 있다.</p><ul><li>출력값의 타입을 명시해야한다.<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    hello(): <span class="built_in">void</span>;</span><br><span class="line">    world(): <span class="built_in">string</span>;</span><br><span class="line">    nayoung(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123; <span class="comment">//void일 경우는 써도 되고 안 써도된다.</span></span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    world(): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'World'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    nayoung: (): <span class="function"><span class="params">number</span> =&gt;</span> &#123; <span class="comment">// ES6 문법 합수 사용시 </span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="4-implements-interface-128580"><a href="#4-implements-interface-128580" class="headerlink" title=" 4. implements interface &#128580;"></a><a name="implements"></a> 4. implements interface &#128580;</h3><p>interface를 상속받아서 class에서 사용가능하다.</p><ul><li>class 선언문의 <code>implements</code> 뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현하여야 한다. <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    hello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 만들기. IPeron을 상속받았다.</span></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> IPerson &#123;</span><br><span class="line">  <span class="comment">// IPerson을 다 써줘야한다.</span></span><br><span class="line">    name: <span class="built_in">string</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="comment">// IPerson의 name을 this.name으로 받는다. </span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    hello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`안녕하세요. <span class="subst">$&#123;this.name&#125;</span> 입니다.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> hi(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: IPerson = <span class="keyword">new</span> Person(<span class="string">'Mark'</span>);</span><br><span class="line">person.hello()</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="5-extends-interface"><a href="#5-extends-interface" class="headerlink" title=" 5. extends interface"></a><a name="extends"></a> 5. extends interface</h3><p>상속받는 인터페이스를 만들 수 있다. interface끼리 상속이 가능하다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Korean <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    city: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k: Korean = &#123;</span><br><span class="line">    name: <span class="string">'이웅재'</span>,</span><br><span class="line">    city: <span class="string">'서울'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-function-interface"><a href="#6-function-interface" class="headerlink" title=" 6. function interface"></a><a name="function"></a> 6. function interface</h3><p>함수형 인터페이스이다. </p><ul><li>함수의 타입 체크는 할당할 때가 아니라 <code>사용할 때 한다</code>는 점을 명심</li><li>function의 입출력을 바로 명시하지 않는다.</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> HelloPerson &#123;</span><br><span class="line">    <span class="comment">// (name: string, age: number): void;</span></span><br><span class="line">    (name: <span class="built_in">string</span>, age?: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helloPerson의 타입이 HelloPerson</span></span><br><span class="line"><span class="keyword">let</span> helloPerson: HelloPerson = <span class="function"><span class="keyword">function</span> (<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// name:string을 넣지 않아도 에러가 안난다. =&gt; 호출할 때 에러가 난다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`안녕하세요! <span class="subst">$&#123;name&#125;</span> 입니다.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">helloPerson(<span class="string">'Mark'</span>); <span class="comment">// 안녕하세요! Mark 입니다.</span></span><br><span class="line">helloPerson(); <span class="comment">// 에러가 난다.</span></span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://poiemaweb.com/typescript-interface" target="_blank" rel="noopener">http://poiemaweb.com/typescript-interface</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>4/ 타입추론, Type assertions, Type alias</title>
    <link href="http://feel5ny.github.io/2017/11/18/Typescript_05/"/>
    <id>http://feel5ny.github.io/2017/11/18/Typescript_05/</id>
    <published>2017-11-18T06:13:11.000Z</published>
    <updated>2018-08-15T14:46:48.719Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8-14" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><p><strong>목표</strong><br>이 포스팅과 interface 포스팅에서는 타입을 명시하는 방법을 배웁니다. 타입을 명시하지 않아도 추론이 가능하며, 강제 타입선언, 별명을 붙여가며 타입을 선언하는 방식 등을 배웁니다.</p><ol><li><a href="#let+const">let과 const의 타입 추론</a><br>변수를 선언할 때 부터 타입을 신경쓰면서 선언할 수 있는데, 타입없이 선언할 경우 할당된 값을 확인 후 타입을 추론한다. let 키워드로 변수 선언시에는 타입추론이 가능하지만 const 키워드로 선언할 경우 추론이 되지 않으며 <code>리터럴 타입</code>으로 값이 타입이 된다.</li><li><a href="#assertions">Type assertions</a><br>타입을 강제적으로 명시해줄 수 있다. (as와 &lt;&gt;방법)</li><li><a href="#alias">Type alias</a><ol><li><a href="#Interface">Type alias와 Interface와 차이점</a><br>타입에 다른 이름을 붙여주는 것인데, Interface와 유사하지만 차이점은, 상속과 인터페이스 구현(implements)의 가능 여부가 다르다는 것.</li></ol></li></ol><hr><h3 id="1-let과-const의-타입-추론"><a href="#1-let과-const의-타입-추론" class="headerlink" title=" 1. let과 const의 타입 추론"></a><a name="let+const"></a> 1. let과 const의 타입 추론</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> = <span class="string">'진호'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'승민'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: <span class="built_in">string</span> = <span class="string">'나영'</span>;</span><br><span class="line"><span class="keyword">const</span> d = <span class="string">'슬기'</span> <span class="comment">// 리터럴 타입</span></span><br></pre></td></tr></table></figure><ul><li>const는 프리미티브 타입은 다른 값으로 못 바꾸고, 레퍼런스타입은 다른 레퍼런스타입을 가리키지 못하게 하는 것인데, 타입스크립트에서는 <code>리터럴 타입</code>이라고 하는 것으로 타입까지 강제해버린다.</li><li>즉 const에서 타입없이 선언될 경우 타입 추론에 의해서 할단된 값이 타입으로 된다. (리터럴 타입)<br>ex. 위에서 <code>const d = &#39;슬기&#39;</code>에서 d는 <code>const d:&#39;슬기&#39;</code>라고 뜨고, 슬기라는 리터럴 타입으로 된다.</li></ul><p>재할당 redeclare</p><ul><li>let은 재할당(redeclare)이 가능하다.</li><li>const는 <ul><li>레퍼런스 타입은 레퍼런스 값이 바뀌는 것을 허용하지 않고, 속안의 프로퍼티 바꾸는 것은 허용된다. </li><li>프리미티브 타입은 재할당이 아예 불가능.</li></ul></li></ul><blockquote><p>보통은 const를 사용하며, let을 쓰면서 명시적으로도 값이 바껴지는 변수라고도 표시한다.</p></blockquote><hr><h3 id="2-Type-assertions-assertions-’단언’"><a href="#2-Type-assertions-assertions-’단언’" class="headerlink" title=" 2. Type assertions (assertions:’단언’)"></a><a name="assertions"></a> 2. Type assertions (assertions:’단언’)</h3><ul><li>형 변환과는 다르다.<br>형 변환은 : 실제 데이터 구조를 바꾼다.</li><li><code>&#39;타입이 이것이다&#39;라고 컴파일러에게 알려주는 것</code>을 의미한다.<br>예_<code>넓은 범위의 타입</code>이 (union타입) 어떤 상황에서 고정이 되어야할 경우, 타입 어셜션으로 타입을 강제해 준다.</li><li>방법은 2가지가 있다.<ol><li>변수 as 강제할 타입</li><li>&lt;강제할타입&gt;변수</li></ol></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 주로 넓은 타입에서 좁은 타입으로 강제하는 경우가 많다.</span></span><br><span class="line"><span class="comment">2. jsx 에서는 as 를 쓴다.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-Type-alias-alias-’별명’"><a href="#3-Type-alias-alias-’별명’" class="headerlink" title=" 3. Type alias (alias:’별명’)"></a><a name="alias"></a> 3. Type alias (alias:’별명’)</h3><p>타입에 별명을 붙인다고 생각하면 된다.</p><ul><li>타입이 생기는 것이 아니라, 따로 이름을 붙여주는 것이다.</li><li>interface가 유사하지만 interface처럼 쓸수 없는 경우가 있다.</li><li>Primitive나 Union Type, Tuple 같은 타입에서 쓴다.<br>보통 Primitive 타입은 .. 많이 안쓴다. (number나 string을 구지..)</li><li>만들어진 타입의 refer로 사용하는 것이지 `타입을 만드는 것은 아니다.</li><li><code>type + 별칭</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Aliaing Primitive</span></span><br><span class="line"><span class="keyword">type</span> MyStringType = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">let</span> myStr: MyStringType = <span class="string">'hello'</span>;</span><br><span class="line">myStr = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string에 'world'라는 별명을 주었다.</span></span><br><span class="line"><span class="comment">// 별 의미가 없다..</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Aliaing Union Type</span></span><br><span class="line"><span class="keyword">let</span> person: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">person = <span class="string">'Mark'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// StringOrNumber이라는 타입별칭을 붙였다. </span></span><br><span class="line"><span class="comment">// 별칭 붙일 때는 앞에 type + 별칭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> another: StringOrNumber = <span class="number">0</span>;</span><br><span class="line">another = <span class="string">'Anna'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 유니온 타입은 A 도 가능하고 B 도 가능한 타입</span></span><br><span class="line"><span class="comment">2. 길게 쓰는걸 짧게</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Aliaing Tuple</span></span><br><span class="line"><span class="keyword">let</span> person: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Mark'</span>, <span class="number">35</span>];</span><br><span class="line"><span class="keyword">type</span> PersonTuple = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">let</span> another: PersonTuple = [<span class="string">'Anna'</span>, <span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 튜플 타입에 별칭을 줘서 여러군데서 사용할 수 있게 한다.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-1-Type-alias와-Interface와-차이점"><a href="#3-1-Type-alias와-Interface와-차이점" class="headerlink" title=" 3-1. Type alias와 Interface와 차이점"></a><a name="Interface"></a> 3-1. Type alias와 Interface와 차이점</h4><p>보통은 interface와 class등을 자주 사용하기 때문에 alias 쓰는 타이밍이 초반에는 많이 없다. interface를 사용하다가 굳이 사용할 필요가 없는 순간에 alias를 쓰면 된다.</p><ol><li><p>오류 메세지<br>타입스크립트가 컴파일을 시도할때 오류가 나올때, Alias라는 이름으로 알려주지 않고 타입 자체로 알려준다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Alias = &#123; num: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Interface &#123;</span><br><span class="line">    num: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">aliased</span>(<span class="params">arg: Alias</span>): <span class="title">Alias</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">interfaced</span>(<span class="params">arg: Interface</span>): <span class="title">Interface</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. type alias 는 object literal type 로</span></span><br><span class="line"><span class="comment">2. interface 는 interface 로</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>상속을 받을 수는 있지만 상속을 할 수는 없다.</p><ul><li>당연한건 type alias 끼리는 extends, implements 불가</li><li>interface extends type alias 가능 </li><li>class A implements type alias 가능<br>= A라는 클래스는 type alias 인터페이스를 구현할 수 있다. </li><li>class A extends type alias 블가 (interface 도 마찬가지)<br>= A라는 클래스는 type alias를 상속받지 못한다. </li><li>마치 interface 처럼 동작한다.</li><li>클래스 선언문의 implements 뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현하여야 한다.</li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonAlias = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;; <span class="comment">// type alias</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IPerson <span class="keyword">extends</span> PersonAlias &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ip: IPerson = &#123;</span><br><span class="line">    name: <span class="string">'Mark'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PersonImpl <span class="keyword">implements</span> PersonAlias &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    hello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'안녕하세요'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// PersonImpl라는 클래스는 PersonAlias라는 인터페이스를 구현하겠다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pi: PersonImpl = <span class="keyword">new</span> PersonImpl();</span><br><span class="line">pi.hello();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PersonChild <span class="keyword">extends</span> PersonAlias &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 불가능</span></span><br></pre></td></tr></table></figure><ul><li>extends와 implements의 차이<br><code>class A extends B</code> 라고 하면<br>A는 B라는 클래스를 상속 받아서 +a 시키겠다는 뜻.<br><code>class A implements C</code> 라고 하면<br>A는 C라는 인터페이스를 구현하겠다~ 라는 뜻입니다.</li></ul><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://gdthink.blogspot.kr/2006/06/extends%EC%99%80-implements%EC%9D%98-%EC%B0%A8%EC%9D%B4.html" target="_blank" rel="noopener">http://gdthink.blogspot.kr/2006/06/extends%EC%99%80-implements%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</a></li><li><a href="http://poiemaweb.com/typescript-interface" target="_blank" rel="noopener">http://poiemaweb.com/typescript-interface</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;타입스크립트 정리 글은 이웅재님의 &lt;a href=&quot;https://www.youtube.com/user/2woongjae/videos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;강의&lt;/a&gt;와 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>3/ Typescript_기본 데이터 타입</title>
    <link href="http://feel5ny.github.io/2017/11/17/Typescript_04/"/>
    <id>http://feel5ny.github.io/2017/11/17/Typescript_04/</id>
    <published>2017-11-17T03:33:40.000Z</published>
    <updated>2018-08-15T14:46:48.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="기본-데이터-타입-🌱"><a href="#기본-데이터-타입-🌱" class="headerlink" title="기본 데이터 타입 🌱"></a>기본 데이터 타입 🌱</h2><p>타입스크립트에서 기본 자료형을 <code>잘!</code> 숙지해야 한다. 타입스크립트는 타입을 새로 만들면서 짜는 방식인데, 특정한 골격을 갖출 때 결국 남는건 기본 자료형들이 남는다. 이때 기본 자료형이 정확히 어떤 것들이 있는지 인지하고 있어야, 그 기본 자료형들을 잘 조합해서 내가 사용할 인터페이스를 만들어 낼 수 있고, 타입을 만들 수 있다. 자바스크립트의 기본자료형을 모두 포함한다.</p><hr><blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8#" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다 .</p></blockquote><ol><li><a href="#literal">literal</a></li><li>기본 자료형 Primitive Type (javascript) 🌱<ol><li><a href="#boolean">boolean</a></li><li><a href="#number">number</a></li><li><a href="#string">string</a></li><li><a href="#Template_String">Template String</a></li><li><a href="#Undefined_null">Undefined &amp; null</a><ol><li>undefined &amp; null are subtypes of all other types</li><li>null in JavaScript</li><li>undefined in JavaScript</li></ol></li></ol></li><li>참조타입 (javascript) 🎯<ol><li><a href="#Array">Array</a></li><li><a href="#Symbol">Symbol</a></li></ol></li><li>타입스크립트에서 추가로 제공하는 타입 🐥<ol><li><a href="#Void">Void</a></li><li><a href="#Any">Any</a></li><li><a href="#Never">Never</a></li><li><a href="#Tuple">Tuple</a></li><li><a href="#Enum">Enum</a></li></ol></li></ol><hr><h3 id=""><a href="#" class="headerlink" title=""></a><a name="literal"></a></h3><p>0. literal</p><ul><li><code>값 자체가 변하지 않는 값을 의미합니다 .</code></li><li>상수와 다른 것은 상수는 가리키는 포인터가 고정이라는 것이고, 리터럴은 그 자체가 <strong>값이자 그릇</strong>입니다 .</li><li>“<code>리터럴 상수</code>는 5, 1.23 과 같은 숫자나, ‘This is a string’ 혹은 “It’s a string!” 과 같은 문자열 등을 말합니다. 이것들이 리터럴 상수라고 불리우는 이유는 이것들이 프로그램 내에 직접 <code>문자 형태</code>로 (literally) 지정되는 값들 이기 때문입니다. <code>이러한 값들은 한번 지정되면 변하지 않습니다 .</code></li><li>예를 들면 숫자 <code>2</code>는 언제나 자기 자신이 2 라는 숫자임을 나타내며 어떤 다른 의미도 갖지 않습니다 .</li><li>이들은 한번 지정되면 그 값을 변경할 수 없기 때문에 <em>상수</em>입니다 . 그 중에서도 특별히 이러한 값들을 리터럴 상수라고 부릅니다. @kangpual</li></ul><hr><h2 id="1-기본-자료형-Primitive-Type"><a href="#1-기본-자료형-Primitive-Type" class="headerlink" title="1. 기본 자료형 Primitive Type"></a>1. 기본 자료형 Primitive Type</h2><ul><li>object 와 reference 형태가 아닌 실제 값을 저장하는 자료형입니다 .</li><li>프리미티브 형의 내장 함수를 사용 가능한것은 자바스크립트 처리 방식 덕분<ul><li>동작 자체는 마치 객체인 것처럼 처리된다 .</li><li>메모리를 아끼기 위해서</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Nayoung'</span></span><br><span class="line"></span><br><span class="line">name.toString()</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a name="boolean"></a></h3><p>1-1. boolean</p><ul><li>가장 기본적인 데이터 타입</li><li>단순한 true 혹은 false값 입니다 .</li><li>JavaScript / TypeScript 에서 <strong>‘boolean’</strong> 이라고 부른다 .</li></ul><p><strong>소문자 boolean 과 대문자 Boolean</strong></p><ul><li>소문자 boolean 은 프리미티브 타입의 불린 , 대문자 Boolean 은 레퍼 오브젝트의 생성자 class 인데 , 자바스크립트에서는 두 가지의 차이가 크게 없지만, 타입스크립트에서는 차이가 있다 . 타입스크립트에서는 소문자를 권장한다.<ul><li><code>Type &#39;boolean&#39; is assignable to type &#39;Boolean&#39;.</code></li><li>Type ‘Boolean’ is not assignable to type ‘boolean’.</li><li>‘boolean’ is a primitive, but ‘Boolean’ is a wrapper object.</li><li>Prefer using ‘boolean’ when possible.</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> isDone === <span class="string">'boolean'</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'boolean' is assignable to type 'Boolean'.</span></span><br><span class="line"><span class="keyword">let</span> isOk: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'Boolean' is not assignable to type 'boolean'.</span></span><br><span class="line"><span class="comment">// 'boolean' is a primitive, but 'Boolean' is a wrapper object.</span></span><br><span class="line"><span class="comment">// Prefer using 'boolean' when possible.</span></span><br><span class="line"><span class="keyword">let</span> isNotOk: boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><a name="number"></a></h3><p>1-2. number</p><ul><li>JavaScript 와 같이, TypeScript 의 모든 숫자는 부동 소수점 값 입니다.</li><li>TypeScript 는 16진수 및 10진수 리터럴 외에도, ECMAScript 2015에 도입된 2진수및 8진수를 지원합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimal: number = <span class="number">6</span> <span class="comment">// 10진수 리터럴</span></span><br><span class="line"><span class="keyword">let</span> hex: number = <span class="number">0xf00d</span> <span class="comment">// 16진수 리터럴</span></span><br><span class="line"><span class="keyword">let</span> binary: number = <span class="number">0b1010</span> <span class="comment">// 2진수 리터럴</span></span><br><span class="line"><span class="keyword">let</span> octal: number = <span class="number">0o744</span> <span class="comment">// 8진수 리터럴</span></span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><a name="string"></a></h3><p>1-3. string</p><ul><li>Template String을 자주 쓴다 .</li><li>다른 언어에서와 마찬가지로 텍스트 형식을 참조하기 위해 <code>string</code>형식을 사용한다.</li><li>자바스크립트와 마찬가지로, 타입스크립트는 문자열 데이터를 둘러싸기 위해 큰 따옴표나 작은따옴표를 사용한다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">'mark'</span></span><br><span class="line">name = <span class="string">'anna'</span></span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><a name="Template_String"></a></h3><p>1-4. Template String</p><ul><li>주로 사용한다.</li><li>행에 걸쳐 있거나, 표현식을 넣을 수 있는 문자열</li><li>이 문자열은 backtick (= backquote <figure class="highlight plain"><figcaption><span>기호에 둘러쌓여 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* 포함된 표현식은 `$&#123; expr &#125;`와 같은 형태로 사용합니다.</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let fullName: string = `Bob Bobbington`</span><br><span class="line">let age: number = 37</span><br><span class="line"></span><br><span class="line">let sentence: string = `Hello, my name is $&#123;fullName&#125;.</span><br><span class="line"></span><br><span class="line">I&apos;ll be $&#123;age + 1&#125; years old next month.`</span><br><span class="line"></span><br><span class="line">// template string 을 사용하지 않을 경우</span><br><span class="line">let sentence: string =</span><br><span class="line">  &apos;Hello, my name is &apos; +</span><br><span class="line">  fullName +</span><br><span class="line">  &apos;.\n\n&apos; +</span><br><span class="line">  &quot;I&apos;ll be &quot; +</span><br><span class="line">  (age + 1) +</span><br><span class="line">  &apos; years old next month.&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><a name="Undefined_null"></a></h3><p>1-5. Undefined &amp; null</p><ul><li>TypeScript에서 ‘undefined’와 ‘null’은 실제로 각각 ‘undefined’와 ‘null’이라는 고유한 타입을 가집니다.</li><li>‘void’ 와 마찬가지로, undefined 와 null 은 그 자체로는 쓸모가 없습니다.</li><li>둘다 소문자만 존재합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이 변수들에 할당할 수 있는 것들은 거의 없다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li>위 처럼 사용하기 보다는 <code>return</code>에서 주로 사용</li></ul><h3 id="1-5-1-undefined-amp-null-are-subtypes-of-all-other-types"><a href="#1-5-1-undefined-amp-null-are-subtypes-of-all-other-types" class="headerlink" title="1-5-1. undefined &amp; null are subtypes of all other types"></a>1-5-1. undefined &amp; null are subtypes of all other types</h3><ul><li>기본 설정이 그렇습니다.</li><li>대입이 가능하다는 것이다.</li><li>number에 null 또는 undefined 를 <code>할당할 수 있다는 의미</code>입니다.</li><li>하지만, 컴파일 옵션에서 <code>--strictNullChecks</code>사용하면, null과 undefined 는 void 나 자기 자신들에게만 할당할 수 있습니다.</li><li>이 경우, null과 undefined를 할당할 수 있게 하려면, union type 을 이용해야합니다. (union type: 두개의 타입을 합치는 것.)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대입 가능</span></span><br><span class="line"><span class="keyword">let</span> name: string = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> age: number = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strictNullChecks =&gt; true</span></span><br><span class="line"><span class="comment">// 보통 위의 옵션을 true로 하진 않는다..</span></span><br><span class="line"><span class="comment">// 위의 옵션이 추가되면 자기 자신이나 void에게만 할당 가능, 다른 타입에는 할당하지 못함.</span></span><br><span class="line"><span class="comment">// let name: null = null; // (O)</span></span><br><span class="line"><span class="comment">// Type 'null' is not assignable to type 'string'.</span></span><br><span class="line"><span class="keyword">let</span> name: string = <span class="literal">null</span> <span class="comment">// (X)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null =&gt; null || void, undefined =&gt; undefined || void</span></span><br><span class="line"><span class="comment">// Type 'null' is not assignable to type 'undefined'.</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">null</span> <span class="comment">// (X)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v: <span class="keyword">void</span> = <span class="literal">undefined</span> <span class="comment">// (O)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> union: string | <span class="literal">null</span> | <span class="literal">undefined</span> = <span class="string">'str'</span></span><br></pre></td></tr></table></figure><h3 id="1-5-2-null-in-JavaScript"><a href="#1-5-2-null-in-JavaScript" class="headerlink" title="1-5-2. null in JavaScript"></a>1-5-2. null in JavaScript</h3><ul><li>null 이라는 값으로 할당된 것을 null 이라고 합니다.</li><li><code>무언가가 있는데, 사용할 준비가 덜 된 상태.</code> (undefined 는 <code>무언가가 아예 준비가 안된 상태</code>)</li><li>null 이라는 타입은 null 이라는 값만 가질 수 있습니다.</li><li>런타임에서 typeof 연산자를 이용해서 알아내면 , <code>object</code> 입니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n) <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3-undefined-in-JavaScript"><a href="#1-5-3-undefined-in-JavaScript" class="headerlink" title="1-5-3. undefined in JavaScript"></a>1-5-3. undefined in JavaScript</h3><ul><li>값을 할당하지 않은 변수는 undefined 라는 값을 가집니다.</li><li><code>무언가가 아예 준비가 안된 상태</code></li><li>object 의 property 가 없을 때도 undefined 입니다.</li><li>런타임에서 typeof 연산자를 이용해서 알아내면 , <code>undefined</code> 입니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(u) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-참조타입-javascript"><a href="#2-참조타입-javascript" class="headerlink" title="2. 참조타입 (javascript)"></a>2. 참조타입 (javascript)</h2><h3 id="-6"><a href="#-6" class="headerlink" title=""></a><a name="Array"></a></h3><p>2-1. Array</p><ul><li>원래 자바스크립트에서 array는 객체입니다.</li><li>사용방법 2가지 &#9996;<ul><li>Array&lt;타입&gt; (내부적으로 제네릭을 이용한 것이다.)</li><li>타입 []</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="-7"><a href="#-7" class="headerlink" title=""></a><a name="Symbol"></a></h3><p>2-2. Symbol 🙄</p><ul><li>ECMAScript 2015의 Symbol 입니다.</li><li><code>프리미티브 타입</code>의 값을 담아서 사용합니다.</li><li>고유하고 수정불가능한 값으로 만들어줍니다.</li><li>그래서 주로 접근을 제어하는데 쓰는 경우가 많았습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [sym]: <span class="string">'value'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]) <span class="comment">// "value"</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-타입스크립트에서-추가로-제공하는-타입"><a href="#3-타입스크립트에서-추가로-제공하는-타입" class="headerlink" title="3. 타입스크립트에서 추가로 제공하는 타입"></a>3. 타입스크립트에서 추가로 제공하는 타입</h2><h3 id="-8"><a href="#-8" class="headerlink" title=""></a><a name="Void"></a></h3><p>3-1. Void</p><ul><li>타입이 없는 상태입니다.</li><li><code>any</code> 와 반대의 의미를 가집니다.</li><li>Void 는 대문자가 없습니다. 소문자입니다.</li><li>주로 함수의 <code>리턴이 없을 때</code> 사용합니다. 그 외에는 <code>사용할 일이 거의 없습니다.</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnVoid</span>(<span class="params">message</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnVoid(<span class="string">'리턴이 없다'</span>)</span><br></pre></td></tr></table></figure><h3 id="-9"><a href="#-9" class="headerlink" title=""></a><a name="Any"></a></h3><p>3-2. Any</p><ul><li>어떤 타입이어도 상관없는 타입입니다.</li><li>이걸 최대한 쓰지 않는게 핵심입니다.</li><li>왜냐면 컴파일 타임에 타입 체크가 정상적으로 이뤄지지 않기 때문입니다.</li><li>그래서 컴파일 옵션 중에는 any 를 쓰면 오류를 뱉도록 하는 옵션도 있습니다.<ul><li><code>noImplicitAny</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnAny</span>(<span class="params">message</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnVoid(<span class="string">'리턴은 아무거나'</span>)</span><br></pre></td></tr></table></figure><h3 id="-10"><a href="#-10" class="headerlink" title=""></a><a name="Never"></a></h3><p>3-3. Never</p><ul><li>리턴에 주로 사용된다.</li><li>아래의 3 가지 정도가 대부분</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function returning never must have unreachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">'Something failed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function returning never must have unreachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-11"><a href="#-11" class="headerlink" title=""></a><a name="Tuple"></a></h3><p>3-4. Tuple</p><ul><li><strong>배열인데 타입이 한가지가 아닌 경우</strong></li><li>마찬가지로 <strong>객체</strong>입니다.</li><li>꺼내 사용할때 주의가 필요합니다.<ul><li>배열을 Destructuting 하면 타입이 제대로 얻어집니다.</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number]</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>] <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span> <span class="comment">// OK, 'string' can be assigned to 'string | number'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()) <span class="comment">// OK, 'string' and 'number' both have 'toString'</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span> <span class="comment">// Error, 'boolean' isn't 'string | number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: [string, number] = [<span class="string">'mark'</span>, <span class="number">35</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [name, age] = person</span><br></pre></td></tr></table></figure><h3 id="-12"><a href="#-12" class="headerlink" title=""></a><a name="Enum"></a></h3><p>3-5. Enum</p><ul><li>C 에서 보던것과 같습니다.</li><li>아래 예제만 이해하면 사용 준비 끝</li><li>Enum 의 결과값은 string 형이다.<blockquote><p>Da,Da 할때 아침 / 점심 / 저녁 / 간식을 Enum 타입으로 받았는데 , 이때 문자열<br>이였기 때문에 <code>*1</code>을 해줬었다 .</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: string = Color[<span class="number">2</span>]; <span class="comment">// 결과값은 string으로 해야한다.</span></span><br></pre></td></tr></table></figure><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://jaroinside.tistory.com/10" target="_blank" rel="noopener">http://jaroinside.tistory.com/10</a></li><li><a href="http://poiemaweb.com/typescript-vscode" target="_blank" rel="noopener">http://poiemaweb.com/typescript-vscode</a></li><li><a href="http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html" target="_blank" rel="noopener">http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;기본-데이터-타입-🌱&quot;&gt;&lt;a href=&quot;#기본-데이터-타입-🌱&quot; class=&quot;headerlink&quot; title=&quot;기본 데이터 타입 🌱&quot;&gt;&lt;/a&gt;기본 데이터 타입 🌱&lt;/h2&gt;&lt;p&gt;타입스크립트에서 기본 자료형을 &lt;code&gt;잘!&lt;/cod
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>2016년 A월 B일</title>
    <link href="http://feel5ny.github.io/2017/11/16/algorithm_02/"/>
    <id>http://feel5ny.github.io/2017/11/16/algorithm_02/</id>
    <published>2017-11-16T04:42:33.000Z</published>
    <updated>2017-11-27T09:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2016년-A월-B일"><a href="#2016년-A월-B일" class="headerlink" title="2016년 A월 B일"></a>2016년 A월 B일</h2><p>2016년 1월 1일은 금요일입니다. 2016년 A월 B일은 무슨 요일일까요? 두 수 A,B를 입력받아 A월 B일이 무슨 요일인지 출력하는 getDayName 함수를 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각<br><code>SUN,MON,TUE,WED,THU,FRI,SAT</code><br>를 출력해주면 됩니다. 예를 들어 A=5, B=24가 입력된다면 5월 24일은 화요일이므로 TUE를 반환하면 됩니다. </p><hr><h3 id="1-처음-생각한-로직"><a href="#1-처음-생각한-로직" class="headerlink" title="1. 처음 생각한 로직"></a>1. 처음 생각한 로직</h3><ul><li>월마다 일 수가 다르다.<br>a월이 1,3,5,7,10,12 &gt; 31일<br>a월이 4,6,8,9,11 &gt; 30일<br>a월이 2 &gt; 28일</li></ul><ul><li><p>일별로 요일이 다르다.<br><code>const day = [&quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;]</code><br>7일 day[0]<br>6일 day[6]</p><p>전체 일수가 x라면<br>x일을 7로 나눈후 나머지값 arr[x%7]<br>x의 값은 ?</p></li></ul><ul><li>전체 일수를 배열과 연결하자.<br>31일 + 1 = 32 // 배열에서 금요일부터 32번 후의 값<br>1월 <code>0</code><br>2월 <code>31일 + b</code><br>3월 <code>31일 + 29일 + b</code><br>4월 <code>31일 + 29일 + 31일 + b</code><br>5월 <code>31일 + 29일 + 31일 + 30일 + b</code><br>6월 <code>31일 + 29일 + 31일 + 30일 + 31일</code> = <code>31일 * 3 + 30일 * 2 - 1</code><br>7월 <code>31일 * 3 + 30일 * 3 -1</code><br>8월 <code>31일 * 4 + 30일 * 3 -1</code><br>9월 <code>31일 * 5 + 30일 * 3 -1</code><br>10월 <code>31일 * 5 + 30일 * 4 -1</code><br>11월 <code>31일 * 6 + 30일 * 4 -1</code><br>12월 <code>31일 * 6 + 30일 * 5 -1</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDayName</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> month = a;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> inputDate = b;</span><br><span class="line">  <span class="keyword">let</span> week = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> day = [<span class="string">"FRI"</span>, <span class="string">"SAT"</span>, <span class="string">"SUN"</span>, <span class="string">"MON"</span>, <span class="string">"TUE"</span>, <span class="string">"WED"</span>, <span class="string">"THU"</span>]</span><br><span class="line">  <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      date = <span class="number">0</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      date = <span class="number">31</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      date = <span class="number">31</span> + <span class="number">28</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">2</span> + <span class="number">29</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">2</span> + <span class="number">30</span> * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">3</span> + <span class="number">30</span> * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">3</span> + <span class="number">30</span> * <span class="number">3</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">4</span> + <span class="number">30</span> * <span class="number">3</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">5</span> + <span class="number">30</span> * <span class="number">3</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">5</span> + <span class="number">30</span> * <span class="number">4</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">6</span> + <span class="number">30</span> * <span class="number">4</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">      date = <span class="number">31</span> * <span class="number">6</span> + <span class="number">30</span> * <span class="number">5</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  date = date + inputDate</span><br><span class="line">  <span class="keyword">return</span> day[date % <span class="number">7</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//아래 코드는 테스트를 위한 코드입니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(getDayName(<span class="number">5</span>, <span class="number">24</span>));</span><br></pre></td></tr></table></figure><h3 id="2-case-문이-너무-비효율적이다-gt-반복문으로-바꾸자"><a href="#2-case-문이-너무-비효율적이다-gt-반복문으로-바꾸자" class="headerlink" title="2. case 문이 너무 비효율적이다. &gt; 반복문으로 바꾸자"></a>2. case 문이 너무 비효율적이다. &gt; 반복문으로 바꾸자</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDayName</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> answer = [<span class="string">"THU"</span>, <span class="string">"FRI"</span>, <span class="string">"SAT"</span>, <span class="string">"SUN"</span>, <span class="string">"MON"</span>, <span class="string">"TUE"</span>, <span class="string">"WED"</span>,];</span><br><span class="line">  <span class="keyword">let</span> month = [<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    sum += month[i];</span><br><span class="line">  &#125;</span><br><span class="line">  sum += b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer[(sum % <span class="number">7</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Date-메소드를-사용해보자"><a href="#3-Date-메소드를-사용해보자" class="headerlink" title="3. Date 메소드를 사용해보자."></a>3. Date 메소드를 사용해보자.</h3><p>메소드 사용</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDayName</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="string">'SUN'</span>, <span class="string">'MON'</span>, <span class="string">'TUE'</span>, <span class="string">'WED'</span>, <span class="string">'THU'</span>, <span class="string">'FRI'</span>, <span class="string">'SAT'</span>];</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">`2016,<span class="subst">$&#123;a&#125;</span>,<span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> day = date.getDay()</span><br><span class="line">  <span class="keyword">return</span> arr[day];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>템플릿 리터럴을 사용하지 않으면 값이 이상하게 나온다.</p><ul><li><p>이유 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Date();</span><br><span class="line">new Date(value);</span><br><span class="line">new Date(dateString);</span><br><span class="line">new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);</span><br></pre></td></tr></table></figure><p><strong> *dateString</strong><br>날짜를 표현하는 <code>문자열값</code>. 문자열은 parse 메소드에 의해 인식가능한 형식이어야 한다.</p><p><strong> *year, month, date</strong><br>날짜의 각 부분을 표현하는 <code>정수값</code>. 월(month)부분은 0부터 11까지의 값을 가지며, 0이 1월을, 11이 12월을 가리킨다. </p></li></ul><blockquote><p>때문에 템플릿 리터럴로 넣게 되면 문자열이 되어서 그대로 파싱하지만, 숫자일 경우 배열의 인덱스값으로 인지하여서 월의 시작숫자가 0이게 된다.<br>즉, let date = new Date(2016,<code>a-1</code>,b) 이렇게 넣어야 한다.</p></blockquote><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2016년-A월-B일&quot;&gt;&lt;a href=&quot;#2016년-A월-B일&quot; class=&quot;headerlink&quot; title=&quot;2016년 A월 B일&quot;&gt;&lt;/a&gt;2016년 A월 B일&lt;/h2&gt;&lt;p&gt;2016년 1월 1일은 금요일입니다. 2016년 A월 B일은 
      
    
    </summary>
    
      <category term="Algorithm &amp;#128583;" scheme="http://feel5ny.github.io/categories/Algorithm-128583/"/>
    
      <category term="Level2" scheme="http://feel5ny.github.io/categories/Algorithm-128583/Level2/"/>
    
    
      <category term="algorithm" scheme="http://feel5ny.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2/ Typescript_tsconfig.json 프로퍼티의 종류</title>
    <link href="http://feel5ny.github.io/2017/11/15/Typescript_03/"/>
    <id>http://feel5ny.github.io/2017/11/15/Typescript_03/</id>
    <published>2017-11-15T10:30:01.000Z</published>
    <updated>2018-08-15T14:46:48.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컴파일러-옵션"><a href="#컴파일러-옵션" class="headerlink" title="컴파일러 옵션"></a>컴파일러 옵션</h2><p>실제 프로젝트에서는 컴파일러 옵션을 그렇게 많이 셋팅하진 않는다 . 옵션을 셋팅할 수 있는 전체 스펙은 <a href="http://json.schemastore.org/tsconfig" target="_blank" rel="noopener">이 링크</a>로 가면 확인가능하다 .</p><hr><blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8#" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><ol><li>최상위 프로퍼티</li><li>compileOnSave</li><li>extends</li><li>files, include, exclude</li><li>types</li><li>compileOptions<ul><li>6-1. target과 lib</li><li>6-2. outDir, outFile</li><li>6-3. module</li></ul></li></ol><hr><h2 id="1-최상위-프로퍼티"><a href="#1-최상위-프로퍼티" class="headerlink" title="1. 최상위 프로퍼티"></a>1. 최상위 프로퍼티</h2><blockquote><p>tsconfig.json 파일에서 제일 상위에 정의되어있는 컴파일 옵션들</p></blockquote><ul><li>compileOnSave</li><li>extends</li><li>compileOptions ( 초기에는 compileOptions 요소가 많이 존재한다 .)</li><li>files</li><li>include</li><li>exclude</li></ul><h2 id="2-compileOnSave"><a href="#2-compileOnSave" class="headerlink" title="2. compileOnSave"></a>2. compileOnSave</h2><p>파일 변경 후 저장하면 바로 컴파일을 해준다 . 에디터마다 안될 수도 있다.</p><ul><li>true / false (default false)<ul><li>true 이면 저장하면 바로 컴파일됨</li></ul></li><li>최상단에 설정해야 한다.</li><li>누가 ??<ul><li>Visual Studio 2015 with TypeScript 1.8.4 이상</li><li>atom-typescript 플러그인</li></ul></li></ul><h2 id="3-extends"><a href="#3-extends" class="headerlink" title="3. extends"></a>3. extends</h2><p>보통 많이 사용하지 않는다 . 사용 예를 들면 , 클라이언트 타입스크립트와 서버사이드 타입스크립트가 있을 때, 설정이 비슷하다면 어떤 파일을 만든 후, 상속을 받아서 작은 부분만 바꿔서 쓰는 경우 사용 가능하다.</p><ul><li>파일 (상대) 경로명 : string</li><li>TypeScript 2.1 New Spec</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // in config/base.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// in tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"./configs/base"</span>,</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">    <span class="string">"main.ts"</span>,</span><br><span class="line">    <span class="string">"supplemental.ts"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-files-include-exclude"><a href="#4-files-include-exclude" class="headerlink" title="4. files, include, exclude"></a>4. files, include, exclude</h2><ul><li><p>셋다 설정이 없으면 , 전부다 컴파일</p></li><li><p>files</p><ul><li>상대 혹은 절대 경로의 리스트 배열.</li><li>파일별 부분 컴파일이 된다.</li><li>exclude 보다 쎕니다. (exclude가 해놓아도 files 에 있으면 컴파일 실행된다는 뜻)</li><li>특정 폴더를 exclude가 있어도 컴파일 된다.</li></ul></li><li><p>include, exclude</p><ul><li><p>glob 패턴 (마치 .gitignore)</p></li><li><p>include</p><ul><li>exclude 보다 약하다.</li><li><ul><li>같은걸 사용하면 , .ts / .tsx / .d.ts 만 include (allowJS)</li></ul></li></ul></li><li><p>exclude</p><ul><li>설정 안하면 4가지 (node_modules, bower_components, - jspm_packages, <outdir>)를 default 로 제외한다 .</outdir></li><li><outdir> 은 <code>항상 제외합니다 .</code> (include 에 있어도 )</outdir></li></ul></li></ul></li></ul><h2 id="5-types-중요"><a href="#5-types-중요" class="headerlink" title="5.@types (중요 !)"></a>5.@types (중요 !)</h2><p>TypeScript 2.0 부터 사용 가능해진 <code>내장 type definition 시스템</code></p><ul><li>이전 버전에서는 사용하지 못한다.</li><li>아무 설정을 안하면 ?<ul><li>node_modules/@types 라는 모든 경로를 찾아서 사용</li></ul></li><li>typeRoots 를 사용하면 ?<ul><li>배열 안에 들어있는 경로들 아래서만 가져옵니다 .</li></ul></li><li>types 를 사용하면 ?<ul><li>패키지 이름입니다.</li><li>배열 안의 모듈 혹은 <code>./node_modules/@types/</code> 안의 모듈 이름에서 찾아옵니다 .</li><li>[] 빈 배열을 넣는다는건 이 시스템을 이용하지 않겠다는 것입니다 .<ul><li>블루베리 플젝에서는 types 를 사용한다 .</li></ul></li></ul></li><li><code>typeRoots 와 types 를 같이 사용하지 않습니다 .</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// compiileOptions : type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Instructs the TypeScript compiler how to compile .ts files."</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"typeRoots"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specify list of directories for type definition files to be included. Requires TypeScript version 2.0 or later."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"array"</span>,</span><br><span class="line">      <span class="attr">"items"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"types"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Type declaration files to be included in compilation. Requires TypeScript version 2.0 or later."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"array"</span>,</span><br><span class="line">      <span class="attr">"items"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-compileOptions"><a href="#6-compileOptions" class="headerlink" title="6. compileOptions"></a>6. compileOptions</h2><h3 id="6-1-target과-lib"><a href="#6-1-target과-lib" class="headerlink" title="6-1. target과 lib"></a>6-1. target과 lib</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Instructs the TypeScript compiler how to compile .ts files."</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specify ECMAScript target version. Permitted values are 'es3', 'es5', 'es2015', 'es2016', 'es2017' or 'esnext'."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"default"</span>: <span class="string">"es3"</span>,</span><br><span class="line">      <span class="attr">"anyOf"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"enum"</span>: [</span><br><span class="line">            <span class="string">"es3"</span>,</span><br><span class="line">            <span class="string">"es5"</span>,</span><br><span class="line">            <span class="string">"es2015"</span>,</span><br><span class="line">            <span class="string">"es2016"</span>,</span><br><span class="line">            <span class="string">"es2017"</span>,</span><br><span class="line">            <span class="string">"esnext"</span> // 확정은 아니지만 곧 확정될 것 같은 문법들을 모아둔</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"pattern"</span>: <span class="string">"^([eE][sS]([356]|(201[567])|[nN][eE][xX][tT]))$"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"lib"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specify library file to be included in the compilation. Requires TypeScript version 2.0 or later."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"array"</span>,</span><br><span class="line">      <span class="attr">"items"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">        <span class="attr">"enum"</span>: [</span><br><span class="line">          <span class="string">"es5"</span>,</span><br><span class="line">          <span class="string">"es6"</span>,</span><br><span class="line">          <span class="string">"es2015"</span>,</span><br><span class="line">          <span class="string">"es7"</span>,</span><br><span class="line">          <span class="string">"es2016"</span>,</span><br><span class="line">          <span class="string">"es2017"</span>,</span><br><span class="line">          <span class="string">"esnext"</span>,</span><br><span class="line">          <span class="string">"dom"</span>,</span><br><span class="line">          <span class="string">"dom.iterable"</span>,</span><br><span class="line">          <span class="string">"webworker"</span>,</span><br><span class="line">          <span class="string">"scripthost"</span>,</span><br><span class="line">          <span class="string">"es2015.core"</span>,</span><br><span class="line">          <span class="string">"es2015.collection"</span>,</span><br><span class="line">          <span class="string">"es2015.generator"</span>,</span><br><span class="line">          <span class="string">"es2015.iterable"</span>,</span><br><span class="line">          <span class="string">"es2015.promise"</span>,</span><br><span class="line">          <span class="string">"es2015.proxy"</span>,</span><br><span class="line">          <span class="string">"es2015.reflect"</span>,</span><br><span class="line">          <span class="string">"es2015.symbol"</span>,</span><br><span class="line">          <span class="string">"es2015.symbol.wellknown"</span>,</span><br><span class="line">          <span class="string">"es2016.array.include"</span>,</span><br><span class="line">          <span class="string">"es2017.object"</span>,</span><br><span class="line">          <span class="string">"es2017.sharedmemory"</span>,</span><br><span class="line">          <span class="string">"esnext.asynciterable"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"noLib"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Do not include the default library file (lib.d.ts)."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>target</strong></p><ul><li>빌드의 결과물을 어떤 버전으로 할 것이냐</li><li>지정을 안하면 <code>es3</code> 입니다.</li></ul><p><strong>lib</strong></p><ul><li>기본 type definition 라이브러리를 어떤 것을 사용할 것이냐</li><li>잘 정의하지 않으면 빨간줄이 계속 생긴다 .</li><li>lib 를 지정하지 않을 때 ,<ul><li>target 이 ‘es3’ 이고, 디폴트로 lib.d.ts 를 사용합니다.</li><li>target 이 ‘es5’ 이면 , 디폴트로 dom, es5, scripthost 를 사용합니다 .</li><li>target 이 ‘es6’ 이면, 디폴트로 dom, es6, dom.iterable, scripthost 를 사용합니다.</li><li>es5 이후에는 문법별 쪼개서도 설정 가능하다 .</li></ul></li><li>​lib 를 지정하면 그 lib 배열로만 라이브러리를 사용하니다.<ul><li>​ 빈 [] =&gt; ‘no definition found 어쩌구’</li><li>혹은 <code>&quot;noLib&quot; : true</code>로 바꾸면 된다. ( 거의 안쓸듯 )</li></ul></li></ul><h3 id="6-2-compileOptions-outDir-outFile"><a href="#6-2-compileOptions-outDir-outFile" class="headerlink" title="6-2. compileOptions: outDir, outFile"></a>6-2. compileOptions: outDir, outFile</h3><ul><li>파일을 다 모아서 하나의 컴파일된 하나의 파일로 모으고 싶을 때 outFile을 사용</li><li>소스디렉토리에 그대로 똑같이 구조를 컴파일된 상태로 옮길 때 outDir 를 사용</li><li>많이 사용한다 .</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Instructs the TypeScript compiler how to compile .ts files."</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"outFile"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Concatenate and emit output to single file."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"outDir"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Redirect output structure to the directory."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rootDir"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specifies the root directory of input files. Use to control the output directory structure with --outDir."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-compileOptions-module"><a href="#6-3-compileOptions-module" class="headerlink" title="6-3. compileOptions: module"></a>6-3. compileOptions: module</h3><p><strong>module</strong></p><ul><li>결과물을 어떻게 무엇을 쓸것인가에 대한 것이다 .</li><li>컴파일 된 모듈의 결과물을 어떤 모듈 시스템으로 할지를 결정</li><li>target 이 ‘es6’ 이면 es6 가 디폴트이고 ,</li><li>target 이 ‘es6’ 가 아니면 <code>commonjs</code> 가 디폴트 입니다 .</li><li>AMD 나 System 와 사용하려면, <code>outFile 이 지정되어야 합니다 .</code></li><li>ES6 나 ES2015 를 사용하려면, target 이 es5 이하여야 합니다.</li></ul><p><strong>moduleResolution</strong></p><ul><li>ts 소스에서 모듈을 사용하는 방식을 지정해야 합니다 .</li><li>classic 아니면 node 입니다 .</li><li>commonJS 일때만 node 라고 생각하시면 됩니다.</li></ul><p><strong>path<em>s</em> 와 baseUrl</strong></p><ul><li>상대경로 방식이 아닌 baseUrl 로 꼭지점과 paths 안의 키/ 밸류로 모듈을 가져가는방식입니다 .</li></ul><p><strong>rootDirs</strong></p><ul><li>배열 안에서 상대 경로를 찾는 방식입니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Instructs the TypeScript compiler how to compile .ts files."</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specify module code generation: 'none', 'CommonJS', 'Amd', 'System', 'UMD', or 'es2015'."</span>,</span><br><span class="line">      <span class="attr">"enum"</span>: [<span class="string">"commonjs"</span>, <span class="string">"amd"</span>, <span class="string">"umd"</span>, <span class="string">"system"</span>, <span class="string">"es6"</span>, <span class="string">"es2015"</span>, <span class="string">"none"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specifies module resolution strategy: 'node' (Node) or 'classic' (TypeScript pre 1.6) ."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"pattern"</span>: <span class="string">"^(([Nn]ode)|([Cc]lassic))$"</span>,</span><br><span class="line">      <span class="attr">"default"</span>: <span class="string">"classic"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"baseUrl"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Base directory to resolve non-relative module names."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"paths"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specify path mapping to be computed relative to baseUrl option."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"object"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rootDirs"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>:</span><br><span class="line">        <span class="string">"Specify list of root directories to be used when resolving modules."</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"array"</span>,</span><br><span class="line">      <span class="attr">"items"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="현재-플젝-tsconfig-json"><a href="#현재-플젝-tsconfig-json" class="headerlink" title="현재 플젝 tsconfig.json"></a>현재 플젝 tsconfig.json</h3><p>처음보는 옵션들이 있어서 정리해보았다 . 참고 : <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener">타입스크립트 공식 페이지</a></p><p><code>allowSyntheticDefaultImports: true</code></p><ul><li>Allow default imports from modules with no default export. This does not<br>affect code emit, just typechecking.</li><li>리엑트에서 컴포넌트를 import 할 때 주로 쓰는 <code>import Something from &#39;./Something&#39;</code>을 사용할 수 있다 .</li></ul><p><code>noImplicitAny: false</code></p><ul><li>Raise error on expressions and declarations with an implied any type.</li><li>암시적으로 선언되었는데 any 로 추론되면 에러를 알려줍니다 . false이면 무시됨.</li></ul><p><code>preserveConstEnums: true</code></p><ul><li>Do not erase const enum declarations in generated code. See const enums documentation for more details.</li><li>enum 변수선언을 유지한다는 것 같은데 정확히 잘 모르겠다.</li></ul><p><code>allowJs : false</code></p><ul><li>include 에 있는 파일 경로들에 존재하는 모든 .ts, .tsx파일들이 컴파일되는데 ,<br>allowJs를 true 로 하면 .js와 .jsx 파일도 컴파일 대상이 된다 .</li></ul><p><code>sourceMap : true</code></p><ul><li>Generates corresponding .map file.</li><li>트랜스파일을 거치는 많은 모듈들이 디버깅을 위해서 기본적으로 source map 출력을 지원한다 .</li></ul><p><code>noImplicitReturns : true</code></p><ul><li>Report error when not all code paths in function return a value.</li><li>제대로 리턴 다 안되면 에러 -&gt; 오류에 대해 강력하게 체크한다는 뜻입니다.</li></ul><p><code>noUnusedParameters : true</code></p><ul><li>Report errors on unused parameters.</li><li>사용하지 않는 파라미터가 있으면 에러를 알려줍니다.</li></ul><p><code>noUnusedLocals : true</code></p><ul><li>Report errors on unused locals.</li><li>사용 안하는 로컬 변수가 있으면 에러를 알려줍니다 .</li></ul><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://jaroinside.tistory.com/10" target="_blank" rel="noopener">http://jaroinside.tistory.com/10</a></li><li><a href="http://poiemaweb.com/typescript-vscode" target="_blank" rel="noopener">http://poiemaweb.com/typescript-vscode</a></li><li><a href="http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html" target="_blank" rel="noopener">http://spectrumdig.blogspot.kr/2016/12/chrome-source-map-coffeescripttypescrip.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;컴파일러-옵션&quot;&gt;&lt;a href=&quot;#컴파일러-옵션&quot; class=&quot;headerlink&quot; title=&quot;컴파일러 옵션&quot;&gt;&lt;/a&gt;컴파일러 옵션&lt;/h2&gt;&lt;p&gt;실제 프로젝트에서는 컴파일러 옵션을 그렇게 많이 셋팅하진 않는다 . 옵션을 셋팅할 수 있는
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>overview</title>
    <link href="http://feel5ny.github.io/2017/11/14/dada_06week/"/>
    <id>http://feel5ny.github.io/2017/11/14/dada_06week/</id>
    <published>2017-11-14T01:10:04.000Z</published>
    <updated>2017-12-14T14:49:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="식단-다이어리-서비스-DA-DA"><a href="#식단-다이어리-서비스-DA-DA" class="headerlink" title="식단 다이어리 서비스, DA,DA"></a>식단 다이어리 서비스, DA,DA</h1><p>프론트엔드 스쿨을 마지막 달에는 그동안 배운 기술을 토대로 프로젝트를 필수적으로 진행해야 했다. node.js 스쿨과 함께 5명으로 이루어진 우리 조는 33일간의 대장정을 끝으로, 알바퍼전의 웹서비스가 배포할 수 있게 되었다. 블로그에서는 <strong>프론트엔드 중심으로</strong> 이번 프로젝트에 대한 개인적인 후기와 더불어 전반적인 진행과정, 이슈에 대해서 5가지 챕터로 포스팅하려고 한다.</p><hr><p>chapter 1 : 기획 및 프로토타입 및 디자인<br>chapter 2 : 퍼블리싱<br>chapter 3 : 핵심기능 개발<br>chapter 4 : 리팩토링 및 테스트<br>chapter 5 : 추가개발 및 배포</p><hr><p>이번 프로젝트를 통해서 크게 3가지를 얻을 수 있었다.</p><ol><li>비동기통신</li><li>redux 자유로운 사용</li><li>react 라이프사이클과 한계</li></ol><hr><p>프로젝트 이후 느낀점</p><h3 id="Rest-API"><a href="#Rest-API" class="headerlink" title="Rest API"></a>Rest API</h3><p>우리 프로젝트에서는 다루는 데이터의 양이 많았었다. 매일 하루 3끼 식단, 운동, 일기, 등등. 이 데이터들을 rest API를 사용해서 rest하게 통신했지만, 해당 액션마다 필요한 데이터 + 필요 없는 데이터까지 가져오는 경우가 많았다. 이를 방지하기위해서는 백엔드에 엔드포인트를 요청해야했고, 여러면에서 낭비되는 리소스가 많이 발생함.<br>GraphQL과 Rest Api를 같이 써보자.</p><h3 id="다른-상태관리-라이브러리"><a href="#다른-상태관리-라이브러리" class="headerlink" title="다른 상태관리 라이브러리"></a>다른 상태관리 라이브러리</h3><p>redux의 사용은 props로 액션을 주고받는 면에서는 혁신이다. 당연히. 그치만 많은 액션을 다루고, 관리하는 면에서 이건 액션으로 처리해야해. 라고 말하는 순간 귀찮음이 도지게 된다. 아 그럼 또 액션을 놓고 리듀서에 놓고 payload의 타입을 잘 지정해서 넣어주어야겠구나. 이런 불편함을 해소하고자 mobX를 사용하나 싶었다. 다음에 사용해보기</p><h3 id="타입-이슈"><a href="#타입-이슈" class="headerlink" title="타입 이슈"></a>타입 이슈</h3><p>타입에 대한 이슈가 종종 있었다. 특히 이건 도대체 무슨에러인거지? 하면서 삽질할 때가 보통 타입때문에 생긴 에러들이었다. 객체형태로 들어오는지, 어떤 타입으로 타입을 내려주는지 등등을 console.log로 찍는건 한계가 있었고, PropsType으로 설정하는 것도 흠. </p><!-- ### Fetch apihttps://developer.mozilla.org/en-US/docs/Web/API/Fetch_API --><hr><ul><li>github : <a href="https://github.com/huusz/Da-Da" target="_blank" rel="noopener">https://github.com/huusz/Da-Da</a></li><li>DA,DA : <a href="https://dada.downmix.net" target="_blank" rel="noopener">https://dada.downmix.net</a> (카카오 아이디로 로그인)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;식단-다이어리-서비스-DA-DA&quot;&gt;&lt;a href=&quot;#식단-다이어리-서비스-DA-DA&quot; class=&quot;headerlink&quot; title=&quot;식단 다이어리 서비스, DA,DA&quot;&gt;&lt;/a&gt;식단 다이어리 서비스, DA,DA&lt;/h1&gt;&lt;p&gt;프론트엔드 스쿨
      
    
    </summary>
    
      <category term="Project &amp;#127939;" scheme="http://feel5ny.github.io/categories/Project-127939/"/>
    
      <category term="DA, DA" scheme="http://feel5ny.github.io/categories/Project-127939/DA-DA/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
      <category term="DADA" scheme="http://feel5ny.github.io/tags/DADA/"/>
    
  </entry>
  
  <entry>
    <title>야근지수 (미제)</title>
    <link href="http://feel5ny.github.io/2017/11/13/algorithm_01/"/>
    <id>http://feel5ny.github.io/2017/11/13/algorithm_01/</id>
    <published>2017-11-13T08:10:04.000Z</published>
    <updated>2017-11-27T09:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="야근-지수"><a href="#야근-지수" class="headerlink" title="야근 지수"></a>야근 지수</h2><p>회사원인 수민이는 많은 일이 쌓여 있습니다. 수민이는 야근을 최소화하기 위해 남은 일의 작업량을 숫자로 메기고, 일에 대한 야근 지수를 줄이기로 결정했습니다. 야근 지수는 남은 일의 작업량을 제곱하여 더한 값을 의미합니다. 수민이는 1시간 동안 남은 일 중 하나를 골라 작업량 1만큼 처리할 수 있습니다. 수민이의 퇴근까지 남은 N 시간과 각 일에 대한 작업량이 있을 때, noOvertime 함수를 제작하여 수민이의 야근 지수를 최소화 한 결과를 출력해 주세요. 예를 들어, N=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 일을 한 결과는 [2, 2, 2]가 되고 야근 지수는 22 + 22 + 22 = 12가 되어 12를 반환해 줍니다.</p><hr><ul><li>처음 생각한 로직</li></ul><ol><li>해당 배열의 전체 합 - N값</li><li>1번의 값을 배열의 길이로 나눈다.</li><li>나머지가 0인 경우와, 0이 아닌 경우가 생긴다.<ul><li>나머지가 0인 경우, 해당 몫의 제곱근에 length값을 곱한다. (끝)</li><li>나머지가 0이 아닌경우, <ul><li>몫이 소수점이 나온는데, 이는 내림하여 소수점 자리수들을 버리고 (floor)</li><li>해당 값과 배열의 인자를 비교하여, 해당 값보다 작은 인자의 경우 바로 제곱근화 하고, 나머지 값은 해당 몫으로 제곱하여 더한다. <strong>(이 부분이 잘못되었음)</strong></li></ul></li></ul></li><li>3번의 첫번째 나머지가 0인 경우는 테스트가 통과하는데 2번째 경우는 로직이 잘못됨</li></ol><hr><blockquote><p>통과하고 싶다</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;야근-지수&quot;&gt;&lt;a href=&quot;#야근-지수&quot; class=&quot;headerlink&quot; title=&quot;야근 지수&quot;&gt;&lt;/a&gt;야근 지수&lt;/h2&gt;&lt;p&gt;회사원인 수민이는 많은 일이 쌓여 있습니다. 수민이는 야근을 최소화하기 위해 남은 일의 작업량을 숫자로 
      
    
    </summary>
    
      <category term="Algorithm &amp;#128583;" scheme="http://feel5ny.github.io/categories/Algorithm-128583/"/>
    
      <category term="Level3" scheme="http://feel5ny.github.io/categories/Algorithm-128583/Level3/"/>
    
    
      <category term="algorithm" scheme="http://feel5ny.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Firebase의 storage 연동하기</title>
    <link href="http://feel5ny.github.io/2017/11/12/firebaseStorage/"/>
    <id>http://feel5ny.github.io/2017/11/12/firebaseStorage/</id>
    <published>2017-11-12T01:10:04.000Z</published>
    <updated>2017-11-27T08:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="학교-로고-모음-사이트"><a href="#학교-로고-모음-사이트" class="headerlink" title="학교 로고 모음 사이트"></a>학교 로고 모음 사이트</h2><blockquote><p>현재 상황</p></blockquote><p>팀 프로젝트인 식단 다이어리 서비스 dada 프로젝트에서는 db 설계에 대한 이슈가 없었다. 당연히 난 프론트엔드다보니.. db 설계를 담당하지 않아서인 건데, 현재 개인 프로젝트에서는 db 구조까지 짜는 작업을 하고 있다.</p><h3 id="DB-구조짜기"><a href="#DB-구조짜기" class="headerlink" title="DB 구조짜기"></a>DB 구조짜기</h3><p>300개의 데이터와 개당 storage에 연동되어있는 파일들이 있는데, 제일 좋은 건 db에 url 칼럼을 넣는 방식. 파이어베이스에서는 스토리지와 데이터베이스 연결하는 것까지는 제공하지 않는 듯하다. 수동으로 작업해야 하는데 아직 좋은 방법이 떠오르지 않는다. </p><h3 id="데이터-불러오기"><a href="#데이터-불러오기" class="headerlink" title="데이터 불러오기"></a>데이터 불러오기</h3><p>storage에 있는 데이터를 가져오는데, 현재 이슈.</p><ol><li>한 디렉토리에 300개를 넣어두고 한 번에 갖고 오는 방식이라 아주 느리다.<ul><li>db 디렉토리를 20개씩 분리한 후, 더 보기 형태의 방식으로 해결해야겠다.<br><br></li></ul></li><li>map을 돌려서 해당 db 인덱스값과 같은 값의 파일을 갖고 오게 하기위해서 파일 이름에 학교 이름이 아닌 PNG_1.png 이런 방식의 파일 이름으로 지정해두었다. 매칭이 잘못된 학교 이름을 찾아 내기도 힘들고, ux도 너무 안 좋을 것 같아서, 파일 이름을 학교 이름으로 바꾸기로 결정했다.<br><br></li><li>생각해 보니 지역별 칼럼을 정리하지 않았다.<br><br></li><li>비록 일일이 검토 후에 로고를 올리는 것이지만, 한 번 더 체킹을 위해 학교 url을 넣는게 좋겠다고 판단. 칼럼을 추가해야겠다.<ul><li>공공api가 있었으면 좋겠다.</li></ul></li></ol><blockquote><p>생각보다 db 짜는건 굉장한 노가다다! dada 프로젝트 할 때 백엔드 분께서 ‘생각보다 노가다도 많이 하게 되는데, 또 생각보다 어렵진 않더라구요!’ 라고 했던 말이 와닿는 하루다. </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;학교-로고-모음-사이트&quot;&gt;&lt;a href=&quot;#학교-로고-모음-사이트&quot; class=&quot;headerlink&quot; title=&quot;학교 로고 모음 사이트&quot;&gt;&lt;/a&gt;학교 로고 모음 사이트&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;현재 상황&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="Project &amp;#127939;" scheme="http://feel5ny.github.io/categories/Project-127939/"/>
    
      <category term="Univ Project" scheme="http://feel5ny.github.io/categories/Project-127939/Univ-Project/"/>
    
    
      <category term="react" scheme="http://feel5ny.github.io/tags/react/"/>
    
      <category term="firebase" scheme="http://feel5ny.github.io/tags/firebase/"/>
    
      <category term="db" scheme="http://feel5ny.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>1/ Typescript_환경 셋팅</title>
    <link href="http://feel5ny.github.io/2017/11/10/Typescript_02/"/>
    <id>http://feel5ny.github.io/2017/11/10/Typescript_02/</id>
    <published>2017-11-10T01:52:01.000Z</published>
    <updated>2018-08-15T14:46:48.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개발환경-구축-및-컴파일러-셋팅"><a href="#개발환경-구축-및-컴파일러-셋팅" class="headerlink" title="개발환경 구축 및 컴파일러 셋팅"></a>개발환경 구축 및 컴파일러 셋팅</h2><p><a href="https://feel5ny.github.io/2017/11/08/TS_01/">앞선 글</a>에서 컴파일러와 트랜스파일러 인터프리터의 차이점을 알아보았다. 트랜스파일러와 컴파일러의 차이가 있다고는 했지만, 앞으로의 글에서는 컴파일러라고 통일해서 쓰려고 한다 . 타입스크립트는 컴파일드 언어라고 했지만 , 실제적으로 어떻게 환경을 셋팅하고 작업해야하는지 알아보자 .</p><p><img src="/images/post_img/12/index.jpg"></p><hr><blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8#" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다. (짱짱)<br><strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다.</p></blockquote><ol><li>실행환경</li><li>컴파일러 셋팅, 에디터</li><li>간단하게 실습</li><li>컴파일러 옵션</li></ol><p><strong>목표</strong><br>타입스크립트를 사용하기 위해서 첫번째 실행환경을 셋팅하고 , 컴파일러 셋팅(npm으로 설치), 에디터에서 환경셋팅(tslint, 등등) 을 하고 , 간단하게 실습으로 컴파일 테스팅해본다. 기본 테스트가 완료되면 컴파일러 옵션을 어떻게 추가해야하는지 알아본다 .</p><hr><h2 id="1-실행환경"><a href="#1-실행환경" class="headerlink" title="1. 실행환경"></a>1. 실행환경</h2><p>런타임 환경</p><h3 id="1-1-node-js"><a href="#1-1-node-js" class="headerlink" title="1-1. node.js"></a>1-1. node.js</h3><ul><li>자바스크립트 런타임 환경으로 node.js를 사용한다.</li><li>컴파일러를 설치하기 위해서 필요하다.</li><li>타입스크립트에서 컴파일러 프로그램을 제공하는 것이 npm 모듈로 있기 때문에 ..</li><li>node.js없이 VScode에서도 셋팅이 가능하긴하다 . (2번에서 확인!)</li><li>버전을 바꾸고 싶을 때는 nvm (node.js version manager) 사용 ~</li></ul><h3 id="1-2-browser"><a href="#1-2-browser" class="headerlink" title="1-2. browser"></a>1-2. browser</h3><ul><li>결과를 보는 곳.. 그냥 있는거 쓰자 .</li></ul><hr><h2 id="2-타입스크립트-컴파일러-셋팅-에디터"><a href="#2-타입스크립트-컴파일러-셋팅-에디터" class="headerlink" title="2. (타입스크립트) 컴파일러 셋팅 , 에디터"></a>2. (타입스크립트) 컴파일러 셋팅 , 에디터</h2><p>타입스크립트를 셋팅해 보자. 셋팅 방법에는 npm 과 VScode plugin으로 설치하는 방법이 있는데 , npm으로 설치해보았다 .</p><h3 id="2-1-npm으로-설치하기"><a href="#2-1-npm으로-설치하기" class="headerlink" title="2-1. npm으로 설치하기"></a>2-1. npm으로 설치하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><p>설치 후 node_modules 폴더의 bin파일에 tsc 파일이 생성되는 것을 볼 수 있다 .<br><code>.bin</code> 내부에 있는 파일들은 스크립트에서 경로 없이 파일 이름으로만 바로 실행시킬수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node_modules/.bin/tsc 파일이름</span><br><span class="line">// 원래는 이렇게</span><br><span class="line"></span><br><span class="line">tsc source.ts</span><br><span class="line">// 경로 생략 가능, 뒷부분은 컴파일 할 파일 이름</span><br></pre></td></tr></table></figure><h3 id="2-2-Visual-Studio-Code-내장-플러그인-사용하기"><a href="#2-2-Visual-Studio-Code-내장-플러그인-사용하기" class="headerlink" title="2-2. Visual Studio Code 내장 플러그인 사용하기"></a>2-2. Visual Studio Code 내장 플러그인 사용하기</h3><p>타입스크립트로 만들어졌기 때문에 타입스크립트에 대한 지원이 강력 !</p><p><img src="/images/post_img/12/vs_01.jpg"><br>ts파일을 선택 후 하단 bar를 보면 Typescript라는 단어와 버전이 보인다. 버전을 누르면 옵션창이 보이게 되는데, 이는 VS Code에 내장되어있는 컴파일러 리스트 중 선택하라는 옵션창이다. 내장된 컴파일러 버전은 VS Code 가 업데이트 되면서 자동으로 올라가며, 컴파일러 버전과 VS Code 의 버전은 상관 관계가 있다. 내장된 컴파일러를 선택할수 있고, 직접 설치한 컴파일러를 선택할 수도 있다.</p><h3 id="2-3-tslint-설치"><a href="#2-3-tslint-설치" class="headerlink" title="2-3. tslint 설치"></a>2-3. tslint 설치</h3><p>eslint와 같이 코딩 컨벤션을 맞추기 위한 프로그램이다 .</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript tslint (로컬)</span><br><span class="line">tslint --init</span><br></pre></td></tr></table></figure><p>tslint.json파일이 생성되고, 프로젝트에 맞게 코딩 컨벤션을 셋팅할 수 있다 .<br><a href="https://palantir.github.io/tslint/" target="_blank" rel="noopener">https://palantir.github.io/tslint/</a></p><ul><li><p>에디터에서 tslint 플러그인 설치</p><ol><li>cmd + p &gt; 옵션창</li><li>ext install tslint 그냥 확장프로그램에 가서 tslint 검색 후 다운로드 받아도<br>된다.</li></ol><p>VScode : <a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=eg2.tslint</a></p></li></ul><hr><h2 id="3-간단하게-실습"><a href="#3-간단하게-실습" class="headerlink" title="3. 간단하게 실습"></a>3. 간단하게 실습</h2><h3 id="3-1-특정-프로젝트-폴더에서-타입스크립트-컴파일러-설정에-맞춰-컴파일"><a href="#3-1-특정-프로젝트-폴더에서-타입스크립트-컴파일러-설정에-맞춰-컴파일" class="headerlink" title="3-1. 특정 프로젝트 폴더에서 타입스크립트 컴파일러 설정에 맞춰 컴파일"></a>3-1. 특정 프로젝트 폴더에서 타입스크립트 컴파일러 설정에 맞춰 컴파일</h3><p>tsconfig.json 파일에서 옵션을 추가하여 컴파일시 여러 조건을 걸 수 있다.</p><ul><li>tsconfig 파일 초기셋팅</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>tsconfig.json 파일이 생성이 된다. 처음 생성시 디폴트로 되어있는 tsconfig.json파일</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    /* Basic Options */</span><br><span class="line">    "target":</span><br><span class="line">      "es5" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. */,</span><br><span class="line">    "module":</span><br><span class="line">      "commonjs" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */,</span><br><span class="line">    "strict": true /* Enable all strict type-checking options. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>target : 컴파일된 결과물을 es5 버전으로 맞추겠다는 것</li><li>module : 컴파일된 결과물이 어떤 모듈로 사용할 것인지?</li></ul><p>옵션에 대한 자세한 설명은 4번에서 설명!</p><h3 id="3-2-watch-모드"><a href="#3-2-watch-모드" class="headerlink" title="3-2. watch 모드"></a>3-2. watch 모드</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -w</span><br></pre></td></tr></table></figure><ul><li>변경되면 감지해서 새로 컴파일 해주는 것 .</li><li>보통은 gulp 를 사용한다 .</li></ul><h3 id="3-3-프로젝트-파일-내에서만-설치할-경우-로컬"><a href="#3-3-프로젝트-파일-내에서만-설치할-경우-로컬" class="headerlink" title="3-3. 프로젝트 파일 내에서만 설치할 경우 ( 로컬)"></a>3-3. 프로젝트 파일 내에서만 설치할 경우 ( 로컬)</h3><p>셋팅 방법</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm i typescript // 프로젝트 이름(폴더이름)이 동일하면 안된다.</span><br><span class="line">package.json &gt; <span class="string">"scripts"</span>에 <span class="string">"transpile"</span> : <span class="string">"tsc"</span> 추가.</span><br><span class="line">// tsc파일이 .bin폴더 내부에 있는데, npm에서는 .bin내부의 파일들은 전체 상대 경로를 적지 않아도 접근가능하다.</span><br><span class="line">npm run transpile</span><br></pre></td></tr></table></figure><ul><li>typescirpt 를 글로벌로 설치할 경우 <code>tsc 파일이름.ts</code> 명령어만으로 컴파일이 가능하다.</li><li>로컬로만 설치할 경우 , 위의 방법처럼 따로 스크립트에 추가 후에 명령어를 사용하면된다.</li></ul><blockquote><p>cli 명령어로 명렁어를 다 걸어둘 수 있지만 json 파일을 만들어서 설정을 정리하며서 쓴다 .</p></blockquote><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=eg2.tslint</a></li><li><a href="https://palantir.github.io/tslint/" target="_blank" rel="noopener">https://palantir.github.io/tslint/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개발환경-구축-및-컴파일러-셋팅&quot;&gt;&lt;a href=&quot;#개발환경-구축-및-컴파일러-셋팅&quot; class=&quot;headerlink&quot; title=&quot;개발환경 구축 및 컴파일러 셋팅&quot;&gt;&lt;/a&gt;개발환경 구축 및 컴파일러 셋팅&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>0/ Typescript?</title>
    <link href="http://feel5ny.github.io/2017/11/08/Typescript_01/"/>
    <id>http://feel5ny.github.io/2017/11/08/Typescript_01/</id>
    <published>2017-11-08T09:23:55.000Z</published>
    <updated>2018-08-15T14:48:09.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자바스크립트-말고-타입스크립트"><a href="#자바스크립트-말고-타입스크립트" class="headerlink" title="자바스크립트 말고 타입스크립트 ?"></a>자바스크립트 말고 타입스크립트 ?</h2><p>최근 <a href="https://feel5ny.github.io/2017/11/14/dada_06week/">프로젝트</a>를 진행하면서<br>나도 모르는 사이에 타입이 자주 바뀌는 자바스크립트의 불편함을 느끼곤 했었다. 애초에 값을 할당할 때 타입 체킹은 그 순간에 내 머릿속에서만 생각만 하지, 그 이후는 케어하지 못하게 되었다. 나중에 에러가 발생하면, <code>삽질</code> 후에 원인이 타입 때문이라는 것을 알게 되고.. 이는 생각보다 빈번하게 일어났다. 콘솔에서 타입 에러를 잡지않고 렌더링이 될 때가 있기 때문에 타입으로 발생한 버그를 잡을 때는 시간이 더 걸린다.( 왜 에러가 나는 거여? 물론 리액트는 타입도 종종 잡아준다 . 무튼 시간 아까워! ) 버그 잡는 게 중요하긴 한데 , 타입이 원인이라는 것은 뭔가 어처구니없는 실수라는 생각도 들었다 .. 그러다 문득! 예전에 타입 버그가 날 때마다 <code>타입스크립트를 배우면 이런 버그는 애초에 만나지 않을 겁니다!</code> 라고 자주 얘기하셨던 선생님이 종종 생각났고 .. 게다가 지금 여러 프로젝트에서 타입스크립트을 도입하고도 있고, 얼마 후에 앵귤러도 시작하고자 해서 .. 겸사겸사 동기부여가 여러 군데에서 생겼기 때문에!! 시작!!</p><hr><blockquote><p>타입스크립트 정리 글은 이웅재님의 <a href="https://www.youtube.com/user/2woongjae/videos" target="_blank" rel="noopener">강의</a>와 <a href="http://slides.com/woongjae/deck-8#" target="_blank" rel="noopener">강의록</a>을 참고하여 작성하였습니다 . (짱짱<br>) <strong>오류</strong>가 있다면 언제든지 댓글 부탁드립니다 .</p></blockquote><ol><li>타입스크립트는 무엇인가</li><li>컴파일러? 트랜스파일러? 인터프리터 ?</li><li>정적타입 언어 vs 동적타입 언어</li></ol><hr><h2 id="1-타입스크립트는-무엇인가"><a href="#1-타입스크립트는-무엇인가" class="headerlink" title="1. 타입스크립트는 무엇인가."></a>1. 타입스크립트는 무엇인가.</h2><p>타입스크립트는 프로그래밍 언어 중 하나이다 . 자바스크립트가 인터프리터 기반의 언어로써, 실행과 동시에 렌더링이 되는데 , 타입스크립트는 인터프리터 방식이 아닌 컴파일 후에 실행되는 <code>Compiled Language</code>이다 . 별도의 빌드 과정이 필요 ! 전통적인 컴파일 언어와는 다른데 , (C언어 , 자바 …) 때문에 Compile 말고, <code>Transpile</code>이라는 용어를 사용하기도 한다 . 혹은 meta programming이라고 한다.</p><h2 id="2-컴파일러-트랜스파일러-인터프리터"><a href="#2-컴파일러-트랜스파일러-인터프리터" class="headerlink" title="2. 컴파일러? 트랜스파일러? 인터프리터 ?"></a>2. 컴파일러? 트랜스파일러? 인터프리터 ?</h2><p>간단하게 3가지를 비교해보면 아래 그림과 같다.<br><img src="/images/post_img/11/CompileTranspileInterpreter.jpg"></p><ul><li><strong>transpiler</strong> 하나의 <strong>언어</strong>를 다른 형태의 <strong>언어</strong>로 변환해 주는 기능을 <code>부각</code>시키는 표현으로 compiler라는 표현보다 transpiler라는 표현을 쓴다. ( 번역이라는 말과 합쳐진 듯 하다 .) ex. Typescript, Babel <br></li><li><p><strong>compiler</strong> 한 번 컴파일 하게 되면, 별도 생성된 목적 파일을 통해 빠르게 실행할 수 있다. 대용량 소스에 적합</p><ul><li>컴파일이 필요 O </li><li>컴파일러가 필요 O </li><li>컴파일 하는 시점 O =&gt; 컴파일 타임 </li><li>컴파일된 결과물을 실행 </li><li>컴파일된 결과물을 실행하는 시점 ex. C, Go, C#, JAVA, … <br></li></ul></li><li><p><strong>interpreter</strong> 목적 파일 산출 과정이 없이 실행과 동시에 줄 단위로 번역이 된<br>다. 저용량 소스에 적합</p><ul><li>컴파일이 필요 X </li><li>컴파일러가 필요 X </li><li>컴파일하는 시점 X </li><li>코드 자체를 실행 </li><li>코드를 실행하는 시점 o = 런타임 ex. javascript</li></ul></li></ul><h3 id="Tranditional-Compiled-Language"><a href="#Tranditional-Compiled-Language" class="headerlink" title="*Tranditional Compiled Language"></a>*Tranditional Compiled Language</h3><ul><li>컴파일 언어라고 한다.</li><li>C, C++, Go, C#, Java, …</li><li>프로그래머가 작성한 <code>Source Code</code> 를 기계어로 변환하는 과정을 <code>Compile</code>이라고<br>한다.</li><li>기계어로 변환된 결과물을 <code>Object Code</code> (목적 코드 )라 한다.</li><li><code>Compile</code> 하는 프로그램을 <code>Compiler</code> 라고 한다 .</li><li><code>Compile</code> 하는 동안을 <code>Compile Time</code> 이라고 한다 .</li><li>컴파일된 코드는 프로세서에 따라 다르다.</li><li>소스 코드에서는 OS 에 따라 라이브러리가 다르다 .</li><li>컴파일된 코드는 작은 크기에 최적화된다.</li><li>일반적으로 실행시 기계어로 바꾸는 방식 (인터프리터 언어) 보다 빠르다 .</li><li>실행시 기계어로 바꿔주는 연산이 필요없기 때문이다 .</li></ul><h2 id="3-정적타입-언어-vs-동적타입-언어"><a href="#3-정적타입-언어-vs-동적타입-언어" class="headerlink" title="3. 정적타입 언어 vs 동적타입 언어"></a>3. 정적타입 언어 vs 동적타입 언어</h2><ul><li>정적 타입 언어 : 미리 타입을 지정해놓고 시작<ul><li>자바스크립트에서 정적타입언어만 갖고오자라고 한 것이 TypeScript</li><li>동적 타입 언어가 갖고 있는 단점을 커버하자 .하는 목적이다 .</li><li>test coverage를 올리면 상관없긴하다 .</li><li>ex. Typescript</li></ul></li><li>동적 타입 언어 : 타입을 정하지 않는다. 타입 자체가 변화하는 것을 막지않는다.<ul><li>ex. Javascript</li></ul></li></ul><h3 id="The-End-of-Dynamic-Languages-vs-Have-Static-Languages-Won"><a href="#The-End-of-Dynamic-Languages-vs-Have-Static-Languages-Won" class="headerlink" title="*The End of Dynamic Languages vs Have Static Languages Won?"></a>*<a href="http://elbenshira.com/blog/the-end-of-dynamic-languages/" target="_blank" rel="noopener">The End of Dynamic Languages</a> vs <a href="https://pointersgonewild.com/2015/11/25/have-static-languages-won/?utm_source=Clojure+Gazette&amp;utm_medium=email&amp;utm_campaign=152" target="_blank" rel="noopener">Have Static Languages Won?</a></h3><ul><li>최근 나타나는 신생언어들은 대부분 정적 타입을 지원한다. (Typed Racket, Typed<br>Clojure, TypeScript, Typed Lua, Python with type hints)</li><li><code>정적 언어로 작성된 코드의 버그는 해당 코드를 실행하기 전까지는 찾을 수 없다.</code></li><li>동적 언어의 경우 대부분 대충 디자인되어있다 . JavaScript의 경우에는 2 주만에<br>개발된 언어이다보니 컴파일러와 힌들리- 밀너 타입추론 시스템과 같은 CS 지식으로<br>무장한 사람들이 디자인한 언어와 비교하는건 무리다.</li><li>Closure 같은 경우에도 이제는 대부분의 언어에서 지원하게 되면서 functional 과<br>imperative 프로그래밍이 융합되듯이, 동적 언어와 정적 언어도 그렇게 되지 않을<br>까? Crystal Programming Language 의 경우 루비를 기반으로 하는 정적/ 동적 언어<br>가 합쳐진 언어이다.</li></ul><hr><h3 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h3><ol><li><a href="http://www.notforme.kr/archives/1541" target="_blank" rel="noopener">http://www.notforme.kr/archives/1541</a></li><li><a href="http://www.geekhours.com/2017/03/08/difference-compiling-transpiling/" target="_blank" rel="noopener">http://www.geekhours.com/2017/03/08/difference-compiling-transpiling/</a></li><li><a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part1/</a></li><li><a href="http://blog.sejongin.kr/44" target="_blank" rel="noopener">http://blog.sejongin.kr/44</a></li><li><a href="http://hieroglyph.tistory.com/4" target="_blank" rel="noopener">http://hieroglyph.tistory.com/4</a></li><li><a href="https://okky.kr/article/304342" target="_blank" rel="noopener">https://okky.kr/article/304342</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;자바스크립트-말고-타입스크립트&quot;&gt;&lt;a href=&quot;#자바스크립트-말고-타입스크립트&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 말고 타입스크립트 ?&quot;&gt;&lt;/a&gt;자바스크립트 말고 타입스크립트 ?&lt;/h2&gt;&lt;p&gt;최근 &lt;a href
      
    
    </summary>
    
      <category term="TIL &amp;#9997;" scheme="http://feel5ny.github.io/categories/TIL-9997/"/>
    
      <category term="Typescript" scheme="http://feel5ny.github.io/categories/TIL-9997/Typescript/"/>
    
    
      <category term="typescript" scheme="http://feel5ny.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 설치</title>
    <link href="http://feel5ny.github.io/2017/09/10/aboutHEXO/"/>
    <id>http://feel5ny.github.io/2017/09/10/aboutHEXO/</id>
    <published>2017-09-10T11:46:25.000Z</published>
    <updated>2018-08-02T11:47:05.049Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>intro</p></blockquote><p> 무언가를 배울때 하루하루의 기록을 남기는 것은 자기계발의 첫 스타트라고 생각합니다. 머리속에 있는 것을 그대로 옮기는 작업은, 정리하며 내것으로 만들기에도 좋고, 그때그때의 생각을 기록하는 용으로도 좋기 때문입니다. 그래서 우리는 일기를 쓰고, 일지를 쓰고, 이렇게 블로그도 만들며 기록합니다. 특히나 개발은 많은 개념을 숙지하면서 공부해야하기 때문에 블로깅 자체가 공부가 됩니다.</p><p> 이왕 <code>node.js</code>까지 배우고 있으니, <code>jekyll</code>이 아닌, <code>hexo</code>를 사용해서 블로그를 만들었습니다. </p><p><img src="/images/post_img/01/post_1-10.svg"></p><hr><blockquote><p>목차</p></blockquote><ol><li>Github 간단 소개<ol><li>원격 저장소</li><li>원격저장소 Github이 제공하는 정적웹사이트, Github Pages</li><li>호스팅을 편리하게 만들어주는 generator, Jekyll &amp; HEXO</li></ol></li><li>Github Pages로 정적 페이지 Hosting하기<ol><li>로컬에 저장소 생성하기</li><li>원격 저장소 생성하기 (Github Repository)</li><li>원격 저장소와 로컬 저장소 연결하기</li></ol></li><li>Hexo 설치하기<ol><li>Hexo 설치 전 준비</li><li>Hexo npm 설치하기</li><li>설정파일 업데이트</li></ol></li><li>Github에 배포하기<ol><li>hexo 설정을 통해 정적 리소스를 생성하기</li><li>배포하기</li></ol></li><li>anatol 테마적용하기</li></ol><hr><h2 id="0-Github-간단-소개"><a href="#0-Github-간단-소개" class="headerlink" title="0. Github 간단 소개"></a>0. Github 간단 소개</h2><p>깃에 대해서 잘 알고 있다면 1번으로 넘어가도 됩니다.</p><h3 id="0-1-원격저장소"><a href="#0-1-원격저장소" class="headerlink" title="0-1. 원격저장소"></a>0-1. 원격저장소</h3><p><img src="/images/post_img/01/post_1-01.svg" width="600px"><br><a href="https://backlogtool.com/git-tutorial/kr/intro/intro1_1.html" target="_blank" rel="noopener">Git</a>이란 소스코드를 효과적으로 관리하기 위해 개발된 ‘분산형 버전 관리 시스템’입니다.<br>git은 저장소에서 관리를 하는데, 내 컴퓨터에 있는 저장소를 <code>로컬저장소</code>라고 하고, 웹 상에 있는 저장소를 <code>원격저장소</code>라고 합니다. 우리가 흔히 알고 있는 원격저장소를 제공하는 서비스에는 <strong>깃헙, 비트버킷, 깃랩</strong>등이 있습니다다. 헥소를 이용한 블로그 개설을 위해서는 <strong>깃헙</strong>을 사용해야합니다.</p><h3 id="0-2-원격저장소-Github이-제공하는-정적웹사이트-Github-Pages"><a href="#0-2-원격저장소-Github이-제공하는-정적웹사이트-Github-Pages" class="headerlink" title="0-2. 원격저장소 Github이 제공하는 정적웹사이트, Github Pages"></a>0-2. 원격저장소 Github이 제공하는 정적웹사이트, Github Pages</h3><p><img src="/images/post_img/01/post_1-02.svg" width="600px"><br>Github에서 제공하는 Static Website, Github Pages가 있다. 깃헙 저장소에 리소스를 <code>push</code>만 해도(push란 저장소에 리소스를 넣을때 사용하는 명령어) 간단하게 웹사이트를 만들 수 있다. 즉, 다른 호스팅 서비스의 도움없이, 원격저장소에 올리기만해도 호스팅이 가능하다.</p><h3 id="0-3-호스팅을-편리하게-만들어주는-generator-Jekyll-amp-HEXO"><a href="#0-3-호스팅을-편리하게-만들어주는-generator-Jekyll-amp-HEXO" class="headerlink" title="0-3. 호스팅을 편리하게 만들어주는 generator, Jekyll &amp; HEXO"></a>0-3. 호스팅을 편리하게 만들어주는 generator, Jekyll &amp; HEXO</h3><p><img src="/images/post_img/01/post_1-04.svg" width="600px"></p><p>사실, hexo나 jekyll이 없이도, html,css,javascript를 통해서도 호스팅이 가능하나, 블로그 구성상 <strong>글을 등록하고, 리스트를 보여주며, 댓글을 달 수 있는, 블로그가 갖고 있는 기능을 편라히게 사용하기 위해서</strong> hexo나 jekyll과 같은 generator를 사용해야 한다.</p><p>Static Website generator는 마크다운을(.md 파일)로 편집 후 html로 변환할 수 있도록 돕는다. generator에는 jekyll과 HEXO가 있는데, jekyll은 <code>ruby</code>기반, HEXO는 <code>node.js</code>기반이다.</p><hr><p>그럼 generator을 셋팅하기 전, 내 컴퓨터에 디렉토리(폴더)를 생성하고, 원격저장소(github)에 연결을 시켜보자.</p><h2 id="1-Github-Pages로-정적-페이지-호스팅하기"><a href="#1-Github-Pages로-정적-페이지-호스팅하기" class="headerlink" title="1. Github Pages로 정적 페이지 호스팅하기"></a>1. Github Pages로 정적 페이지 호스팅하기</h2><p>Github Pages를 사용하기 위해 Github의 원격저장소에 리소스를 올려야한다는 사실을 잊지말자. 아래 그림의 저장소들이 필요하다.</p><p><img src="/images/post_img/01/post_1-05.svg" width="600px"></p><h3 id="1-1-로컬에-저장소-생성하기"><a href="#1-1-로컬에-저장소-생성하기" class="headerlink" title="1-1. 로컬에 저장소 생성하기"></a>1-1. 로컬에 저장소 생성하기</h3><p>내 컴퓨터 원하는 장소에 폴더를 생성한다.<br>terminal없이도 생성해도 된다.<br>아래는 terminal을 이용한 생성방법</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 바탕화면에 생성한다는 가정 </span><br><span class="line">(글쓴이는 운영체제가 mac입니다.) --&gt;</span><br><span class="line">$ <span class="built_in">cd</span> Desktop</span><br><span class="line">$ mkdir github-blog</span><br></pre></td></tr></table></figure><p>바탕화면에 <code>github-blog</code>라는 이름의 폴더가 생성이 되었다.</p><h3 id="1-2-원격-저장소-생성하기-Github-Repository"><a href="#1-2-원격-저장소-생성하기-Github-Repository" class="headerlink" title="1-2. 원격 저장소 생성하기 (Github Repository)"></a>1-2. 원격 저장소 생성하기 (Github Repository)</h3><p><img src="/images/post_img/01/post_1-11.jpg" width="600px"><br>github pages를 통해 손쉽게 <code>USERNAME.github.io</code>를 통해 정적 페이지를 호스팅 할 수 있다. </p><blockquote><p>번외 &gt; gh-pages 브랜치를 생성하면, 각 repository마다 <code>USERNAME.github.io/레포이름</code>으로 호스팅이 가능하다.</p></blockquote><p>지금부터 말하는 USERNAME은, 당신의 아이디이다. 깃헙주소 뒷부분 <code>/</code>이후 붙는 유저네임을 붙이면된다. 아래 순서로 깃 저장소를 생성한다.</p><ol><li>New Repository &gt; 이름은 꼭 <code>USERNAME.github.io</code>로 적용한다. </li><li>Public선택.</li><li>원격저장소 생성 완료</li></ol><p><img src="/images/post_img/01/post_1-12.jpg" width="600px"></p><h3 id="1-3-원격-저장소와-로컬-저장소-연결하기"><a href="#1-3-원격-저장소와-로컬-저장소-연결하기" class="headerlink" title="1-3. 원격 저장소와 로컬 저장소 연결하기"></a>1-3. 원격 저장소와 로컬 저장소 연결하기</h3><p><img src="/images/post_img/01/post_1-06.svg" width="600px"><br>내 컴퓨터에 저장소를 만들고, 원격에도 만들었으니, 연결을 해야한다. 연결하는 방법은 간단하다. 지금은 터미널을 열고 명령어를 입력해야하는 타이밍이다.</p><ol><li>1번에서 만들었던 디렉토리로 이동한다.</li><li>해당 디렉토리에서 원격저장소의 git을 clone한다. clone 뒤에 생성한 원격저장소의 주소를 입력하는데, 이는 remote가 동시에 일어나므로, 따로 remote 명령어를 입력안해도 된다.</li><li>연결 테스트겸, READMD.md 파일을 생성한다.</li><li>생성된 README.md파일을 푸시한다. (commit &gt; push)</li></ol><p>위의 순서를 코드로 옮기면. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1. 해당 디렉토리로 이동 --&gt;</span><br><span class="line"><span class="built_in">cd</span> Desktop</span><br><span class="line"><span class="built_in">cd</span> github-blog</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. git <span class="built_in">clone</span> --&gt;</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/feel5ny/TEST.github.io.git</span><br><span class="line"><span class="built_in">cd</span> test.github.io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 3. README.md파일 생성 --&gt;</span><br><span class="line"><span class="built_in">echo</span> README.md</span><br><span class="line"></span><br><span class="line">&lt;!-- 4. 원격저장소에 올리기 --&gt;</span><br><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>step 1이 끝났다! 그리고 벌써 호스팅이 완료되었다.<br><strong>USERNAME.github.io</strong>에 가보자.</p><hr><p>아직 블로그의 형태를 띄지 않았다. 위에서 말했던 generator를 이용하여 블로그의 구조를 짤 예정인데, 우리는 HEXO를 이용할 것이다. </p><h2 id="2-Hexo-설치하기"><a href="#2-Hexo-설치하기" class="headerlink" title="2. Hexo 설치하기"></a>2. Hexo 설치하기</h2><p>Hexo는 node.js기반이기 때문에 npm을 통해 쉽게 설치가 가능하다. 다양한 plugin과 테마를 지원하고 있다.<br><img src="/images/post_img/01/post_1-07.svg" width="600px"></p><h3 id="2-1-Hexo-설치-전-준비"><a href="#2-1-Hexo-설치-전-준비" class="headerlink" title="2-1. Hexo 설치 전 준비"></a>2-1. Hexo 설치 전 준비</h3><p>Hexo는 말했다 싶이 node.js 기반이기 때문에 node.js가 로컬에 기본적으로 설치되어있어야 한다. node.js는 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">공식 사이트</a>에서 설치가 가능하다. stable버전을 추천한다.</p><h3 id="2-2-Hexo-npm-설치하기"><a href="#2-2-Hexo-npm-설치하기" class="headerlink" title="2-2. Hexo npm 설치하기"></a>2-2. Hexo npm 설치하기</h3><p>Node.js를 설치 한 후에 아래 CLI를 순서대로 입력하여 npm을 설치한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>node.js를 설치하면 npm을 사용할 수 있는데, 패키지 중에 hexo-cli를 설치한다. blog파일을 생성하여 hexo를 초기화한다. blog 디렉토리로 이동후, npm install을 사용하여, blog에 필요한 파일들을 자동으로 설치한다.</p><h3 id="2-3-설정파일-업데이트"><a href="#2-3-설정파일-업데이트" class="headerlink" title="2-3. 설정파일 업데이트"></a>2-3. 설정파일 업데이트</h3><p>위의 순서가 끝나면, root 디렉토리에 <code>_config.yml</code>이라는 설정파일이 생성된다. (yml파일은 사람이 쉽게 읽을 수 있는 데이터 직력화 양식으로,…<a href="http://www.openthefile.net/ko/extension/yml" target="_blank" rel="noopener">more</a>) 해당 파일에 블로그 정보를 수정한다. 나머지 정보는 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">hexo 공식 문서</a>에서.</p><ol><li><p>Site 정보<br>블로그 정보를 수정할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 제목(html head에 들어가는 title태그에 들어가는 제목과 같다.)</span><br><span class="line">subtitle: </span><br><span class="line">description:</span><br><span class="line">author: Nayoung Kim</span><br></pre></td></tr></table></figure></li><li><p>URL 정보<br>블로그 URL 정보를 설정할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://USERNAME.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></li><li><p>Github 정보<br>배포를 위해서 저장소 주소를 추가한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/feel5ny/TEST.github.io.git</span><br></pre></td></tr></table></figure></li></ol><p>테마별로 구성을 수정하는 스타일이 다르다. 테마 적용하기 파트에서 anatol 레이아웃 수정방법을 설명하겠다.</p><h3 id="2-4-로컬에서-테스트하기"><a href="#2-4-로컬에서-테스트하기" class="headerlink" title="2-4. 로컬에서 테스트하기"></a>2-4. 로컬에서 테스트하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>blog 디렉토리에 위치되어있는 상태에서 서버를 구동한다. blog에 위치되어있지 않으면 서버구동이 안된다. 서버 구동이 완료되면 4000번 포트로 접속이 가능하다. </p><ul><li><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></li></ul><p>테스트시 구동이 잘 안될 경우, 서버를 껐다가 다시 실행해 보면된다. 서버를 끄는 방법은 터미널에서 <code>ctrl+c</code>를 두번 입력하면 된다. </p><hr><h2 id="3-Github에-배포하기"><a href="#3-Github에-배포하기" class="headerlink" title="3. Github에 배포하기"></a>3. Github에 배포하기</h2><p>로컬에서 테스트를 완료하면 USERNAME.github.io 주소로 배포해보자.<br><img src="/images/post_img/01/post_1-08.svg" width="600px"></p><h3 id="3-1-hexo-설정을-통해-정적-리소스를-생성하기"><a href="#3-1-hexo-설정을-통해-정적-리소스를-생성하기" class="headerlink" title="3-1. hexo 설정을 통해 정적 리소스를 생성하기"></a>3-1. hexo 설정을 통해 정적 리소스를 생성하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>위 명령어를 입력하면, github에 올라갈 리소스만 정리되어 따로 폴더가 생성된다.</p><h3 id="3-2-배포하기"><a href="#3-2-배포하기" class="headerlink" title="3-2. 배포하기"></a>3-2. 배포하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>위 명령어를 입력하면 배고가 완료된다. generate와 deploy를 한번에 진행하고 싶은 경우 아래 명령어를 입력한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy --generate</span><br></pre></td></tr></table></figure><p>약자로 <code>hexo d g</code>를 사용해도 됩니다.</p><h3 id="3-3-배포가-잘-안될-경우"><a href="#3-3-배포가-잘-안될-경우" class="headerlink" title="3-3. 배포가 잘 안될 경우"></a>3-3. 배포가 잘 안될 경우</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy --generate</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;intro&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 무언가를 배울때 하루하루의 기록을 남기는 것은 자기계발의 첫 스타트라고 생각합니다. 머리속에 있는 것을 그대로 옮기는 작업은, 정리하며 내것으로 만들기에도 좋고, 그때그때의
      
    
    </summary>
    
      <category term="blog" scheme="http://feel5ny.github.io/categories/blog/"/>
    
      <category term="hexo" scheme="http://feel5ny.github.io/categories/blog/hexo/"/>
    
    
      <category term="hexo" scheme="http://feel5ny.github.io/tags/hexo/"/>
    
      <category term="node.js" scheme="http://feel5ny.github.io/tags/node-js/"/>
    
  </entry>
  
</feed>
